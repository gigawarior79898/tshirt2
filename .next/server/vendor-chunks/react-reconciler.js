"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  ((exports.ConcurrentRoot = 1),\n  (exports.ContinuousEventPriority = 8),\n  (exports.DefaultEventPriority = 32),\n  (exports.DiscreteEventPriority = 2),\n  (exports.IdleEventPriority = 268435456),\n  (exports.LegacyRoot = 0),\n  (exports.NoEventPriority = 0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckMsSUFBSSxzQkFBc0I7QUFDMUIsR0FBRywrQkFBK0I7QUFDbEMsR0FBRyw0QkFBNEI7QUFDL0IsR0FBRyw2QkFBNkI7QUFDaEMsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyx1QkFBdUIiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoKGV4cG9ydHMuQ29uY3VycmVudFJvb3QgPSAxKSxcbiAgKGV4cG9ydHMuQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSA4KSxcbiAgKGV4cG9ydHMuRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSAzMiksXG4gIChleHBvcnRzLkRpc2NyZXRlRXZlbnRQcmlvcml0eSA9IDIpLFxuICAoZXhwb3J0cy5JZGxlRXZlbnRQcmlvcml0eSA9IDI2ODQzNTQ1NiksXG4gIChleHBvcnRzLkxlZ2FjeVJvb3QgPSAwKSxcbiAgKGV4cG9ydHMuTm9FdmVudFByaW9yaXR5ID0gMCkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && (module.exports = function($$$config) {\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPassiveEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_CONTEXT_TYPE:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function describeFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;\n            case 11:\n                return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;\n            case 1:\n                return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\";\n            do {\n                info += describeFiber(workInProgress);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info, env = entry.env;\n                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? \" [\" + env + \"]\" : \"\"));\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function getCurrentFiberStackInDev() {\n        return null === current ? \"\" : getStackByFiberInDevAndProd(current);\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n        try {\n            return callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            current = previousFiber;\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiber(parent) {\n        parent = findCurrentFiberUsingSlowPath(parent);\n        return null !== parent ? findCurrentHostFiberImpl(parent) : null;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function findCurrentHostFiberWithNoPortalsImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;\n    }\n    function getLabelForLane(lane) {\n        if (lane & 1) return \"SyncHydrationLane\";\n        if (lane & 2) return \"Sync\";\n        if (lane & 4) return \"InputContinuousHydration\";\n        if (lane & 8) return \"InputContinuous\";\n        if (lane & 16) return \"DefaultHydration\";\n        if (lane & 32) return \"Default\";\n        if (lane & 64) return \"TransitionHydration\";\n        if (lane & 4194176) return \"Transition\";\n        if (lane & 62914560) return \"Retry\";\n        if (lane & 67108864) return \"SelectiveHydration\";\n        if (lane & 134217728) return \"IdleHydration\";\n        if (lane & 268435456) return \"Idle\";\n        if (lane & 536870912) return \"Offscreen\";\n        if (lane & 1073741824) return \"Deferred\";\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 4194176;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, warmLanes = root.warmLanes;\n        root = 0 !== root.finishedLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 64:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n        return lane;\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %s.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function onCommitRoot$1(root, eventPriority) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n            var didError = 128 === (root.current.flags & 128);\n            switch(eventPriority){\n                case 2:\n                    var schedulerPriority = ImmediatePriority;\n                    break;\n                case 8:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                case 32:\n                    schedulerPriority = NormalPriority$1;\n                    break;\n                case 268435456:\n                    schedulerPriority = IdlePriority;\n                    break;\n                default:\n                    schedulerPriority = NormalPriority$1;\n            }\n            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n    }\n    function markCommitStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();\n    }\n    function markComponentRenderStarted(fiber) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n    function markComponentRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();\n    }\n    function markRenderStarted(lanes) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);\n    }\n    function markRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();\n    }\n    function markStateUpdateScheduled(fiber, lane) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        nextRootInstance = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootInstance, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber, hostContext) {\n        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n        hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 3:\n            case 27:\n                rootOrSingletonContext = !0;\n                return;\n            case 5:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (!supportsHydration || fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var shouldClear = !1;\n        supportsSingletons ? 3 !== fiber.tag && 27 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0) : 3 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0);\n        if (shouldClear && nextHydratableInstance) {\n            for(shouldClear = nextHydratableInstance; shouldClear;){\n                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(shouldClear);\n                diffNode.serverTail.push(description);\n                shouldClear = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratableSibling(shouldClear);\n            }\n            throwOnHydrationMismatch(fiber);\n        }\n        popToNextHostParent(fiber);\n        if (13 === fiber.tag) {\n            if (!supportsHydration) throw Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return !0;\n    }\n    function resetHydrationState() {\n        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = !1);\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diffRoot));\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [\n            update\n        ] : sourceFiber.push(update), update.lane = lane | 536870912);\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n        }\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case 2:\n                case 8:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case 32:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case 268435456:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        var originalCallbackNode = root.callbackNode;\n        if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPassiveEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateTask(cb) {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            cb();\n            return null;\n        });\n        supportsMicrotasks ? scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();\n        }) : scheduleCallback$3(ImmediatePriority, cb);\n    }\n    function requestTransitionLane() {\n        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());\n        return currentEventTransitionLane;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function noop$1() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$1, noop$1), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$1, noop$1);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 33554434;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateElement(returnFiber, current, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updatePortal(returnFiber, current, portal, lanes) {\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        if (22 === fiber.tag) {\n            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {\n                var current = fiber.alternate;\n                null !== current && null !== current.memoizedState && (shellBoundary = fiber);\n            }\n        } else reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber$1 = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & 8) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber$1 = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);\n        return maybeThenable;\n    }\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & 16) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber$1.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber$1;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber$1.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {\n            destroy: void 0\n        }, null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {\n                destroy: void 0\n            }, null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber$1.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            ReactSharedInternals.T._updatedFibers = new Set();\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$2) {\n            onActionError(actionQueue, node, error$2);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber$1;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratableSibling(markerInstance);\n                                isMatching = isFormStateMarkerMatching(markerInstance);\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, setPendingState, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        currentStateHook = \"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;\n        var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;\n        action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {\n            destroy: void 0\n        }, null));\n        return [\n            currentStateHook,\n            dispatch,\n            stateHook\n        ];\n    }\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushEffect(tag, create, inst, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            inst: inst,\n            deps: deps,\n            next: null\n        };\n        create = currentlyRenderingFiber$1.updateQueue;\n        null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);\n        inst = create.lastEffect;\n        null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {\n            destroy: void 0\n        }, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (currentlyRenderingFiber$1.mode & 64) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        currentTransition._updatedFibers = new Set();\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function rerenderTransition() {\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \":\" + identifierPrefix + \"R\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \":\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \":\" + identifierPrefix + \"r\" + treeId.toString(32) + \":\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider);\n                    fiber = createUpdate(lane);\n                    var root = enqueueUpdate(provider, fiber, lane);\n                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    provider = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    fiber.payload = {\n                        cache: provider\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);\n        action = {\n            lane: JSCompiler_OptimizeArgumentsArray_p0,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);\n    }\n    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n        markStateUpdateScheduled(fiber, 2);\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194176)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & 8) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;\n        markRef(current, workInProgress);\n        if (\"hidden\" === nextProps.mode || nextIsDetached) {\n            if (0 !== (workInProgress.flags & 128)) {\n                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextChildren = workInProgress.child = current.child;\n                    for(nextIsDetached = 0; null !== nextChildren;)nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;\n                    workInProgress.childLanes = nextIsDetached & ~nextProps;\n                } else workInProgress.childLanes = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        return null;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864);\n            _instance = !0;\n        } else if (null === current$jscomp$0) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current$jscomp$0, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current$jscomp$0, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;\n            isRendering = !1;\n            current = workInProgress;\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else {\n                markComponentRenderStarted(workInProgress);\n                Component = callRenderInDEV(lane);\n                if (workInProgress.mode & 8) {\n                    setIsStrictModeForDevtools(!0);\n                    try {\n                        callRenderInDEV(lane);\n                    } finally{\n                        setIsStrictModeForDevtools(!1);\n                    }\n                }\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= 1;\n            null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current$jscomp$0 = workInProgress.child;\n        } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current$jscomp$0;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var showFallback = !1, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;\n        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);\n        JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                if (isHydrating) {\n                    var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;\n                    (JSCompiler_temp$jscomp$0 = !nextInstance) || (JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext), null !== JSCompiler_temp$jscomp$0 ? (warnIfNotHydrating(), workInProgress.memoizedState = {\n                        dehydrated: JSCompiler_temp$jscomp$0,\n                        treeContext: null !== treeContextProvider ? {\n                            id: treeContextId,\n                            overflow: treeContextOverflow\n                        } : null,\n                        retryLane: 536870912\n                    }, didSuspend = createFiber(18, null, null, NoMode), didSuspend.stateNode = JSCompiler_temp$jscomp$0, didSuspend.return = workInProgress, workInProgress.child = didSuspend, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1, JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0);\n                    JSCompiler_temp$jscomp$0 && (warnNonHydratedInstance(workInProgress, nextInstance), throwOnHydrationMismatch(workInProgress));\n                }\n                nextInstance = workInProgress.memoizedState;\n                if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;\n                popSuspenseHandler(workInProgress);\n            }\n            nextInstance = nextProps.children;\n            nextProps = nextProps.fallback;\n            if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: nextInstance\n            }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n        }\n        JSCompiler_temp$jscomp$0 = current.memoizedState;\n        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: nextProps.children\n            }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\"), isSuspenseInstanceFallback(nextInstance)) nextInstance = getSuspenseInstanceFallbackErrorDetails(nextInstance), JSCompiler_temp = nextInstance.digest, showFallback = nextInstance.message, nextProps = nextInstance.stack, nextInstance = nextInstance.componentStack, showFallback = showFallback ? Error(showFallback) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\"), showFallback.stack = nextProps || \"\", showFallback.digest = JSCompiler_temp, JSCompiler_temp = void 0 === nextInstance ? null : nextInstance, nextProps = {\n                value: showFallback,\n                source: null,\n                stack: JSCompiler_temp\n            }, \"string\" === typeof JSCompiler_temp && CapturedStacks.set(showFallback, nextProps), queueHydrationError(nextProps), workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {\n                JSCompiler_temp = workInProgressRoot;\n                if (null !== JSCompiler_temp) {\n                    nextProps = renderLanes & -renderLanes;\n                    if (0 !== (nextProps & 42)) nextProps = 1;\n                    else switch(nextProps){\n                        case 2:\n                            nextProps = 1;\n                            break;\n                        case 8:\n                            nextProps = 4;\n                            break;\n                        case 32:\n                            nextProps = 16;\n                            break;\n                        case 128:\n                        case 256:\n                        case 512:\n                        case 1024:\n                        case 2048:\n                        case 4096:\n                        case 8192:\n                        case 16384:\n                        case 32768:\n                        case 65536:\n                        case 131072:\n                        case 262144:\n                        case 524288:\n                        case 1048576:\n                        case 2097152:\n                        case 4194304:\n                        case 8388608:\n                        case 16777216:\n                        case 33554432:\n                            nextProps = 64;\n                            break;\n                        case 268435456:\n                            nextProps = 134217728;\n                            break;\n                        default:\n                            nextProps = 0;\n                    }\n                    nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps;\n                    if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;\n                }\n                isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else isSuspenseInstancePending(nextInstance) ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), registerSuspenseInstanceRetry(nextInstance, workInProgress), workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress)), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n            mode: \"hidden\",\n            children: nextProps.children\n        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? {\n            parent: didSuspend,\n            pool: didSuspend\n        } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: nextProps.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_temp.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;\n        nextProps = nextProps.children;\n        if (void 0 !== revealOrder && \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"together\" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, \"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || (\"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode)));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){\n            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;\n        }\n        else if (i = getIteratorFn(nextProps), \"function\" === typeof i) {\n            if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        nextProps = suspenseStackCursor.current;\n        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;\n        else {\n            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (null !== current.child) {\n                    current.child.return = current;\n                    current = current.child;\n                    continue;\n                }\n                if (current === workInProgress) break a;\n                for(; null === current.sibling;){\n                    if (null === current.return || current.return === workInProgress) break a;\n                    current = current.return;\n                }\n                current.sibling.return = current.return;\n                current = current.sibling;\n            }\n            nextProps &= SubtreeSuspenseContextMask;\n        }\n        push(suspenseStackCursor, nextProps, workInProgress);\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);\n                break;\n            case \"backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n            case 23:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    var nextProps = workInProgress.pendingProps;\n                    prevSibling = workInProgress.memoizedState;\n                    returnFiber = prevSibling.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    nextProps = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, nextProps);\n                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    nextProps = nextState.element;\n                    if (supportsHydration && prevSibling.isDehydrated) if (prevSibling = {\n                        element: nextProps,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else if (nextProps !== returnFiber) {\n                        returnFiber = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(returnFiber);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else for(supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0), current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    else {\n                        resetHydrationState();\n                        if (nextProps === returnFiber) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                if (supportsResources) return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress)) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                if (supportsSingletons) return pushHostContext(workInProgress), null === current && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChild(prevSibling)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress.type, workInProgress.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), current = validateHydratableTextInstance(current, renderLanes), renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer2 = rendererSigil);\n    }\n    function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            var context = currentDependencies.context;\n            if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$1(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: cacheFromPool\n        };\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function doesRequireClone(current, completedWork) {\n        if (null !== current && current.child === completedWork.child) return !1;\n        if (0 !== (completedWork.flags & 16)) return !0;\n        for(current = completedWork.child; null !== current;){\n            if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878)) return !0;\n            current = current.sibling;\n        }\n        return !1;\n    }\n    function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsMutation) for(needsVisibilityToggle = workInProgress.child; null !== needsVisibilityToggle;){\n            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);\n            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {\n                needsVisibilityToggle.child.return = needsVisibilityToggle;\n                needsVisibilityToggle = needsVisibilityToggle.child;\n                continue;\n            }\n            if (needsVisibilityToggle === workInProgress) break;\n            for(; null === needsVisibilityToggle.sibling;){\n                if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress) return;\n                needsVisibilityToggle = needsVisibilityToggle.return;\n            }\n            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;\n            needsVisibilityToggle = needsVisibilityToggle.sibling;\n        }\n        else if (supportsPersistence) for(var _node = workInProgress.child; null !== _node;){\n            if (5 === _node.tag) {\n                var instance = _node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));\n                appendInitialChild(parent, instance);\n            } else if (6 === _node.tag) instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);\n            else if (4 !== _node.tag) {\n                if (22 === _node.tag && null !== _node.memoizedState) instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, !0, !0);\n                else if (null !== _node.child) {\n                    _node.child.return = _node;\n                    _node = _node.child;\n                    continue;\n                }\n            }\n            if (_node === workInProgress) break;\n            for(; null === _node.sibling;){\n                if (null === _node.return || _node.return === workInProgress) return;\n                _node = _node.return;\n            }\n            _node.sibling.return = _node.return;\n            _node = _node.sibling;\n        }\n    }\n    function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsPersistence) for(var node = workInProgress.child; null !== node;){\n            if (5 === node.tag) {\n                var instance = node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));\n                appendChildToContainerChildSet(containerChildSet, instance);\n            } else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);\n            else if (4 !== node.tag) {\n                if (22 === node.tag && null !== node.memoizedState) instance = node.child, null !== instance && (instance.return = node), appendAllChildrenToContainer(containerChildSet, node, !(null !== node.memoizedProps && \"manual\" === node.memoizedProps.mode), !0);\n                else if (null !== node.child) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n            }\n            if (node === workInProgress) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === workInProgress) return;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n    }\n    function updateHostContainer(current, workInProgress) {\n        if (supportsPersistence && doesRequireClone(current, workInProgress)) {\n            current = workInProgress.stateNode;\n            var container = current.containerInfo, newChildSet = createContainerChildSet();\n            appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);\n            current.pendingChildren = newChildSet;\n            markUpdate(workInProgress);\n            finalizeContainerChildren(container, newChildSet);\n        }\n    }\n    function updateHostComponent(current, workInProgress, type, newProps) {\n        if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress);\n        else if (supportsPersistence) {\n            var currentInstance = current.stateNode, _oldProps = current.memoizedProps;\n            if ((current = doesRequireClone(current, workInProgress)) || _oldProps !== newProps) {\n                var currentHostContext = getHostContext();\n                _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current, null);\n                _oldProps === currentInstance ? workInProgress.stateNode = currentInstance : (finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress), workInProgress.stateNode = _oldProps, current ? appendAllChildren(_oldProps, workInProgress, !1, !1) : markUpdate(workInProgress));\n            } else workInProgress.stateNode = currentInstance;\n        }\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {\n        if (maySuspendCommit(type, props)) {\n            if (workInProgress.flags |= 16777216, !preloadInstance(type, props)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (mayResourceSuspendCommit(resource)) {\n            if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & 2) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & 2) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));\n                updateHostContainer(current, workInProgress);\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                if (supportsResources) {\n                    renderLanes = workInProgress.type;\n                    var nextResource = workInProgress.memoizedState;\n                    null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, renderLanes, newProps), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps));\n                    return null;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    popHostContext(workInProgress);\n                    renderLanes = requiredContext(rootInstanceStackCursor.current);\n                    nextResource = workInProgress.type;\n                    if (null !== current && null != workInProgress.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, nextResource, newProps);\n                    else {\n                        if (!newProps) {\n                            if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        current = getHostContext();\n                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(nextResource, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                }\n            case 5:\n                popHostContext(workInProgress);\n                renderLanes = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) updateHostComponent(current, workInProgress, renderLanes, newProps);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    current = getHostContext();\n                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (nextResource = requiredContext(rootInstanceStackCursor.current), nextResource = createInstance(renderLanes, newProps, nextResource, current, workInProgress), appendAllChildren(nextResource, workInProgress, !1, !1), workInProgress.stateNode = nextResource, finalizeInitialChildren(nextResource, renderLanes, newProps, current) && markUpdate(workInProgress));\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) renderLanes = current.memoizedProps, supportsMutation ? renderLanes !== newProps && markUpdate(workInProgress) : supportsPersistence && (renderLanes !== newProps ? (current = requiredContext(rootInstanceStackCursor.current), renderLanes = getHostContext(), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress), markUpdate(workInProgress)) : workInProgress.stateNode = current.stateNode);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        nextResource = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        var returnFiber = hydrationParentFiber;\n                        if (null !== returnFiber) switch(returnFiber.tag){\n                            case 3:\n                                nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = returnFiber.memoizedProps, nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                        }\n                        hydrateTextInstance(current, renderLanes, workInProgress, newProps) || throwOnHydrationMismatch(workInProgress);\n                    } else workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    nextResource = popHydrationState(workInProgress);\n                    if (null !== newProps && null !== newProps.dehydrated) {\n                        if (null === current) {\n                            if (!nextResource) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            nextResource = workInProgress.memoizedState;\n                            nextResource = null !== nextResource ? nextResource.dehydrated : null;\n                            if (!nextResource) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateSuspenseInstance(nextResource, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        nextResource = !1;\n                    } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), nextResource = !0;\n                    if (!nextResource) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, nextResource = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== nextResource && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & 2) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), updateHostContainer(current, workInProgress), null === current && preparePortalMount(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                nextResource = workInProgress.memoizedState;\n                if (null === nextResource) return bubbleProperties(workInProgress), null;\n                newProps = 0 !== (workInProgress.flags & 128);\n                returnFiber = nextResource.rendering;\n                if (null === returnFiber) if (newProps) cutOffTailIfNeeded(nextResource, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        returnFiber = findFirstSuspended(current);\n                        if (null !== returnFiber) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(nextResource, !1);\n                            current = returnFiber.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== nextResource.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {\n                        if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(nextResource, !0), null === nextResource.tail && \"hidden\" === nextResource.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                    nextResource.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = nextResource.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, nextResource.last = returnFiber);\n                }\n                if (null !== nextResource.tail) return current = nextResource.tail, nextResource.rendering = current, nextResource.tail = current.sibling, nextResource.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & 2) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            var instance = finishedWork.stateNode;\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    instance = getPublicInstance(instance);\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instance);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instance);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instance;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$3) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$3);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag : !1) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && (supportsSingletons ? 27 !== fiber.tag : 1) && 18 !== fiber.tag;){\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        if (supportsMutation && (!supportsSingletons || 27 !== finishedWork.tag)) {\n            a: {\n                for(var parent = finishedWork.return; null !== parent;){\n                    if (isHostParent(parent)) {\n                        var parentFiber = parent;\n                        break a;\n                    }\n                    parent = parent.return;\n                }\n                throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            switch(parentFiber.tag){\n                case 27:\n                    if (supportsSingletons) {\n                        parent = parentFiber.stateNode;\n                        parentFiber = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                        break;\n                    }\n                case 5:\n                    parent = parentFiber.stateNode;\n                    parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                    break;\n                case 3:\n                case 4:\n                    parent = parentFiber.stateNode.containerInfo;\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);\n                    break;\n                default:\n                    throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n    }\n    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {\n        portal = portal.containerInfo;\n        try {\n            runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        prepareForCommit(root.containerInfo);\n        for(nextEffect = firstChild; null !== nextEffect;)if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1028) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;\n        else for(; null !== nextEffect;){\n            firstChild = root = nextEffect;\n            var current = firstChild.alternate, flags = firstChild.flags;\n            switch(firstChild.tag){\n                case 0:\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (flags & 1024) && null !== current && commitClassSnapshot(firstChild, current);\n                    break;\n                case 3:\n                    0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (flags & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            firstChild = root.sibling;\n            if (null !== firstChild) {\n                firstChild.return = root.return;\n                nextEffect = firstChild;\n                break;\n            }\n            nextEffect = root.return;\n        }\n        root = shouldFireAfterActiveInstanceBlur;\n        shouldFireAfterActiveInstanceBlur = !1;\n        return root;\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = getPublicInstance(finishedWork.child.stateNode);\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 26:\n                if (supportsResources) {\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                    break;\n                }\n            case 27:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                null === current && flags & 4 && commitHostMount(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!prevProps) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = prevProps;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                flags & 512 && (\"manual\" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        switch(deletedFiber.tag){\n            case 26:\n                if (supportsResources) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                    hostParent = deletedFiber.stateNode;\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    releaseSingletonInstance(deletedFiber.stateNode);\n                    hostParent = prevHostParent;\n                    hostParentIsContainer = prevHostParentIsContainer;\n                    break;\n                }\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                if (supportsMutation) {\n                    if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {\n                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                    else try {\n                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                } else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 18:\n                supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function commitMutationEffects(root, finishedWork, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitMutationEffectsOnFiber(finishedWork, root);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i];\n            if (supportsMutation) {\n                var parent = returnFiber;\n                a: for(; null !== parent;){\n                    switch(parent.tag){\n                        case 27:\n                        case 5:\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        case 3:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                        case 4:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                    }\n                    parent = parent.return;\n                }\n                if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = !1;\n            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));\n                break;\n            case 26:\n                if (supportsResources) {\n                    var hoistableRoot = currentHoistableRoot;\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    flags & 4 && (flags = null !== current ? current.memoizedState : null, root = finishedWork.memoizedState, null === current ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === root ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : null === root && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps));\n                    break;\n                }\n            case 27:\n                if (supportsSingletons && flags & 4 && null === finishedWork.alternate) {\n                    hoistableRoot = finishedWork.stateNode;\n                    var props = finishedWork.memoizedProps;\n                    try {\n                        clearSingleton(hoistableRoot), runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, hoistableRoot, finishedWork);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (supportsMutation) {\n                    if (finishedWork.flags & 32) {\n                        root = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, resetTextContent, root);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                    flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                    flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                }\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && supportsMutation) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                supportsResources ? (prepareToCommitHoistables(), props = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = props) : recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {\n                        runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    if (supportsPersistence) {\n                        flags = root.containerInfo;\n                        current = root.pendingChildren;\n                        try {\n                            runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));\n                flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                commitReconciliationEffects(finishedWork);\n                root = finishedWork.stateNode;\n                root._current = finishedWork;\n                root._visibility &= -3;\n                root._visibility |= root._pendingVisibility & 2;\n                if (flags & 8192 && (root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || wasHidden || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation && (null === finishedWork.memoizedProps || \"manual\" !== finishedWork.memoizedProps.mode))) {\n                    a: if (current = null, supportsMutation) for(root = finishedWork;;){\n                        if (5 === root.tag || supportsResources && 26 === root.tag || supportsSingletons && 27 === root.tag) {\n                            if (null === current) {\n                                wasHidden = current = root;\n                                try {\n                                    props = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, props) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (6 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                            root.child.return = root;\n                            root = root.child;\n                            continue;\n                        }\n                        if (root === finishedWork) break a;\n                        for(; null === root.sibling;){\n                            if (null === root.return || root.return === finishedWork) break a;\n                            current === root && (current = null);\n                            root = root.return;\n                        }\n                        current === root && (current = null);\n                        root.sibling.return = root.return;\n                        root = root.sibling;\n                    }\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function commitLayoutEffects(finishedWork, root, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    prevEffectDuration = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 23:\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        }\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n            }\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps) : suspendInstance(fiber.type, fiber.memoizedProps));\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);\n                break;\n            case 3:\n            case 4:\n                if (supportsResources) {\n                    var previousHoistableRoot = currentHoistableRoot;\n                    currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n                    recursivelyAccumulateSuspenseyCommit(fiber);\n                    currentHoistableRoot = previousHoistableRoot;\n                } else recursivelyAccumulateSuspenseyCommit(fiber);\n                break;\n            case 22:\n                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevEffectDuration._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & 4 && (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber;\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            current = fiber.child;\n            if (null !== current) current.return = fiber, nextEffect = current;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                current = nextEffect;\n                var sibling = current.sibling, returnFiber = current.return;\n                detachFiberAfterEffects(current);\n                if (current === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== sibling) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    break a;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n    }\n    function findFiberRootForHostRoot(hostRoot) {\n        var maybeFiber = getInstanceFromNode(hostRoot);\n        if (null != maybeFiber) {\n            if (\"string\" !== typeof maybeFiber.memoizedProps[\"data-testname\"]) throw Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n            return maybeFiber;\n        }\n        hostRoot = findFiberRoot(hostRoot);\n        if (null === hostRoot) throw Error(\"Could not find React container within specified host subtree.\");\n        return hostRoot.stateNode.current;\n    }\n    function matchSelector(fiber$jscomp$0, selector) {\n        var tag = fiber$jscomp$0.tag;\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                if (fiber$jscomp$0.type === selector.value) return !0;\n                break;\n            case HAS_PSEUDO_CLASS_TYPE:\n                a: {\n                    selector = selector.value;\n                    fiber$jscomp$0 = [\n                        fiber$jscomp$0,\n                        0\n                    ];\n                    for(tag = 0; tag < fiber$jscomp$0.length;){\n                        var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];\n                        if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {\n                            for(; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);)selectorIndex++, selector$jscomp$0 = selector[selectorIndex];\n                            if (selectorIndex === selector.length) {\n                                selector = !0;\n                                break a;\n                            } else for(fiber = fiber.child; null !== fiber;)fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;\n                        }\n                    }\n                    selector = !1;\n                }\n                return selector;\n            case ROLE_TYPE:\n                if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;\n                break;\n            case TEXT_TYPE:\n                if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;\n                }\n                break;\n            case TEST_NAME_TYPE:\n                if (5 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps[\"data-testname\"], \"string\" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;\n                }\n                break;\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n        return !1;\n    }\n    function selectorToString(selector) {\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                return \"<\" + (getComponentNameFromType(selector.value) || \"Unknown\") + \">\";\n            case HAS_PSEUDO_CLASS_TYPE:\n                return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n            case ROLE_TYPE:\n                return '[role=\"' + selector.value + '\"]';\n            case TEXT_TYPE:\n                return '\"' + selector.value + '\"';\n            case TEST_NAME_TYPE:\n                return '[data-testname=\"' + selector.value + '\"]';\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n    }\n    function findPaths(root, selectors) {\n        var matchingFibers = [];\n        root = [\n            root,\n            0\n        ];\n        for(var index = 0; index < root.length;){\n            var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                for(; null != selector && matchSelector(fiber, selector);)selectorIndex++, selector = selectors[selectorIndex];\n                if (selectorIndex === selectors.length) matchingFibers.push(fiber);\n                else for(fiber = fiber.child; null !== fiber;)root.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        return matchingFibers;\n    }\n    function findAllNodes(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        hostRoot = findPaths(hostRoot, selectors);\n        selectors = [];\n        hostRoot = Array.from(hostRoot);\n        for(var index = 0; index < hostRoot.length;){\n            var node = hostRoot[index++], tag = node.tag;\n            if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);\n            else for(node = node.child; null !== node;)hostRoot.push(node), node = node.sibling;\n        }\n        return selectors;\n    }\n    function onCommitRoot() {\n        supportsTestSelectors && commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);\n        var suspenseHandler = suspenseHandlerStackCursor.current;\n        null !== suspenseHandler && (suspenseHandler.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;\n        do {\n            if (exitStatus === RootInProgress) {\n                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);\n                break;\n            } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);\n            else {\n                forceSync = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {\n                    exitStatus = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (exitStatus === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        lanes = errorRetryLanes;\n                        a: {\n                            exitStatus = root;\n                            var errorRetryLanes$jscomp$0 = errorRetryLanes;\n                            errorRetryLanes = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = supportsHydration && exitStatus.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);\n                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);\n                            if (errorRetryLanes$jscomp$0 !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;\n                                    exitStatus = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                exitStatus = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = errorRetryLanes;\n                                null !== exitStatus && queueRecoverableErrors(exitStatus);\n                            }\n                            exitStatus = errorRetryLanes$jscomp$0;\n                        }\n                        renderWasConcurrent = !1;\n                        if (exitStatus !== RootErrored) continue;\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    shouldTimeSlice = root;\n                    switch(exitStatus){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194176) === lanes) {\n                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                                break a;\n                            }\n                            break;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    shouldTimeSlice.finishedWork = forceSync;\n                    shouldTimeSlice.finishedLanes = lanes;\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, -0, 0);\n                    else {\n                        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, -0, 0), exitStatus);\n                            break a;\n                        }\n                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, -0, 0);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function queueRecoverableErrors(errors) {\n        null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var subtreeFlags = finishedWork.subtreeFlags;\n        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {\n            if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {\n                root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function prepareFreshStack(root, lanes) {\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        var timeoutHandle = root.timeoutHandle;\n        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));\n        timeoutHandle = root.cancelPendingCommit;\n        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        var allEntangledLanes = root.entangledLanes;\n        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){\n            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;\n            lanes |= root[index];\n            allEntangledLanes &= ~lane;\n        }\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return timeoutHandle;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber$1 = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n        else switch(erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){\n            case SuspendedOnError:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                break;\n            case SuspendedOnData:\n            case SuspendedOnImmediate:\n            case SuspendedOnDeprecatedThrowPromise:\n            case SuspendedAndReadyToContinue:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        markRenderStarted(lanes);\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootDidNotComplete;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$4) {\n            handleThrow(root, thrownValue$4);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        markRenderStopped();\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        markRenderStarted(lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;\n                            if (resource ? preloadResource(resource) : preloadInstance(type, props)) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootDidNotComplete;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();\n            break;\n        } catch (thrownValue$5) {\n            handleThrow(root, thrownValue$5);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;\n        markRenderStopped();\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrent() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & 2) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n    }\n    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = getCurrentUpdatePriority();\n        try {\n            setCurrentUpdatePriority(2), ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n        } finally{\n            ReactSharedInternals.T = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);\n        }\n    }\n    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        do flushPassiveEffects();\n        while (null !== rootWithPendingPassiveEffects);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var finishedWork = root.finishedWork;\n        didIncludeRenderPhaseUpdate = root.finishedLanes;\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);\n        if (null === finishedWork) return markCommitStopped(), null;\n        0 === didIncludeRenderPhaseUpdate && console.error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n        root.callbackNode = null;\n        root.callbackPriority = 0;\n        root.cancelPendingCommit = null;\n        var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n        remainingLanes |= concurrentlyUpdatedLanes;\n        markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);\n        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n        0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback(NormalPriority$1, function() {\n            flushPassiveEffects(!0);\n            return null;\n        }));\n        commitStartTime = now();\n        transitions = 0 !== (finishedWork.flags & 15990);\n        0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = getCurrentUpdatePriority(), setCurrentUpdatePriority(2), updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), resetAfterCommit(root.containerInfo), root.current = finishedWork, null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, setCurrentUpdatePriority(spawnedLane), ReactSharedInternals.T = transitions) : root.current = finishedWork;\n        (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n        remainingLanes = root.pendingLanes;\n        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n        transitions || commitDoubleInvokeEffectsInDEV(root);\n        onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n        isDevToolsPresent && root.memoizedUpdaters.clear();\n        onCommitRoot();\n        ensureRootIsScheduled(root);\n        if (null !== recoverableErrors) for(renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);\n        0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n        remainingLanes = root.pendingLanes;\n        0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        markCommitStopped();\n        return null;\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPassiveEffects() {\n        if (null !== rootWithPendingPassiveEffects) {\n            var root = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;\n            pendingPassiveEffectsRemainingLanes = 0;\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;\n            renderPriority = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(priority);\n                ReactSharedInternals.T = null;\n                if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;\n                else {\n                    priority = pendingPassiveTransitions;\n                    pendingPassiveTransitions = null;\n                    var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;\n                    rootWithPendingPassiveEffects = null;\n                    pendingPassiveEffectsLanes = 0;\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n                    isFlushingPassiveEffects = !0;\n                    didScheduleUpdateDuringPassiveEffects = !1;\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                    var prevExecutionContext = executionContext;\n                    executionContext |= CommitContext;\n                    commitPassiveUnmountOnFiber(root$jscomp$0.current);\n                    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();\n                    commitDoubleInvokeEffectsInDEV(root$jscomp$0);\n                    executionContext = prevExecutionContext;\n                    flushSyncWorkAcrossRoots_impl(0, !1);\n                    didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;\n                    didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n                    if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n                    } catch (err) {\n                        hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n                    }\n                    var stateNode = root$jscomp$0.current.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                    JSCompiler_inline_result = !0;\n                }\n                return JSCompiler_inline_result;\n            } finally{\n                setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n            }\n        }\n        return !1;\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 33562624)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & 64) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & 24 || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;\n        switch(tag){\n            case 0:\n            case 15:\n            case 1:\n                candidateType = type;\n                break;\n            case 11:\n                candidateType = type.render;\n        }\n        if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n        var needsRender = !1;\n        type = !1;\n        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));\n        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);\n        type && (fiber._debugNeedsRemount = !0);\n        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 31457280;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 31457282;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;\n        else a: switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= 24;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                fiberTag = owner ? \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null : null;\n                fiberTag && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n        pendingProps = createFiber(22, pendingProps, key, mode);\n        pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n        pendingProps.lanes = lanes;\n        var primaryChildInstance = {\n            _visibility: 1,\n            _pendingVisibility: 1,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null,\n            _current: null,\n            detach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 === (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility |= 2, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            },\n            attach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 !== (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility &= -3, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            }\n        };\n        pendingProps.stateNode = primaryChildInstance;\n        return pendingProps;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n        tag = 1;\n        !0 === isStrictMode && (tag |= 24);\n        isDevToolsPresent && (tag |= 2);\n        isStrictMode = createFiber(3, null, null, tag);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerSync(element, container, parentComponent, callback) {\n        0 === container.tag && flushPassiveEffects();\n        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);\n        return 2;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    function getLaneLabelMap() {\n        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n        }\n        return map;\n    }\n    var exports = {};\n    \"use strict\";\n    var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"), Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    Symbol.for(\"react.debug_trace_mode\");\n    var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var current = null, isRendering = !1, isArrayImpl = Array.isArray, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance, appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance, scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;\n    $$$config.warnsIfNotActing;\n    var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;\n    $$$config.beforeActiveInstanceBlur;\n    $$$config.afterActiveInstanceBlur;\n    var preparePortalMount = $$$config.preparePortalMount;\n    $$$config.prepareScopeUpdate;\n    $$$config.getInstanceFromScope;\n    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;\n    $$$config.resolveEventType;\n    $$$config.resolveEventTimeStamp;\n    var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;\n    $$$config.requestPostPaintCallback;\n    var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance, waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance, clearContainer = $$$config.clearContainer, cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, clearSingleton = $$$config.clearSingleton, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, objectIs = \"function\" === typeof Object.is ? Object.is : is, CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), NoMode = 0, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, now = Scheduler.unstable_now, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, hasOwnProperty = Object.prototype.hasOwnProperty, ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & 8 && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callRender = {\n        \"react-stack-bottom-frame\": function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender), callComponentDidMount = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount[\"react-stack-bottom-frame\"].bind(callComponentDidMount), callComponentDidUpdate = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate[\"react-stack-bottom-frame\"].bind(callComponentDidUpdate), callComponentDidCatch = {\n        \"react-stack-bottom-frame\": function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch[\"react-stack-bottom-frame\"].bind(callComponentDidCatch), callComponentWillUnmount = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount[\"react-stack-bottom-frame\"].bind(callComponentWillUnmount), callCreate = {\n        \"react-stack-bottom-frame\": function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate[\"react-stack-bottom-frame\"].bind(callCreate), callDestroy = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy[\"react-stack-bottom-frame\"].bind(callDestroy), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;\n    var createFunctionComponentUpdateQueue = function() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    };\n    var ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError\n    };\n    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n    ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n    ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        mountHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        isMounted: function(component) {\n            var owner = current;\n            if (null !== owner && isRendering && 1 === owner.tag) {\n                var instance = owner.stateNode;\n                instance._warnedAboutRefsInRender || console.error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(owner) || \"A component\");\n                instance._warnedAboutRefsInRender = !0;\n            }\n            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;\n        },\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);\n        }\n    }, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (false) { var event; } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var renderer2CursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = !1, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        getOwner: function() {\n            return current;\n        }\n    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e) {\n        hasBadMapPolyfill = !0;\n    }\n    var didWarnAboutNestedUpdates = !1;\n    var didWarnAboutFindNodeInStrictMode = {};\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    exports.attemptContinuousHydration = function(fiber) {\n        if (13 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    };\n    exports.attemptHydrationAtCurrentPriority = function(fiber) {\n        if (13 === fiber.tag) {\n            var lane = requestUpdateLane(fiber), root = enqueueConcurrentRenderForLane(fiber, lane);\n            null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n    };\n    exports.attemptSynchronousHydration = function(fiber) {\n        switch(fiber.tag){\n            case 3:\n                fiber = fiber.stateNode;\n                if (fiber.current.memoizedState.isDehydrated) {\n                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                    if (0 !== lanes) {\n                        fiber.pendingLanes |= 2;\n                        for(fiber.entangledLanes |= 2; lanes;){\n                            var lane = 1 << 31 - clz32(lanes);\n                            fiber.entanglements[1] |= lane;\n                            lanes &= ~lane;\n                        }\n                        ensureRootIsScheduled(fiber);\n                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                    }\n                }\n                break;\n            case 13:\n                lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);\n        }\n    };\n    exports.batchedUpdates = function(fn, a) {\n        return fn(a);\n    };\n    exports.createComponentSelector = function(component) {\n        return {\n            $$typeof: COMPONENT_TYPE,\n            value: component\n        };\n    };\n    exports.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n        return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n    };\n    exports.createHasPseudoClassSelector = function(selectors) {\n        return {\n            $$typeof: HAS_PSEUDO_CLASS_TYPE,\n            value: selectors\n        };\n    };\n    exports.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);\n        initialChildren.context = getContextForSubtree(null);\n        containerInfo = initialChildren.current;\n        tag = requestUpdateLane(containerInfo);\n        hydrationCallbacks = createUpdate(tag);\n        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;\n        enqueueUpdate(containerInfo, hydrationCallbacks, tag);\n        initialChildren.current.lanes = tag;\n        markRootUpdated$1(initialChildren, tag);\n        ensureRootIsScheduled(initialChildren);\n        return initialChildren;\n    };\n    exports.createPortal = function(children, containerInfo, implementation) {\n        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n        try {\n            testStringCoercion(key);\n            var JSCompiler_inline_result = !1;\n        } catch (e$6) {\n            JSCompiler_inline_result = !0;\n        }\n        JSCompiler_inline_result && (console.error(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", \"function\" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || \"Object\"), testStringCoercion(key));\n        return {\n            $$typeof: REACT_PORTAL_TYPE,\n            key: null == key ? null : \"\" + key,\n            children: children,\n            containerInfo: containerInfo,\n            implementation: implementation\n        };\n    };\n    exports.createRoleSelector = function(role) {\n        return {\n            $$typeof: ROLE_TYPE,\n            value: role\n        };\n    };\n    exports.createTestNameSelector = function(id) {\n        return {\n            $$typeof: TEST_NAME_TYPE,\n            value: id\n        };\n    };\n    exports.createTextSelector = function(text) {\n        return {\n            $$typeof: TEXT_TYPE,\n            value: text\n        };\n    };\n    exports.defaultOnCaughtError = function(error, errorInfo) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\"), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            \"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName ? bindToConsole(\"error\", [\n                \"%o\\n\\n%s\\n\\n%s\\n\",\n                error,\n                componentNameMessage,\n                recreateMessage\n            ], error.environmentName)() : console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.defaultOnRecoverableError = function(error) {\n        reportGlobalError(error);\n    };\n    exports.defaultOnUncaughtError = function(error, errorInfo) {\n        reportGlobalError(error);\n        error = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\";\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            console.warn(\"%s\\n\\n%s\\n\", error, \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.deferredUpdates = function(fn) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;\n        }\n    };\n    exports.discreteUpdates = function(fn, a, b, c, d) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);\n        }\n    };\n    exports.findAllNodes = findAllNodes;\n    exports.findBoundingRects = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        selectors = findAllNodes(hostRoot, selectors);\n        hostRoot = [];\n        for(var i = 0; i < selectors.length; i++)hostRoot.push(getBoundingRect(selectors[i]));\n        for(selectors = hostRoot.length - 1; 0 < selectors; selectors--){\n            i = hostRoot[selectors];\n            for(var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)if (selectors !== j) {\n                var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;\n                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {\n                    otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);\n                    otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {\n                    otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);\n                    otherRight < targetRight && (otherRect.width = targetRight - otherLeft);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                }\n            }\n        }\n        return hostRoot;\n    };\n    exports.findHostInstance = function(component) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        return null === component ? null : getPublicInstance(component.stateNode);\n    };\n    exports.findHostInstanceWithNoPortals = function(fiber) {\n        fiber = findCurrentFiberUsingSlowPath(fiber);\n        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;\n        return null === fiber ? null : getPublicInstance(fiber.stateNode);\n    };\n    exports.findHostInstanceWithWarning = function(component, methodName) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        if (null === component) return null;\n        if (component.mode & 8) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            didWarnAboutFindNodeInStrictMode[componentName] || (didWarnAboutFindNodeInStrictMode[componentName] = !0, runWithFiberInDEV(component, function() {\n                fiber.mode & 8 ? console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName) : console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName);\n            }));\n        }\n        return getPublicInstance(component.stateNode);\n    };\n    exports.flushPassiveEffects = flushPassiveEffects;\n    exports.flushSyncFromReconciler = function(fn) {\n        var prevExecutionContext = executionContext;\n        executionContext |= 1;\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn) return fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    };\n    exports.flushSyncWork = flushSyncWork;\n    exports.focusWithin = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        selectors = findPaths(hostRoot, selectors);\n        selectors = Array.from(selectors);\n        for(hostRoot = 0; hostRoot < selectors.length;){\n            var fiber = selectors[hostRoot++], tag = fiber.tag;\n            if (!isHiddenSubtree(fiber)) {\n                if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;\n                for(fiber = fiber.child; null !== fiber;)selectors.push(fiber), fiber = fiber.sibling;\n            }\n        }\n        return !1;\n    };\n    exports.getFindAllNodesFailureDescription = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var maxSelectorIndex = 0, matchedNames = [];\n        hostRoot = [\n            findFiberRootForHostRoot(hostRoot),\n            0\n        ];\n        for(var index = 0; index < hostRoot.length;){\n            var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for(fiber = fiber.child; null !== fiber;)hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        if (maxSelectorIndex < selectors.length) {\n            for(hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));\n            return \"findAllNodes was able to match part of the selector:\\n  \" + (matchedNames.join(\" > \") + \"\\n\\nNo matching component was found for:\\n  \") + hostRoot.join(\" > \");\n        }\n        return null;\n    };\n    exports.getPublicRootInstance = function(container) {\n        container = container.current;\n        if (!container.child) return null;\n        switch(container.child.tag){\n            case 27:\n            case 5:\n                return getPublicInstance(container.child.stateNode);\n            default:\n                return container.child.stateNode;\n        }\n    };\n    exports.injectIntoDevTools = function() {\n        var internals = {\n            bundleType: 1,\n            version: rendererVersion,\n            rendererPackageName: rendererPackageName,\n            currentDispatcherRef: ReactSharedInternals,\n            findFiberByHostInstance: getInstanceFromNode,\n            reconcilerVersion: \"19.0.0\"\n        };\n        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        internals.getLaneLabelMap = getLaneLabelMap;\n        internals.injectProfilingHooks = injectProfilingHooks;\n        return injectInternals(internals);\n    };\n    exports.isAlreadyRendering = function() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n    };\n    exports.observeVisibleRects = function(hostRoot, selectors, callback, options) {\n        function commitHook() {\n            var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n            instanceRoots.forEach(function(target) {\n                0 > nextInstanceRoots.indexOf(target) && unobserve(target);\n            });\n            nextInstanceRoots.forEach(function(target) {\n                0 > instanceRoots.indexOf(target) && observe(target);\n            });\n        }\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var instanceRoots = findAllNodes(hostRoot, selectors);\n        callback = setupIntersectionObserver(instanceRoots, callback, options);\n        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;\n        commitHooks.push(commitHook);\n        return {\n            disconnect: function() {\n                var index = commitHooks.indexOf(commitHook);\n                0 <= index && commitHooks.splice(index, 1);\n                disconnect();\n            }\n        };\n    };\n    exports.shouldError = function(fiber) {\n        return shouldErrorImpl(fiber);\n    };\n    exports.shouldSuspend = function(fiber) {\n        return shouldSuspendImpl(fiber);\n    };\n    exports.startHostTransition = function(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop : function() {\n            null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n            dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));\n            return action(formData);\n        });\n    };\n    exports.updateContainer = function(element, container, parentComponent, callback) {\n        var current = container.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, element, container, parentComponent, callback);\n        return lane;\n    };\n    exports.updateContainerSync = updateContainerSync;\n    return exports;\n}, module.exports[\"default\"] = module.exports, Object.defineProperty(module.exports, \"__esModule\", {\n    value: !0\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0FBcUMsSUFDbEMsUUFBUUksT0FBTyxHQUFHLFNBQVVDLFNBQVM7SUFDcEMsU0FBU0MsU0FBU0MsS0FBSyxFQUFFQyxFQUFFO1FBQ3pCLElBQUtELFFBQVFBLE1BQU1FLGFBQWEsRUFBRSxTQUFTRixTQUFTLElBQUlDLElBQ3RELFFBQVNELE1BQU1HLElBQUksRUFBR0Y7UUFDeEIsT0FBT0Q7SUFDVDtJQUNBLFNBQVNJLGdCQUFnQkMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsS0FBSztRQUM5QyxJQUFJRCxTQUFTRCxLQUFLRyxNQUFNLEVBQUUsT0FBT0Q7UUFDakMsSUFBSUUsTUFBTUosSUFBSSxDQUFDQyxNQUFNLEVBQ25CSSxVQUFVQyxZQUFZUCxPQUFPQSxJQUFJUSxLQUFLLEtBQUtDLE9BQU8sQ0FBQyxHQUFHVDtRQUN4RE0sT0FBTyxDQUFDRCxJQUFJLEdBQUdOLGdCQUFnQkMsR0FBRyxDQUFDSyxJQUFJLEVBQUVKLE1BQU1DLFFBQVEsR0FBR0M7UUFDMUQsT0FBT0c7SUFDVDtJQUNBLFNBQVNJLGVBQWVWLEdBQUcsRUFBRVcsT0FBTyxFQUFFQyxPQUFPO1FBQzNDLElBQUlELFFBQVFQLE1BQU0sS0FBS1EsUUFBUVIsTUFBTSxFQUNuQ1MsUUFBUUMsSUFBSSxDQUFDO2FBQ1Y7WUFDSCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsUUFBUVIsTUFBTSxHQUFHLEdBQUdXLElBQ3RDLElBQUlKLE9BQU8sQ0FBQ0ksRUFBRSxLQUFLSCxPQUFPLENBQUNHLEVBQUUsRUFBRTtnQkFDN0JGLFFBQVFDLElBQUksQ0FDVjtnQkFFRjtZQUNGO1lBQ0YsT0FBT0UsbUJBQW1CaEIsS0FBS1csU0FBU0MsU0FBUztRQUNuRDtJQUNGO0lBQ0EsU0FBU0ksbUJBQW1CaEIsR0FBRyxFQUFFVyxPQUFPLEVBQUVDLE9BQU8sRUFBRVYsS0FBSztRQUN0RCxJQUFJZSxTQUFTTixPQUFPLENBQUNULE1BQU0sRUFDekJJLFVBQVVDLFlBQVlQLE9BQU9BLElBQUlRLEtBQUssS0FBS0MsT0FBTyxDQUFDLEdBQUdUO1FBQ3hERSxRQUFRLE1BQU1TLFFBQVFQLE1BQU0sR0FDdkIsUUFBUSxDQUFDUSxPQUFPLENBQUNWLE1BQU0sQ0FBQyxHQUFHSSxPQUFPLENBQUNXLE9BQU8sRUFDM0NWLFlBQVlELFdBQ1JBLFFBQVFZLE1BQU0sQ0FBQ0QsUUFBUSxLQUN2QixPQUFPWCxPQUFPLENBQUNXLE9BQU8sSUFDekJYLE9BQU8sQ0FBQ1csT0FBTyxHQUFHRCxtQkFDakJoQixHQUFHLENBQUNpQixPQUFPLEVBQ1hOLFNBQ0FDLFNBQ0FWLFFBQVE7UUFFZCxPQUFPSTtJQUNUO0lBQ0EsU0FBU2EsbUJBQW1CbkIsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLEtBQUs7UUFDMUMsSUFBSUcsTUFBTUosSUFBSSxDQUFDQyxNQUFNLEVBQ25CSSxVQUFVQyxZQUFZUCxPQUFPQSxJQUFJUSxLQUFLLEtBQUtDLE9BQU8sQ0FBQyxHQUFHVDtRQUN4RCxJQUFJRSxRQUFRLE1BQU1ELEtBQUtHLE1BQU0sRUFDM0IsT0FDRUcsWUFBWUQsV0FBV0EsUUFBUVksTUFBTSxDQUFDYixLQUFLLEtBQUssT0FBT0MsT0FBTyxDQUFDRCxJQUFJLEVBQ25FQztRQUVKQSxPQUFPLENBQUNELElBQUksR0FBR2MsbUJBQW1CbkIsR0FBRyxDQUFDSyxJQUFJLEVBQUVKLE1BQU1DLFFBQVE7UUFDMUQsT0FBT0k7SUFDVDtJQUNBLFNBQVNjO1FBQ1AsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxTQUFTQztRQUNQLE9BQU87SUFDVDtJQUNBLFNBQVNDLFlBQVlDLEdBQUcsRUFBRUMsWUFBWSxFQUFFbkIsR0FBRyxFQUFFb0IsSUFBSTtRQUMvQyxPQUFPLElBQUlDLFVBQVVILEtBQUtDLGNBQWNuQixLQUFLb0I7SUFDL0M7SUFDQSxTQUFTRSxhQUFhQyxJQUFJLEVBQUVDLE9BQU87UUFDakNELEtBQUtFLE9BQU8sS0FBS0Msc0JBQ2RDLENBQUFBLG9CQUFvQkgsU0FBU0QsTUFBTSxNQUFNLE9BQU9LLGVBQWM7SUFDbkU7SUFDQSxTQUFTQyxnQkFBZ0JOLElBQUksRUFBRU8sTUFBTTtRQUNuQyxJQUFJLFNBQVNDLGVBQWU7WUFDMUIsSUFBSUMsZ0JBQWdCRixPQUFPRSxhQUFhO1lBQ3hDRixTQUFTQSxPQUFPRyxlQUFlO1lBQy9CQztZQUNBQyxzQ0FDRVosS0FBS2EsT0FBTyxFQUNaTixRQUNBRTtZQUVGSjtRQUNGO0lBQ0Y7SUFDQSxTQUFTUyxrQkFBa0JDLE9BQU87UUFDaENQLGdCQUFnQk87SUFDbEI7SUFDQSxTQUFTQztRQUNQL0IsUUFBUWdDLEtBQUssQ0FDWDtJQUVKO0lBQ0EsU0FBU0M7UUFDUGpDLFFBQVFnQyxLQUFLLENBQ1g7SUFFSjtJQUNBLFNBQVNFLFFBQVE7SUFDakIsU0FBU0MscUJBQXFCO0lBQzlCLFNBQVNDLGtCQUFrQkMsR0FBRztRQUM1QixJQUFJQyxRQUFRLEVBQUU7UUFDZEQsSUFBSUUsT0FBTyxDQUFDLFNBQVVqRCxLQUFLO1lBQ3pCZ0QsTUFBTUUsSUFBSSxDQUFDbEQ7UUFDYjtRQUNBLE9BQU9nRCxNQUFNRyxJQUFJLEdBQUdDLElBQUksQ0FBQztJQUMzQjtJQUNBLFNBQVNDLGNBQWNDLGFBQWE7UUFDbEMsSUFBSSxTQUFTQSxpQkFBaUIsYUFBYSxPQUFPQSxlQUNoRCxPQUFPO1FBQ1RBLGdCQUNFLHlCQUEwQkEsYUFBYSxDQUFDQyxzQkFBc0IsSUFDOURELGFBQWEsQ0FBQyxhQUFhO1FBQzdCLE9BQU8sZUFBZSxPQUFPQSxnQkFBZ0JBLGdCQUFnQjtJQUMvRDtJQUNBLFNBQVNFLHlCQUF5QkMsSUFBSTtRQUNwQyxJQUFJLFFBQVFBLE1BQU0sT0FBTztRQUN6QixJQUFJLGVBQWUsT0FBT0EsTUFDeEIsT0FBT0EsS0FBS0MsUUFBUSxLQUFLQyx5QkFDckIsT0FDQUYsS0FBS0csV0FBVyxJQUFJSCxLQUFLSSxJQUFJLElBQUk7UUFDdkMsSUFBSSxhQUFhLE9BQU9KLE1BQU0sT0FBT0E7UUFDckMsT0FBUUE7WUFDTixLQUFLSztnQkFDSCxPQUFPO1lBQ1QsS0FBS0M7Z0JBQ0gsT0FBTztZQUNULEtBQUtDO2dCQUNILE9BQU87WUFDVCxLQUFLQztnQkFDSCxPQUFPO1lBQ1QsS0FBS0M7Z0JBQ0gsT0FBTztZQUNULEtBQUtDO2dCQUNILE9BQU87UUFDWDtRQUNBLElBQUksYUFBYSxPQUFPVixNQUN0QixPQUNHLGFBQWEsT0FBT0EsS0FBS3JDLEdBQUcsSUFDM0JWLFFBQVFnQyxLQUFLLENBQ1gsc0hBRUplLEtBQUtDLFFBQVE7WUFFYixLQUFLVTtnQkFDSCxPQUFPLENBQUNYLEtBQUtHLFdBQVcsSUFBSSxTQUFRLElBQUs7WUFDM0MsS0FBS1M7Z0JBQ0gsT0FBTyxDQUFDWixLQUFLYSxRQUFRLENBQUNWLFdBQVcsSUFBSSxTQUFRLElBQUs7WUFDcEQsS0FBS1c7Z0JBQ0gsSUFBSUMsWUFBWWYsS0FBS2dCLE1BQU07Z0JBQzNCaEIsT0FBT0EsS0FBS0csV0FBVztnQkFDdkJILFFBQ0csUUFBUWUsVUFBVVosV0FBVyxJQUFJWSxVQUFVWCxJQUFJLElBQUksSUFDbkRKLE9BQU8sT0FBT0EsT0FBTyxnQkFBZ0JBLE9BQU8sTUFBTSxZQUFZO2dCQUNqRSxPQUFPQTtZQUNULEtBQUtpQjtnQkFDSCxPQUNFLFlBQWFqQixLQUFLRyxXQUFXLElBQUksTUFDakMsU0FBU1ksWUFDTEEsWUFDQWhCLHlCQUF5QkMsS0FBS0EsSUFBSSxLQUFLO1lBRS9DLEtBQUtrQjtnQkFDSEgsWUFBWWYsS0FBS21CLFFBQVE7Z0JBQ3pCbkIsT0FBT0EsS0FBS29CLEtBQUs7Z0JBQ2pCLElBQUk7b0JBQ0YsT0FBT3JCLHlCQUF5QkMsS0FBS2U7Z0JBQ3ZDLEVBQUUsT0FBT00sR0FBRyxDQUFDO1FBQ2pCO1FBQ0YsT0FBTztJQUNUO0lBQ0EsU0FBU0MsMEJBQTBCdkYsS0FBSztRQUN0QyxJQUFJaUUsT0FBT2pFLE1BQU1pRSxJQUFJO1FBQ3JCLE9BQVFqRSxNQUFNNEIsR0FBRztZQUNmLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTyxDQUFDcUMsS0FBS2EsUUFBUSxDQUFDVixXQUFXLElBQUksU0FBUSxJQUFLO1lBQ3BELEtBQUs7Z0JBQ0gsT0FBTyxDQUFDSCxLQUFLRyxXQUFXLElBQUksU0FBUSxJQUFLO1lBQzNDLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FDRSxRQUFTSCxLQUFLZ0IsTUFBTSxFQUNuQmpGLFFBQVFBLE1BQU1vRSxXQUFXLElBQUlwRSxNQUFNcUUsSUFBSSxJQUFJLElBQzVDSixLQUFLRyxXQUFXLElBQ2IsUUFBT3BFLFFBQVEsZ0JBQWdCQSxRQUFRLE1BQU0sWUFBVztZQUUvRCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBT2lFO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPRCx5QkFBeUJDO1lBQ2xDLEtBQUs7Z0JBQ0gsT0FBT0EsU0FBU1EseUJBQXlCLGVBQWU7WUFDMUQsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxJQUFJLGVBQWUsT0FBT1IsTUFDeEIsT0FBT0EsS0FBS0csV0FBVyxJQUFJSCxLQUFLSSxJQUFJLElBQUk7Z0JBQzFDLElBQUksYUFBYSxPQUFPSixNQUFNLE9BQU9BO2dCQUNyQztZQUNGLEtBQUs7Z0JBQ0hBLE9BQU9qRSxNQUFNd0YsVUFBVTtnQkFDdkIsSUFBSSxRQUFRdkIsTUFDVjtvQkFBQSxJQUFLLElBQUk3QyxJQUFJNkMsS0FBS3hELE1BQU0sR0FBRyxHQUFHLEtBQUtXLEdBQUdBLElBQ3BDLElBQUksYUFBYSxPQUFPNkMsSUFBSSxDQUFDN0MsRUFBRSxDQUFDaUQsSUFBSSxFQUFFLE9BQU9KLElBQUksQ0FBQzdDLEVBQUUsQ0FBQ2lELElBQUk7Z0JBQUE7Z0JBQzdELElBQUksU0FBU3JFLE1BQU15RixNQUFNLEVBQ3ZCLE9BQU9GLDBCQUEwQnZGLE1BQU15RixNQUFNO1FBQ25EO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBU0MsZUFBZTtJQUN4QixTQUFTQztRQUNQLElBQUksTUFBTUMsZUFBZTtZQUN2QkMsVUFBVTNFLFFBQVE0RSxHQUFHO1lBQ3JCQyxXQUFXN0UsUUFBUThFLElBQUk7WUFDdkJDLFdBQVcvRSxRQUFRQyxJQUFJO1lBQ3ZCK0UsWUFBWWhGLFFBQVFnQyxLQUFLO1lBQ3pCaUQsWUFBWWpGLFFBQVFrRixLQUFLO1lBQ3pCQyxxQkFBcUJuRixRQUFRb0YsY0FBYztZQUMzQ0MsZUFBZXJGLFFBQVFzRixRQUFRO1lBQy9CLElBQUlDLFFBQVE7Z0JBQ1ZDLGNBQWMsQ0FBQztnQkFDZkMsWUFBWSxDQUFDO2dCQUNibkcsT0FBT2tGO2dCQUNQa0IsVUFBVSxDQUFDO1lBQ2I7WUFDQUMsT0FBT0MsZ0JBQWdCLENBQUM1RixTQUFTO2dCQUMvQjhFLE1BQU1TO2dCQUNOWCxLQUFLVztnQkFDTHRGLE1BQU1zRjtnQkFDTnZELE9BQU91RDtnQkFDUEwsT0FBT0s7Z0JBQ1BILGdCQUFnQkc7Z0JBQ2hCRCxVQUFVQztZQUNaO1FBQ0Y7UUFDQWI7SUFDRjtJQUNBLFNBQVNtQjtRQUNQbkI7UUFDQSxJQUFJLE1BQU1BLGVBQWU7WUFDdkIsSUFBSWEsUUFBUTtnQkFBRUMsY0FBYyxDQUFDO2dCQUFHQyxZQUFZLENBQUM7Z0JBQUdDLFVBQVUsQ0FBQztZQUFFO1lBQzdEQyxPQUFPQyxnQkFBZ0IsQ0FBQzVGLFNBQVM7Z0JBQy9CNEUsS0FBS2hGLE9BQU8sQ0FBQyxHQUFHMkYsT0FBTztvQkFBRWpHLE9BQU9xRjtnQkFBUTtnQkFDeENHLE1BQU1sRixPQUFPLENBQUMsR0FBRzJGLE9BQU87b0JBQUVqRyxPQUFPdUY7Z0JBQVM7Z0JBQzFDNUUsTUFBTUwsT0FBTyxDQUFDLEdBQUcyRixPQUFPO29CQUFFakcsT0FBT3lGO2dCQUFTO2dCQUMxQy9DLE9BQU9wQyxPQUFPLENBQUMsR0FBRzJGLE9BQU87b0JBQUVqRyxPQUFPMEY7Z0JBQVU7Z0JBQzVDRSxPQUFPdEYsT0FBTyxDQUFDLEdBQUcyRixPQUFPO29CQUFFakcsT0FBTzJGO2dCQUFVO2dCQUM1Q0csZ0JBQWdCeEYsT0FBTyxDQUFDLEdBQUcyRixPQUFPO29CQUFFakcsT0FBTzZGO2dCQUFtQjtnQkFDOURHLFVBQVUxRixPQUFPLENBQUMsR0FBRzJGLE9BQU87b0JBQUVqRyxPQUFPK0Y7Z0JBQWE7WUFDcEQ7UUFDRjtRQUNBLElBQUlYLGlCQUNGMUUsUUFBUWdDLEtBQUssQ0FDWDtJQUVOO0lBQ0EsU0FBUzhELDhCQUE4QjNDLElBQUk7UUFDekMsSUFBSSxLQUFLLE1BQU00QyxRQUNiLElBQUk7WUFDRixNQUFNQztRQUNSLEVBQUUsT0FBTzVCLEdBQUc7WUFDVixJQUFJNkIsUUFBUTdCLEVBQUU4QixLQUFLLENBQUNDLElBQUksR0FBR0YsS0FBSyxDQUFDO1lBQ2pDRixTQUFTLFNBQVVFLEtBQUssQ0FBQyxFQUFFLElBQUs7WUFDaENHLFNBQ0UsQ0FBQyxJQUFJaEMsRUFBRThCLEtBQUssQ0FBQ0csT0FBTyxDQUFDLGNBQ2pCLG1CQUNBLENBQUMsSUFBSWpDLEVBQUU4QixLQUFLLENBQUNHLE9BQU8sQ0FBQyxPQUNuQixpQkFDQTtRQUNWO1FBQ0YsT0FBTyxPQUFPTixTQUFTNUMsT0FBT2lEO0lBQ2hDO0lBQ0EsU0FBU0UsNkJBQTZCQyxFQUFFLEVBQUVDLFNBQVM7UUFDakQsSUFBSSxDQUFDRCxNQUFNRSxTQUFTLE9BQU87UUFDM0IsSUFBSUMsUUFBUUMsb0JBQW9CQyxHQUFHLENBQUNMO1FBQ3BDLElBQUksS0FBSyxNQUFNRyxPQUFPLE9BQU9BO1FBQzdCRCxVQUFVLENBQUM7UUFDWEMsUUFBUVYsTUFBTWEsaUJBQWlCO1FBQy9CYixNQUFNYSxpQkFBaUIsR0FBRyxLQUFLO1FBQy9CLElBQUlDLHFCQUFxQjtRQUN6QkEscUJBQXFCQyxxQkFBcUJDLENBQUM7UUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHO1FBQ3pCdkM7UUFDQSxJQUFJO1lBQ0YsSUFBSXdDLGlCQUFpQjtnQkFDbkJDLDZCQUE2QjtvQkFDM0IsSUFBSTt3QkFDRixJQUFJVixXQUFXOzRCQUNiLElBQUlXLE9BQU87Z0NBQ1QsTUFBTW5COzRCQUNSOzRCQUNBTCxPQUFPeUIsY0FBYyxDQUFDRCxLQUFLRSxTQUFTLEVBQUUsU0FBUztnQ0FDN0NoRixLQUFLO29DQUNILE1BQU0yRDtnQ0FDUjs0QkFDRjs0QkFDQSxJQUFJLGFBQWEsT0FBT3NCLFdBQVdBLFFBQVFkLFNBQVMsRUFBRTtnQ0FDcEQsSUFBSTtvQ0FDRmMsUUFBUWQsU0FBUyxDQUFDVyxNQUFNLEVBQUU7Z0NBQzVCLEVBQUUsT0FBTy9DLEdBQUc7b0NBQ1YsSUFBSW1ELFVBQVVuRDtnQ0FDaEI7Z0NBQ0FrRCxRQUFRZCxTQUFTLENBQUNELElBQUksRUFBRSxFQUFFWTs0QkFDNUIsT0FBTztnQ0FDTCxJQUFJO29DQUNGQSxLQUFLSyxJQUFJO2dDQUNYLEVBQUUsT0FBT0MsS0FBSztvQ0FDWkYsVUFBVUU7Z0NBQ1o7Z0NBQ0FsQixHQUFHaUIsSUFBSSxDQUFDTCxLQUFLRSxTQUFTOzRCQUN4Qjt3QkFDRixPQUFPOzRCQUNMLElBQUk7Z0NBQ0YsTUFBTXJCOzRCQUNSLEVBQUUsT0FBTzBCLEtBQUs7Z0NBQ1pILFVBQVVHOzRCQUNaOzRCQUNDUCxDQUFBQSxPQUFPWixJQUFHLEtBQ1QsZUFBZSxPQUFPWSxLQUFLUSxLQUFLLElBQ2hDUixLQUFLUSxLQUFLLENBQUMsWUFBYTt3QkFDNUI7b0JBQ0YsRUFBRSxPQUFPQyxRQUFRO3dCQUNmLElBQUlBLFVBQVVMLFdBQVcsYUFBYSxPQUFPSyxPQUFPMUIsS0FBSyxFQUN2RCxPQUFPOzRCQUFDMEIsT0FBTzFCLEtBQUs7NEJBQUVxQixRQUFRckIsS0FBSzt5QkFBQztvQkFDeEM7b0JBQ0EsT0FBTzt3QkFBQzt3QkFBTTtxQkFBSztnQkFDckI7WUFDRjtZQUNBZSxlQUFlQywyQkFBMkIsQ0FBQ2hFLFdBQVcsR0FDcEQ7WUFDRixJQUFJMkUscUJBQXFCbEMsT0FBT21DLHdCQUF3QixDQUN0RGIsZUFBZUMsMkJBQTJCLEVBQzFDO1lBRUZXLHNCQUNFQSxtQkFBbUJyQyxZQUFZLElBQy9CRyxPQUFPeUIsY0FBYyxDQUNuQkgsZUFBZUMsMkJBQTJCLEVBQzFDLFFBQ0E7Z0JBQUU1SCxPQUFPO1lBQThCO1lBRTNDLElBQUl5SSx3QkFDQWQsZUFBZUMsMkJBQTJCLElBQzVDYyxjQUFjRCxxQkFBcUIsQ0FBQyxFQUFFLEVBQ3RDRSxlQUFlRixxQkFBcUIsQ0FBQyxFQUFFO1lBQ3pDLElBQUlDLGVBQWVDLGNBQWM7Z0JBQy9CLElBQUlDLGNBQWNGLFlBQVlHLEtBQUssQ0FBQyxPQUNsQ0MsZUFBZUgsYUFBYUUsS0FBSyxDQUFDO2dCQUNwQyxJQUNFSix3QkFBd0JGLHFCQUFxQixHQUM3Q0EscUJBQXFCSyxZQUFZM0ksTUFBTSxJQUN2QyxDQUFDMkksV0FBVyxDQUFDTCxtQkFBbUIsQ0FBQ1EsUUFBUSxDQUN2QyxnQ0FJRlI7Z0JBQ0YsTUFFRUUsd0JBQXdCSyxhQUFhN0ksTUFBTSxJQUMzQyxDQUFDNkksWUFBWSxDQUFDTCxzQkFBc0IsQ0FBQ00sUUFBUSxDQUMzQyxnQ0FJRk47Z0JBQ0YsSUFDRUYsdUJBQXVCSyxZQUFZM0ksTUFBTSxJQUN6Q3dJLDBCQUEwQkssYUFBYTdJLE1BQU0sRUFFN0MsSUFDRXNJLHFCQUFxQkssWUFBWTNJLE1BQU0sR0FBRyxHQUN4Q3dJLHdCQUF3QkssYUFBYTdJLE1BQU0sR0FBRyxHQUNoRCxLQUFLc0ksc0JBQ0wsS0FBS0UseUJBQ0xHLFdBQVcsQ0FBQ0wsbUJBQW1CLEtBQzdCTyxZQUFZLENBQUNMLHNCQUFzQixFQUdyQ0E7Z0JBQ0osTUFFRSxLQUFLRixzQkFBc0IsS0FBS0UsdUJBQ2hDRixzQkFBc0JFLHdCQUV0QixJQUNFRyxXQUFXLENBQUNMLG1CQUFtQixLQUMvQk8sWUFBWSxDQUFDTCxzQkFBc0IsRUFDbkM7b0JBQ0EsSUFBSSxNQUFNRixzQkFBc0IsTUFBTUUsdUJBQXVCO3dCQUMzRCxHQUNFLElBQ0dGLHNCQUNERSx5QkFDQSxJQUFJQSx5QkFDRkcsV0FBVyxDQUFDTCxtQkFBbUIsS0FDN0JPLFlBQVksQ0FBQ0wsc0JBQXNCLEVBQ3ZDOzRCQUNBLElBQUlPLFNBQ0YsT0FDQUosV0FBVyxDQUFDTCxtQkFBbUIsQ0FBQ1UsT0FBTyxDQUNyQyxZQUNBOzRCQUVKaEMsR0FBR3JELFdBQVcsSUFDWm9GLE9BQU9ELFFBQVEsQ0FBQyxrQkFDZkMsQ0FBQUEsU0FBU0EsT0FBT0MsT0FBTyxDQUFDLGVBQWVoQyxHQUFHckQsV0FBVzs0QkFDeEQsZUFBZSxPQUFPcUQsTUFDcEJJLG9CQUFvQnRFLEdBQUcsQ0FBQ2tFLElBQUkrQjs0QkFDOUIsT0FBT0E7d0JBQ1Q7K0JBQ0ssS0FBS1Qsc0JBQXNCLEtBQUtFLHVCQUF1QjtvQkFDaEU7b0JBQ0E7Z0JBQ0Y7WUFDSjtRQUNGLFNBQVU7WUFDUHRCLFVBQVUsQ0FBQyxHQUNUTSxxQkFBcUJDLENBQUMsR0FBR0Ysb0JBQzFCakIsZ0JBQ0NHLE1BQU1hLGlCQUFpQixHQUFHSDtRQUMvQjtRQUNBd0IsY0FBYyxDQUFDQSxjQUFjM0IsS0FBS0EsR0FBR3JELFdBQVcsSUFBSXFELEdBQUdwRCxJQUFJLEdBQUcsRUFBQyxJQUMzRDJDLDhCQUE4Qm9DLGVBQzlCO1FBQ0osZUFBZSxPQUFPM0IsTUFBTUksb0JBQW9CdEUsR0FBRyxDQUFDa0UsSUFBSTJCO1FBQ3hELE9BQU9BO0lBQ1Q7SUFDQSxTQUFTTSxjQUFjMUosS0FBSztRQUMxQixPQUFRQSxNQUFNNEIsR0FBRztZQUNmLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPb0YsOEJBQThCaEgsTUFBTWlFLElBQUk7WUFDakQsS0FBSztnQkFDSCxPQUFPK0MsOEJBQThCO1lBQ3ZDLEtBQUs7Z0JBQ0gsT0FBT0EsOEJBQThCO1lBQ3ZDLEtBQUs7Z0JBQ0gsT0FBT0EsOEJBQThCO1lBQ3ZDLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU8sUUFBU1EsNkJBQTZCeEgsTUFBTWlFLElBQUksRUFBRSxDQUFDLElBQUtqRTtZQUNqRSxLQUFLO2dCQUNILE9BQ0UsUUFBU3dILDZCQUE2QnhILE1BQU1pRSxJQUFJLENBQUNnQixNQUFNLEVBQUUsQ0FBQyxJQUFLakY7WUFFbkUsS0FBSztnQkFDSCxPQUFPLFFBQVN3SCw2QkFBNkJ4SCxNQUFNaUUsSUFBSSxFQUFFLENBQUMsSUFBS2pFO1lBQ2pFO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBQ0EsU0FBUzJKLDRCQUE0QkMsY0FBYztRQUNqRCxJQUFJO1lBQ0YsSUFBSTVELE9BQU87WUFDWCxHQUFHO2dCQUNEQSxRQUFRMEQsY0FBY0U7Z0JBQ3RCLElBQUlDLFlBQVlELGVBQWVwRSxVQUFVO2dCQUN6QyxJQUFJcUUsV0FDRixJQUFLLElBQUl6SSxJQUFJeUksVUFBVXBKLE1BQU0sR0FBRyxHQUFHLEtBQUtXLEdBQUdBLElBQUs7b0JBQzlDLElBQUkwSSxRQUFRRCxTQUFTLENBQUN6SSxFQUFFO29CQUN4QixJQUFJLGFBQWEsT0FBTzBJLE1BQU16RixJQUFJLEVBQUU7d0JBQ2xDLElBQUkwRix3QkFBd0IvRCxNQUMxQnRHLE1BQU1vSyxNQUFNcEssR0FBRzt3QkFDakIsSUFBSXNLLDJCQUEyQmhELDhCQUM3QjhDLE1BQU16RixJQUFJLEdBQUkzRSxDQUFBQSxNQUFNLE9BQU9BLE1BQU0sTUFBTSxFQUFDO3dCQUUxQ3NHLE9BQU8rRCx3QkFBd0JDO29CQUNqQztnQkFDRjtnQkFDRkosaUJBQWlCQSxlQUFlbkUsTUFBTTtZQUN4QyxRQUFTbUUsZ0JBQWdCO1lBQ3pCLE9BQU81RDtRQUNULEVBQUUsT0FBT1YsR0FBRztZQUNWLE9BQU8sK0JBQStCQSxFQUFFMkUsT0FBTyxHQUFHLE9BQU8zRSxFQUFFOEIsS0FBSztRQUNsRTtJQUNGO0lBQ0EsU0FBUzhDO1FBQ1AsT0FBTyxTQUFTcEgsVUFBVSxLQUFLNkcsNEJBQTRCN0c7SUFDN0Q7SUFDQSxTQUFTcUgsa0JBQWtCbkssS0FBSyxFQUFFb0ssUUFBUSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7UUFDdEUsSUFBSUMsZ0JBQWdCNUg7UUFDcEJtRixxQkFBcUIwQyxlQUFlLEdBQ2xDLFNBQVMzSyxRQUFRLE9BQU9rSztRQUMxQlUsY0FBYyxDQUFDO1FBQ2Y5SCxVQUFVOUM7UUFDVixJQUFJO1lBQ0YsT0FBT29LLFNBQVNDLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DO1FBQzFDLFNBQVU7WUFDUjNILFVBQVU0SDtRQUNaO1FBQ0EsTUFBTXhELE1BQ0o7SUFFSjtJQUNBLFNBQVMyRCx1QkFBdUI3SyxLQUFLO1FBQ25DLElBQUk4SyxPQUFPOUssT0FDVCtLLGlCQUFpQi9LO1FBQ25CLElBQUlBLE1BQU1nTCxTQUFTLEVBQUUsTUFBT0YsS0FBS3JGLE1BQU0sRUFBSXFGLE9BQU9BLEtBQUtyRixNQUFNO2FBQ3hEO1lBQ0h6RixRQUFROEs7WUFDUixHQUNFLE9BQVE5SyxPQUNOLE1BQU84SyxDQUFBQSxLQUFLRyxLQUFLLEdBQUcsSUFBRyxLQUFPRixDQUFBQSxpQkFBaUJELEtBQUtyRixNQUFNLEdBQ3pEekYsUUFBUThLLEtBQUtyRixNQUFNO21CQUNqQnpGLE9BQU87UUFDaEI7UUFDQSxPQUFPLE1BQU04SyxLQUFLbEosR0FBRyxHQUFHbUosaUJBQWlCO0lBQzNDO0lBQ0EsU0FBU0csZ0JBQWdCbEwsS0FBSztRQUM1QixJQUFJNkssdUJBQXVCN0ssV0FBV0EsT0FDcEMsTUFBTWtILE1BQU07SUFDaEI7SUFDQSxTQUFTaUUsOEJBQThCbkwsS0FBSztRQUMxQyxJQUFJZ0wsWUFBWWhMLE1BQU1nTCxTQUFTO1FBQy9CLElBQUksQ0FBQ0EsV0FBVztZQUNkQSxZQUFZSCx1QkFBdUI3SztZQUNuQyxJQUFJLFNBQVNnTCxXQUNYLE1BQU05RCxNQUFNO1lBQ2QsT0FBTzhELGNBQWNoTCxRQUFRLE9BQU9BO1FBQ3RDO1FBQ0EsSUFBSyxJQUFJb0wsSUFBSXBMLE9BQU9xTCxJQUFJTCxZQUFlO1lBQ3JDLElBQUlNLFVBQVVGLEVBQUUzRixNQUFNO1lBQ3RCLElBQUksU0FBUzZGLFNBQVM7WUFDdEIsSUFBSUMsVUFBVUQsUUFBUU4sU0FBUztZQUMvQixJQUFJLFNBQVNPLFNBQVM7Z0JBQ3BCRixJQUFJQyxRQUFRN0YsTUFBTTtnQkFDbEIsSUFBSSxTQUFTNEYsR0FBRztvQkFDZEQsSUFBSUM7b0JBQ0o7Z0JBQ0Y7Z0JBQ0E7WUFDRjtZQUNBLElBQUlDLFFBQVFFLEtBQUssS0FBS0QsUUFBUUMsS0FBSyxFQUFFO2dCQUNuQyxJQUFLRCxVQUFVRCxRQUFRRSxLQUFLLEVBQUVELFNBQVc7b0JBQ3ZDLElBQUlBLFlBQVlILEdBQUcsT0FBT0YsZ0JBQWdCSSxVQUFVdEw7b0JBQ3BELElBQUl1TCxZQUFZRixHQUFHLE9BQU9ILGdCQUFnQkksVUFBVU47b0JBQ3BETyxVQUFVQSxRQUFRRSxPQUFPO2dCQUMzQjtnQkFDQSxNQUFNdkUsTUFBTTtZQUNkO1lBQ0EsSUFBSWtFLEVBQUUzRixNQUFNLEtBQUs0RixFQUFFNUYsTUFBTSxFQUFFLElBQUs2RixTQUFXRCxJQUFJRTtpQkFDMUM7Z0JBQ0gsSUFBSyxJQUFJRyxlQUFlLENBQUMsR0FBR0MsU0FBU0wsUUFBUUUsS0FBSyxFQUFFRyxRQUFVO29CQUM1RCxJQUFJQSxXQUFXUCxHQUFHO3dCQUNoQk0sZUFBZSxDQUFDO3dCQUNoQk4sSUFBSUU7d0JBQ0pELElBQUlFO3dCQUNKO29CQUNGO29CQUNBLElBQUlJLFdBQVdOLEdBQUc7d0JBQ2hCSyxlQUFlLENBQUM7d0JBQ2hCTCxJQUFJQzt3QkFDSkYsSUFBSUc7d0JBQ0o7b0JBQ0Y7b0JBQ0FJLFNBQVNBLE9BQU9GLE9BQU87Z0JBQ3pCO2dCQUNBLElBQUksQ0FBQ0MsY0FBYztvQkFDakIsSUFBS0MsU0FBU0osUUFBUUMsS0FBSyxFQUFFRyxRQUFVO3dCQUNyQyxJQUFJQSxXQUFXUCxHQUFHOzRCQUNoQk0sZUFBZSxDQUFDOzRCQUNoQk4sSUFBSUc7NEJBQ0pGLElBQUlDOzRCQUNKO3dCQUNGO3dCQUNBLElBQUlLLFdBQVdOLEdBQUc7NEJBQ2hCSyxlQUFlLENBQUM7NEJBQ2hCTCxJQUFJRTs0QkFDSkgsSUFBSUU7NEJBQ0o7d0JBQ0Y7d0JBQ0FLLFNBQVNBLE9BQU9GLE9BQU87b0JBQ3pCO29CQUNBLElBQUksQ0FBQ0MsY0FDSCxNQUFNeEUsTUFDSjtnQkFFTjtZQUNGO1lBQ0EsSUFBSWtFLEVBQUVKLFNBQVMsS0FBS0ssR0FDbEIsTUFBTW5FLE1BQ0o7UUFFTjtRQUNBLElBQUksTUFBTWtFLEVBQUV4SixHQUFHLEVBQ2IsTUFBTXNGLE1BQU07UUFDZCxPQUFPa0UsRUFBRVEsU0FBUyxDQUFDOUksT0FBTyxLQUFLc0ksSUFBSXBMLFFBQVFnTDtJQUM3QztJQUNBLFNBQVNhLHFCQUFxQkMsTUFBTTtRQUNsQ0EsU0FBU1gsOEJBQThCVztRQUN2QyxPQUFPLFNBQVNBLFNBQVNDLHlCQUF5QkQsVUFBVTtJQUM5RDtJQUNBLFNBQVNDLHlCQUF5QmpCLElBQUk7UUFDcEMsSUFBSWxKLE1BQU1rSixLQUFLbEosR0FBRztRQUNsQixJQUFJLE1BQU1BLE9BQU8sT0FBT0EsT0FBTyxPQUFPQSxPQUFPLE1BQU1BLEtBQUssT0FBT2tKO1FBQy9ELElBQUtBLE9BQU9BLEtBQUtVLEtBQUssRUFBRSxTQUFTVixNQUFRO1lBQ3ZDbEosTUFBTW1LLHlCQUF5QmpCO1lBQy9CLElBQUksU0FBU2xKLEtBQUssT0FBT0E7WUFDekJrSixPQUFPQSxLQUFLVyxPQUFPO1FBQ3JCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBU08sc0NBQXNDbEIsSUFBSTtRQUNqRCxJQUFJbEosTUFBTWtKLEtBQUtsSixHQUFHO1FBQ2xCLElBQUksTUFBTUEsT0FBTyxPQUFPQSxPQUFPLE9BQU9BLE9BQU8sTUFBTUEsS0FBSyxPQUFPa0o7UUFDL0QsSUFBS0EsT0FBT0EsS0FBS1UsS0FBSyxFQUFFLFNBQVNWLE1BQVE7WUFDdkMsSUFDRSxNQUFNQSxLQUFLbEosR0FBRyxJQUNiLE9BQU9vSyxzQ0FBc0NsQixPQUFRLFNBQVNsSixHQUFFLEdBRWpFLE9BQU9BO1lBQ1RrSixPQUFPQSxLQUFLVyxPQUFPO1FBQ3JCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBU1EsYUFBYUMsWUFBWTtRQUNoQyxPQUFPO1lBQUVwSixTQUFTb0o7UUFBYTtJQUNqQztJQUNBLFNBQVNDLElBQUlDLE1BQU0sRUFBRXBNLEtBQUs7UUFDeEIsSUFBSXFNLGlCQUNBbkwsUUFBUWdDLEtBQUssQ0FBQyxxQkFDYmxELENBQUFBLFVBQVVzTSxVQUFVLENBQUNELGVBQWUsSUFDbkNuTCxRQUFRZ0MsS0FBSyxDQUFDLDZCQUNma0osT0FBT3RKLE9BQU8sR0FBR3lKLFVBQVUsQ0FBQ0YsZUFBZSxFQUMzQ0UsVUFBVSxDQUFDRixlQUFlLEdBQUcsTUFDN0JDLFVBQVUsQ0FBQ0QsZUFBZSxHQUFHLE1BQzlCQSxnQkFBZTtJQUNyQjtJQUNBLFNBQVMzSSxLQUFLMEksTUFBTSxFQUFFNUwsS0FBSyxFQUFFUixLQUFLO1FBQ2hDcU07UUFDQUUsVUFBVSxDQUFDRixlQUFlLEdBQUdELE9BQU90SixPQUFPO1FBQzNDd0osVUFBVSxDQUFDRCxlQUFlLEdBQUdyTTtRQUM3Qm9NLE9BQU90SixPQUFPLEdBQUd0QztJQUNuQjtJQUNBLFNBQVNnTSxjQUFjbEgsQ0FBQztRQUN0QkEsT0FBTztRQUNQLE9BQU8sTUFBTUEsSUFBSSxLQUFLLEtBQU8sT0FBT0EsS0FBS29ILE1BQU8sS0FBTTtJQUN4RDtJQUNBLFNBQVNDLGdCQUFnQkMsSUFBSTtRQUMzQixJQUFJQSxPQUFPLEdBQUcsT0FBTztRQUNyQixJQUFJQSxPQUFPLEdBQUcsT0FBTztRQUNyQixJQUFJQSxPQUFPLEdBQUcsT0FBTztRQUNyQixJQUFJQSxPQUFPLEdBQUcsT0FBTztRQUNyQixJQUFJQSxPQUFPLElBQUksT0FBTztRQUN0QixJQUFJQSxPQUFPLElBQUksT0FBTztRQUN0QixJQUFJQSxPQUFPLElBQUksT0FBTztRQUN0QixJQUFJQSxPQUFPLFNBQVMsT0FBTztRQUMzQixJQUFJQSxPQUFPLFVBQVUsT0FBTztRQUM1QixJQUFJQSxPQUFPLFVBQVUsT0FBTztRQUM1QixJQUFJQSxPQUFPLFdBQVcsT0FBTztRQUM3QixJQUFJQSxPQUFPLFdBQVcsT0FBTztRQUM3QixJQUFJQSxPQUFPLFdBQVcsT0FBTztRQUM3QixJQUFJQSxPQUFPLFlBQVksT0FBTztJQUNoQztJQUNBLFNBQVNDLHdCQUF3QkMsS0FBSztRQUNwQyxJQUFJQyxtQkFBbUJELFFBQVE7UUFDL0IsSUFBSSxNQUFNQyxrQkFBa0IsT0FBT0E7UUFDbkMsT0FBUUQsUUFBUSxDQUFDQTtZQUNmLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPQSxRQUFRO1lBQ2pCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBT0EsUUFBUTtZQUNqQixLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVDtnQkFDRSxPQUNFNUwsUUFBUWdDLEtBQUssQ0FDWCw4REFFRjRKO1FBRU47SUFDRjtJQUNBLFNBQVNFLGFBQWEvSyxJQUFJLEVBQUVnTCxRQUFRO1FBQ2xDLElBQUlDLGVBQWVqTCxLQUFLaUwsWUFBWTtRQUNwQyxJQUFJLE1BQU1BLGNBQWMsT0FBTztRQUMvQixJQUFJQyxZQUFZLEdBQ2RDLGlCQUFpQm5MLEtBQUttTCxjQUFjLEVBQ3BDQyxjQUFjcEwsS0FBS29MLFdBQVcsRUFDOUJDLFlBQVlyTCxLQUFLcUwsU0FBUztRQUM1QnJMLE9BQU8sTUFBTUEsS0FBS3NMLGFBQWE7UUFDL0IsSUFBSUMsc0JBQXNCTixlQUFlO1FBQ3pDLE1BQU1NLHNCQUNELGdCQUFnQkEsc0JBQXNCLENBQUNKLGdCQUN4QyxNQUFNRixlQUNEQyxZQUFZTix3QkFBd0JLLGdCQUNwQyxnQkFBZ0JNLHFCQUNqQixNQUFNSCxjQUNERixZQUFZTix3QkFBd0JRLGVBQ3JDcEwsUUFDQyxhQUFhdUwsc0JBQXNCLENBQUNGLFdBQ3JDLE1BQU1BLGFBQ0hILENBQUFBLFlBQVlOLHdCQUF3QlMsVUFBUyxDQUFDLENBQUMsQ0FBQyxJQUMxRCx1QkFBdUJKLGVBQWUsQ0FBQ0UsZ0JBQ3hDLE1BQU1JLHNCQUNETCxZQUFZTix3QkFBd0JXLHVCQUNyQyxNQUFNSCxjQUNIRixZQUFZTix3QkFBd0JRLGVBQ3JDcEwsUUFDQyxhQUFhaUwsZUFBZSxDQUFDSSxXQUM5QixNQUFNQSxhQUNISCxDQUFBQSxZQUFZTix3QkFBd0JTLFVBQVMsQ0FBQyxDQUFDO1FBQzVELE9BQU8sTUFBTUgsWUFDVCxJQUNBLE1BQU1GLFlBQ0pBLGFBQWFFLGFBQ2IsTUFBT0YsQ0FBQUEsV0FBV0csY0FBYSxLQUM5QixrQkFBa0JELFlBQVksQ0FBQ0EsV0FDL0JHLFlBQVlMLFdBQVcsQ0FBQ0EsVUFDekJHLGtCQUFrQkUsYUFDZixPQUFPRixrQkFBa0IsTUFBT0UsQ0FBQUEsWUFBWSxPQUFNLENBQUUsSUFDdkRMLFdBQ0FFO0lBQ1I7SUFDQSxTQUFTTSwwQkFBMEJ4TCxJQUFJLEVBQUV5TCxXQUFXO1FBQ2xELE9BQ0UsTUFDQ3pMLENBQUFBLEtBQUtpTCxZQUFZLEdBQ2hCLENBQUVqTCxDQUFBQSxLQUFLbUwsY0FBYyxHQUFHLENBQUNuTCxLQUFLb0wsV0FBVyxJQUN6Q0ssV0FBVTtJQUVoQjtJQUNBLFNBQVNDLHNCQUFzQmYsSUFBSSxFQUFFZ0IsV0FBVztRQUM5QyxPQUFRaEI7WUFDTixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU9nQixjQUFjO1lBQ3ZCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPQSxjQUFjO1lBQ3ZCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTyxDQUFDO1lBQ1YsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTyxDQUFDO1lBQ1Y7Z0JBQ0UsT0FDRTFNLFFBQVFnQyxLQUFLLENBQ1gsOERBRUYsQ0FBQztRQUVQO0lBQ0Y7SUFDQSxTQUFTMks7UUFDUCxJQUFJakIsT0FBT2tCO1FBQ1hBLHVCQUF1QjtRQUN2QixNQUFPQSxDQUFBQSxxQkFBcUIsT0FBTSxLQUFPQSxDQUFBQSxxQkFBcUIsR0FBRTtRQUNoRSxPQUFPbEI7SUFDVDtJQUNBLFNBQVNtQjtRQUNQLElBQUluQixPQUFPb0I7UUFDWEEsa0JBQWtCO1FBQ2xCLE1BQU9BLENBQUFBLGdCQUFnQixRQUFPLEtBQU9BLENBQUFBLGdCQUFnQixPQUFNO1FBQzNELE9BQU9wQjtJQUNUO0lBQ0EsU0FBU3FCLGNBQWNDLE9BQU87UUFDNUIsSUFBSyxJQUFJQyxVQUFVLEVBQUUsRUFBRS9NLElBQUksR0FBRyxLQUFLQSxHQUFHQSxJQUFLK00sUUFBUXpLLElBQUksQ0FBQ3dLO1FBQ3hELE9BQU9DO0lBQ1Q7SUFDQSxTQUFTQyxrQkFBa0JuTSxJQUFJLEVBQUVvTSxVQUFVO1FBQ3pDcE0sS0FBS2lMLFlBQVksSUFBSW1CO1FBQ3JCLGNBQWNBLGNBQ1gsTUFBTWpCLGNBQWMsR0FBRyxHQUN2Qm5MLEtBQUtvTCxXQUFXLEdBQUcsR0FDbkJwTCxLQUFLcUwsU0FBUyxHQUFHLENBQUM7SUFDdkI7SUFDQSxTQUFTZ0IsaUJBQ1ByTSxJQUFJLEVBQ0pzTCxhQUFhLEVBQ2JnQixjQUFjLEVBQ2RDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxtQkFBbUI7UUFFbkIsSUFBSUMseUJBQXlCMU0sS0FBS2lMLFlBQVk7UUFDOUNqTCxLQUFLaUwsWUFBWSxHQUFHcUI7UUFDcEJ0TSxLQUFLbUwsY0FBYyxHQUFHO1FBQ3RCbkwsS0FBS29MLFdBQVcsR0FBRztRQUNuQnBMLEtBQUtxTCxTQUFTLEdBQUc7UUFDakJyTCxLQUFLMk0sWUFBWSxJQUFJTDtRQUNyQnRNLEtBQUs0TSxjQUFjLElBQUlOO1FBQ3ZCdE0sS0FBSzZNLDBCQUEwQixJQUFJUDtRQUNuQ3RNLEtBQUs4TSxtQkFBbUIsR0FBRztRQUMzQixJQUFJQyxnQkFBZ0IvTSxLQUFLK00sYUFBYSxFQUNwQ0Msa0JBQWtCaE4sS0FBS2dOLGVBQWUsRUFDdENDLGdCQUFnQmpOLEtBQUtpTixhQUFhO1FBQ3BDLElBQ0VYLGlCQUFpQkkseUJBQXlCLENBQUNKLGdCQUMzQyxJQUFJQSxnQkFFSjtZQUNBLElBQUloTyxRQUFRLEtBQUs0TyxNQUFNWixpQkFDckIzQixPQUFPLEtBQUtyTTtZQUNkeU8sYUFBYSxDQUFDek8sTUFBTSxHQUFHO1lBQ3ZCME8sZUFBZSxDQUFDMU8sTUFBTSxHQUFHLENBQUM7WUFDMUIsSUFBSTZPLHVCQUF1QkYsYUFBYSxDQUFDM08sTUFBTTtZQUMvQyxJQUFJLFNBQVM2TyxzQkFDWCxJQUNFRixhQUFhLENBQUMzTyxNQUFNLEdBQUcsTUFBTUEsUUFBUSxHQUNyQ0EsUUFBUTZPLHFCQUFxQjNPLE1BQU0sRUFDbkNGLFFBQ0E7Z0JBQ0EsSUFBSWlDLFNBQVM0TSxvQkFBb0IsQ0FBQzdPLE1BQU07Z0JBQ3hDLFNBQVNpQyxVQUFXQSxDQUFBQSxPQUFPb0ssSUFBSSxJQUFJLENBQUMsU0FBUTtZQUM5QztZQUNGMkIsa0JBQWtCLENBQUMzQjtRQUNyQjtRQUNBLE1BQU00QixlQUFlYSx3QkFBd0JwTixNQUFNdU0sYUFBYTtRQUNoRSxNQUFNRSx1QkFDSixNQUFNRCxnQkFDTixNQUFNeE0sS0FBS0wsR0FBRyxJQUNiSyxDQUFBQSxLQUFLbUwsY0FBYyxJQUNsQnNCLHNCQUFzQixDQUFFQyxDQUFBQSx5QkFBeUIsQ0FBQ3BCLGFBQVksQ0FBQztJQUNyRTtJQUNBLFNBQVM4Qix3QkFBd0JwTixJQUFJLEVBQUV1TSxXQUFXLEVBQUVLLGNBQWM7UUFDaEU1TSxLQUFLaUwsWUFBWSxJQUFJc0I7UUFDckJ2TSxLQUFLbUwsY0FBYyxJQUFJLENBQUNvQjtRQUN4QixJQUFJYyxtQkFBbUIsS0FBS0gsTUFBTVg7UUFDbEN2TSxLQUFLNE0sY0FBYyxJQUFJTDtRQUN2QnZNLEtBQUsrTSxhQUFhLENBQUNNLGlCQUFpQixHQUNsQ3JOLEtBQUsrTSxhQUFhLENBQUNNLGlCQUFpQixHQUNwQyxhQUNDVCxpQkFBaUI7SUFDdEI7SUFDQSxTQUFTVSxrQkFBa0J0TixJQUFJLEVBQUU0TSxjQUFjO1FBQzdDLElBQUlXLHFCQUFzQnZOLEtBQUs0TSxjQUFjLElBQUlBO1FBQ2pELElBQUs1TSxPQUFPQSxLQUFLK00sYUFBYSxFQUFFUSxvQkFBc0I7WUFDcEQsSUFBSWpQLFFBQVEsS0FBSzRPLE1BQU1LLHFCQUNyQjVDLE9BQU8sS0FBS3JNO1lBQ2JxTSxPQUFPaUMsaUJBQW1CNU0sSUFBSSxDQUFDMUIsTUFBTSxHQUFHc08sa0JBQ3RDNU0sQ0FBQUEsSUFBSSxDQUFDMUIsTUFBTSxJQUFJc08sY0FBYTtZQUMvQlcsc0JBQXNCLENBQUM1QztRQUN6QjtJQUNGO0lBQ0EsU0FBUzZDLG1CQUFtQnhOLElBQUksRUFBRWpDLEtBQUssRUFBRThNLEtBQUs7UUFDNUMsSUFBSTRDLG1CQUNGLElBQUt6TixPQUFPQSxLQUFLME4sc0JBQXNCLEVBQUUsSUFBSTdDLE9BQVM7WUFDcEQsSUFBSXZNLFFBQVEsS0FBSzRPLE1BQU1yQyxRQUNyQkYsT0FBTyxLQUFLck07WUFDZDBCLElBQUksQ0FBQzFCLE1BQU0sQ0FBQ3FQLEdBQUcsQ0FBQzVQO1lBQ2hCOE0sU0FBUyxDQUFDRjtRQUNaO0lBQ0o7SUFDQSxTQUFTaUQsNEJBQTRCNU4sSUFBSSxFQUFFNkssS0FBSztRQUM5QyxJQUFJNEMsbUJBQ0YsSUFDRSxJQUFJQyx5QkFBeUIxTixLQUFLME4sc0JBQXNCLEVBQ3RERyxtQkFBbUI3TixLQUFLNk4sZ0JBQWdCLEVBQzFDLElBQUloRCxPQUVKO1lBQ0EsSUFBSXZNLFFBQVEsS0FBSzRPLE1BQU1yQztZQUN2QjdLLE9BQU8sS0FBSzFCO1lBQ1pBLFFBQVFvUCxzQkFBc0IsQ0FBQ3BQLE1BQU07WUFDckMsSUFBSUEsTUFBTXdQLElBQUksSUFDWHhQLENBQUFBLE1BQU1rRCxPQUFPLENBQUMsU0FBVXpELEtBQUs7Z0JBQzVCLElBQUlnTCxZQUFZaEwsTUFBTWdMLFNBQVM7Z0JBQzlCLFNBQVNBLGFBQWE4RSxpQkFBaUJFLEdBQUcsQ0FBQ2hGLGNBQzFDOEUsaUJBQWlCRixHQUFHLENBQUM1UDtZQUN6QixJQUNBTyxNQUFNMFAsS0FBSyxFQUFDO1lBQ2RuRCxTQUFTLENBQUM3SztRQUNaO0lBQ0o7SUFDQSxTQUFTaU8scUJBQXFCcEQsS0FBSztRQUNqQ0EsU0FBUyxDQUFDQTtRQUNWLE9BQU8sSUFBSUEsUUFDUCxJQUFJQSxRQUNGLE1BQU9BLENBQUFBLFFBQVEsU0FBUSxJQUNyQixLQUNBLFlBQ0YsSUFDRjtJQUNOO0lBQ0EsU0FBU3FELGdCQUFnQkMsU0FBUztRQUNoQyxJQUFJLGdCQUFnQixPQUFPQyxnQ0FBZ0MsT0FBTyxDQUFDO1FBQ25FLElBQUlDLE9BQU9EO1FBQ1gsSUFBSUMsS0FBS0MsVUFBVSxFQUFFLE9BQU8sQ0FBQztRQUM3QixJQUFJLENBQUNELEtBQUtFLGFBQWEsRUFDckIsT0FDRXRQLFFBQVFnQyxLQUFLLENBQ1gsZ0xBRUYsQ0FBQztRQUVMLElBQUk7WUFDRHVOLGFBQWFILEtBQUtJLE1BQU0sQ0FBQ04sWUFBY08sZUFBZUw7UUFDekQsRUFBRSxPQUFPTSxLQUFLO1lBQ1oxUCxRQUFRZ0MsS0FBSyxDQUFDLG1EQUFtRDBOO1FBQ25FO1FBQ0EsT0FBT04sS0FBS08sUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDO0lBQy9CO0lBQ0EsU0FBU0MsZUFBZTdPLElBQUksRUFBRThPLGFBQWE7UUFDekMsSUFBSUosZ0JBQWdCLGVBQWUsT0FBT0EsYUFBYUssaUJBQWlCLEVBQ3RFLElBQUk7WUFDRixJQUFJQyxXQUFXLFFBQVNoUCxDQUFBQSxLQUFLYSxPQUFPLENBQUNtSSxLQUFLLEdBQUcsR0FBRTtZQUMvQyxPQUFROEY7Z0JBQ04sS0FBSztvQkFDSCxJQUFJRyxvQkFBb0JDO29CQUN4QjtnQkFDRixLQUFLO29CQUNIRCxvQkFBb0JFO29CQUNwQjtnQkFDRixLQUFLO29CQUNIRixvQkFBb0JHO29CQUNwQjtnQkFDRixLQUFLO29CQUNISCxvQkFBb0JJO29CQUNwQjtnQkFDRjtvQkFDRUosb0JBQW9CRztZQUN4QjtZQUNBVixhQUFhSyxpQkFBaUIsQ0FDNUJQLFlBQ0F4TyxNQUNBaVAsbUJBQ0FEO1FBRUosRUFBRSxPQUFPTCxLQUFLO1lBQ1pXLGtCQUNHLGtCQUFrQixDQUFDLEdBQ3BCclEsUUFBUWdDLEtBQUssQ0FDWCxrREFDQTBOLElBQ0Y7UUFDSjtJQUNKO0lBQ0EsU0FBU1ksMkJBQTJCQyxlQUFlO1FBQ2pELGVBQWUsT0FBTzNMLE9BQ3BCNEwsOEJBQThCRDtRQUNoQyxJQUFJZCxnQkFBZ0IsZUFBZSxPQUFPQSxhQUFhZ0IsYUFBYSxFQUNsRSxJQUFJO1lBQ0ZoQixhQUFhZ0IsYUFBYSxDQUFDbEIsWUFBWWdCO1FBQ3pDLEVBQUUsT0FBT2IsS0FBSztZQUNaVyxrQkFDRyxrQkFBa0IsQ0FBQyxHQUNwQnJRLFFBQVFnQyxLQUFLLENBQ1gsa0RBQ0EwTixJQUNGO1FBQ0o7SUFDSjtJQUNBLFNBQVNnQixxQkFBcUJDLGNBQWM7UUFDMUNDLHlCQUF5QkQ7SUFDM0I7SUFDQSxTQUFTRTtRQUNQLFNBQVNELDBCQUNQLGVBQWUsT0FBT0EsdUJBQXVCQyxpQkFBaUIsSUFDOURELHVCQUF1QkMsaUJBQWlCO0lBQzVDO0lBQ0EsU0FBU0MsMkJBQTJCaFMsS0FBSztRQUN2QyxTQUFTOFIsMEJBQ1AsZUFDRSxPQUFPQSx1QkFBdUJFLDBCQUEwQixJQUMxREYsdUJBQXVCRSwwQkFBMEIsQ0FBQ2hTO0lBQ3REO0lBQ0EsU0FBU2lTO1FBQ1AsU0FBU0gsMEJBQ1AsZUFDRSxPQUFPQSx1QkFBdUJHLDBCQUEwQixJQUMxREgsdUJBQXVCRywwQkFBMEI7SUFDckQ7SUFDQSxTQUFTQyxrQkFBa0JwRixLQUFLO1FBQzlCLFNBQVNnRiwwQkFDUCxlQUFlLE9BQU9BLHVCQUF1QkksaUJBQWlCLElBQzlESix1QkFBdUJJLGlCQUFpQixDQUFDcEY7SUFDN0M7SUFDQSxTQUFTcUY7UUFDUCxTQUFTTCwwQkFDUCxlQUFlLE9BQU9BLHVCQUF1QkssaUJBQWlCLElBQzlETCx1QkFBdUJLLGlCQUFpQjtJQUM1QztJQUNBLFNBQVNDLHlCQUF5QnBTLEtBQUssRUFBRTRNLElBQUk7UUFDM0MsU0FBU2tGLDBCQUNQLGVBQWUsT0FBT0EsdUJBQXVCTSx3QkFBd0IsSUFDckVOLHVCQUF1Qk0sd0JBQXdCLENBQUNwUyxPQUFPNE07SUFDM0Q7SUFDQSxTQUFTeUYsR0FBRy9NLENBQUMsRUFBRWdOLENBQUM7UUFDZCxPQUFPLE1BQU9BLEtBQU0sT0FBTWhOLEtBQUssSUFBSUEsTUFBTSxJQUFJZ04sQ0FBQUEsS0FBUWhOLE1BQU1BLEtBQUtnTixNQUFNQTtJQUN4RTtJQUNBLFNBQVNDLDJCQUEyQi9SLEtBQUssRUFBRWdTLE1BQU07UUFDL0MsSUFBSSxhQUFhLE9BQU9oUyxTQUFTLFNBQVNBLE9BQU87WUFDL0MsSUFBSWlTLFdBQVdDLGVBQWU1SyxHQUFHLENBQUN0SDtZQUNsQyxJQUFJLEtBQUssTUFBTWlTLFVBQVUsT0FBT0E7WUFDaENELFNBQVM7Z0JBQ1BoUyxPQUFPQTtnQkFDUGdTLFFBQVFBO2dCQUNScEwsT0FBT3VDLDRCQUE0QjZJO1lBQ3JDO1lBQ0FFLGVBQWVuUCxHQUFHLENBQUMvQyxPQUFPZ1M7WUFDMUIsT0FBT0E7UUFDVDtRQUNBLE9BQU87WUFDTGhTLE9BQU9BO1lBQ1BnUyxRQUFRQTtZQUNScEwsT0FBT3VDLDRCQUE0QjZJO1FBQ3JDO0lBQ0Y7SUFDQSxTQUFTRyxhQUFhL0ksY0FBYyxFQUFFZ0osYUFBYTtRQUNqREM7UUFDQUMsU0FBUyxDQUFDQyxpQkFBaUIsR0FBR0M7UUFDOUJGLFNBQVMsQ0FBQ0MsaUJBQWlCLEdBQUdFO1FBQzlCQSxtQkFBbUJySjtRQUNuQm9KLGdCQUFnQko7SUFDbEI7SUFDQSxTQUFTTSxXQUFXdEosY0FBYyxFQUFFZ0osYUFBYSxFQUFFclMsS0FBSztRQUN0RHNTO1FBQ0FNLE9BQU8sQ0FBQ0MsZUFBZSxHQUFHQztRQUMxQkYsT0FBTyxDQUFDQyxlQUFlLEdBQUdFO1FBQzFCSCxPQUFPLENBQUNDLGVBQWUsR0FBR0c7UUFDMUJBLHNCQUFzQjNKO1FBQ3RCLElBQUk0Six1QkFBdUJIO1FBQzNCekosaUJBQWlCMEo7UUFDakIsSUFBSUcsYUFBYSxLQUFLdEUsTUFBTXFFLHdCQUF3QjtRQUNwREEsd0JBQXdCLENBQUUsTUFBS0MsVUFBUztRQUN4Q2xULFNBQVM7UUFDVCxJQUFJRSxTQUFTLEtBQUswTyxNQUFNeUQsaUJBQWlCYTtRQUN6QyxJQUFJLEtBQUtoVCxRQUFRO1lBQ2YsSUFBSWlULHVCQUF1QkQsYUFBY0EsYUFBYTtZQUN0RGhULFNBQVMsQ0FDUCtTLHVCQUNDLENBQUMsS0FBS0Usb0JBQW1CLElBQUssQ0FBQyxFQUNoQ0MsUUFBUSxDQUFDO1lBQ1hILHlCQUF5QkU7WUFDekJELGNBQWNDO1lBQ2RMLGdCQUNFLEtBQU8sS0FBS2xFLE1BQU15RCxpQkFBaUJhLGFBQ2xDbFQsU0FBU2tULGFBQ1ZEO1lBQ0ZGLHNCQUFzQjdTLFNBQVNtSjtRQUNqQyxPQUNFLGdCQUNFLEtBQU1uSixTQUFXRixTQUFTa1QsYUFBY0Qsc0JBQ3ZDRixzQkFBc0IxSjtJQUM3QjtJQUNBLFNBQVNnSyx1QkFBdUJoSyxjQUFjO1FBQzVDaUo7UUFDQSxTQUFTakosZUFBZW5FLE1BQU0sSUFDM0JrTixDQUFBQSxhQUFhL0ksZ0JBQWdCLElBQUlzSixXQUFXdEosZ0JBQWdCLEdBQUcsRUFBQztJQUNyRTtJQUNBLFNBQVNpSyxlQUFlakssY0FBYztRQUNwQyxNQUFPQSxtQkFBbUJxSixrQkFDeEIsbUJBQW9CSCxTQUFTLENBQUMsRUFBRUMsZUFBZSxFQUM1Q0QsU0FBUyxDQUFDQyxlQUFlLEdBQUcsTUFDNUJDLGdCQUFnQkYsU0FBUyxDQUFDLEVBQUVDLGVBQWUsRUFDM0NELFNBQVMsQ0FBQ0MsZUFBZSxHQUFHO1FBQ2pDLE1BQU9uSixtQkFBbUIySixxQkFDeEIsc0JBQXVCSixPQUFPLENBQUMsRUFBRUMsYUFBYSxFQUMzQ0QsT0FBTyxDQUFDQyxhQUFhLEdBQUcsTUFDeEJFLHNCQUFzQkgsT0FBTyxDQUFDLEVBQUVDLGFBQWEsRUFDN0NELE9BQU8sQ0FBQ0MsYUFBYSxHQUFHLE1BQ3hCQyxnQkFBZ0JGLE9BQU8sQ0FBQyxFQUFFQyxhQUFhLEVBQ3ZDRCxPQUFPLENBQUNDLGFBQWEsR0FBRztJQUMvQjtJQUNBLFNBQVNQO1FBQ1BpQixlQUNFNVMsUUFBUWdDLEtBQUssQ0FDWDtJQUVOO0lBQ0EsU0FBUzZRLGdCQUFnQkMsQ0FBQztRQUN4QixTQUFTQSxLQUNQOVMsUUFBUWdDLEtBQUssQ0FDWDtRQUVKLE9BQU84UTtJQUNUO0lBQ0EsU0FBU0Msa0JBQWtCalUsS0FBSyxFQUFFa1UsZ0JBQWdCO1FBQ2hEeFEsS0FBS3lRLHlCQUF5QkQsa0JBQWtCbFU7UUFDaEQwRCxLQUFLMFEseUJBQXlCcFUsT0FBT0E7UUFDckMwRCxLQUFLMlEsb0JBQW9CLE1BQU1yVTtRQUMvQmtVLG1CQUFtQkksbUJBQW1CSjtRQUN0Qy9ILElBQUlrSSxvQkFBb0JyVTtRQUN4QjBELEtBQUsyUSxvQkFBb0JILGtCQUFrQmxVO0lBQzdDO0lBQ0EsU0FBU3VVLGlCQUFpQnZVLEtBQUs7UUFDN0JtTSxJQUFJa0ksb0JBQW9CclU7UUFDeEJtTSxJQUFJaUkseUJBQXlCcFU7UUFDN0JtTSxJQUFJZ0kseUJBQXlCblU7SUFDL0I7SUFDQSxTQUFTd1U7UUFDUCxPQUFPVCxnQkFBZ0JNLG1CQUFtQnZSLE9BQU87SUFDbkQ7SUFDQSxTQUFTMlIsZ0JBQWdCelUsS0FBSztRQUM1QixTQUFTQSxNQUFNRSxhQUFhLElBQzFCd0QsS0FBS2dSLDhCQUE4QjFVLE9BQU9BO1FBQzVDLElBQUltQyxVQUFVNFIsZ0JBQWdCTSxtQkFBbUJ2UixPQUFPLEdBQ3RENlIsY0FBY0Msb0JBQW9CelMsU0FBU25DLE1BQU1pRSxJQUFJO1FBQ3ZEOUIsWUFBWXdTLGVBQ1RqUixDQUFBQSxLQUFLMFEseUJBQXlCcFUsT0FBT0EsUUFDdEMwRCxLQUFLMlEsb0JBQW9CTSxhQUFhM1UsTUFBSztJQUMvQztJQUNBLFNBQVM2VSxlQUFlN1UsS0FBSztRQUMzQm9VLHdCQUF3QnRSLE9BQU8sS0FBSzlDLFNBQ2pDbU0sQ0FBQUEsSUFBSWtJLG9CQUFvQnJVLFFBQVFtTSxJQUFJaUkseUJBQXlCcFUsTUFBSztRQUNyRTBVLDZCQUE2QjVSLE9BQU8sS0FBSzlDLFNBQ3RDbU0sQ0FBQUEsSUFBSXVJLDhCQUE4QjFVLFFBQ25DOFUsb0JBQ0tDLHNCQUFzQkMsYUFBYSxHQUFHQyx1QkFDdENGLHNCQUFzQkcsY0FBYyxHQUFHRCxvQkFBb0I7SUFDcEU7SUFDQSxTQUFTRSxnQkFBZ0JySyxJQUFJLEVBQUVzSyxNQUFNO1FBQ25DLE9BQU8sS0FBSyxNQUFNdEssS0FBS3VLLFdBQVcsSUFDaEMsTUFBTXZLLEtBQUt3SyxVQUFVLENBQUM3VSxNQUFNLElBQzVCLE1BQU1xSyxLQUFLeUssUUFBUSxDQUFDOVUsTUFBTSxJQUMxQixJQUFJcUssS0FBSzBLLGdCQUFnQixJQUN6QjFLLEtBQUswSyxnQkFBZ0IsR0FBRyxLQUFLSixTQUMzQkQsZ0JBQWdCckssS0FBS3lLLFFBQVEsQ0FBQyxFQUFFLEVBQUVILFVBQ2xDdEs7SUFDTjtJQUNBLFNBQVMySyxZQUFZTCxNQUFNO1FBQ3pCLE9BQU8sT0FBTyxLQUFLTSxNQUFNLENBQUNOO0lBQzVCO0lBQ0EsU0FBU08sTUFBTVAsTUFBTTtRQUNuQixPQUFPLE9BQU8sS0FBS00sTUFBTSxDQUFDTjtJQUM1QjtJQUNBLFNBQVNRLFFBQVFSLE1BQU07UUFDckIsT0FBTyxPQUFPLEtBQUtNLE1BQU0sQ0FBQ047SUFDNUI7SUFDQSxTQUFTUyxrQkFBa0I3VixLQUFLO1FBQzlCLE9BQVFBLE1BQU00QixHQUFHO1lBQ2YsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU81QixNQUFNaUUsSUFBSTtZQUNuQixLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPLFFBQVNqRSxNQUFNaUUsSUFBSSxFQUFHakUsTUFBTW9FLFdBQVcsSUFBSXBFLE1BQU1xRSxJQUFJLElBQUk7WUFDbEUsS0FBSztnQkFDSCxPQUNFLFFBQVNyRSxNQUFNaUUsSUFBSSxDQUFDZ0IsTUFBTSxFQUFHakYsTUFBTW9FLFdBQVcsSUFBSXBFLE1BQU1xRSxJQUFJLElBQUk7WUFFcEUsS0FBSztnQkFDSCxPQUFPLFFBQVNyRSxNQUFNaUUsSUFBSSxFQUFHakUsTUFBTW9FLFdBQVcsSUFBSXBFLE1BQU1xRSxJQUFJLElBQUk7WUFDbEU7Z0JBQ0UsT0FBTztRQUNYO0lBQ0Y7SUFDQSxTQUFTeVIsaUJBQWlCQyxPQUFPLEVBQUVDLFNBQVM7UUFDMUMsT0FBT0MsY0FBY0MsSUFBSSxDQUFDSCxXQUNyQixXQUFXSSxLQUFLQyxTQUFTLENBQUNMLFVBQzNCQSxRQUFRdFYsTUFBTSxHQUFHdVYsWUFBWSxJQUN6QixJQUFJQSxZQUNGLFlBQ0EsTUFBTUQsUUFBUWxWLEtBQUssQ0FBQyxHQUFHbVYsWUFBWSxLQUFLLFVBQzFDLE1BQU1ELFVBQVUsR0FBRSxJQUN0QkEsUUFBUXRWLE1BQU0sR0FBR3VWLFlBQ2YsSUFBSUEsWUFDRixZQUNBRCxRQUFRbFYsS0FBSyxDQUFDLEdBQUdtVixZQUFZLEtBQUssUUFDcENEO0lBQ1I7SUFDQSxTQUFTTSxpQkFBaUJDLFVBQVUsRUFBRWpCLFdBQVcsRUFBRUQsTUFBTTtRQUN2RCxJQUFJWSxZQUFZLE1BQU0sSUFBSVo7UUFDMUIsSUFBSSxTQUFTQyxhQUNYLE9BQU9NLE1BQU1QLFVBQVVVLGlCQUFpQlEsWUFBWU4sYUFBYTtRQUNuRSxJQUFJLGFBQWEsT0FBT1gsYUFBYTtZQUNuQyxJQUNFLElBQUlrQixZQUFZLEdBQ2hCQSxZQUFZbEIsWUFBWTVVLE1BQU0sSUFDOUI4VixZQUFZRCxXQUFXN1YsTUFBTSxJQUM3QjRVLFlBQVltQixVQUFVLENBQUNELGVBQ3JCRCxXQUFXRSxVQUFVLENBQUNELFlBQ3hCQTtZQUVGQSxZQUFZUCxZQUFZLEtBQ3RCLEtBQUtPLGFBQ0osY0FBYyxRQUFRRCxXQUFXelYsS0FBSyxDQUFDMFYsWUFBWSxJQUNuRGxCLGNBQWMsUUFBUUEsWUFBWXhVLEtBQUssQ0FBQzBWLFlBQVksRUFBRTtZQUN6RCxPQUNFWixNQUFNUCxVQUNOVSxpQkFBaUJRLFlBQVlOLGFBQzdCLE9BQ0FKLFFBQVFSLFVBQ1JVLGlCQUFpQlQsYUFBYVcsYUFDOUI7UUFFSjtRQUNBLE9BQ0VQLFlBQVlMLFVBQVVVLGlCQUFpQlEsWUFBWU4sYUFBYTtJQUVwRTtJQUNBLFNBQVNTLFdBQVdDLE1BQU07UUFDeEIsT0FBTzdQLE9BQU8wQixTQUFTLENBQUNvTCxRQUFRLENBQzdCakwsSUFBSSxDQUFDZ08sUUFDTGpOLE9BQU8sQ0FBQyxxQkFBcUIsU0FBVWtOLENBQUMsRUFBRUMsRUFBRTtZQUMzQyxPQUFPQTtRQUNUO0lBQ0o7SUFDQSxTQUFTQyxjQUFjclcsS0FBSyxFQUFFd1YsU0FBUztRQUNyQyxPQUFRLE9BQU94VjtZQUNiLEtBQUs7Z0JBQ0gsT0FDRSxRQUFTMlYsS0FBS0MsU0FBUyxDQUFDNVYsUUFDeEJBLE1BQU1DLE1BQU0sR0FBR3VWLFlBQ1gsSUFBSUEsWUFDRixVQUNBeFYsTUFBTUssS0FBSyxDQUFDLEdBQUdtVixZQUFZLEtBQUssU0FDbEN4VjtZQUVSLEtBQUs7Z0JBQ0gsSUFBSSxTQUFTQSxPQUFPLE9BQU87Z0JBQzNCLElBQUlJLFlBQVlKLFFBQVEsT0FBTztnQkFDL0IsSUFBSUEsTUFBTTBELFFBQVEsS0FBSzRTLG9CQUNyQixPQUFPLENBQUNkLFlBQVloUyx5QkFBeUJ4RCxNQUFNeUQsSUFBSSxLQUNuRCxNQUFNK1IsWUFBWSxNQUNsQjtnQkFDTixJQUFJM1IsT0FBT29TLFdBQVdqVztnQkFDdEIsSUFBSSxhQUFhNkQsTUFBTTtvQkFDckJBLE9BQU87b0JBQ1AyUixhQUFhO29CQUNiLElBQUssSUFBSWUsWUFBWXZXLE1BQ25CLElBQUlBLE1BQU13VyxjQUFjLENBQUNELFdBQVc7d0JBQ2xDLElBQUlFLGVBQWVkLEtBQUtDLFNBQVMsQ0FBQ1c7d0JBQ2xDRSxpQkFBaUIsTUFBTUYsV0FBVyxPQUMvQkEsQ0FBQUEsV0FBV0UsWUFBVzt3QkFDekJqQixhQUFhZSxTQUFTdFcsTUFBTSxHQUFHO3dCQUMvQndXLGVBQWVKLGNBQ2JyVyxLQUFLLENBQUN1VyxTQUFTLEVBQ2YsS0FBS2YsWUFBWUEsWUFBWTt3QkFFL0JBLGFBQWFpQixhQUFheFcsTUFBTTt3QkFDaEMsSUFBSSxJQUFJdVYsV0FBVzs0QkFDakIzUixRQUFRLE9BQU9BLE9BQU8sUUFBUTs0QkFDOUI7d0JBQ0Y7d0JBQ0FBLFFBQ0UsQ0FBQyxPQUFPQSxPQUFPLEtBQUssR0FBRSxJQUFLMFMsV0FBVyxNQUFNRTtvQkFDaEQ7b0JBQ0YsT0FBTyxNQUFNNVMsT0FBTztnQkFDdEI7Z0JBQ0EsT0FBT0E7WUFDVCxLQUFLO2dCQUNILE9BQU8sQ0FBQzJSLFlBQVl4VixNQUFNNEQsV0FBVyxJQUFJNUQsTUFBTTZELElBQUksSUFDL0MsY0FBYzJSLFlBQ2Q7WUFDTjtnQkFDRSxPQUFPa0IsT0FBTzFXO1FBQ2xCO0lBQ0Y7SUFDQSxTQUFTMlcsa0JBQWtCM1csS0FBSyxFQUFFd1YsU0FBUztRQUN6QyxPQUFPLGFBQWEsT0FBT3hWLFNBQVN5VixjQUFjQyxJQUFJLENBQUMxVixTQUNuRCxNQUFNcVcsY0FBY3JXLE9BQU93VixZQUFZLEtBQUssTUFDNUN4VixNQUFNQyxNQUFNLEdBQUd1VixZQUFZLElBQ3pCLElBQUlBLFlBQ0YsVUFDQSxNQUFNeFYsTUFBTUssS0FBSyxDQUFDLEdBQUdtVixZQUFZLEtBQUssU0FDeEMsTUFBTXhWLFFBQVE7SUFDdEI7SUFDQSxTQUFTNFcsd0JBQXdCblQsSUFBSSxFQUFFd0MsS0FBSyxFQUFFNFEsU0FBUztRQUNyRCxJQUFJQyxxQkFBcUIsTUFBTUQsVUFBVTVXLE1BQU0sR0FBR3dELEtBQUt4RCxNQUFNLEVBQzNEOFcsYUFBYSxFQUFFLEVBQ2ZSO1FBQ0YsSUFBS0EsWUFBWXRRLE1BQ2YsSUFBSUEsTUFBTXVRLGNBQWMsQ0FBQ0QsYUFBYSxlQUFlQSxVQUFVO1lBQzdELElBQUlTLFlBQVlMLGtCQUNkMVEsS0FBSyxDQUFDc1EsU0FBUyxFQUNmLE1BQU1NLFVBQVU1VyxNQUFNLEdBQUdzVyxTQUFTdFcsTUFBTSxHQUFHO1lBRTdDNlcsc0JBQXNCUCxTQUFTdFcsTUFBTSxHQUFHK1csVUFBVS9XLE1BQU0sR0FBRztZQUMzRDhXLFdBQVc3VCxJQUFJLENBQUNxVCxXQUFXLE1BQU1TO1FBQ25DO1FBQ0YsT0FBTyxNQUFNRCxXQUFXOVcsTUFBTSxHQUMxQjRXLFlBQVksTUFBTXBULE9BQU8sUUFDekIsSUFBSXFULHFCQUNGRCxZQUFZLE1BQU1wVCxPQUFPLE1BQU1zVCxXQUFXM1QsSUFBSSxDQUFDLE9BQU8sUUFDdER5VCxZQUNBLE1BQ0FwVCxPQUNBLE9BQ0FvVCxZQUNBLE9BQ0FFLFdBQVczVCxJQUFJLENBQUMsT0FBT3lULFlBQVksUUFDbkMsT0FDQUEsWUFDQTtJQUNSO0lBQ0EsU0FBU0ksdUJBQXVCQyxZQUFZLEVBQUVDLFlBQVksRUFBRXZDLE1BQU07UUFDaEUsSUFBSW1DLGFBQWEsSUFDZkssNEJBQTRCOVcsT0FBTyxDQUFDLEdBQUc2VyxlQUN2Q1o7UUFDRixJQUFLQSxZQUFZVyxhQUNmLElBQUlBLGFBQWFWLGNBQWMsQ0FBQ0QsV0FBVztZQUN6QyxPQUFPYSx5QkFBeUIsQ0FBQ2IsU0FBUztZQUMxQyxJQUFJZixZQUFZLE1BQU0sSUFBSVosU0FBUzJCLFNBQVN0VyxNQUFNLEdBQUcsR0FDbkRvWCxrQkFBa0JoQixjQUFjYSxZQUFZLENBQUNYLFNBQVMsRUFBRWY7WUFDMUQyQixhQUFhWCxjQUFjLENBQUNELFlBQ3ZCLGFBQWFGLGNBQWNjLFlBQVksQ0FBQ1osU0FBUyxFQUFFZixZQUNuRHVCLGNBQ0M1QixNQUFNUCxVQUFVMkIsV0FBVyxPQUFPYyxrQkFBa0IsTUFDckROLGNBQ0MzQixRQUFRUixVQUFVMkIsV0FBVyxPQUFPZixZQUFZLElBQUksSUFDckR1QixjQUNDNUIsTUFBTVAsVUFBVTJCLFdBQVcsT0FBT2Msa0JBQWtCO1FBQzVEO1FBQ0YsSUFBSyxJQUFJQyxhQUFhRiwwQkFDcEJBLDBCQUEwQlosY0FBYyxDQUFDYyxjQUN0QyxnQkFBZ0JqQixjQUNmZSx5QkFBeUIsQ0FBQ0UsVUFBVSxFQUNwQyxNQUFNLElBQUkxQyxTQUFTMEMsVUFBVXJYLE1BQU0sR0FBRyxJQUV2QzhXLGNBQ0MzQixRQUFRUixVQUFVMEMsWUFBWSxPQUFPSixlQUFlLElBQUk7UUFDOUQsT0FBT0g7SUFDVDtJQUNBLFNBQVNRLG9CQUFvQjlULElBQUksRUFBRStULFdBQVcsRUFBRTNDLFdBQVcsRUFBRUQsTUFBTTtRQUNqRSxJQUFJVyxVQUFVLElBQ1prQyxrQkFBa0IsSUFBSUM7UUFDeEIsSUFBS0MscUJBQXFCOUMsWUFDeEJBLFlBQVkyQixjQUFjLENBQUNtQixzQkFDekJGLGdCQUFnQjFVLEdBQUcsQ0FDakI0VSxrQkFBa0JDLFdBQVcsSUFDN0JEO1FBRU4sSUFBSSxNQUFNRixnQkFBZ0JsSSxJQUFJLElBQUlrSSxnQkFBZ0JqSSxHQUFHLENBQUMsYUFDcEQrRixXQUFXcUIsd0JBQ1RuVCxNQUNBK1QsYUFDQXZDLFlBQVlMO2FBRVg7WUFDSCxJQUFLLElBQUlpRCxjQUFjTCxZQUNyQixJQUNFQSxZQUFZaEIsY0FBYyxDQUFDcUIsZUFDM0IsZUFBZUEsWUFDZjtnQkFDQSxJQUFJQyxxQkFDQSxNQUFNLElBQUtsRCxDQUFBQSxTQUFTLEtBQUtpRCxXQUFXNVgsTUFBTSxHQUFHLEdBQy9DOFgsaUJBQWlCTixnQkFBZ0JuUSxHQUFHLENBQUN1USxXQUFXRCxXQUFXO2dCQUM3RCxJQUFJLEtBQUssTUFBTUcsZ0JBQWdCO29CQUM3Qk4sZ0JBQWdCTyxNQUFNLENBQUNILFdBQVdELFdBQVc7b0JBQzdDLElBQUlELG9CQUFvQkgsV0FBVyxDQUFDSyxXQUFXO29CQUMvQ0UsaUJBQWlCbEQsV0FBVyxDQUFDa0QsZUFBZTtvQkFDNUMsSUFBSVYsa0JBQWtCVixrQkFDcEJnQixtQkFDQUc7b0JBRUZBLHFCQUFxQm5CLGtCQUNuQm9CLGdCQUNBRDtvQkFFRixhQUFhLE9BQU9ILHFCQUNwQixTQUFTQSxxQkFDVCxhQUFhLE9BQU9JLGtCQUNwQixTQUFTQSxrQkFDVCxhQUFhOUIsV0FBVzBCLHNCQUN4QixhQUFhMUIsV0FBVzhCLG1CQUN2QixLQUFJMVIsT0FBTzRSLElBQUksQ0FBQ04sbUJBQW1CMVgsTUFBTSxJQUN4QyxJQUFJb0csT0FBTzRSLElBQUksQ0FBQ0YsZ0JBQWdCOVgsTUFBTSxJQUN0QyxDQUFDLElBQUlvWCxnQkFBZ0J0USxPQUFPLENBQUMsVUFDN0IsQ0FBQyxJQUFJK1EsbUJBQW1CL1EsT0FBTyxDQUFDLE1BQUssSUFDbEN3TyxXQUNDTixZQUFZTCxTQUFTLEtBQ3JCaUQsYUFDQSxVQUNBWix1QkFDRVUsbUJBQ0FJLGdCQUNBbkQsU0FBUyxLQUVYSyxZQUFZTCxTQUFTLEtBQ3JCLFNBQ0QsWUFDQ08sTUFBTVAsU0FBUyxLQUNmaUQsYUFDQSxNQUNBUixrQkFDQSxNQUNEOUIsV0FDQ0gsUUFBUVIsU0FBUyxLQUNqQmlELGFBQ0EsTUFDQUMscUJBQ0EsSUFBSTtnQkFDWixPQUNFdkMsV0FDRU4sWUFBWUwsU0FBUyxLQUNyQmlELGFBQ0EsTUFDQWxCLGtCQUFrQmEsV0FBVyxDQUFDSyxXQUFXLEVBQUVDLHNCQUMzQztZQUNOO1lBQ0ZMLGdCQUFnQnhVLE9BQU8sQ0FBQyxTQUFVc1QsUUFBUTtnQkFDeEMsSUFBSSxlQUFlQSxVQUFVO29CQUMzQixJQUFJZixZQUFZLE1BQU0sSUFBS1osQ0FBQUEsU0FBUyxLQUFLMkIsU0FBU3RXLE1BQU0sR0FBRztvQkFDM0RzVixXQUNFSCxRQUFRUixTQUFTLEtBQ2pCMkIsV0FDQSxNQUNBSSxrQkFBa0I5QixXQUFXLENBQUMwQixTQUFTLEVBQUVmLGFBQ3pDO2dCQUNKO1lBQ0Y7WUFDQUQsVUFDRSxPQUFPQSxVQUNITixZQUFZTCxVQUFVLE1BQU1uUixPQUFPLFFBQ25Dd1IsWUFBWUwsVUFDWixNQUNBblIsT0FDQSxPQUNBOFIsVUFDQU4sWUFBWUwsVUFDWjtRQUNSO1FBQ0FuUixPQUFPb1IsWUFBWUUsUUFBUTtRQUMzQnlDLGNBQWNBLFlBQVl6QyxRQUFRO1FBQ2xDLElBQ0UsYUFBYSxPQUFPdFIsUUFDcEIsYUFBYSxPQUFPQSxRQUNwQixhQUFhLE9BQU9BLE1BQ3BCO1lBQ0FnVSxrQkFBa0I7WUFDbEIsSUFDRSxhQUFhLE9BQU9ELGVBQ3BCLGFBQWEsT0FBT0EsZUFDcEIsYUFBYSxPQUFPQSxhQUVwQkMsa0JBQWtCLEtBQUtEO1lBQ3pCakMsV0FBV00saUJBQWlCNEIsaUJBQWlCLEtBQUtoVSxNQUFNbVIsU0FBUztRQUNuRSxPQUFPLElBQ0wsYUFBYSxPQUFPNEMsZUFDcEIsYUFBYSxPQUFPQSxlQUNwQixhQUFhLE9BQU9BLGFBRXBCakMsVUFDRSxRQUFROVIsT0FDSjhSLFVBQVVNLGlCQUFpQixLQUFLMkIsYUFBYSxNQUFNNUMsU0FBUyxLQUM1RFcsVUFBVU0saUJBQWlCLEtBQUsyQixhQUFhLEtBQUssR0FBRzVDLFNBQVM7UUFDdEUsT0FBT1c7SUFDVDtJQUNBLFNBQVMyQyxxQkFBcUIxWSxLQUFLLEVBQUVvVixNQUFNO1FBQ3pDLElBQUluUixPQUFPNFIsa0JBQWtCN1Y7UUFDN0IsSUFBSSxTQUFTaUUsTUFBTTtZQUNqQkEsT0FBTztZQUNQLElBQUtqRSxRQUFRQSxNQUFNd0wsS0FBSyxFQUFFeEwsT0FDeEIsUUFBUzBZLHFCQUFxQjFZLE9BQU9vVixTQUNsQ3BWLFFBQVFBLE1BQU15TCxPQUFPO1lBQzFCLE9BQU94SDtRQUNUO1FBQ0EsT0FBT3dSLFlBQVlMLFVBQVUsTUFBTW5SLE9BQU87SUFDNUM7SUFDQSxTQUFTMFUsYUFBYTdOLElBQUksRUFBRXNLLE1BQU07UUFDaEMsSUFBSXdELGFBQWF6RCxnQkFBZ0JySyxNQUFNc0s7UUFDdkMsSUFDRXdELGVBQWU5TixRQUNkLE9BQU1BLEtBQUt5SyxRQUFRLENBQUM5VSxNQUFNLElBQUlxSyxLQUFLeUssUUFBUSxDQUFDLEVBQUUsS0FBS3FELFVBQVMsR0FFN0QsT0FDRW5ELFlBQVlMLFVBQVUsVUFBVXVELGFBQWFDLFlBQVl4RCxTQUFTO1FBRXRFd0QsYUFBYTtRQUNiLElBQUkvTyxZQUFZaUIsS0FBSzlLLEtBQUssQ0FBQ3dGLFVBQVU7UUFDckMsSUFBSXFFLFdBQ0YsSUFBSyxJQUFJekksSUFBSSxHQUFHQSxJQUFJeUksVUFBVXBKLE1BQU0sRUFBRVcsSUFBSztZQUN6QyxJQUFJeVgsc0JBQXNCaFAsU0FBUyxDQUFDekksRUFBRSxDQUFDaUQsSUFBSTtZQUMzQyxhQUFhLE9BQU93VSx1QkFDakIsZUFDQ3BELFlBQVlMLFVBQVUsTUFBTXlELHNCQUFzQixPQUNwRHpELFFBQU87UUFDWDtRQUNGdkwsWUFBWTtRQUNaekksSUFBSTBKLEtBQUs5SyxLQUFLLENBQUM2QixZQUFZO1FBQzNCLElBQUksTUFBTWlKLEtBQUs5SyxLQUFLLENBQUM0QixHQUFHLEVBQ3RCLFlBQWF5VSxpQkFBaUJqVixHQUFHMEosS0FBS3VLLFdBQVcsRUFBRUQsU0FBVUE7YUFDMUQsSUFDRixzQkFBdUJTLGtCQUFrQi9LLEtBQUs5SyxLQUFLLEdBQ3BELFNBQVM2WSxxQkFFVCxJQUFJLEtBQUssTUFBTS9OLEtBQUt1SyxXQUFXLEVBQUU7WUFDL0J4TCxZQUFZdUw7WUFDWixJQUFJWSxZQUFZLE1BQU0sSUFBSW5NLFlBQVlnUCxvQkFBb0JwWSxNQUFNLEdBQUcsR0FDakVzVixVQUFVO1lBQ1osSUFBS2dCLFlBQVkzVixFQUNmLElBQUlBLEVBQUU0VixjQUFjLENBQUNELGFBQWEsZUFBZUEsVUFBVTtnQkFDekQsSUFBSVMsWUFBWUwsa0JBQWtCL1YsQ0FBQyxDQUFDMlYsU0FBUyxFQUFFO2dCQUMvQ2YsYUFBYWUsU0FBU3RXLE1BQU0sR0FBRytXLFVBQVUvVyxNQUFNLEdBQUc7Z0JBQ2xELElBQUksSUFBSXVWLFdBQVc7b0JBQ2pCRCxXQUFXO29CQUNYO2dCQUNGO2dCQUNBQSxXQUFXLE1BQU1nQixXQUFXLE1BQU1TO1lBQ3BDO1lBQ0YzTixZQUNFNEwsWUFBWTVMLGFBQ1osTUFDQWdQLHNCQUNBOUMsVUFDQTtZQUNGWDtRQUNGLE9BQ0UsU0FBU3RLLEtBQUt1SyxXQUFXLEdBQ3BCLGFBQWErQix3QkFDWnlCLHFCQUNBelgsR0FDQXVVLE1BQU1QLFVBRVJBLFFBQU8sSUFDUCxhQUFhLE9BQU90SyxLQUFLdUssV0FBVyxHQUNsQ25VLFFBQVFnQyxLQUFLLENBQ1gsMEZBRUQsYUFBYTZVLG9CQUNaYyxxQkFDQXpYLEdBQ0EwSixLQUFLdUssV0FBVyxFQUNoQkQsU0FFRkEsUUFBTztRQUNqQixJQUFJMkIsV0FBVztRQUNmM1YsSUFBSTBKLEtBQUs5SyxLQUFLLENBQUN3TCxLQUFLO1FBQ3BCLElBQ0VxTixzQkFBc0IsR0FDdEJ6WCxLQUFLeVgsc0JBQXNCL04sS0FBS3lLLFFBQVEsQ0FBQzlVLE1BQU0sRUFHL0MsWUFBYXFLLEtBQUt5SyxRQUFRLENBQUNzRCxvQkFBb0IsRUFDN0M3QyxVQUFVaFcsS0FBSyxLQUFLb0IsSUFDZixhQUFhdVgsYUFBYTNDLFdBQVdaLFNBQ3RDeUQscUJBQW9CLElBQ25COUIsWUFBWTJCLHFCQUFxQnRYLEdBQUdnVSxTQUN4Q2hVLElBQUlBLEVBQUVxSyxPQUFPO1FBQ2xCckssS0FDRSxJQUFJMEosS0FBS3lLLFFBQVEsQ0FBQzlVLE1BQU0sSUFDdkJzVyxDQUFBQSxZQUFZdEIsWUFBWUwsVUFBVSxPQUFNO1FBQzNDaFUsSUFBSTBKLEtBQUt3SyxVQUFVO1FBQ25CLFNBQVN4SyxLQUFLdUssV0FBVyxJQUFJRDtRQUM3QixJQUFLdEssT0FBTyxHQUFHQSxPQUFPMUosRUFBRVgsTUFBTSxFQUFFcUssT0FDOUIsc0JBQXVCMUosQ0FBQyxDQUFDMEosS0FBSyxFQUMzQmlNLFdBQ0MsYUFBYSxPQUFPOEIsc0JBQ2hCOUIsV0FDQ25CLENBQUFBLFFBQVFSLFVBQ1BVLGlCQUFpQitDLHFCQUFxQixNQUFNLElBQUl6RCxVQUNoRCxJQUFHLElBQ0wyQixXQUNBSyx3QkFDRXlCLG9CQUFvQjVVLElBQUksRUFDeEI0VSxvQkFBb0JwUyxLQUFLLEVBQ3pCbVAsUUFBUVI7UUFFcEIsT0FBT3dELGFBQWEvTyxZQUFZa047SUFDbEM7SUFDQSxTQUFTK0IsYUFBYUMsUUFBUTtRQUM1QixJQUFJO1lBQ0YsT0FBTyxTQUFTSixhQUFhSSxVQUFVO1FBQ3pDLEVBQUUsT0FBT3pULEdBQUc7WUFDVixPQUFPO1FBQ1Q7SUFDRjtJQUNBLFNBQVMwVCx1QkFBdUJoWixLQUFLLEVBQUV3VixnQkFBZ0I7UUFDckQsSUFBSSxTQUFTeFYsTUFBTXlGLE1BQU0sRUFBRTtZQUN6QixJQUFJLFNBQVN3VCxzQkFDWEEsdUJBQXVCO2dCQUNyQmpaLE9BQU9BO2dCQUNQdVYsVUFBVSxFQUFFO2dCQUNaRixhQUFhLEtBQUs7Z0JBQ2xCQyxZQUFZLEVBQUU7Z0JBQ2RFLGtCQUFrQkE7WUFDcEI7aUJBQ0c7Z0JBQ0gsSUFBSXlELHFCQUFxQmpaLEtBQUssS0FBS0EsT0FDakMsTUFBTWtILE1BQ0o7Z0JBRUorUixxQkFBcUJ6RCxnQkFBZ0IsR0FBR0Esb0JBQ3JDeUQsQ0FBQUEscUJBQXFCekQsZ0JBQWdCLEdBQUdBLGdCQUFlO1lBQzVEO1lBQ0EsT0FBT3lEO1FBQ1Q7UUFDQSxJQUFJQyxXQUFXRix1QkFDYmhaLE1BQU15RixNQUFNLEVBQ1orUCxtQkFBbUIsR0FDbkJELFFBQVE7UUFDVixJQUFJLElBQUkyRCxTQUFTelksTUFBTSxJQUFJeVksUUFBUSxDQUFDQSxTQUFTelksTUFBTSxHQUFHLEVBQUUsQ0FBQ1QsS0FBSyxLQUFLQSxPQUNqRSxPQUNFLFdBQVlrWixRQUFRLENBQUNBLFNBQVN6WSxNQUFNLEdBQUcsRUFBRSxFQUN6Q3lZLFNBQVMxRCxnQkFBZ0IsR0FBR0Esb0JBQ3pCMEQsQ0FBQUEsU0FBUzFELGdCQUFnQixHQUFHQSxnQkFBZSxHQUM5QzBEO1FBRUoxRCxtQkFBbUI7WUFDakJ4VixPQUFPQTtZQUNQdVYsVUFBVSxFQUFFO1lBQ1pGLGFBQWEsS0FBSztZQUNsQkMsWUFBWSxFQUFFO1lBQ2RFLGtCQUFrQkE7UUFDcEI7UUFDQTBELFNBQVN4VixJQUFJLENBQUM4UjtRQUNkLE9BQU9BO0lBQ1Q7SUFDQSxTQUFTMkQsd0JBQXdCblosS0FBSyxFQUFFb1osaUJBQWlCO1FBQ3ZEQyx3QkFDRyxTQUFTTCx1QkFBdUJoWixPQUFPLElBQ3ZDQSxNQUFNcVYsV0FBVyxHQUFHLE1BQ3JCLFNBQVMrRCxxQkFDTixxQkFDQ0UseUNBQXlDRixvQkFDM0NwWixNQUFNc1YsVUFBVSxDQUFDNVIsSUFBSSxDQUFDMFYsa0JBQWlCLENBQUM7SUFDOUM7SUFDQSxTQUFTRyx5QkFBeUJ2WixLQUFLO1FBQ3JDLElBQUl3WixPQUFPLElBQ1RDLFdBQVdSO1FBQ2IsU0FBU1EsWUFDTix3QkFBd0IsTUFBUUQsT0FBT1YsYUFBYVcsU0FBUztRQUNoRUMsb0JBQ0VuSCwyQkFDRXJMLE1BQ0Usa3JCQUNFc1MsT0FFSnhaO1FBR0osTUFBTTJaO0lBQ1I7SUFDQSxTQUFTQyw2QkFBNkI1WixLQUFLLEVBQUU2WixXQUFXO1FBQ3RELElBQUksQ0FBQ0MsbUJBQ0gsTUFBTTVTLE1BQ0o7UUFFSjZTLGdCQUNFL1osTUFBTTRMLFNBQVMsRUFDZjVMLE1BQU1pRSxJQUFJLEVBQ1ZqRSxNQUFNZ2EsYUFBYSxFQUNuQkgsYUFDQTdaLFVBQ0d1Wix5QkFBeUJ2WjtJQUNoQztJQUNBLFNBQVNpYSxvQkFBb0JqYSxLQUFLO1FBQ2hDLElBQUtrYSx1QkFBdUJsYSxNQUFNeUYsTUFBTSxFQUFFeVUsc0JBQ3hDLE9BQVFBLHFCQUFxQnRZLEdBQUc7WUFDOUIsS0FBSztZQUNMLEtBQUs7Z0JBQ0h1WSx5QkFBeUIsQ0FBQztnQkFDMUI7WUFDRixLQUFLO1lBQ0wsS0FBSztnQkFDSEEseUJBQXlCLENBQUM7Z0JBQzFCO1lBQ0Y7Z0JBQ0VELHVCQUF1QkEscUJBQXFCelUsTUFBTTtRQUN0RDtJQUNKO0lBQ0EsU0FBUzJVLGtCQUFrQnBhLEtBQUs7UUFDOUIsSUFBSSxDQUFDOFoscUJBQXFCOVosVUFBVWthLHNCQUFzQixPQUFPLENBQUM7UUFDbEUsSUFBSSxDQUFDcEcsYUFDSCxPQUFPbUcsb0JBQW9CamEsUUFBUzhULGNBQWMsQ0FBQyxHQUFJLENBQUM7UUFDMUQsSUFBSXVHLGNBQWMsQ0FBQztRQUNuQkMscUJBQ0ksTUFBTXRhLE1BQU00QixHQUFHLElBQ2YsT0FBTzVCLE1BQU00QixHQUFHLElBQ2YsT0FBTTVCLE1BQU00QixHQUFHLElBQ2IyWSxvQ0FBb0N2YSxNQUFNaUUsSUFBSSxLQUM3QyxDQUFDdVcscUJBQXFCeGEsTUFBTWlFLElBQUksRUFBRWpFLE1BQU1nYSxhQUFhLENBQUMsS0FDekRLLENBQUFBLGNBQWMsQ0FBQyxLQUNoQixNQUFNcmEsTUFBTTRCLEdBQUcsSUFDZCxPQUFNNUIsTUFBTTRCLEdBQUcsSUFDYjJZLG9DQUFvQ3ZhLE1BQU1pRSxJQUFJLEtBQzdDLENBQUN1VyxxQkFBcUJ4YSxNQUFNaUUsSUFBSSxFQUFFakUsTUFBTWdhLGFBQWEsQ0FBQyxLQUN6REssQ0FBQUEsY0FBYyxDQUFDO1FBQ3BCLElBQUlBLGVBQWVJLHdCQUF3QjtZQUN6QyxJQUFLSixjQUFjSSx3QkFBd0JKLGFBQWU7Z0JBQ3hELElBQUlLLFdBQVcxQix1QkFBdUJoWixPQUFPLElBQzNDMmEsY0FBY3JCLHlDQUF5Q2U7Z0JBQ3pESyxTQUFTcEYsVUFBVSxDQUFDNVIsSUFBSSxDQUFDaVg7Z0JBQ3pCTixjQUNFLGVBQWVNLFlBQVkxVyxJQUFJLEdBQzNCMlcsK0NBQStDUCxlQUMvQ1EseUJBQXlCUjtZQUNqQztZQUNBZCx5QkFBeUJ2WjtRQUMzQjtRQUNBaWEsb0JBQW9CamE7UUFDcEIsSUFBSSxPQUFPQSxNQUFNNEIsR0FBRyxFQUFFO1lBQ3BCLElBQUksQ0FBQ2tZLG1CQUNILE1BQU01UyxNQUNKO1lBRUpsSCxRQUFRQSxNQUFNRSxhQUFhO1lBQzNCRixRQUFRLFNBQVNBLFFBQVFBLE1BQU04YSxVQUFVLEdBQUc7WUFDNUMsSUFBSSxDQUFDOWEsT0FDSCxNQUFNa0gsTUFDSjtZQUVKdVQseUJBQ0VHLCtDQUErQzVhO1FBQ25ELE9BQ0V5YSx5QkFBeUJQLHVCQUNyQlcseUJBQXlCN2EsTUFBTTRMLFNBQVMsSUFDeEM7UUFDTixPQUFPLENBQUM7SUFDVjtJQUNBLFNBQVNtUDtRQUNQakIscUJBQ0csMEJBQTBCSSx1QkFBdUIsTUFDakRiLHVCQUF1QnZGLGNBQWMsQ0FBQyxDQUFDO0lBQzVDO0lBQ0EsU0FBUzRGLG9CQUFvQnhXLEtBQUs7UUFDaEMsU0FBUzhYLGtCQUNKQSxrQkFBa0I7WUFBQzlYO1NBQU0sR0FDMUI4WCxnQkFBZ0J0WCxJQUFJLENBQUNSO0lBQzNCO0lBQ0EsU0FBUytYO1FBQ1AsSUFBSXhCLFdBQVdSO1FBQ2YsU0FBU1EsWUFDTix3QkFBd0IsTUFDeEJBLFdBQVdYLGFBQWFXLFdBQ3pCdlksUUFBUWdDLEtBQUssQ0FDWCxzb0JBQ0EsNkNBQ0F1VyxTQUNGO0lBQ0o7SUFDQSxTQUFTeUI7UUFDUCxJQUNFLElBQUlDLFdBQVdDLHVCQUNiaGEsSUFBS2lhLDJCQUEyQkQsd0JBQXdCLEdBQzFEaGEsSUFBSStaLFVBRUo7WUFDQSxJQUFJbmIsUUFBUXNiLGdCQUFnQixDQUFDbGEsRUFBRTtZQUMvQmthLGdCQUFnQixDQUFDbGEsSUFBSSxHQUFHO1lBQ3hCLElBQUltYSxRQUFRRCxnQkFBZ0IsQ0FBQ2xhLEVBQUU7WUFDL0JrYSxnQkFBZ0IsQ0FBQ2xhLElBQUksR0FBRztZQUN4QixJQUFJb0IsU0FBUzhZLGdCQUFnQixDQUFDbGEsRUFBRTtZQUNoQ2thLGdCQUFnQixDQUFDbGEsSUFBSSxHQUFHO1lBQ3hCLElBQUl3TCxPQUFPME8sZ0JBQWdCLENBQUNsYSxFQUFFO1lBQzlCa2EsZ0JBQWdCLENBQUNsYSxJQUFJLEdBQUc7WUFDeEIsSUFBSSxTQUFTbWEsU0FBUyxTQUFTL1ksUUFBUTtnQkFDckMsSUFBSWdaLFVBQVVELE1BQU1DLE9BQU87Z0JBQzNCLFNBQVNBLFVBQ0poWixPQUFPckMsSUFBSSxHQUFHcUMsU0FDZCxRQUFRckMsSUFBSSxHQUFHcWIsUUFBUXJiLElBQUksRUFBSXFiLFFBQVFyYixJQUFJLEdBQUdxQyxNQUFNO2dCQUN6RCtZLE1BQU1DLE9BQU8sR0FBR2haO1lBQ2xCO1lBQ0EsTUFBTW9LLFFBQVE2Tyw4QkFBOEJ6YixPQUFPd0MsUUFBUW9LO1FBQzdEO0lBQ0Y7SUFDQSxTQUFTOE8sZ0JBQWdCMWIsS0FBSyxFQUFFdWIsS0FBSyxFQUFFL1ksTUFBTSxFQUFFb0ssSUFBSTtRQUNqRDBPLGdCQUFnQixDQUFDRix3QkFBd0IsR0FBR3BiO1FBQzVDc2IsZ0JBQWdCLENBQUNGLHdCQUF3QixHQUFHRztRQUM1Q0QsZ0JBQWdCLENBQUNGLHdCQUF3QixHQUFHNVk7UUFDNUM4WSxnQkFBZ0IsQ0FBQ0Ysd0JBQXdCLEdBQUd4TztRQUM1Q3lPLDRCQUE0QnpPO1FBQzVCNU0sTUFBTThNLEtBQUssSUFBSUY7UUFDZjVNLFFBQVFBLE1BQU1nTCxTQUFTO1FBQ3ZCLFNBQVNoTCxTQUFVQSxDQUFBQSxNQUFNOE0sS0FBSyxJQUFJRixJQUFHO0lBQ3ZDO0lBQ0EsU0FBUytPLDRCQUE0QjNiLEtBQUssRUFBRXViLEtBQUssRUFBRS9ZLE1BQU0sRUFBRW9LLElBQUk7UUFDN0Q4TyxnQkFBZ0IxYixPQUFPdWIsT0FBTy9ZLFFBQVFvSztRQUN0QyxPQUFPZ1AsdUJBQXVCNWI7SUFDaEM7SUFDQSxTQUFTNmIsK0JBQStCN2IsS0FBSyxFQUFFNE0sSUFBSTtRQUNqRDhPLGdCQUFnQjFiLE9BQU8sTUFBTSxNQUFNNE07UUFDbkMsT0FBT2dQLHVCQUF1QjViO0lBQ2hDO0lBQ0EsU0FBU3liLDhCQUE4QkssV0FBVyxFQUFFdFosTUFBTSxFQUFFb0ssSUFBSTtRQUM5RGtQLFlBQVloUCxLQUFLLElBQUlGO1FBQ3JCLElBQUk1QixZQUFZOFEsWUFBWTlRLFNBQVM7UUFDckMsU0FBU0EsYUFBY0EsQ0FBQUEsVUFBVThCLEtBQUssSUFBSUYsSUFBRztRQUM3QyxJQUFLLElBQUltUCxXQUFXLENBQUMsR0FBR2pRLFNBQVNnUSxZQUFZclcsTUFBTSxFQUFFLFNBQVNxRyxRQUM1RCxPQUFRa1EsVUFBVSxJQUFJcFAsTUFDbkI1QixZQUFZYyxPQUFPZCxTQUFTLEVBQzdCLFNBQVNBLGFBQWNBLENBQUFBLFVBQVVnUixVQUFVLElBQUlwUCxJQUFHLEdBQ2xELE9BQU9kLE9BQU9sSyxHQUFHLElBQ2QsZUFBZWtLLE9BQU9GLFNBQVMsRUFDaEMsU0FBU2tRLGVBQ1BBLFlBQVlHLFdBQVcsR0FBRyxLQUN6QkYsQ0FBQUEsV0FBVyxDQUFDLEVBQUMsR0FDakJELGNBQWNoUSxRQUNkQSxTQUFTQSxPQUFPckcsTUFBTTtRQUMzQnNXLFlBQ0UsU0FBU3ZaLFVBQ1QsTUFBTXNaLFlBQVlsYSxHQUFHLElBQ3BCLFVBQVVrYSxZQUFZbFEsU0FBUyxFQUMvQm1RLFdBQVcsS0FBSzVNLE1BQU12QyxPQUN0QmQsU0FBU0EsT0FBT29ELGFBQWEsRUFDN0I0TSxjQUFjaFEsTUFBTSxDQUFDaVEsU0FBUyxFQUMvQixTQUFTRCxjQUNKaFEsTUFBTSxDQUFDaVEsU0FBUyxHQUFHO1lBQUN2WjtTQUFPLEdBQzVCc1osWUFBWXBZLElBQUksQ0FBQ2xCLFNBQ3BCQSxPQUFPb0ssSUFBSSxHQUFHQSxPQUFPLFNBQVM7SUFDbkM7SUFDQSxTQUFTZ1AsdUJBQXVCRSxXQUFXO1FBQ3pDLElBQUlJLG9CQUFvQkMscUJBQ3RCLE1BQ0csMkJBQTRCRCxvQkFBb0IsR0FDaERHLCtCQUErQkMsd0JBQXdCLE1BQ3hEcFYsTUFDRTtRQUdOa1YsMkJBQTJCRywrQkFDeEIsNEJBQTRCLEdBQzVCRiwrQkFBK0IsTUFDaENuYixRQUFRZ0MsS0FBSyxDQUNYLDZNQUNGO1FBQ0YsU0FBUzRZLFlBQVk5USxTQUFTLElBQzVCLE1BQU84USxDQUFBQSxZQUFZN1EsS0FBSyxHQUFHLElBQUcsS0FDOUJ1Uix5Q0FBeUNWO1FBQzNDLElBQUssSUFBSWhSLE9BQU9nUixhQUFhaFEsU0FBU2hCLEtBQUtyRixNQUFNLEVBQUUsU0FBU3FHLFFBQzFELFNBQVNoQixLQUFLRSxTQUFTLElBQ3JCLE1BQU9GLENBQUFBLEtBQUtHLEtBQUssR0FBRyxJQUFHLEtBQ3ZCdVIseUNBQXlDVixjQUN4Q2hSLE9BQU9nQixRQUNQQSxTQUFTaEIsS0FBS3JGLE1BQU07UUFDekIsT0FBTyxNQUFNcUYsS0FBS2xKLEdBQUcsR0FBR2tKLEtBQUtjLFNBQVMsR0FBRztJQUMzQztJQUNBLFNBQVM2UTtRQUNQLElBQUlDLHFCQUFxQkM7UUFDekJBLHlCQUF5QjtRQUN6QixPQUFPRDtJQUNUO0lBQ0EsU0FBU0UseUJBQXlCRixrQkFBa0I7UUFDbEQsSUFBSUcsY0FBY0Y7UUFDbEJBLHlCQUF5QkQ7UUFDekIsT0FBT0c7SUFDVDtJQUNBLFNBQVNDLDRCQUE0Qkosa0JBQWtCO1FBQ3JELElBQUlHLGNBQWNGO1FBQ2xCQSwwQkFBMEJEO1FBQzFCLE9BQU9HO0lBQ1Q7SUFDQSxTQUFTRSxtQkFBbUIvYyxLQUFLO1FBQy9CZ2Qsb0JBQW9CQztRQUNwQixJQUFJamQsTUFBTWtkLGVBQWUsSUFBS2xkLENBQUFBLE1BQU1rZCxlQUFlLEdBQUdGLGlCQUFnQjtJQUN4RTtJQUNBLFNBQVNHLDRDQUE0Q25kLEtBQUs7UUFDeEQsSUFBSSxLQUFLZ2QsbUJBQW1CO1lBQzFCLElBQUlILGNBQWNJLFFBQVFEO1lBQzFCaGQsTUFBTW9kLGNBQWMsSUFBSVA7WUFDeEI3YyxNQUFNcWQsZ0JBQWdCLEdBQUdSO1lBQ3pCRyxvQkFBb0IsQ0FBQztRQUN2QjtJQUNGO0lBQ0EsU0FBU00sc0RBQXNEdGQsS0FBSztRQUNsRSxJQUFJLEtBQUtnZCxtQkFBbUI7WUFDMUIsSUFBSUgsY0FBY0ksUUFBUUQ7WUFDMUJoZCxNQUFNb2QsY0FBYyxJQUFJUDtZQUN4Qkcsb0JBQW9CLENBQUM7UUFDdkI7SUFDRjtJQUNBLFNBQVNPO1FBQ1AsSUFBSSxLQUFLUCxtQkFBbUI7WUFDMUIsSUFBSUgsY0FBY0ksUUFBUUQ7WUFDMUJBLG9CQUFvQixDQUFDO1lBQ3JCTCwwQkFBMEJFO1FBQzVCO0lBQ0Y7SUFDQSxTQUFTVztRQUNQUixvQkFBb0JDO0lBQ3RCO0lBQ0EsU0FBU1EsdUJBQXVCemQsS0FBSztRQUNuQyxJQUFLLElBQUl3TCxRQUFReEwsTUFBTXdMLEtBQUssRUFBRUEsT0FDNUIsTUFBTzRSLGNBQWMsSUFBSTVSLE1BQU00UixjQUFjLEVBQUk1UixRQUFRQSxNQUFNQyxPQUFPO0lBQzFFO0lBQ0EsU0FBU2lTLHNCQUFzQnpiLElBQUk7UUFDakNBLFNBQVMwYixxQkFDUCxTQUFTMWIsS0FBSzlCLElBQUksSUFDakIsVUFBU3dkLG9CQUNMQyxxQkFBcUJELG9CQUFvQjFiLE9BQ3pDMGIsb0JBQW9CQSxrQkFBa0J4ZCxJQUFJLEdBQUc4QixJQUFJO1FBQ3hENGIsMkJBQTJCLENBQUM7UUFDNUIsU0FBUzVWLHFCQUFxQjZWLFFBQVEsR0FDbENDLDRCQUNDLDRCQUE0QixDQUFDLEdBQzlCQyxzQkFBc0JDLCtCQUE4QixJQUNwREMsd0JBQ0Msd0JBQXdCLENBQUMsR0FDMUJGLHNCQUFzQkMsK0JBQThCO0lBQzFEO0lBQ0EsU0FBU0UsOEJBQThCQyxtQkFBbUIsRUFBRUMsVUFBVTtRQUNwRSxJQUFJLENBQUNDLGtCQUFrQlQsMEJBQTBCO1lBQy9DUyxpQkFBaUIsQ0FBQztZQUNsQixHQUFHO2dCQUNELElBQUlDLHFCQUFxQixDQUFDO2dCQUMxQixJQUFLLElBQUl0YyxPQUFPMmIsb0JBQW9CLFNBQVMzYixNQUFRO29CQUNuRCxJQUFJLENBQUNvYyxZQUNILElBQUksTUFBTUQscUJBQXFCO3dCQUM3QixJQUFJbFIsZUFBZWpMLEtBQUtpTCxZQUFZO3dCQUNwQyxJQUFJLE1BQU1BLGNBQWMsSUFBSUMsWUFBWTs2QkFDbkM7NEJBQ0gsSUFBSUMsaUJBQWlCbkwsS0FBS21MLGNBQWMsRUFDdENDLGNBQWNwTCxLQUFLb0wsV0FBVzs0QkFDaENGLFlBQ0UsQ0FBQyxLQUFNLEtBQUtnQyxNQUFNLEtBQUtpUCx1QkFBdUIsQ0FBQyxJQUFLOzRCQUN0RGpSLGFBQWFELGVBQWUsQ0FBRUUsQ0FBQUEsaUJBQWlCLENBQUNDLFdBQVU7NEJBQzFERixZQUNFQSxZQUFZLFlBQ1IsWUFBYSxZQUFhLElBQzFCQSxZQUNFQSxZQUFZLElBQ1o7d0JBQ1Y7d0JBQ0EsTUFBTUEsYUFDSCxzQkFBc0IsQ0FBQyxHQUN4QnFSLHNCQUFzQnZjLE1BQU1rTCxVQUFTO29CQUN6QyxPQUNFLFlBQWFzUiwrQkFDVnRSLFlBQVlILGFBQ1gvSyxNQUNBQSxTQUFTeWMscUJBQXFCdlIsWUFBWSxJQUU1QyxNQUFPQSxDQUFBQSxZQUFZLE1BQ2pCTSwwQkFBMEJ4TCxNQUFNa0wsY0FDL0Isc0JBQXNCLENBQUMsR0FDeEJxUixzQkFBc0J2YyxNQUFNa0wsVUFBUztvQkFDN0NsTCxPQUFPQSxLQUFLOUIsSUFBSTtnQkFDbEI7WUFDRixRQUFTb2Usb0JBQW9CO1lBQzdCRCxpQkFBaUIsQ0FBQztRQUNwQjtJQUNGO0lBQ0EsU0FBU0w7UUFDUEosMkJBQ0VFLDJCQUNBRyx1QkFDRSxDQUFDO1FBQ0wsSUFBSUUsc0JBQXNCO1FBQzFCLE1BQU1PLDhCQUNIQyxDQUFBQSxrQ0FDRVIsQ0FBQUEsc0JBQXNCTywwQkFBeUIsR0FDakRBLDZCQUE2QixDQUFDO1FBQ2pDLElBQ0UsSUFBSS9RLGNBQWNpUixTQUFTQyxPQUFPLE1BQU03YyxPQUFPMmIsb0JBQy9DLFNBQVMzYixNQUVUO1lBQ0EsSUFBSTlCLE9BQU84QixLQUFLOUIsSUFBSSxFQUNsQmdOLFlBQVk0UixtQ0FBbUM5YyxNQUFNMkw7WUFDdkQsSUFBSSxNQUFNVCxXQUNSLEtBQU1oTixJQUFJLEdBQUcsTUFDWCxTQUFTMmUsT0FBUWxCLHFCQUFxQnpkLE9BQVMyZSxLQUFLM2UsSUFBSSxHQUFHQSxNQUMzRCxTQUFTQSxRQUFTd2QsQ0FBQUEsb0JBQW9CbUIsSUFBRztpQkFDeEMsSUFDRixPQUFRN2MsTUFBTyxNQUFNbWMsdUJBQXVCLE1BQU9qUixDQUFBQSxZQUFZLElBRWhFMFEsMkJBQTJCLENBQUM7WUFDOUI1YixPQUFPOUI7UUFDVDtRQUNBZ2UsOEJBQThCQyxxQkFBcUIsQ0FBQztJQUN0RDtJQUNBLFNBQVNXLG1DQUFtQzljLElBQUksRUFBRTJMLFdBQVc7UUFDM0QsSUFDRSxJQUFJUixpQkFBaUJuTCxLQUFLbUwsY0FBYyxFQUN0Q0MsY0FBY3BMLEtBQUtvTCxXQUFXLEVBQzlCNEIsa0JBQWtCaE4sS0FBS2dOLGVBQWUsRUFDdENuQyxRQUFRN0ssS0FBS2lMLFlBQVksR0FBRyxDQUFDLFVBQy9CLElBQUlKLE9BRUo7WUFDQSxJQUFJdk0sUUFBUSxLQUFLNE8sTUFBTXJDLFFBQ3JCRixPQUFPLEtBQUtyTSxPQUNaeWUsaUJBQWlCL1AsZUFBZSxDQUFDMU8sTUFBTTtZQUN6QyxJQUFJLENBQUMsTUFBTXllLGdCQUFnQjtnQkFDekIsSUFBSSxNQUFPcFMsQ0FBQUEsT0FBT1EsY0FBYSxLQUFNLE1BQU9SLENBQUFBLE9BQU9TLFdBQVUsR0FDM0Q0QixlQUFlLENBQUMxTyxNQUFNLEdBQUdvTixzQkFBc0JmLE1BQU1nQjtZQUN6RCxPQUFPb1Isa0JBQWtCcFIsZUFBZ0IzTCxDQUFBQSxLQUFLMk0sWUFBWSxJQUFJaEMsSUFBRztZQUNqRUUsU0FBUyxDQUFDRjtRQUNaO1FBQ0FnQixjQUFjOFE7UUFDZHRSLGlCQUFpQnFSO1FBQ2pCclIsaUJBQWlCSixhQUNmL0ssTUFDQUEsU0FBUzJMLGNBQWNSLGlCQUFpQjtRQUUxQ0MsY0FBY3BMLEtBQUtnZCxZQUFZO1FBQy9CLElBQ0UsTUFBTTdSLGtCQUNMbkwsU0FBUzJMLGVBQ1JzUixrQ0FBa0NDLG1CQUNwQyxTQUFTbGQsS0FBS21kLG1CQUFtQixFQUVqQyxPQUNFLFNBQVMvUixlQUFlZ1MsZUFBZWhTLGNBQ3RDcEwsS0FBS2dkLFlBQVksR0FBRyxNQUNwQmhkLEtBQUtxZCxnQkFBZ0IsR0FBRztRQUU3QixJQUNFLE1BQU9sUyxDQUFBQSxpQkFBaUIsTUFDeEJLLDBCQUEwQnhMLE1BQU1tTCxpQkFDaEM7WUFDQVEsY0FBY1IsaUJBQWlCLENBQUNBO1lBQ2hDLElBQ0VRLGdCQUFnQjNMLEtBQUtxZCxnQkFBZ0IsSUFDcEMsU0FBU3JYLHFCQUFxQjZWLFFBQVEsSUFDckN6USxnQkFBZ0JrUyx1QkFFbEJGLGVBQWVoUztpQkFDWixPQUFPTztZQUNaLE9BQVFzQyxxQkFBcUI5QztnQkFDM0IsS0FBSztnQkFDTCxLQUFLO29CQUNIQSxpQkFBaUJnRTtvQkFDakI7Z0JBQ0YsS0FBSztvQkFDSGhFLGlCQUFpQmlFO29CQUNqQjtnQkFDRixLQUFLO29CQUNIakUsaUJBQWlCa0U7b0JBQ2pCO2dCQUNGO29CQUNFbEUsaUJBQWlCaUU7WUFDckI7WUFDQWhFLGNBQWNtUyxrQ0FBa0NDLElBQUksQ0FBQyxNQUFNeGQ7WUFDM0QsU0FBU2dHLHFCQUFxQjZWLFFBQVEsR0FDakM3VixDQUFBQSxxQkFBcUI2VixRQUFRLENBQUNwYSxJQUFJLENBQUMySixjQUNuQ0QsaUJBQWlCbVMscUJBQXFCLElBQ3RDblMsaUJBQWlCc1MsbUJBQW1CdFMsZ0JBQWdCQztZQUN6RHBMLEtBQUtxZCxnQkFBZ0IsR0FBRzFSO1lBQ3hCM0wsS0FBS2dkLFlBQVksR0FBRzdSO1lBQ3BCLE9BQU9RO1FBQ1Q7UUFDQSxTQUFTUCxlQUFlZ1MsZUFBZWhTO1FBQ3ZDcEwsS0FBS3FkLGdCQUFnQixHQUFHO1FBQ3hCcmQsS0FBS2dkLFlBQVksR0FBRztRQUNwQixPQUFPO0lBQ1Q7SUFDQSxTQUFTTyxrQ0FBa0N2ZCxJQUFJLEVBQUUwZCxVQUFVO1FBQ3pEQyx3QkFBd0JDLHdCQUF3QixDQUFDO1FBQ2pELElBQUlDLHVCQUF1QjdkLEtBQUtnZCxZQUFZO1FBQzVDLElBQUlyYyx5QkFBeUJYLEtBQUtnZCxZQUFZLEtBQUthLHNCQUNqRCxPQUFPO1FBQ1QsSUFBSUMseUNBQ0Z0QjtRQUNGc0IseUNBQXlDL1MsYUFDdkMvSyxNQUNBQSxTQUFTeWMscUJBQXFCcUIseUNBQXlDO1FBRXpFLElBQUksTUFBTUEsd0NBQXdDLE9BQU87UUFDekRDLGtCQUNFL2QsTUFDQThkLHdDQUNBSjtRQUVGWixtQ0FBbUM5YyxNQUFNNGM7UUFDekMsT0FBTyxRQUFRNWMsS0FBS2dkLFlBQVksSUFDOUJoZCxLQUFLZ2QsWUFBWSxLQUFLYSx1QkFDcEJOLGtDQUFrQ0MsSUFBSSxDQUFDLE1BQU14ZCxRQUM3QztJQUNOO0lBQ0EsU0FBU3VjLHNCQUFzQnZjLElBQUksRUFBRTZLLEtBQUs7UUFDeEMsSUFBSWxLLHVCQUF1QixPQUFPO1FBQ2xDaWQsd0JBQXdCRDtRQUN4QkEsd0JBQXdCLENBQUM7UUFDekJJLGtCQUFrQi9kLE1BQU02SyxPQUFPLENBQUM7SUFDbEM7SUFDQSxTQUFTdVMsZUFBZUosWUFBWTtRQUNsQ0EsaUJBQWlCTSx5QkFDZixTQUFTTixnQkFDVGdCLGlCQUFpQmhCO0lBQ3JCO0lBQ0EsU0FBU2pCLHNCQUFzQmtDLEVBQUU7UUFDL0IsU0FBU2pZLHFCQUFxQjZWLFFBQVEsSUFDcEM3VixxQkFBcUI2VixRQUFRLENBQUNwYSxJQUFJLENBQUM7WUFDakN3YztZQUNBLE9BQU87UUFDVDtRQUNGQyxxQkFDSUMsa0JBQWtCO1lBQ2ZDLENBQUFBLG1CQUFvQkMsQ0FBQUEsZ0JBQWdCQyxhQUFZLENBQUMsTUFBT0MsWUFDckRkLG1CQUFtQnZPLG1CQUFtQitPLE1BQ3RDQTtRQUNOLEtBQ0FSLG1CQUFtQnZPLG1CQUFtQitPO0lBQzVDO0lBQ0EsU0FBU087UUFDUCxNQUFNOUIsOEJBQ0hBLENBQUFBLDZCQUE2QjlRLHlCQUF3QjtRQUN4RCxPQUFPOFE7SUFDVDtJQUNBLFNBQVMrQixvQkFBb0JDLFVBQVUsRUFBRUMsUUFBUTtRQUMvQyxJQUFJLFNBQVNDLDJCQUEyQjtZQUN0QyxJQUFJQyxxQkFBc0JELDRCQUE0QixFQUFFO1lBQ3hERSwrQkFBK0I7WUFDL0JDLHVCQUF1QlA7WUFDdkJRLGlDQUFpQztnQkFDL0JDLFFBQVE7Z0JBQ1IxZ0IsT0FBTyxLQUFLO2dCQUNaMmdCLE1BQU0sU0FBVUMsT0FBTztvQkFDckJOLG1CQUFtQnBkLElBQUksQ0FBQzBkO2dCQUMxQjtZQUNGO1FBQ0Y7UUFDQUw7UUFDQUgsU0FBU08sSUFBSSxDQUFDRSwyQkFBMkJBO1FBQ3pDLE9BQU9UO0lBQ1Q7SUFDQSxTQUFTUztRQUNQLElBQ0UsTUFBTSxFQUFFTixnQ0FDUixTQUFTRiwyQkFDVDtZQUNBLFNBQVNJLGtDQUNOQSxDQUFBQSwrQkFBK0JDLE1BQU0sR0FBRyxXQUFVO1lBQ3JELElBQUlJLFlBQVlUO1lBQ2hCQSw0QkFBNEI7WUFDNUJHLHVCQUF1QjtZQUN2QkMsaUNBQWlDO1lBQ2pDLElBQUssSUFBSTdmLElBQUksR0FBR0EsSUFBSWtnQixVQUFVN2dCLE1BQU0sRUFBRVcsSUFBSyxDQUFDLEdBQUdrZ0IsU0FBUyxDQUFDbGdCLEVBQUU7UUFDN0Q7SUFDRjtJQUNBLFNBQVNtZ0IsbUJBQW1CWCxRQUFRLEVBQUVZLE1BQU07UUFDMUMsSUFBSUYsWUFBWSxFQUFFLEVBQ2hCRyx1QkFBdUI7WUFDckJQLFFBQVE7WUFDUjFnQixPQUFPO1lBQ1BraEIsUUFBUTtZQUNSUCxNQUFNLFNBQVVDLE9BQU87Z0JBQ3JCRSxVQUFVNWQsSUFBSSxDQUFDMGQ7WUFDakI7UUFDRjtRQUNGUixTQUFTTyxJQUFJLENBQ1g7WUFDRU0scUJBQXFCUCxNQUFNLEdBQUc7WUFDOUJPLHFCQUFxQmpoQixLQUFLLEdBQUdnaEI7WUFDN0IsSUFBSyxJQUFJcGdCLElBQUksR0FBR0EsSUFBSWtnQixVQUFVN2dCLE1BQU0sRUFBRVcsSUFBSyxDQUFDLEdBQUdrZ0IsU0FBUyxDQUFDbGdCLEVBQUUsRUFBRW9nQjtRQUMvRCxHQUNBLFNBQVV0ZSxLQUFLO1lBQ2J1ZSxxQkFBcUJQLE1BQU0sR0FBRztZQUM5Qk8scUJBQXFCQyxNQUFNLEdBQUd4ZTtZQUM5QixJQUFLQSxRQUFRLEdBQUdBLFFBQVFvZSxVQUFVN2dCLE1BQU0sRUFBRXlDLFFBQ3hDLENBQUMsR0FBR29lLFNBQVMsQ0FBQ3BlLE1BQU0sRUFBRSxLQUFLO1FBQy9CO1FBRUYsT0FBT3VlO0lBQ1Q7SUFDQSxTQUFTRSxzQkFBc0IzaEIsS0FBSztRQUNsQ0EsTUFBTTRoQixXQUFXLEdBQUc7WUFDbEJDLFdBQVc3aEIsTUFBTUUsYUFBYTtZQUM5QjRoQixpQkFBaUI7WUFDakJDLGdCQUFnQjtZQUNoQkMsUUFBUTtnQkFBRXhHLFNBQVM7Z0JBQU0xTyxPQUFPO2dCQUFHbVYsaUJBQWlCO1lBQUs7WUFDekRDLFdBQVc7UUFDYjtJQUNGO0lBQ0EsU0FBU0MsaUJBQWlCcmYsT0FBTyxFQUFFOEcsY0FBYztRQUMvQzlHLFVBQVVBLFFBQVE4ZSxXQUFXO1FBQzdCaFksZUFBZWdZLFdBQVcsS0FBSzllLFdBQzVCOEcsQ0FBQUEsZUFBZWdZLFdBQVcsR0FBRztZQUM1QkMsV0FBVy9lLFFBQVErZSxTQUFTO1lBQzVCQyxpQkFBaUJoZixRQUFRZ2YsZUFBZTtZQUN4Q0MsZ0JBQWdCamYsUUFBUWlmLGNBQWM7WUFDdENDLFFBQVFsZixRQUFRa2YsTUFBTTtZQUN0QkUsV0FBVztRQUNiO0lBQ0o7SUFDQSxTQUFTRSxhQUFheFYsSUFBSTtRQUN4QixPQUFPO1lBQ0xBLE1BQU1BO1lBQ05oTCxLQUFLeWdCO1lBQ0xDLFNBQVM7WUFDVGxZLFVBQVU7WUFDVmpLLE1BQU07UUFDUjtJQUNGO0lBQ0EsU0FBU29pQixjQUFjdmlCLEtBQUssRUFBRXdDLE1BQU0sRUFBRW9LLElBQUk7UUFDeEMsSUFBSWdWLGNBQWM1aEIsTUFBTTRoQixXQUFXO1FBQ25DLElBQUksU0FBU0EsYUFBYSxPQUFPO1FBQ2pDQSxjQUFjQSxZQUFZSSxNQUFNO1FBQ2hDLElBQ0VRLDZCQUE2QlosZUFDN0IsQ0FBQ2EsMkJBQ0Q7WUFDQSxJQUFJQyxnQkFBZ0JuZCwwQkFBMEJ2RjtZQUM5Q2tCLFFBQVFnQyxLQUFLLENBQ1gsMlBBQ0F3ZjtZQUVGRCw0QkFBNEIsQ0FBQztRQUMvQjtRQUNBLElBQUksQ0FBQ3BDLG1CQUFtQkMsYUFBWSxNQUFPRSxXQUN6QyxPQUNFLGdCQUFpQm9CLFlBQVlwRyxPQUFPLEVBQ3BDLFNBQVNrSCxnQkFDSmxnQixPQUFPckMsSUFBSSxHQUFHcUMsU0FDZCxRQUFRckMsSUFBSSxHQUFHdWlCLGNBQWN2aUIsSUFBSSxFQUNqQ3VpQixjQUFjdmlCLElBQUksR0FBR3FDLE1BQU0sR0FDL0JvZixZQUFZcEcsT0FBTyxHQUFHaFosUUFDdEJBLFNBQVNvWix1QkFBdUI1YixRQUNqQ3liLDhCQUE4QnpiLE9BQU8sTUFBTTRNLE9BQzNDcEs7UUFFSmtaLGdCQUFnQjFiLE9BQU80aEIsYUFBYXBmLFFBQVFvSztRQUM1QyxPQUFPZ1AsdUJBQXVCNWI7SUFDaEM7SUFDQSxTQUFTMmlCLG9CQUFvQjFnQixJQUFJLEVBQUVqQyxLQUFLLEVBQUU0TSxJQUFJO1FBQzVDNU0sUUFBUUEsTUFBTTRoQixXQUFXO1FBQ3pCLElBQUksU0FBUzVoQixTQUFVLFNBQVNBLE1BQU1naUIsTUFBTSxFQUFHLE1BQU9wVixDQUFBQSxPQUFPLE9BQU0sQ0FBQyxHQUFJO1lBQ3RFLElBQUlnVyxhQUFhNWlCLE1BQU04TSxLQUFLO1lBQzVCOFYsY0FBYzNnQixLQUFLaUwsWUFBWTtZQUMvQk4sUUFBUWdXO1lBQ1I1aUIsTUFBTThNLEtBQUssR0FBR0Y7WUFDZDJDLGtCQUFrQnROLE1BQU0ySztRQUMxQjtJQUNGO0lBQ0EsU0FBU2lXLHNCQUFzQmpaLGNBQWMsRUFBRWtaLGNBQWM7UUFDM0QsSUFBSXZILFFBQVEzUixlQUFlZ1ksV0FBVyxFQUNwQzllLFVBQVU4RyxlQUFlb0IsU0FBUztRQUNwQyxJQUNFLFNBQVNsSSxXQUNSLFdBQVdBLFFBQVE4ZSxXQUFXLEVBQUdyRyxVQUFVelksT0FBTSxHQUNsRDtZQUNBLElBQUlpZ0IsV0FBVyxNQUNiQyxVQUFVO1lBQ1p6SCxRQUFRQSxNQUFNdUcsZUFBZTtZQUM3QixJQUFJLFNBQVN2RyxPQUFPO2dCQUNsQixHQUFHO29CQUNELElBQUkwSCxRQUFRO3dCQUNWclcsTUFBTTJPLE1BQU0zTyxJQUFJO3dCQUNoQmhMLEtBQUsyWixNQUFNM1osR0FBRzt3QkFDZDBnQixTQUFTL0csTUFBTStHLE9BQU87d0JBQ3RCbFksVUFBVTt3QkFDVmpLLE1BQU07b0JBQ1I7b0JBQ0EsU0FBUzZpQixVQUNKRCxXQUFXQyxVQUFVQyxRQUNyQkQsVUFBVUEsUUFBUTdpQixJQUFJLEdBQUc4aUI7b0JBQzlCMUgsUUFBUUEsTUFBTXBiLElBQUk7Z0JBQ3BCLFFBQVMsU0FBU29iLE9BQU87Z0JBQ3pCLFNBQVN5SCxVQUNKRCxXQUFXQyxVQUFVRixpQkFDckJFLFVBQVVBLFFBQVE3aUIsSUFBSSxHQUFHMmlCO1lBQ2hDLE9BQU9DLFdBQVdDLFVBQVVGO1lBQzVCdkgsUUFBUTtnQkFDTnNHLFdBQVcvZSxRQUFRK2UsU0FBUztnQkFDNUJDLGlCQUFpQmlCO2dCQUNqQmhCLGdCQUFnQmlCO2dCQUNoQmhCLFFBQVFsZixRQUFRa2YsTUFBTTtnQkFDdEJFLFdBQVdwZixRQUFRb2YsU0FBUztZQUM5QjtZQUNBdFksZUFBZWdZLFdBQVcsR0FBR3JHO1lBQzdCO1FBQ0Y7UUFDQTNSLGlCQUFpQjJSLE1BQU13RyxjQUFjO1FBQ3JDLFNBQVNuWSxpQkFDSjJSLE1BQU11RyxlQUFlLEdBQUdnQixpQkFDeEJsWixlQUFlekosSUFBSSxHQUFHMmlCO1FBQzNCdkgsTUFBTXdHLGNBQWMsR0FBR2U7SUFDekI7SUFDQSxTQUFTSTtRQUNQLElBQUlDLGlDQUFpQztZQUNuQyxJQUFJQywwQkFBMEJuQztZQUM5QixJQUFJLFNBQVNtQyx5QkFBeUIsTUFBTUE7UUFDOUM7SUFDRjtJQUNBLFNBQVNDLG1CQUNQelosY0FBYyxFQUNkbkQsS0FBSyxFQUNMNmMsaUJBQWlCLEVBQ2pCNVYsV0FBVztRQUVYeVYsa0NBQWtDLENBQUM7UUFDbkMsSUFBSTVILFFBQVEzUixlQUFlZ1ksV0FBVztRQUN0QzJCLGlCQUFpQixDQUFDO1FBQ2xCZiwyQkFBMkJqSCxNQUFNeUcsTUFBTTtRQUN2QyxJQUFJRixrQkFBa0J2RyxNQUFNdUcsZUFBZSxFQUN6Q0MsaUJBQWlCeEcsTUFBTXdHLGNBQWMsRUFDckN5QixlQUFlakksTUFBTXlHLE1BQU0sQ0FBQ3hHLE9BQU87UUFDckMsSUFBSSxTQUFTZ0ksY0FBYztZQUN6QmpJLE1BQU15RyxNQUFNLENBQUN4RyxPQUFPLEdBQUc7WUFDdkIsSUFBSWlJLG9CQUFvQkQsY0FDdEJFLHFCQUFxQkQsa0JBQWtCdGpCLElBQUk7WUFDN0NzakIsa0JBQWtCdGpCLElBQUksR0FBRztZQUN6QixTQUFTNGhCLGlCQUNKRCxrQkFBa0I0QixxQkFDbEIzQixlQUFlNWhCLElBQUksR0FBR3VqQjtZQUMzQjNCLGlCQUFpQjBCO1lBQ2pCLElBQUkzZ0IsVUFBVThHLGVBQWVvQixTQUFTO1lBQ3RDLFNBQVNsSSxXQUNOLFdBQVdBLFFBQVE4ZSxXQUFXLEVBQzlCNEIsZUFBZTFnQixRQUFRaWYsY0FBYyxFQUN0Q3lCLGlCQUFpQnpCLGtCQUNkLFVBQVN5QixlQUNMMWdCLFFBQVFnZixlQUFlLEdBQUc0QixxQkFDMUJGLGFBQWFyakIsSUFBSSxHQUFHdWpCLG9CQUN4QjVnQixRQUFRaWYsY0FBYyxHQUFHMEIsaUJBQWlCLENBQUM7UUFDbEQ7UUFDQSxJQUFJLFNBQVMzQixpQkFBaUI7WUFDNUIsSUFBSTZCLFdBQVdwSSxNQUFNc0csU0FBUztZQUM5QkUsaUJBQWlCO1lBQ2pCamYsVUFBVTRnQixxQkFBcUJELG9CQUFvQjtZQUNuREQsZUFBZTFCO1lBQ2YsR0FBRztnQkFDRCxJQUFJelQsYUFBYW1WLGFBQWE1VyxJQUFJLEdBQUcsQ0FBQyxXQUNwQ2dYLGlCQUFpQnZWLGVBQWVtVixhQUFhNVcsSUFBSTtnQkFDbkQsSUFDRWdYLGlCQUNJLENBQUNuRixnQ0FBZ0NwUSxVQUFTLE1BQU9BLGFBQ2pELENBQUNYLGNBQWNXLFVBQVMsTUFBT0EsWUFDbkM7b0JBQ0EsTUFBTUEsY0FDSkEsZUFBZTJTLHdCQUNkbUMsQ0FBQUEsa0NBQWtDLENBQUM7b0JBQ3RDLFNBQVNyZ0IsV0FDTkEsQ0FBQUEsVUFBVUEsUUFBUTNDLElBQUksR0FDckI7d0JBQ0V5TSxNQUFNO3dCQUNOaEwsS0FBSzRoQixhQUFhNWhCLEdBQUc7d0JBQ3JCMGdCLFNBQVNrQixhQUFhbEIsT0FBTzt3QkFDN0JsWSxVQUFVO3dCQUNWakssTUFBTTtvQkFDUjtvQkFDSmlMLEdBQUc7d0JBQ0RpRCxhQUFhekU7d0JBQ2IsSUFBSWlhLGVBQWVMO3dCQUNuQixJQUFJTSxZQUFZcmQsT0FDZHNkLFdBQVdUO3dCQUNiLE9BQVFPLGFBQWFqaUIsR0FBRzs0QkFDdEIsS0FBS29pQjtnQ0FDSEgsZUFBZUEsYUFBYXZCLE9BQU87Z0NBQ25DLElBQUksZUFBZSxPQUFPdUIsY0FBYztvQ0FDdENJLCtCQUErQixDQUFDO29DQUNoQyxJQUFJQyxZQUFZTCxhQUFhbmIsSUFBSSxDQUMvQnFiLFVBQ0FKLFVBQ0FHO29DQUVGLElBQUl6VixXQUFXdk0sSUFBSSxHQUFHLEdBQUc7d0NBQ3ZCMFAsMkJBQTJCLENBQUM7d0NBQzVCLElBQUk7NENBQ0ZxUyxhQUFhbmIsSUFBSSxDQUFDcWIsVUFBVUosVUFBVUc7d0NBQ3hDLFNBQVU7NENBQ1J0UywyQkFBMkIsQ0FBQzt3Q0FDOUI7b0NBQ0Y7b0NBQ0F5UywrQkFBK0IsQ0FBQztvQ0FDaENOLFdBQVdPO29DQUNYLE1BQU05WTtnQ0FDUjtnQ0FDQXVZLFdBQVdFO2dDQUNYLE1BQU16WTs0QkFDUixLQUFLK1k7Z0NBQ0g5VixXQUFXcEQsS0FBSyxHQUFHLFdBQVlBLEtBQUssR0FBRyxDQUFDLFFBQVM7NEJBQ25ELEtBQUtvWDtnQ0FDSDZCLFlBQVlMLGFBQWF2QixPQUFPO2dDQUNoQyxJQUFJLGVBQWUsT0FBTzRCLFdBQVc7b0NBQ25DRCwrQkFBK0IsQ0FBQztvQ0FDaENKLGVBQWVLLFVBQVV4YixJQUFJLENBQzNCcWIsVUFDQUosVUFDQUc7b0NBRUYsSUFBSXpWLFdBQVd2TSxJQUFJLEdBQUcsR0FBRzt3Q0FDdkIwUCwyQkFBMkIsQ0FBQzt3Q0FDNUIsSUFBSTs0Q0FDRjBTLFVBQVV4YixJQUFJLENBQUNxYixVQUFVSixVQUFVRzt3Q0FDckMsU0FBVTs0Q0FDUnRTLDJCQUEyQixDQUFDO3dDQUM5QjtvQ0FDRjtvQ0FDQXlTLCtCQUErQixDQUFDO2dDQUNsQyxPQUFPSixlQUFlSztnQ0FDdEIsSUFBSSxTQUFTTCxnQkFBZ0IsS0FBSyxNQUFNQSxjQUFjLE1BQU16WTtnQ0FDNUR1WSxXQUFXN2lCLE9BQU8sQ0FBQyxHQUFHNmlCLFVBQVVFO2dDQUNoQyxNQUFNelk7NEJBQ1IsS0FBS2daO2dDQUNIYixpQkFBaUIsQ0FBQzt3QkFDdEI7b0JBQ0Y7b0JBQ0FsVixhQUFhbVYsYUFBYXBaLFFBQVE7b0JBQ2xDLFNBQVNpRSxjQUNOLGdCQUFnQnBELEtBQUssSUFBSSxJQUMxQjJZLGtCQUFtQmhhLENBQUFBLGVBQWVxQixLQUFLLElBQUksSUFBRyxHQUM3QzJZLGlCQUFpQnJJLE1BQU0yRyxTQUFTLEVBQ2pDLFNBQVMwQixpQkFDSnJJLE1BQU0yRyxTQUFTLEdBQUc7d0JBQUM3VDtxQkFBVyxHQUMvQnVWLGVBQWVsZ0IsSUFBSSxDQUFDMkssV0FBVTtnQkFDdEMsT0FDRSxpQkFBa0I7b0JBQ2hCekIsTUFBTXlCO29CQUNOek0sS0FBSzRoQixhQUFhNWhCLEdBQUc7b0JBQ3JCMGdCLFNBQVNrQixhQUFhbEIsT0FBTztvQkFDN0JsWSxVQUFVb1osYUFBYXBaLFFBQVE7b0JBQy9CakssTUFBTTtnQkFDUixHQUNFLFNBQVMyQyxVQUNKLHNCQUFzQkEsVUFBVThnQixnQkFDaENILG9CQUFvQkUsUUFBUSxJQUM1QjdnQixVQUFVQSxRQUFRM0MsSUFBSSxHQUFHeWpCLGdCQUM3QjdCLGtCQUFrQjFUO2dCQUN2Qm1WLGVBQWVBLGFBQWFyakIsSUFBSTtnQkFDaEMsSUFBSSxTQUFTcWpCLGNBQ1gsSUFBSyxlQUFnQmpJLE1BQU15RyxNQUFNLENBQUN4RyxPQUFPLEVBQUcsU0FBU2dJLGNBQ25EO3FCQUVBLGlCQUFrQkEsY0FDZkEsZUFBZUksZUFBZXpqQixJQUFJLEVBQ2xDeWpCLGVBQWV6akIsSUFBSSxHQUFHLE1BQ3RCb2IsTUFBTXdHLGNBQWMsR0FBRzZCLGdCQUN2QnJJLE1BQU15RyxNQUFNLENBQUN4RyxPQUFPLEdBQUc7WUFDaEMsUUFBUyxHQUFHO1lBQ1osU0FBUzFZLFdBQVkyZ0IsQ0FBQUEsb0JBQW9CRSxRQUFPO1lBQ2hEcEksTUFBTXNHLFNBQVMsR0FBRzRCO1lBQ2xCbEksTUFBTXVHLGVBQWUsR0FBRzRCO1lBQ3hCbkksTUFBTXdHLGNBQWMsR0FBR2pmO1lBQ3ZCLFNBQVNnZixtQkFBb0J2RyxDQUFBQSxNQUFNeUcsTUFBTSxDQUFDbFYsS0FBSyxHQUFHO1lBQ2xEdVgsa0NBQWtDdEM7WUFDbENuWSxlQUFla0QsS0FBSyxHQUFHaVY7WUFDdkJuWSxlQUFlMUosYUFBYSxHQUFHeWpCO1FBQ2pDO1FBQ0FuQiwyQkFBMkI7SUFDN0I7SUFDQSxTQUFTOEIsYUFBYWxhLFFBQVEsRUFBRWpJLE9BQU87UUFDckMsSUFBSSxlQUFlLE9BQU9pSSxVQUN4QixNQUFNbEQsTUFDSixpRkFDRWtEO1FBRU5BLFNBQVMxQixJQUFJLENBQUN2RztJQUNoQjtJQUNBLFNBQVNvaUIsc0JBQXNCM0MsV0FBVyxFQUFFemYsT0FBTztRQUNqRCxJQUFJOGYsa0JBQWtCTCxZQUFZSSxNQUFNLENBQUNDLGVBQWU7UUFDeEQsSUFBSSxTQUFTQSxpQkFDWCxJQUNFTCxZQUFZSSxNQUFNLENBQUNDLGVBQWUsR0FBRyxNQUFNTCxjQUFjLEdBQ3pEQSxjQUFjSyxnQkFBZ0J4aEIsTUFBTSxFQUNwQ21oQixjQUVBMEMsYUFBYXJDLGVBQWUsQ0FBQ0wsWUFBWSxFQUFFemY7SUFDakQ7SUFDQSxTQUFTcWlCLGdCQUFnQjVDLFdBQVcsRUFBRXpmLE9BQU87UUFDM0MsSUFBSStmLFlBQVlOLFlBQVlNLFNBQVM7UUFDckMsSUFBSSxTQUFTQSxXQUNYLElBQ0VOLFlBQVlNLFNBQVMsR0FBRyxNQUFNTixjQUFjLEdBQzVDQSxjQUFjTSxVQUFVemhCLE1BQU0sRUFDOUJtaEIsY0FFQTBDLGFBQWFwQyxTQUFTLENBQUNOLFlBQVksRUFBRXpmO0lBQzNDO0lBQ0EsU0FBU3NpQixhQUFhQyxJQUFJLEVBQUVDLElBQUk7UUFDOUIsSUFBSUMsU0FBU0YsTUFBTUMsT0FBTyxPQUFPLENBQUM7UUFDbEMsSUFDRSxhQUFhLE9BQU9ELFFBQ3BCLFNBQVNBLFFBQ1QsYUFBYSxPQUFPQyxRQUNwQixTQUFTQSxNQUVULE9BQU8sQ0FBQztRQUNWLElBQUlFLFFBQVFoZSxPQUFPNFIsSUFBSSxDQUFDaU0sT0FDdEJJLFFBQVFqZSxPQUFPNFIsSUFBSSxDQUFDa007UUFDdEIsSUFBSUUsTUFBTXBrQixNQUFNLEtBQUtxa0IsTUFBTXJrQixNQUFNLEVBQUUsT0FBTyxDQUFDO1FBQzNDLElBQUtxa0IsUUFBUSxHQUFHQSxRQUFRRCxNQUFNcGtCLE1BQU0sRUFBRXFrQixRQUFTO1lBQzdDLElBQUlDLGFBQWFGLEtBQUssQ0FBQ0MsTUFBTTtZQUM3QixJQUNFLENBQUM5TixlQUFldE8sSUFBSSxDQUFDaWMsTUFBTUksZUFDM0IsQ0FBQ0gsU0FBU0YsSUFBSSxDQUFDSyxXQUFXLEVBQUVKLElBQUksQ0FBQ0ksV0FBVyxHQUU1QyxPQUFPLENBQUM7UUFDWjtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBQ0EsU0FBU0M7UUFDUCxPQUFPO1lBQUVDLDZCQUE2QixDQUFDO1lBQUdDLFdBQVcsRUFBRTtRQUFDO0lBQzFEO0lBQ0EsU0FBU0MsbUJBQW1CdkUsUUFBUTtRQUNsQ0EsV0FBV0EsU0FBU00sTUFBTTtRQUMxQixPQUFPLGdCQUFnQk4sWUFBWSxlQUFlQTtJQUNwRDtJQUNBLFNBQVN3RSxVQUFVO0lBQ25CLFNBQVNDLGtCQUFrQkMsYUFBYSxFQUFFMUUsUUFBUSxFQUFFcmdCLEtBQUs7UUFDdkQsU0FBUzBILHFCQUFxQjZWLFFBQVEsSUFDbkM3VixDQUFBQSxxQkFBcUJzZCxhQUFhLEdBQUcsQ0FBQztRQUN6QyxJQUFJQyxtQkFBbUJGLGNBQWNKLFNBQVM7UUFDOUMza0IsUUFBUWlsQixnQkFBZ0IsQ0FBQ2psQixNQUFNO1FBQy9CLEtBQUssTUFBTUEsUUFDUGlsQixpQkFBaUI5aEIsSUFBSSxDQUFDa2QsWUFDdEJyZ0IsVUFBVXFnQixZQUNUMEUsQ0FBQUEsY0FBY0wsMkJBQTJCLElBQ3ZDLGVBQWVBLDJCQUEyQixHQUFHLENBQUMsR0FDL0MvakIsUUFBUWdDLEtBQUssQ0FDWCxxTEFDRixHQUNGMGQsU0FBU08sSUFBSSxDQUFDaUUsUUFBUUEsU0FDckJ4RSxXQUFXcmdCLEtBQUs7UUFDckIsT0FBUXFnQixTQUFTTSxNQUFNO1lBQ3JCLEtBQUs7Z0JBQ0gsT0FBT04sU0FBU3BnQixLQUFLO1lBQ3ZCLEtBQUs7Z0JBQ0gsTUFDRyxnQkFBaUJvZ0IsU0FBU2MsTUFBTSxFQUNqQytELDhCQUE4QkgsZ0JBQzlCQTtZQUVKO2dCQUNFLElBQUksYUFBYSxPQUFPMUUsU0FBU00sTUFBTSxFQUNyQ04sU0FBU08sSUFBSSxDQUFDaUUsUUFBUUE7cUJBQ25CO29CQUNIRSxnQkFBZ0I1RztvQkFDaEIsSUFDRSxTQUFTNEcsaUJBQ1QsTUFBTUEsY0FBY3ZXLG1CQUFtQixFQUV2QyxNQUFNN0gsTUFDSjtvQkFFSm9lLGdCQUFnQjFFO29CQUNoQjBFLGNBQWNwRSxNQUFNLEdBQUc7b0JBQ3ZCb0UsY0FBY25FLElBQUksQ0FDaEIsU0FBVXVFLGNBQWM7d0JBQ3RCLElBQUksY0FBYzlFLFNBQVNNLE1BQU0sRUFBRTs0QkFDakMsSUFBSXlFLG9CQUFvQi9FOzRCQUN4QitFLGtCQUFrQnpFLE1BQU0sR0FBRzs0QkFDM0J5RSxrQkFBa0JubEIsS0FBSyxHQUFHa2xCO3dCQUM1QjtvQkFDRixHQUNBLFNBQVV4aUIsS0FBSzt3QkFDYixJQUFJLGNBQWMwZCxTQUFTTSxNQUFNLEVBQUU7NEJBQ2pDLElBQUkwRSxtQkFBbUJoRjs0QkFDdkJnRixpQkFBaUIxRSxNQUFNLEdBQUc7NEJBQzFCMEUsaUJBQWlCbEUsTUFBTSxHQUFHeGU7d0JBQzVCO29CQUNGO2dCQUVKO2dCQUNBLE9BQVEwZCxTQUFTTSxNQUFNO29CQUNyQixLQUFLO3dCQUNILE9BQU9OLFNBQVNwZ0IsS0FBSztvQkFDdkIsS0FBSzt3QkFDSCxNQUNHLGdCQUFpQm9nQixTQUFTYyxNQUFNLEVBQ2pDK0QsOEJBQThCSCxnQkFDOUJBO2dCQUVOO2dCQUNBTyxvQkFBb0JqRjtnQkFDcEJrRixtQ0FBbUMsQ0FBQztnQkFDcEMsTUFBTUM7UUFDVjtJQUNGO0lBQ0EsU0FBU0M7UUFDUCxJQUFJLFNBQVNILG1CQUNYLE1BQU0zZSxNQUNKO1FBRUosSUFBSTBaLFdBQVdpRjtRQUNmQSxvQkFBb0I7UUFDcEJDLG1DQUFtQyxDQUFDO1FBQ3BDLE9BQU9sRjtJQUNUO0lBQ0EsU0FBUzZFLDhCQUE4QlEsY0FBYztRQUNuRCxJQUFJQSxtQkFBbUJGLG1CQUNyQixNQUFNN2UsTUFDSjtJQUVOO0lBQ0EsU0FBU2dmLGNBQWNyYyxTQUFTO1FBQzlCLElBQUlzYyxvQkFBb0JDO1FBQ3hCLFFBQVF2YyxhQUNMdWMsQ0FBQUEsbUJBQ0MsU0FBU0Qsb0JBQ0x0YyxZQUNBc2Msa0JBQWtCRSxNQUFNLENBQUN4YyxVQUFTO1FBQzFDLE9BQU9zYztJQUNUO0lBQ0EsU0FBU0csc0JBQXNCcGtCLE9BQU8sRUFBRWxDLEtBQUssRUFBRXVtQixXQUFXO1FBQ3hELElBQUssSUFBSTlOLE9BQU81UixPQUFPNFIsSUFBSSxDQUFDdlcsUUFBUXVFLEtBQUssR0FBR3JGLElBQUksR0FBR0EsSUFBSXFYLEtBQUtoWSxNQUFNLEVBQUVXLElBQUs7WUFDdkUsSUFBSVYsTUFBTStYLElBQUksQ0FBQ3JYLEVBQUU7WUFDakIsSUFBSSxlQUFlVixPQUFPLFVBQVVBLEtBQUs7Z0JBQ3ZDLFNBQVNWLFNBQ04sU0FBU3dtQix1QkFBdUJ0a0IsU0FBU3FrQixZQUFZemtCLElBQUksRUFBRSxJQUMzRDlCLE1BQU13RixVQUFVLEdBQUc0Z0Isa0JBQ25CcG1CLE1BQU15RixNQUFNLEdBQUc4Z0IsV0FBVztnQkFDN0JwYyxrQkFDRW5LLE9BQ0EsU0FBVXltQixVQUFVO29CQUNsQnZsQixRQUFRZ0MsS0FBSyxDQUNYLDRHQUNBdWpCO2dCQUVKLEdBQ0EvbEI7Z0JBRUY7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxTQUFTZ21CLGVBQWU5RixRQUFRO1FBQzlCLElBQUlyZ0IsUUFBUW9tQjtRQUNaQSwwQkFBMEI7UUFDMUIsU0FBU0MsbUJBQW9CQSxDQUFBQSxrQkFBa0I1QixxQkFBb0I7UUFDbkUsT0FBT0ssa0JBQWtCdUIsaUJBQWlCaEcsVUFBVXJnQjtJQUN0RDtJQUNBLFNBQVNzbUIsVUFBVWpkLGNBQWMsRUFBRTFILE9BQU87UUFDeENBLFVBQVVBLFFBQVF1RSxLQUFLLENBQUNxZ0IsR0FBRztRQUMzQmxkLGVBQWVrZCxHQUFHLEdBQUcsS0FBSyxNQUFNNWtCLFVBQVVBLFVBQVU7SUFDdEQ7SUFDQSxTQUFTNmtCLHlCQUF5QlIsV0FBVyxFQUFFUyxRQUFRO1FBQ3JELElBQUlBLFNBQVM5aUIsUUFBUSxLQUFLK2lCLDJCQUN4QixNQUFNL2YsTUFDSjtRQUVKcWYsY0FBYzFmLE9BQU8wQixTQUFTLENBQUNvTCxRQUFRLENBQUNqTCxJQUFJLENBQUNzZTtRQUM3QyxNQUFNOWYsTUFDSixvREFDRyx1QkFBc0JxZixjQUNuQix1QkFBdUIxZixPQUFPNFIsSUFBSSxDQUFDdU8sVUFBVXBqQixJQUFJLENBQUMsUUFBUSxNQUMxRDJpQixXQUFVLElBQ2Q7SUFFTjtJQUNBLFNBQVNXLG1CQUFtQlgsV0FBVyxFQUFFWSxZQUFZO1FBQ25ELElBQUlDLGFBQWE3aEIsMEJBQTBCZ2hCLGdCQUFnQjtRQUMzRGMsMkJBQTJCLENBQUNELFdBQVcsSUFDcEMsNEJBQTRCLENBQUNBLFdBQVcsR0FBRyxDQUFDLEdBQzVDRCxlQUNDQSxhQUFhL2lCLFdBQVcsSUFBSStpQixhQUFhOWlCLElBQUksSUFBSSxhQUNuRCxNQUFNa2lCLFlBQVkza0IsR0FBRyxHQUNqQlYsUUFBUWdDLEtBQUssQ0FDWCxnTUFDQWlrQixjQUNBQSxjQUNBQSxnQkFFRmptQixRQUFRZ0MsS0FBSyxDQUNYLDhMQUNBaWtCLGNBQ0FBLGNBQ0FDLFlBQ0FELGNBQ0FDLFdBQ0Y7SUFDUjtJQUNBLFNBQVNFLGlCQUFpQmYsV0FBVyxFQUFFWSxZQUFZO1FBQ2pELElBQUlDLGFBQWE3aEIsMEJBQTBCZ2hCLGdCQUFnQjtRQUMzRGdCLHlCQUF5QixDQUFDSCxXQUFXLElBQ2xDLDBCQUEwQixDQUFDQSxXQUFXLEdBQUcsQ0FBQyxHQUMxQ0QsZUFBZWpRLE9BQU9pUSxlQUN2QixNQUFNWixZQUFZM2tCLEdBQUcsR0FDakJWLFFBQVFnQyxLQUFLLENBQ1gsOERBQ0Fpa0IsZ0JBRUZqbUIsUUFBUWdDLEtBQUssQ0FDWCwwREFDQWtrQixZQUNBRCxjQUNBQyxXQUNGO0lBQ1I7SUFDQSxTQUFTSSxzQkFBc0JDLHNCQUFzQjtRQUNuRCxTQUFTQyxZQUFZbkIsV0FBVyxFQUFFb0IsYUFBYTtZQUM3QyxJQUFJRix3QkFBd0I7Z0JBQzFCLElBQUlHLFlBQVlyQixZQUFZcUIsU0FBUztnQkFDckMsU0FBU0EsWUFDSixhQUFhQSxTQUFTLEdBQUc7b0JBQUNEO2lCQUFjLEVBQ3hDcEIsWUFBWXRiLEtBQUssSUFBSSxFQUFFLElBQ3hCMmMsVUFBVWxrQixJQUFJLENBQUNpa0I7WUFDckI7UUFDRjtRQUNBLFNBQVNFLHdCQUF3QnRCLFdBQVcsRUFBRXVCLGlCQUFpQjtZQUM3RCxJQUFJLENBQUNMLHdCQUF3QixPQUFPO1lBQ3BDLE1BQU8sU0FBU0ssbUJBQ2RKLFlBQVluQixhQUFhdUIsb0JBQ3RCQSxvQkFBb0JBLGtCQUFrQnJjLE9BQU87WUFDbEQsT0FBTztRQUNUO1FBQ0EsU0FBU3NjLHFCQUFxQkQsaUJBQWlCO1lBQzdDLElBQUssSUFBSUUsbUJBQW1CLElBQUk5UCxPQUFPLFNBQVM0UCxtQkFDOUMsU0FBU0Esa0JBQWtCcG5CLEdBQUcsR0FDMUJzbkIsaUJBQWlCemtCLEdBQUcsQ0FBQ3VrQixrQkFBa0JwbkIsR0FBRyxFQUFFb25CLHFCQUM1Q0UsaUJBQWlCemtCLEdBQUcsQ0FBQ3VrQixrQkFBa0J2bkIsS0FBSyxFQUFFdW5CLG9CQUMvQ0Esb0JBQW9CQSxrQkFBa0JyYyxPQUFPO1lBQ2xELE9BQU91YztRQUNUO1FBQ0EsU0FBU0MsU0FBU2pvQixLQUFLLEVBQUU2QixZQUFZO1lBQ25DN0IsUUFBUWtvQixxQkFBcUJsb0IsT0FBTzZCO1lBQ3BDN0IsTUFBTU8sS0FBSyxHQUFHO1lBQ2RQLE1BQU15TCxPQUFPLEdBQUc7WUFDaEIsT0FBT3pMO1FBQ1Q7UUFDQSxTQUFTbW9CLFdBQVdDLFFBQVEsRUFBRUMsZUFBZSxFQUFFQyxRQUFRO1lBQ3JERixTQUFTN25CLEtBQUssR0FBRytuQjtZQUNqQixJQUFJLENBQUNiLHdCQUNILE9BQU8sU0FBVXhjLEtBQUssSUFBSSxTQUFVb2Q7WUFDdENDLFdBQVdGLFNBQVNwZCxTQUFTO1lBQzdCLElBQUksU0FBU3NkLFVBQ1gsT0FDRSxXQUFZQSxTQUFTL25CLEtBQUssRUFDMUIrbkIsV0FBV0Qsa0JBQ04sVUFBVXBkLEtBQUssSUFBSSxVQUFXb2QsZUFBYyxJQUM3Q0M7WUFFUkYsU0FBU25kLEtBQUssSUFBSTtZQUNsQixPQUFPb2Q7UUFDVDtRQUNBLFNBQVNFLGlCQUFpQkgsUUFBUTtZQUNoQ1gsMEJBQ0UsU0FBU1csU0FBU3BkLFNBQVMsSUFDMUJvZCxDQUFBQSxTQUFTbmQsS0FBSyxJQUFJLFFBQU87WUFDNUIsT0FBT21kO1FBQ1Q7UUFDQSxTQUFTSSxlQUFlakMsV0FBVyxFQUFFempCLE9BQU8sRUFBRTJsQixXQUFXLEVBQUUzYixLQUFLO1lBQzlELElBQUksU0FBU2hLLFdBQVcsTUFBTUEsUUFBUWxCLEdBQUcsRUFDdkMsT0FDRSxVQUFXOG1CLG9CQUNURCxhQUNBbEMsWUFBWXprQixJQUFJLEVBQ2hCZ0wsUUFFRGhLLFFBQVEyQyxNQUFNLEdBQUc4Z0IsYUFDakJ6akIsUUFBUTZsQixXQUFXLEdBQUdwQyxhQUN0QnpqQixRQUFRMEMsVUFBVSxHQUFHNGdCLGtCQUN0QnRqQjtZQUVKQSxVQUFVbWxCLFNBQVNubEIsU0FBUzJsQjtZQUM1QjNsQixRQUFRMkMsTUFBTSxHQUFHOGdCO1lBQ2pCempCLFFBQVEwQyxVQUFVLEdBQUc0Z0I7WUFDckIsT0FBT3RqQjtRQUNUO1FBQ0EsU0FBUzhsQixjQUFjckMsV0FBVyxFQUFFempCLE9BQU8sRUFBRVosT0FBTyxFQUFFNEssS0FBSztZQUN6RCxJQUFJK2IsY0FBYzNtQixRQUFRK0IsSUFBSTtZQUM5QixJQUFJNGtCLGdCQUFnQnZrQixxQkFDbEIsT0FDRSxVQUFXd2tCLGVBQ1R2QyxhQUNBempCLFNBQ0FaLFFBQVF1RSxLQUFLLENBQUM4TyxRQUFRLEVBQ3RCekksT0FDQTVLLFFBQVF4QixHQUFHLEdBRWI0bEIsc0JBQXNCcGtCLFNBQVNZLFNBQVN5akIsY0FDeEN6akI7WUFFSixJQUNFLFNBQVNBLFdBQ1JBLENBQUFBLFFBQVErbEIsV0FBVyxLQUFLQSxlQUN2QkUsa0NBQWtDam1CLFNBQVNaLFlBQzFDLGFBQWEsT0FBTzJtQixlQUNuQixTQUFTQSxlQUNUQSxZQUFZM2tCLFFBQVEsS0FBS2lCLG1CQUN6QjZqQixrQkFBa0JILGlCQUFpQi9sQixRQUFRbUIsSUFBSSxHQUVuRCxPQUNFLFVBQVdna0IsU0FBU25sQixTQUFTWixRQUFRdUUsS0FBSyxHQUMxQ29nQixVQUFVL2pCLFNBQVNaLFVBQ2xCWSxRQUFRMkMsTUFBTSxHQUFHOGdCLGFBQ2pCempCLFFBQVE2bEIsV0FBVyxHQUFHem1CLFFBQVErbUIsTUFBTSxFQUNwQ25tQixRQUFRMEMsVUFBVSxHQUFHNGdCLGtCQUN0QnRqQjtZQUVKQSxVQUFVMGpCLHVCQUF1QnRrQixTQUFTcWtCLFlBQVl6a0IsSUFBSSxFQUFFZ0w7WUFDNUQrWixVQUFVL2pCLFNBQVNaO1lBQ25CWSxRQUFRMkMsTUFBTSxHQUFHOGdCO1lBQ2pCempCLFFBQVEwQyxVQUFVLEdBQUc0Z0I7WUFDckIsT0FBT3RqQjtRQUNUO1FBQ0EsU0FBU29tQixhQUFhM0MsV0FBVyxFQUFFempCLE9BQU8sRUFBRXFtQixNQUFNLEVBQUVyYyxLQUFLO1lBQ3ZELElBQ0UsU0FBU2hLLFdBQ1QsTUFBTUEsUUFBUWxCLEdBQUcsSUFDakJrQixRQUFROEksU0FBUyxDQUFDd2QsYUFBYSxLQUFLRCxPQUFPQyxhQUFhLElBQ3hEdG1CLFFBQVE4SSxTQUFTLENBQUN5ZCxjQUFjLEtBQUtGLE9BQU9FLGNBQWMsRUFFMUQsT0FDRSxVQUFXQyxzQkFBc0JILFFBQVE1QyxZQUFZemtCLElBQUksRUFBRWdMLFFBQzFEaEssUUFBUTJDLE1BQU0sR0FBRzhnQixhQUNqQnpqQixRQUFRMEMsVUFBVSxHQUFHNGdCLGtCQUN0QnRqQjtZQUVKQSxVQUFVbWxCLFNBQVNubEIsU0FBU3FtQixPQUFPNVQsUUFBUSxJQUFJLEVBQUU7WUFDakR6UyxRQUFRMkMsTUFBTSxHQUFHOGdCO1lBQ2pCempCLFFBQVEwQyxVQUFVLEdBQUc0Z0I7WUFDckIsT0FBT3RqQjtRQUNUO1FBQ0EsU0FBU2dtQixlQUFldkMsV0FBVyxFQUFFempCLE9BQU8sRUFBRXltQixRQUFRLEVBQUV6YyxLQUFLLEVBQUVwTSxHQUFHO1lBQ2hFLElBQUksU0FBU29DLFdBQVcsTUFBTUEsUUFBUWxCLEdBQUcsRUFDdkMsT0FDRSxVQUFXNG5CLHdCQUNURCxVQUNBaEQsWUFBWXprQixJQUFJLEVBQ2hCZ0wsT0FDQXBNLE1BRURvQyxRQUFRMkMsTUFBTSxHQUFHOGdCLGFBQ2pCempCLFFBQVE2bEIsV0FBVyxHQUFHcEMsYUFDdEJ6akIsUUFBUTBDLFVBQVUsR0FBRzRnQixrQkFDdEJ0akI7WUFFSkEsVUFBVW1sQixTQUFTbmxCLFNBQVN5bUI7WUFDNUJ6bUIsUUFBUTJDLE1BQU0sR0FBRzhnQjtZQUNqQnpqQixRQUFRMEMsVUFBVSxHQUFHNGdCO1lBQ3JCLE9BQU90akI7UUFDVDtRQUNBLFNBQVMybUIsWUFBWWxELFdBQVcsRUFBRVMsUUFBUSxFQUFFbGEsS0FBSztZQUMvQyxJQUNFLGFBQWMsT0FBT2thLFlBQVksT0FBT0EsWUFDeEMsYUFBYSxPQUFPQSxZQUNwQixhQUFhLE9BQU9BLFVBRXBCLE9BQ0UsV0FBWTBCLG9CQUNWLEtBQUsxQixVQUNMVCxZQUFZemtCLElBQUksRUFDaEJnTCxRQUVEa2EsU0FBU3ZoQixNQUFNLEdBQUc4Z0IsYUFDbEJTLFNBQVMyQixXQUFXLEdBQUdwQyxhQUN2QlMsU0FBU3hoQixVQUFVLEdBQUc0Z0Isa0JBQ3ZCWTtZQUVKLElBQUksYUFBYSxPQUFPQSxZQUFZLFNBQVNBLFVBQVU7Z0JBQ3JELE9BQVFBLFNBQVM5aUIsUUFBUTtvQkFDdkIsS0FBSzRTO3dCQUNILE9BQ0UsUUFBUzBQLHVCQUNQUSxVQUNBVCxZQUFZemtCLElBQUksRUFDaEJnTCxRQUVGK1osVUFBVS9aLE9BQU9rYSxXQUNoQmxhLE1BQU1ySCxNQUFNLEdBQUc4Z0IsYUFDZkEsY0FBY0wsY0FBY2MsU0FBU3hoQixVQUFVLEdBQy9Dc0gsTUFBTXRILFVBQVUsR0FBRzRnQixrQkFDbkJBLG1CQUFtQkcsYUFDcEJ6WjtvQkFFSixLQUFLdkk7d0JBQ0gsT0FDRSxXQUFZK2tCLHNCQUNWdEMsVUFDQVQsWUFBWXprQixJQUFJLEVBQ2hCZ0wsUUFFRGthLFNBQVN2aEIsTUFBTSxHQUFHOGdCLGFBQ2xCUyxTQUFTeGhCLFVBQVUsR0FBRzRnQixrQkFDdkJZO29CQUVKLEtBQUs3aEI7d0JBQ0gsSUFBSXVrQixpQkFBaUJ4RCxjQUFjYyxTQUFTeGhCLFVBQVU7d0JBQ3REd2hCLFdBQVdnQyxrQkFBa0JoQzt3QkFDN0JULGNBQWNrRCxZQUFZbEQsYUFBYVMsVUFBVWxhO3dCQUNqRHNaLG1CQUFtQnNEO3dCQUNuQixPQUFPbkQ7Z0JBQ1g7Z0JBQ0EsSUFBSTNsQixZQUFZb21CLGFBQWFuakIsY0FBY21qQixXQUN6QyxPQUNFLFFBQVN3Qyx3QkFDUHhDLFVBQ0FULFlBQVl6a0IsSUFBSSxFQUNoQmdMLE9BQ0EsT0FFREEsTUFBTXJILE1BQU0sR0FBRzhnQixhQUNmelosTUFBTTZiLFdBQVcsR0FBR3BDLGFBQ3BCQSxjQUFjTCxjQUFjYyxTQUFTeGhCLFVBQVUsR0FDL0NzSCxNQUFNdEgsVUFBVSxHQUFHNGdCLGtCQUNuQkEsbUJBQW1CRyxhQUNwQnpaO2dCQUVKLElBQUksZUFBZSxPQUFPa2EsU0FBUzdGLElBQUksRUFDckMsT0FDRSxpQkFBa0IrRSxjQUFjYyxTQUFTeGhCLFVBQVUsR0FDbEQrZ0IsY0FBY2tELFlBQ2JsRCxhQUNBRyxlQUFlTSxXQUNmbGEsUUFFRHNaLG1CQUFtQnNELGdCQUNwQm5EO2dCQUVKLElBQUlTLFNBQVM5aUIsUUFBUSxLQUFLVSxvQkFDeEIsT0FBTzZrQixZQUNMbEQsYUFDQW9ELGdDQUFnQ3BELGFBQWFTLFdBQzdDbGE7Z0JBRUppYSx5QkFBeUJSLGFBQWFTO1lBQ3hDO1lBQ0EsZUFBZSxPQUFPQSxZQUNwQkUsbUJBQW1CWCxhQUFhUztZQUNsQyxhQUFhLE9BQU9BLFlBQVlNLGlCQUFpQmYsYUFBYVM7WUFDOUQsT0FBTztRQUNUO1FBQ0EsU0FBUzRDLFdBQVdyRCxXQUFXLEVBQUVzRCxRQUFRLEVBQUU3QyxRQUFRLEVBQUVsYSxLQUFLO1lBQ3hELElBQUlwTSxNQUFNLFNBQVNtcEIsV0FBV0EsU0FBU25wQixHQUFHLEdBQUc7WUFDN0MsSUFDRSxhQUFjLE9BQU9zbUIsWUFBWSxPQUFPQSxZQUN4QyxhQUFhLE9BQU9BLFlBQ3BCLGFBQWEsT0FBT0EsVUFFcEIsT0FBTyxTQUFTdG1CLE1BQ1osT0FDQThuQixlQUFlakMsYUFBYXNELFVBQVUsS0FBSzdDLFVBQVVsYTtZQUMzRCxJQUFJLGFBQWEsT0FBT2thLFlBQVksU0FBU0EsVUFBVTtnQkFDckQsT0FBUUEsU0FBUzlpQixRQUFRO29CQUN2QixLQUFLNFM7d0JBQ0gsT0FBT2tRLFNBQVN0bUIsR0FBRyxLQUFLQSxNQUNuQixPQUFPd2xCLGNBQWNjLFNBQVN4aEIsVUFBVSxHQUN4QytnQixjQUFjcUMsY0FDYnJDLGFBQ0FzRCxVQUNBN0MsVUFDQWxhLFFBRURzWixtQkFBbUIxbEIsS0FDcEI2bEIsV0FBVSxJQUNWO29CQUNOLEtBQUtoaUI7d0JBQ0gsT0FBT3lpQixTQUFTdG1CLEdBQUcsS0FBS0EsTUFDcEJ3b0IsYUFBYTNDLGFBQWFzRCxVQUFVN0MsVUFBVWxhLFNBQzlDO29CQUNOLEtBQUszSDt3QkFDSCxPQUNFLE1BQU8rZ0IsY0FBY2MsU0FBU3hoQixVQUFVLEdBQ3ZDd2hCLFdBQVdnQyxrQkFBa0JoQyxXQUM3QlQsY0FBY3FELFdBQ2JyRCxhQUNBc0QsVUFDQTdDLFVBQ0FsYSxRQUVEc1osbUJBQW1CMWxCLEtBQ3BCNmxCO2dCQUVOO2dCQUNBLElBQUkzbEIsWUFBWW9tQixhQUFhbmpCLGNBQWNtakIsV0FBVztvQkFDcEQsSUFBSSxTQUFTdG1CLEtBQUssT0FBTztvQkFDekJBLE1BQU13bEIsY0FBY2MsU0FBU3hoQixVQUFVO29CQUN2QytnQixjQUFjdUMsZUFDWnZDLGFBQ0FzRCxVQUNBN0MsVUFDQWxhLE9BQ0E7b0JBRUZzWixtQkFBbUIxbEI7b0JBQ25CLE9BQU82bEI7Z0JBQ1Q7Z0JBQ0EsSUFBSSxlQUFlLE9BQU9TLFNBQVM3RixJQUFJLEVBQ3JDLE9BQ0UsTUFBTytFLGNBQWNjLFNBQVN4aEIsVUFBVSxHQUN2QytnQixjQUFjcUQsV0FDYnJELGFBQ0FzRCxVQUNBbkQsZUFBZU0sV0FDZmxhLFFBRURzWixtQkFBbUIxbEIsS0FDcEI2bEI7Z0JBRUosSUFBSVMsU0FBUzlpQixRQUFRLEtBQUtVLG9CQUN4QixPQUFPZ2xCLFdBQ0xyRCxhQUNBc0QsVUFDQUYsZ0NBQWdDcEQsYUFBYVMsV0FDN0NsYTtnQkFFSmlhLHlCQUF5QlIsYUFBYVM7WUFDeEM7WUFDQSxlQUFlLE9BQU9BLFlBQ3BCRSxtQkFBbUJYLGFBQWFTO1lBQ2xDLGFBQWEsT0FBT0EsWUFBWU0saUJBQWlCZixhQUFhUztZQUM5RCxPQUFPO1FBQ1Q7UUFDQSxTQUFTOEMsY0FDUDlCLGdCQUFnQixFQUNoQnpCLFdBQVcsRUFDWHdELE1BQU0sRUFDTi9DLFFBQVEsRUFDUmxhLEtBQUs7WUFFTCxJQUNFLGFBQWMsT0FBT2thLFlBQVksT0FBT0EsWUFDeEMsYUFBYSxPQUFPQSxZQUNwQixhQUFhLE9BQU9BLFVBRXBCLE9BQ0UsbUJBQW9CZ0IsaUJBQWlCbGdCLEdBQUcsQ0FBQ2lpQixXQUFXLE1BQ3BEdkIsZUFBZWpDLGFBQWF5QixrQkFBa0IsS0FBS2hCLFVBQVVsYTtZQUVqRSxJQUFJLGFBQWEsT0FBT2thLFlBQVksU0FBU0EsVUFBVTtnQkFDckQsT0FBUUEsU0FBUzlpQixRQUFRO29CQUN2QixLQUFLNFM7d0JBQ0gsT0FDRSxTQUNFa1IsaUJBQWlCbGdCLEdBQUcsQ0FDbEIsU0FBU2tmLFNBQVN0bUIsR0FBRyxHQUFHcXBCLFNBQVMvQyxTQUFTdG1CLEdBQUcsS0FDMUMsTUFDTnNuQixtQkFBbUI5QixjQUFjYyxTQUFTeGhCLFVBQVUsR0FDcEQrZ0IsY0FBY3FDLGNBQ2JyQyxhQUNBd0QsUUFDQS9DLFVBQ0FsYSxRQUVEc1osbUJBQW1CNEIsa0JBQ3BCekI7b0JBRUosS0FBS2hpQjt3QkFDSCxPQUNFLG1CQUNFeWpCLGlCQUFpQmxnQixHQUFHLENBQ2xCLFNBQVNrZixTQUFTdG1CLEdBQUcsR0FBR3FwQixTQUFTL0MsU0FBU3RtQixHQUFHLEtBQzFDLE1BQ1B3b0IsYUFBYTNDLGFBQWF5QixrQkFBa0JoQixVQUFVbGE7b0JBRTFELEtBQUszSDt3QkFDSCxJQUFJNmtCLGtCQUFrQjlELGNBQWNjLFNBQVN4aEIsVUFBVTt3QkFDdkR3aEIsV0FBV2dDLGtCQUFrQmhDO3dCQUM3QlQsY0FBY3VELGNBQ1o5QixrQkFDQXpCLGFBQ0F3RCxRQUNBL0MsVUFDQWxhO3dCQUVGc1osbUJBQW1CNEQ7d0JBQ25CLE9BQU96RDtnQkFDWDtnQkFDQSxJQUFJM2xCLFlBQVlvbUIsYUFBYW5qQixjQUFjbWpCLFdBQ3pDLE9BQ0UsU0FBVWdCLGlCQUFpQmxnQixHQUFHLENBQUNpaUIsV0FBVyxNQUN6Qy9CLG1CQUFtQjlCLGNBQWNjLFNBQVN4aEIsVUFBVSxHQUNwRCtnQixjQUFjdUMsZUFDYnZDLGFBQ0F3RCxRQUNBL0MsVUFDQWxhLE9BQ0EsT0FFRHNaLG1CQUFtQjRCLGtCQUNwQnpCO2dCQUVKLElBQUksZUFBZSxPQUFPUyxTQUFTN0YsSUFBSSxFQUNyQyxPQUNFLGtCQUFtQitFLGNBQWNjLFNBQVN4aEIsVUFBVSxHQUNuRCtnQixjQUFjdUQsY0FDYjlCLGtCQUNBekIsYUFDQXdELFFBQ0FyRCxlQUFlTSxXQUNmbGEsUUFFRHNaLG1CQUFtQjRELGlCQUNwQnpEO2dCQUVKLElBQUlTLFNBQVM5aUIsUUFBUSxLQUFLVSxvQkFDeEIsT0FBT2tsQixjQUNMOUIsa0JBQ0F6QixhQUNBd0QsUUFDQUosZ0NBQWdDcEQsYUFBYVMsV0FDN0NsYTtnQkFFSmlhLHlCQUF5QlIsYUFBYVM7WUFDeEM7WUFDQSxlQUFlLE9BQU9BLFlBQ3BCRSxtQkFBbUJYLGFBQWFTO1lBQ2xDLGFBQWEsT0FBT0EsWUFBWU0saUJBQWlCZixhQUFhUztZQUM5RCxPQUFPO1FBQ1Q7UUFDQSxTQUFTaUQsaUJBQWlCMUQsV0FBVyxFQUFFM2MsY0FBYyxFQUFFNEIsS0FBSyxFQUFFMGUsU0FBUztZQUNyRSxJQUFJLGFBQWEsT0FBTzFlLFNBQVMsU0FBU0EsT0FBTyxPQUFPMGU7WUFDeEQsT0FBUTFlLE1BQU10SCxRQUFRO2dCQUNwQixLQUFLNFM7Z0JBQ0wsS0FBS3ZTO29CQUNIbEIsa0JBQWtCa2pCLGFBQWEzYyxnQkFBZ0I0QjtvQkFDL0MsSUFBSTlLLE1BQU04SyxNQUFNOUssR0FBRztvQkFDbkIsSUFBSSxhQUFhLE9BQU9BLEtBQUs7b0JBQzdCLElBQUksU0FBU3dwQixXQUFXO3dCQUN0QkEsWUFBWSxJQUFJQzt3QkFDaEJELFVBQVV0YSxHQUFHLENBQUNsUDt3QkFDZDtvQkFDRjtvQkFDQSxJQUFJLENBQUN3cEIsVUFBVWxhLEdBQUcsQ0FBQ3RQLE1BQU07d0JBQ3ZCd3BCLFVBQVV0YSxHQUFHLENBQUNsUDt3QkFDZDtvQkFDRjtvQkFDQXlKLGtCQUFrQlAsZ0JBQWdCO3dCQUNoQzFJLFFBQVFnQyxLQUFLLENBQ1gsa1JBQ0F4QztvQkFFSjtvQkFDQTtnQkFDRixLQUFLeUU7b0JBQ0ZxRyxRQUFRd2Qsa0JBQWtCeGQsUUFDekJ5ZSxpQkFBaUIxRCxhQUFhM2MsZ0JBQWdCNEIsT0FBTzBlO1lBQzNEO1lBQ0EsT0FBT0E7UUFDVDtRQUNBLFNBQVNFLHVCQUNQN0QsV0FBVyxFQUNYdUIsaUJBQWlCLEVBQ2pCdUMsV0FBVyxFQUNYdmQsS0FBSztZQUVMLElBQ0UsSUFBSW9kLFlBQVksTUFDZEksc0JBQXNCLE1BQ3RCQyxtQkFBbUIsTUFDbkJWLFdBQVcvQixtQkFDWGlDLFNBQVVqQyxvQkFBb0IsR0FDOUIwQyxlQUFlLE1BQ2pCLFNBQVNYLFlBQVlFLFNBQVNNLFlBQVk1cEIsTUFBTSxFQUNoRHNwQixTQUNBO2dCQUNBRixTQUFTdHBCLEtBQUssR0FBR3dwQixTQUNaLGdCQUFnQkYsVUFBWUEsV0FBVyxJQUFJLElBQzNDVyxlQUFlWCxTQUFTcGUsT0FBTztnQkFDcEMsSUFBSTJjLFdBQVd3QixXQUNickQsYUFDQXNELFVBQ0FRLFdBQVcsQ0FBQ04sT0FBTyxFQUNuQmpkO2dCQUVGLElBQUksU0FBU3NiLFVBQVU7b0JBQ3JCLFNBQVN5QixZQUFhQSxDQUFBQSxXQUFXVyxZQUFXO29CQUM1QztnQkFDRjtnQkFDQU4sWUFBWUQsaUJBQ1YxRCxhQUNBNkIsVUFDQWlDLFdBQVcsQ0FBQ04sT0FBTyxFQUNuQkc7Z0JBRUZ6QywwQkFDRW9DLFlBQ0EsU0FBU3pCLFNBQVNwZCxTQUFTLElBQzNCMGMsWUFBWW5CLGFBQWFzRDtnQkFDM0IvQixvQkFBb0JLLFdBQVdDLFVBQVVOLG1CQUFtQmlDO2dCQUM1RCxTQUFTUSxtQkFDSkQsc0JBQXNCbEMsV0FDdEJtQyxpQkFBaUI5ZSxPQUFPLEdBQUcyYztnQkFDaENtQyxtQkFBbUJuQztnQkFDbkJ5QixXQUFXVztZQUNiO1lBQ0EsSUFBSVQsV0FBV00sWUFBWTVwQixNQUFNLEVBQy9CLE9BQ0VvbkIsd0JBQXdCdEIsYUFBYXNELFdBQ3JDL1YsZUFBZW5CLGFBQWE0VCxhQUFhd0QsU0FDekNPO1lBRUosSUFBSSxTQUFTVCxVQUFVO2dCQUNyQixNQUFPRSxTQUFTTSxZQUFZNXBCLE1BQU0sRUFBRXNwQixTQUNsQyxXQUFZTixZQUFZbEQsYUFBYThELFdBQVcsQ0FBQ04sT0FBTyxFQUFFamQsUUFDeEQsU0FBUytjLFlBQ04sYUFBYUksaUJBQ1oxRCxhQUNBc0QsVUFDQVEsV0FBVyxDQUFDTixPQUFPLEVBQ25CRyxZQUVEcEMsb0JBQW9CSyxXQUNuQjBCLFVBQ0EvQixtQkFDQWlDLFNBRUYsU0FBU1EsbUJBQ0pELHNCQUFzQlQsV0FDdEJVLGlCQUFpQjllLE9BQU8sR0FBR29lLFVBQy9CVSxtQkFBbUJWLFFBQVE7Z0JBQ2xDL1YsZUFBZW5CLGFBQWE0VCxhQUFhd0Q7Z0JBQ3pDLE9BQU9PO1lBQ1Q7WUFDQSxJQUNFVCxXQUFXOUIscUJBQXFCOEIsV0FDaENFLFNBQVNNLFlBQVk1cEIsTUFBTSxFQUMzQnNwQixTQUVBLGVBQWdCRCxjQUNkRCxVQUNBdEQsYUFDQXdELFFBQ0FNLFdBQVcsQ0FBQ04sT0FBTyxFQUNuQmpkLFFBRUEsU0FBUzBkLGdCQUNOLGFBQWFQLGlCQUNaMUQsYUFDQWlFLGNBQ0FILFdBQVcsQ0FBQ04sT0FBTyxFQUNuQkcsWUFFRnpDLDBCQUNFLFNBQVMrQyxhQUFheGYsU0FBUyxJQUMvQjZlLFNBQVNyUixNQUFNLENBQ2IsU0FBU2dTLGFBQWE5cEIsR0FBRyxHQUFHcXBCLFNBQVNTLGFBQWE5cEIsR0FBRyxHQUV4RG9uQixvQkFBb0JLLFdBQ25CcUMsY0FDQTFDLG1CQUNBaUMsU0FFRixTQUFTUSxtQkFDSkQsc0JBQXNCRSxlQUN0QkQsaUJBQWlCOWUsT0FBTyxHQUFHK2UsY0FDL0JELG1CQUFtQkMsWUFBWTtZQUN0Qy9DLDBCQUNFb0MsU0FBU3BtQixPQUFPLENBQUMsU0FBVStILEtBQUs7Z0JBQzlCLE9BQU9rYyxZQUFZbkIsYUFBYS9hO1lBQ2xDO1lBQ0ZzSSxlQUFlbkIsYUFBYTRULGFBQWF3RDtZQUN6QyxPQUFPTztRQUNUO1FBQ0EsU0FBU0csMEJBQ1BsRSxXQUFXLEVBQ1h1QixpQkFBaUIsRUFDakJ1QyxXQUFXLEVBQ1h2ZCxLQUFLO1lBRUwsSUFBSSxRQUFRdWQsYUFDVixNQUFNbmpCLE1BQU07WUFDZCxJQUNFLElBQUlvakIsc0JBQXNCLE1BQ3hCQyxtQkFBbUIsTUFDbkJWLFdBQVcvQixtQkFDWGlDLFNBQVVqQyxvQkFBb0IsR0FDOUIwQyxlQUFlLE1BQ2ZOLFlBQVksTUFDWlEsT0FBT0wsWUFBWWxxQixJQUFJLElBQ3pCLFNBQVMwcEIsWUFBWSxDQUFDYSxLQUFLQyxJQUFJLEVBQy9CWixVQUFVVyxPQUFPTCxZQUFZbHFCLElBQUksR0FDakM7Z0JBQ0EwcEIsU0FBU3RwQixLQUFLLEdBQUd3cEIsU0FDWixnQkFBZ0JGLFVBQVlBLFdBQVcsSUFBSSxJQUMzQ1csZUFBZVgsU0FBU3BlLE9BQU87Z0JBQ3BDLElBQUkyYyxXQUFXd0IsV0FBV3JELGFBQWFzRCxVQUFVYSxLQUFLbHFCLEtBQUssRUFBRXNNO2dCQUM3RCxJQUFJLFNBQVNzYixVQUFVO29CQUNyQixTQUFTeUIsWUFBYUEsQ0FBQUEsV0FBV1csWUFBVztvQkFDNUM7Z0JBQ0Y7Z0JBQ0FOLFlBQVlELGlCQUNWMUQsYUFDQTZCLFVBQ0FzQyxLQUFLbHFCLEtBQUssRUFDVjBwQjtnQkFFRnpDLDBCQUNFb0MsWUFDQSxTQUFTekIsU0FBU3BkLFNBQVMsSUFDM0IwYyxZQUFZbkIsYUFBYXNEO2dCQUMzQi9CLG9CQUFvQkssV0FBV0MsVUFBVU4sbUJBQW1CaUM7Z0JBQzVELFNBQVNRLG1CQUNKRCxzQkFBc0JsQyxXQUN0Qm1DLGlCQUFpQjllLE9BQU8sR0FBRzJjO2dCQUNoQ21DLG1CQUFtQm5DO2dCQUNuQnlCLFdBQVdXO1lBQ2I7WUFDQSxJQUFJRSxLQUFLQyxJQUFJLEVBQ1gsT0FDRTlDLHdCQUF3QnRCLGFBQWFzRCxXQUNyQy9WLGVBQWVuQixhQUFhNFQsYUFBYXdELFNBQ3pDTztZQUVKLElBQUksU0FBU1QsVUFBVTtnQkFDckIsTUFBTyxDQUFDYSxLQUFLQyxJQUFJLEVBQUVaLFVBQVVXLE9BQU9MLFlBQVlscUIsSUFBSSxHQUNsRCxXQUFZc3BCLFlBQVlsRCxhQUFhbUUsS0FBS2xxQixLQUFLLEVBQUVzTSxRQUMvQyxTQUFTK2MsWUFDTixhQUFhSSxpQkFDWjFELGFBQ0FzRCxVQUNBYSxLQUFLbHFCLEtBQUssRUFDVjBwQixZQUVEcEMsb0JBQW9CSyxXQUNuQjBCLFVBQ0EvQixtQkFDQWlDLFNBRUYsU0FBU1EsbUJBQ0pELHNCQUFzQlQsV0FDdEJVLGlCQUFpQjllLE9BQU8sR0FBR29lLFVBQy9CVSxtQkFBbUJWLFFBQVE7Z0JBQ2xDL1YsZUFBZW5CLGFBQWE0VCxhQUFhd0Q7Z0JBQ3pDLE9BQU9PO1lBQ1Q7WUFDQSxJQUNFVCxXQUFXOUIscUJBQXFCOEIsV0FDaEMsQ0FBQ2EsS0FBS0MsSUFBSSxFQUNWWixVQUFVVyxPQUFPTCxZQUFZbHFCLElBQUksR0FFakMsZUFBZ0IycEIsY0FDZEQsVUFDQXRELGFBQ0F3RCxRQUNBVyxLQUFLbHFCLEtBQUssRUFDVnNNLFFBRUEsU0FBUzBkLGdCQUNOLGFBQWFQLGlCQUNaMUQsYUFDQWlFLGNBQ0FFLEtBQUtscUIsS0FBSyxFQUNWMHBCLFlBRUZ6QywwQkFDRSxTQUFTK0MsYUFBYXhmLFNBQVMsSUFDL0I2ZSxTQUFTclIsTUFBTSxDQUNiLFNBQVNnUyxhQUFhOXBCLEdBQUcsR0FBR3FwQixTQUFTUyxhQUFhOXBCLEdBQUcsR0FFeERvbkIsb0JBQW9CSyxXQUNuQnFDLGNBQ0ExQyxtQkFDQWlDLFNBRUYsU0FBU1EsbUJBQ0pELHNCQUFzQkUsZUFDdEJELGlCQUFpQjllLE9BQU8sR0FBRytlLGNBQy9CRCxtQkFBbUJDLFlBQVk7WUFDdEMvQywwQkFDRW9DLFNBQVNwbUIsT0FBTyxDQUFDLFNBQVUrSCxLQUFLO2dCQUM5QixPQUFPa2MsWUFBWW5CLGFBQWEvYTtZQUNsQztZQUNGc0ksZUFBZW5CLGFBQWE0VCxhQUFhd0Q7WUFDekMsT0FBT087UUFDVDtRQUNBLFNBQVNNLHlCQUNQckUsV0FBVyxFQUNYdUIsaUJBQWlCLEVBQ2pCZCxRQUFRLEVBQ1JsYSxLQUFLO1lBRUwsYUFBYSxPQUFPa2EsWUFDbEIsU0FBU0EsWUFDVEEsU0FBUy9pQixJQUFJLEtBQUtLLHVCQUNsQixTQUFTMGlCLFNBQVN0bUIsR0FBRyxJQUNwQjRsQixDQUFBQSxzQkFBc0JVLFVBQVUsTUFBTVQsY0FDdENTLFdBQVdBLFNBQVN2Z0IsS0FBSyxDQUFDOE8sUUFBUTtZQUNyQyxJQUFJLGFBQWEsT0FBT3lSLFlBQVksU0FBU0EsVUFBVTtnQkFDckQsT0FBUUEsU0FBUzlpQixRQUFRO29CQUN2QixLQUFLNFM7d0JBQ0gsSUFBSStULGdCQUFnQjNFLGNBQWNjLFNBQVN4aEIsVUFBVTt3QkFDckQ0RixHQUFHOzRCQUNELElBQUssSUFBSTFLLE1BQU1zbUIsU0FBU3RtQixHQUFHLEVBQUUsU0FBU29uQixtQkFBcUI7Z0NBQ3pELElBQUlBLGtCQUFrQnBuQixHQUFHLEtBQUtBLEtBQUs7b0NBQ2pDQSxNQUFNc21CLFNBQVMvaUIsSUFBSTtvQ0FDbkIsSUFBSXZELFFBQVE0RCxxQkFBcUI7d0NBQy9CLElBQUksTUFBTXdqQixrQkFBa0JsbUIsR0FBRyxFQUFFOzRDQUMvQmltQix3QkFDRXRCLGFBQ0F1QixrQkFBa0JyYyxPQUFPOzRDQUUzQnFCLFFBQVFtYixTQUNOSCxtQkFDQWQsU0FBU3ZnQixLQUFLLENBQUM4TyxRQUFROzRDQUV6QnpJLE1BQU1ySCxNQUFNLEdBQUc4Z0I7NENBQ2Z6WixNQUFNNmIsV0FBVyxHQUFHM0IsU0FBU2lDLE1BQU07NENBQ25DbmMsTUFBTXRILFVBQVUsR0FBRzRnQjs0Q0FDbkJFLHNCQUFzQlUsVUFBVWxhLE9BQU95Wjs0Q0FDdkNBLGNBQWN6Wjs0Q0FDZCxNQUFNMUI7d0NBQ1I7b0NBQ0YsT0FBTyxJQUNMMGMsa0JBQWtCZSxXQUFXLEtBQUtub0IsT0FDbENxb0Isa0NBQ0VqQixtQkFDQWQsYUFFRCxhQUFhLE9BQU90bUIsT0FDbkIsU0FBU0EsT0FDVEEsSUFBSXdELFFBQVEsS0FBS2lCLG1CQUNqQjZqQixrQkFBa0J0b0IsU0FBU29uQixrQkFBa0I3akIsSUFBSSxFQUNuRDt3Q0FDQTRqQix3QkFDRXRCLGFBQ0F1QixrQkFBa0JyYyxPQUFPO3dDQUUzQnFCLFFBQVFtYixTQUFTSCxtQkFBbUJkLFNBQVN2Z0IsS0FBSzt3Q0FDbERvZ0IsVUFBVS9aLE9BQU9rYTt3Q0FDakJsYSxNQUFNckgsTUFBTSxHQUFHOGdCO3dDQUNmelosTUFBTTZiLFdBQVcsR0FBRzNCLFNBQVNpQyxNQUFNO3dDQUNuQ25jLE1BQU10SCxVQUFVLEdBQUc0Z0I7d0NBQ25CRyxjQUFjelo7d0NBQ2QsTUFBTTFCO29DQUNSO29DQUNBeWMsd0JBQXdCdEIsYUFBYXVCO29DQUNyQztnQ0FDRixPQUFPSixZQUFZbkIsYUFBYXVCO2dDQUNoQ0Esb0JBQW9CQSxrQkFBa0JyYyxPQUFPOzRCQUMvQzs0QkFDQXViLFNBQVMvaUIsSUFBSSxLQUFLSyxzQkFDYixTQUFTa2xCLHdCQUNSeEMsU0FBU3ZnQixLQUFLLENBQUM4TyxRQUFRLEVBQ3ZCZ1IsWUFBWXprQixJQUFJLEVBQ2hCZ0wsT0FDQWthLFNBQVN0bUIsR0FBRyxHQUVib00sTUFBTXJILE1BQU0sR0FBRzhnQixhQUNmelosTUFBTTZiLFdBQVcsR0FBR3BDLGFBQ3BCelosTUFBTXRILFVBQVUsR0FBRzRnQixrQkFDcEJFLHNCQUFzQlUsVUFBVWxhLE9BQU95WixjQUN0Q0EsY0FBY3paLEtBQUssSUFDbkIsU0FBUzBaLHVCQUNSUSxVQUNBVCxZQUFZemtCLElBQUksRUFDaEJnTCxRQUVGK1osVUFBVS9aLE9BQU9rYSxXQUNoQmxhLE1BQU1ySCxNQUFNLEdBQUc4Z0IsYUFDZnpaLE1BQU10SCxVQUFVLEdBQUc0Z0Isa0JBQ25CRyxjQUFjelosS0FBSzt3QkFDMUI7d0JBQ0F5WixjQUFjZ0MsaUJBQWlCaEM7d0JBQy9CSCxtQkFBbUJ5RTt3QkFDbkIsT0FBT3RFO29CQUNULEtBQUtoaUI7d0JBQ0g2RyxHQUFHOzRCQUNEeWYsZ0JBQWdCN0Q7NEJBQ2hCLElBQ0VBLFdBQVc2RCxjQUFjbnFCLEdBQUcsRUFDNUIsU0FBU29uQixtQkFFVDtnQ0FDQSxJQUFJQSxrQkFBa0JwbkIsR0FBRyxLQUFLc21CLFVBQzVCLElBQ0UsTUFBTWMsa0JBQWtCbG1CLEdBQUcsSUFDM0JrbUIsa0JBQWtCbGMsU0FBUyxDQUFDd2QsYUFBYSxLQUN2Q3lCLGNBQWN6QixhQUFhLElBQzdCdEIsa0JBQWtCbGMsU0FBUyxDQUFDeWQsY0FBYyxLQUN4Q3dCLGNBQWN4QixjQUFjLEVBQzlCO29DQUNBeEIsd0JBQ0V0QixhQUNBdUIsa0JBQWtCcmMsT0FBTztvQ0FFM0JxQixRQUFRbWIsU0FDTkgsbUJBQ0ErQyxjQUFjdFYsUUFBUSxJQUFJLEVBQUU7b0NBRTlCekksTUFBTXJILE1BQU0sR0FBRzhnQjtvQ0FDZkEsY0FBY3paO29DQUNkLE1BQU0xQjtnQ0FDUixPQUFPO29DQUNMeWMsd0JBQXdCdEIsYUFBYXVCO29DQUNyQztnQ0FDRjtxQ0FDR0osWUFBWW5CLGFBQWF1QjtnQ0FDOUJBLG9CQUFvQkEsa0JBQWtCcmMsT0FBTzs0QkFDL0M7NEJBQ0FxQixRQUFRd2Msc0JBQ051QixlQUNBdEUsWUFBWXprQixJQUFJLEVBQ2hCZ0w7NEJBRUZBLE1BQU1ySCxNQUFNLEdBQUc4Z0I7NEJBQ2ZBLGNBQWN6Wjt3QkFDaEI7d0JBQ0EsT0FBT3liLGlCQUFpQmhDO29CQUMxQixLQUFLcGhCO3dCQUNILE9BQ0UsZ0JBQWlCK2dCLGNBQWNjLFNBQVN4aEIsVUFBVSxHQUNqRHdoQixXQUFXZ0Msa0JBQWtCaEMsV0FDN0JULGNBQWNxRSx5QkFDYnJFLGFBQ0F1QixtQkFDQWQsVUFDQWxhLFFBRURzWixtQkFBbUJ5RSxlQUNwQnRFO2dCQUVOO2dCQUNBLElBQUkzbEIsWUFBWW9tQixXQUNkLE9BQ0UsZ0JBQWlCZCxjQUFjYyxTQUFTeGhCLFVBQVUsR0FDakQrZ0IsY0FBYzZELHVCQUNiN0QsYUFDQXVCLG1CQUNBZCxVQUNBbGEsUUFFRHNaLG1CQUFtQnlFLGVBQ3BCdEU7Z0JBRUosSUFBSTFpQixjQUFjbWpCLFdBQVc7b0JBQzNCNkQsZ0JBQWdCM0UsY0FBY2MsU0FBU3hoQixVQUFVO29CQUNqRDlFLE1BQU1tRCxjQUFjbWpCO29CQUNwQixJQUFJLGVBQWUsT0FBT3RtQixLQUN4QixNQUFNd0csTUFDSjtvQkFFSixJQUFJbWpCLGNBQWMzcEIsSUFBSWdJLElBQUksQ0FBQ3NlO29CQUMzQixJQUFJcUQsZ0JBQWdCckQsVUFBVTt3QkFDNUIsSUFDRSxNQUFNVCxZQUFZM2tCLEdBQUcsSUFDckIsaUNBQ0VpRixPQUFPMEIsU0FBUyxDQUFDb0wsUUFBUSxDQUFDakwsSUFBSSxDQUFDNmQsWUFBWXRpQixJQUFJLEtBQ2pELHlCQUNFNEMsT0FBTzBCLFNBQVMsQ0FBQ29MLFFBQVEsQ0FBQ2pMLElBQUksQ0FBQzJoQixjQUVqQ1MsMEJBQ0U1cEIsUUFBUWdDLEtBQUssQ0FDWCx5VEFFRDRuQix5QkFBeUIsQ0FBQztvQkFDakMsT0FDRTlELFNBQVMrRCxPQUFPLEtBQUtycUIsT0FDbkJzcUIsb0JBQ0M5cEIsQ0FBQUEsUUFBUWdDLEtBQUssQ0FDWiwwRkFFRDhuQixtQkFBbUIsQ0FBQyxDQUFDO29CQUMxQnpFLGNBQWNrRSwwQkFDWmxFLGFBQ0F1QixtQkFDQXVDLGFBQ0F2ZDtvQkFFRnNaLG1CQUFtQnlFO29CQUNuQixPQUFPdEU7Z0JBQ1Q7Z0JBQ0EsSUFBSSxlQUFlLE9BQU9TLFNBQVM3RixJQUFJLEVBQ3JDLE9BQ0UsZ0JBQWlCK0UsY0FBY2MsU0FBU3hoQixVQUFVLEdBQ2pEK2dCLGNBQWNxRSx5QkFDYnJFLGFBQ0F1QixtQkFDQXBCLGVBQWVNLFdBQ2ZsYSxRQUVEc1osbUJBQW1CeUUsZUFDcEJ0RTtnQkFFSixJQUFJUyxTQUFTOWlCLFFBQVEsS0FBS1Usb0JBQ3hCLE9BQU9nbUIseUJBQ0xyRSxhQUNBdUIsbUJBQ0E2QixnQ0FBZ0NwRCxhQUFhUyxXQUM3Q2xhO2dCQUVKaWEseUJBQXlCUixhQUFhUztZQUN4QztZQUNBLElBQ0UsYUFBYyxPQUFPQSxZQUFZLE9BQU9BLFlBQ3hDLGFBQWEsT0FBT0EsWUFDcEIsYUFBYSxPQUFPQSxVQUVwQixPQUNFLGdCQUFpQixLQUFLQSxVQUN0QixTQUFTYyxxQkFBcUIsTUFBTUEsa0JBQWtCbG1CLEdBQUcsR0FDcERpbUIsQ0FBQUEsd0JBQ0N0QixhQUNBdUIsa0JBQWtCcmMsT0FBTyxHQUUxQnFCLFFBQVFtYixTQUFTSCxtQkFBbUIrQyxnQkFDcEMvZCxNQUFNckgsTUFBTSxHQUFHOGdCLGFBQ2ZBLGNBQWN6WixLQUFLLElBQ25CK2EsQ0FBQUEsd0JBQXdCdEIsYUFBYXVCLG9CQUNyQ2hiLFFBQVE0YixvQkFDUG1DLGVBQ0F0RSxZQUFZemtCLElBQUksRUFDaEJnTCxRQUVEQSxNQUFNckgsTUFBTSxHQUFHOGdCLGFBQ2Z6WixNQUFNNmIsV0FBVyxHQUFHcEMsYUFDcEJ6WixNQUFNdEgsVUFBVSxHQUFHNGdCLGtCQUNuQkcsY0FBY3paLEtBQUssR0FDeEJ5YixpQkFBaUJoQztZQUVyQixlQUFlLE9BQU9TLFlBQ3BCRSxtQkFBbUJYLGFBQWFTO1lBQ2xDLGFBQWEsT0FBT0EsWUFBWU0saUJBQWlCZixhQUFhUztZQUM5RCxPQUFPYSx3QkFBd0J0QixhQUFhdUI7UUFDOUM7UUFDQSxPQUFPLFNBQVV2QixXQUFXLEVBQUV1QixpQkFBaUIsRUFBRWQsUUFBUSxFQUFFbGEsS0FBSztZQUM5RCxJQUFJK2QsZ0JBQWdCekU7WUFDcEJBLG1CQUFtQjtZQUNuQixJQUFJO2dCQUNGTyx5QkFBeUI7Z0JBQ3pCLElBQUlzRSxrQkFBa0JMLHlCQUNwQnJFLGFBQ0F1QixtQkFDQWQsVUFDQWxhO2dCQUVGOFosa0JBQWtCO2dCQUNsQixPQUFPcUU7WUFDVCxFQUFFLE9BQU8zbEIsR0FBRztnQkFDVixJQUFJQSxNQUFNeWdCLG1CQUFtQixNQUFNemdCO2dCQUNuQyxJQUFJdEYsUUFBUTJCLFlBQVksSUFBSTJELEdBQUcsTUFBTWloQixZQUFZemtCLElBQUk7Z0JBQ3JEOUIsTUFBTThNLEtBQUssR0FBR0E7Z0JBQ2Q5TSxNQUFNeUYsTUFBTSxHQUFHOGdCO2dCQUNmLElBQUkxYyxZQUFhN0osTUFBTXdGLFVBQVUsR0FBRzRnQjtnQkFDcENwbUIsTUFBTTJvQixXQUFXLEdBQUdwQyxZQUFZb0MsV0FBVztnQkFDM0MsSUFBSSxRQUFROWUsV0FDVjtvQkFBQSxJQUFLLElBQUl6SSxJQUFJeUksVUFBVXBKLE1BQU0sR0FBRyxHQUFHLEtBQUtXLEdBQUdBLElBQ3pDLElBQUksYUFBYSxPQUFPeUksU0FBUyxDQUFDekksRUFBRSxDQUFDZ0csS0FBSyxFQUFFO3dCQUMxQ3BILE1BQU0yb0IsV0FBVyxHQUFHOWUsU0FBUyxDQUFDekksRUFBRTt3QkFDaEM7b0JBQ0Y7Z0JBQUE7Z0JBQ0osT0FBT3BCO1lBQ1QsU0FBVTtnQkFDUm9tQixtQkFBbUJ5RTtZQUNyQjtRQUNGO0lBQ0Y7SUFDQSxTQUFTSyxrQkFBa0JsckIsS0FBSyxFQUFFbUMsT0FBTztRQUN2QyxJQUFJZ3BCLDJCQUEyQkM7UUFDL0IxbkIsS0FBSzJuQixnQ0FBZ0NGLDBCQUEwQm5yQjtRQUMvRDBELEtBQUs0bkIsOEJBQThCbnBCLFNBQVNuQztRQUM1Q29yQix1QkFBdUJELDJCQUEyQmhwQixRQUFRb3BCLFNBQVM7SUFDckU7SUFDQSxTQUFTQywwQkFBMEJ4ckIsS0FBSztRQUN0QzBELEtBQUsybkIsZ0NBQWdDRCxzQkFBc0JwckI7UUFDM0QwRCxLQUNFNG5CLDhCQUNBQSw2QkFBNkJ4b0IsT0FBTyxFQUNwQzlDO0lBRUo7SUFDQSxTQUFTeXJCLGlCQUFpQnpyQixLQUFLO1FBQzdCb3JCLHVCQUF1QkMsK0JBQStCdm9CLE9BQU87UUFDN0RxSixJQUFJbWYsOEJBQThCdHJCO1FBQ2xDbU0sSUFBSWtmLGdDQUFnQ3JyQjtJQUN0QztJQUNBLFNBQVMwckIsK0JBQStCMW9CLE9BQU87UUFDN0MsSUFBSUYsVUFBVUUsUUFBUWdJLFNBQVM7UUFDL0J0SCxLQUNFaW9CLHFCQUNBQSxvQkFBb0I3b0IsT0FBTyxHQUFHOG9CLDRCQUM5QjVvQjtRQUVGVSxLQUFLbW9CLDRCQUE0QjdvQixTQUFTQTtRQUMxQyxTQUFTOG9CLGlCQUNOLFVBQVNocEIsV0FBVyxTQUFTd29CLDZCQUE2QnhvQixPQUFPLEdBQzdEZ3BCLGdCQUFnQjlvQixVQUNqQixTQUFTRixRQUFRNUMsYUFBYSxJQUFLNHJCLENBQUFBLGdCQUFnQjlvQixPQUFNLENBQUM7SUFDbEU7SUFDQSxTQUFTK29CLDZCQUE2Qi9yQixLQUFLO1FBQ3pDLElBQUksT0FBT0EsTUFBTTRCLEdBQUcsRUFBRTtZQUNwQixJQUNHOEIsS0FBS2lvQixxQkFBcUJBLG9CQUFvQjdvQixPQUFPLEVBQUU5QyxRQUN4RDBELEtBQUttb0IsNEJBQTRCN3JCLE9BQU9BLFFBQ3hDLFNBQVM4ckIsZUFDVDtnQkFDQSxJQUFJaHBCLFVBQVU5QyxNQUFNZ0wsU0FBUztnQkFDN0IsU0FBU2xJLFdBQ1AsU0FBU0EsUUFBUTVDLGFBQWEsSUFDN0I0ckIsQ0FBQUEsZ0JBQWdCOXJCLEtBQUk7WUFDekI7UUFDRixPQUFPZ3NCLDRCQUE0QmhzQjtJQUNyQztJQUNBLFNBQVNnc0IsNEJBQTRCaHNCLEtBQUs7UUFDeEMwRCxLQUFLaW9CLHFCQUFxQkEsb0JBQW9CN29CLE9BQU8sRUFBRTlDO1FBQ3ZEMEQsS0FDRW1vQiw0QkFDQUEsMkJBQTJCL29CLE9BQU8sRUFDbEM5QztJQUVKO0lBQ0EsU0FBU2lzQixtQkFBbUJqc0IsS0FBSztRQUMvQm1NLElBQUkwZiw0QkFBNEI3ckI7UUFDaEM4ckIsa0JBQWtCOXJCLFNBQVU4ckIsQ0FBQUEsZ0JBQWdCLElBQUc7UUFDL0MzZixJQUFJd2YscUJBQXFCM3JCO0lBQzNCO0lBQ0EsU0FBU2tzQixtQkFBbUJDLEdBQUc7UUFDN0IsSUFBSyxJQUFJcmhCLE9BQU9xaEIsS0FBSyxTQUFTcmhCLE1BQVE7WUFDcEMsSUFBSSxPQUFPQSxLQUFLbEosR0FBRyxFQUFFO2dCQUNuQixJQUFJd3FCLFFBQVF0aEIsS0FBSzVLLGFBQWE7Z0JBQzlCLElBQ0UsU0FBU2tzQixTQUNSLFNBQVNBLE1BQU10UixVQUFVLEVBQzFCLFNBQVNzUixTQUNQQywwQkFBMEJELFVBQzFCRSwyQkFBMkJGLE1BQUssR0FFbEMsT0FBT3RoQjtZQUNYLE9BQU8sSUFDTCxPQUFPQSxLQUFLbEosR0FBRyxJQUNmLEtBQUssTUFBTWtKLEtBQUtrUCxhQUFhLENBQUN1UyxXQUFXLEVBQ3pDO2dCQUNBLElBQUksTUFBT3poQixDQUFBQSxLQUFLRyxLQUFLLEdBQUcsR0FBRSxHQUFJLE9BQU9IO1lBQ3ZDLE9BQU8sSUFBSSxTQUFTQSxLQUFLVSxLQUFLLEVBQUU7Z0JBQzlCVixLQUFLVSxLQUFLLENBQUMvRixNQUFNLEdBQUdxRjtnQkFDcEJBLE9BQU9BLEtBQUtVLEtBQUs7Z0JBQ2pCO1lBQ0Y7WUFDQSxJQUFJVixTQUFTcWhCLEtBQUs7WUFDbEIsTUFBTyxTQUFTcmhCLEtBQUtXLE9BQU8sRUFBSTtnQkFDOUIsSUFBSSxTQUFTWCxLQUFLckYsTUFBTSxJQUFJcUYsS0FBS3JGLE1BQU0sS0FBSzBtQixLQUFLLE9BQU87Z0JBQ3hEcmhCLE9BQU9BLEtBQUtyRixNQUFNO1lBQ3BCO1lBQ0FxRixLQUFLVyxPQUFPLENBQUNoRyxNQUFNLEdBQUdxRixLQUFLckYsTUFBTTtZQUNqQ3FGLE9BQU9BLEtBQUtXLE9BQU87UUFDckI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTK2dCO1FBQ1AsSUFBSUMsV0FBV0M7UUFDZixTQUFTQyxlQUNKQSxlQUFlO1lBQUNGO1NBQVMsR0FDMUJFLGFBQWFqcEIsSUFBSSxDQUFDK29CO0lBQ3hCO0lBQ0EsU0FBU0c7UUFDUCxJQUFJSCxXQUFXQztRQUNmLElBQ0UsU0FBU0MsZ0JBQ1JFLENBQUFBLDJCQUNERixZQUFZLENBQUNFLHdCQUF3QixLQUFLSixRQUFPLEdBQ2pEO1lBQ0EsSUFBSS9KLGdCQUFnQm5kLDBCQUNsQnVuQjtZQUVGLElBQ0UsQ0FBQ0Msd0NBQXdDL2MsR0FBRyxDQUFDMFMsa0JBQzVDcUssQ0FBQUEsd0NBQXdDbmQsR0FBRyxDQUFDOFMsZ0JBQzdDLFNBQVNpSyxZQUFXLEdBQ3BCO2dCQUNBLElBQUssSUFBSUssUUFBUSxJQUFJNXJCLElBQUksR0FBR0EsS0FBS3lyQix5QkFBeUJ6ckIsSUFBSztvQkFDN0QsSUFBSTZyQixjQUFjTixZQUFZLENBQUN2ckIsRUFBRSxFQUMvQjhyQixjQUNFOXJCLE1BQU15ckIsMEJBQTBCSixXQUFXUTtvQkFDL0MsSUFDRUEsY0FBYzdyQixJQUFJLElBQUksT0FBTzZyQixhQUM3QixLQUFLQSxZQUFZeHNCLE1BQU0sRUFHdkJ3c0IsZUFBZTtvQkFDakJBLGVBQWVDLGNBQWM7b0JBQzdCRixTQUFTQztnQkFDWDtnQkFDQS9yQixRQUFRZ0MsS0FBSyxDQUNYLCtXQUNBd2YsZUFDQXNLO1lBRUo7UUFDRjtJQUNGO0lBQ0EsU0FBU0cscUJBQXFCQyxJQUFJO1FBQ2hDLEtBQUssTUFBTUEsUUFDVCxTQUFTQSxRQUNUeHNCLFlBQVl3c0IsU0FDWmxzQixRQUFRZ0MsS0FBSyxDQUNYLG9JQUNBd3BCLHNCQUNBLE9BQU9VO0lBRWI7SUFDQSxTQUFTQztRQUNQLElBQUkzSyxnQkFBZ0JuZCwwQkFBMEJ1bkI7UUFDOUNRLHlCQUF5QnRkLEdBQUcsQ0FBQzBTLGtCQUMxQjRLLENBQUFBLHlCQUF5QjFkLEdBQUcsQ0FBQzhTLGdCQUM5QnhoQixRQUFRZ0MsS0FBSyxDQUNYLGlIQUNBd2YsY0FDRjtJQUNKO0lBQ0EsU0FBUzZLO1FBQ1AsTUFBTXJtQixNQUNKO0lBRUo7SUFDQSxTQUFTc21CLG1CQUFtQkMsUUFBUSxFQUFFQyxRQUFRO1FBQzVDLElBQUlDLDRCQUE0QixPQUFPLENBQUM7UUFDeEMsSUFBSSxTQUFTRCxVQUNYLE9BQ0V4c0IsUUFBUWdDLEtBQUssQ0FDWCw0S0FDQXdwQix1QkFFRixDQUFDO1FBRUxlLFNBQVNodEIsTUFBTSxLQUFLaXRCLFNBQVNqdEIsTUFBTSxJQUNqQ1MsUUFBUWdDLEtBQUssQ0FDWCxzSkFDQXdwQixzQkFDQSxNQUFNZ0IsU0FBUzlwQixJQUFJLENBQUMsUUFBUSxLQUM1QixNQUFNNnBCLFNBQVM3cEIsSUFBSSxDQUFDLFFBQVE7UUFFaEMsSUFBSyxJQUFJeEMsSUFBSSxHQUFHQSxJQUFJc3NCLFNBQVNqdEIsTUFBTSxJQUFJVyxJQUFJcXNCLFNBQVNodEIsTUFBTSxFQUFFVyxJQUMxRCxJQUFJLENBQUN3akIsU0FBUzZJLFFBQVEsQ0FBQ3JzQixFQUFFLEVBQUVzc0IsUUFBUSxDQUFDdHNCLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDbkQsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxTQUFTd3NCLGdCQUNQOXFCLE9BQU8sRUFDUDhHLGNBQWMsRUFDZGlrQixTQUFTLEVBQ1RwbkIsS0FBSyxFQUNMcW5CLFNBQVMsRUFDVEMsZUFBZTtRQUVmcmdCLGNBQWNxZ0I7UUFDZGpCLDRCQUE0QmxqQjtRQUM1QitpQixlQUFlLFNBQVM3cEIsVUFBVUEsUUFBUWtyQixlQUFlLEdBQUc7UUFDNURuQiwwQkFBMEIsQ0FBQztRQUMzQmMsNkJBQ0UsU0FBUzdxQixXQUFXQSxRQUFRbUIsSUFBSSxLQUFLMkYsZUFBZTNGLElBQUk7UUFDMUQsSUFDRSw2QkFDRTRDLE9BQU8wQixTQUFTLENBQUNvTCxRQUFRLENBQUNqTCxJQUFJLENBQUNtbEIsY0FDakMsc0NBQ0VobkIsT0FBTzBCLFNBQVMsQ0FBQ29MLFFBQVEsQ0FBQ2pMLElBQUksQ0FBQ21sQixZQUVqQyxrQkFBbUJ0b0IsMEJBQ2pCdW5CLDRCQUVBbUIsaUNBQWlDamUsR0FBRyxDQUFDK2Qsb0JBQ2xDRSxDQUFBQSxpQ0FBaUNyZSxHQUFHLENBQUNtZSxrQkFDdEM3c0IsUUFBUWdDLEtBQUssQ0FDWCwwTUFDRjtRQUNOMEcsZUFBZTFKLGFBQWEsR0FBRztRQUMvQjBKLGVBQWVnWSxXQUFXLEdBQUc7UUFDN0JoWSxlQUFla0QsS0FBSyxHQUFHO1FBQ3ZCN0UscUJBQXFCQyxDQUFDLEdBQ3BCLFNBQVNwRixXQUFXLFNBQVNBLFFBQVE1QyxhQUFhLEdBQzlDZ3VCLCtCQUNBLFNBQVN2QixlQUNQd0IsMkNBQ0FDO1FBQ1JDLHNDQUFzQ04sa0JBQ3BDLENBQUNua0IsZUFBZTlILElBQUksR0FBRyxPQUFPd3NCO1FBQ2hDLElBQUkvWSxXQUFXZ1osbUJBQW1CVixXQUFXcG5CLE9BQU9xbkI7UUFDcERPLHNDQUFzQyxDQUFDO1FBQ3ZDRyw4Q0FDR2paLENBQUFBLFdBQVdrWixxQkFDVjdrQixnQkFDQWlrQixXQUNBcG5CLE9BQ0FxbkIsVUFDRjtRQUNGLElBQUlDLGlCQUFpQjtZQUNuQnZjLDJCQUEyQixDQUFDO1lBQzVCLElBQUk7Z0JBQ0YrRCxXQUFXa1oscUJBQ1Q3a0IsZ0JBQ0Fpa0IsV0FDQXBuQixPQUNBcW5CO1lBRUosU0FBVTtnQkFDUnRjLDJCQUEyQixDQUFDO1lBQzlCO1FBQ0Y7UUFDQWtkLHFCQUFxQjVyQixTQUFTOEc7UUFDOUIsT0FBTzJMO0lBQ1Q7SUFDQSxTQUFTbVoscUJBQXFCNXJCLE9BQU8sRUFBRThHLGNBQWM7UUFDbkRBLGVBQWVva0IsZUFBZSxHQUFHckI7UUFDakMsU0FBUy9pQixlQUFlK2tCLFlBQVksR0FDaEMsU0FBU3JKLGlCQUNSMWIsQ0FBQUEsZUFBZStrQixZQUFZLEdBQUc7WUFDN0I3aEIsT0FBTztZQUNQOGhCLGNBQWM7WUFDZEMscUJBQXFCdko7UUFDdkIsS0FDQzFiLGVBQWUra0IsWUFBWSxDQUFDRSxtQkFBbUIsR0FBR3ZKO1FBQ3ZEcmQscUJBQXFCQyxDQUFDLEdBQUc0bUI7UUFDekIsSUFBSUMsdUJBQ0YsU0FBU0MsZUFBZSxTQUFTQSxZQUFZN3VCLElBQUk7UUFDbkR1TixjQUFjO1FBQ2RpZixlQUNFRCx1QkFDQXVDLHFCQUNBRCxjQUNBbEMsNEJBQ0U7UUFDSkQsMEJBQTBCLENBQUM7UUFDM0IsU0FBUy9wQixXQUNQLENBQUNBLFFBQVFtSSxLQUFLLEdBQUcsUUFBTyxNQUFRckIsQ0FBQUEsZUFBZXFCLEtBQUssR0FBRyxRQUFPLEtBQzlEL0osUUFBUWdDLEtBQUssQ0FDWDtRQUVKZ3NCLCtCQUErQixDQUFDO1FBQ2hDQyx1QkFBdUI7UUFDdkI3SixnQkFBZ0I7UUFDaEIsSUFBSXlKLHNCQUNGLE1BQU03bkIsTUFDSjtRQUVKLFNBQVNwRSxXQUNQc3NCLG9CQUNDLFdBQVd0c0IsUUFBUTZyQixZQUFZLEVBQ2hDLFNBQVM3ckIsV0FDUHVzQixzQkFBc0J2c0IsWUFDckJzc0IsQ0FBQUEsbUJBQW1CLENBQUMsRUFBQztRQUMxQnRKLG1DQUNLLG9DQUFvQyxDQUFDLEdBQUtoakIsVUFBVSxDQUFDLENBQUMsSUFDdERBLFVBQVUsQ0FBQztRQUNoQkEsV0FDRyxrQkFDQ3lDLDBCQUEwQnFFLG1CQUFtQixXQUMvQzBsQixpQ0FBaUN0ZixHQUFHLENBQUNwRyxtQkFDbkNxa0IsaUNBQWlDamUsR0FBRyxDQUFDcEcsbUJBQ3BDMGxCLENBQUFBLGlDQUFpQzFmLEdBQUcsQ0FBQ2hHLGlCQUN0QzFJLFFBQVFnQyxLQUFLLENBQ1gseUxBQ0YsQ0FBQztJQUNQO0lBQ0EsU0FBU3VyQixxQkFBcUI3a0IsY0FBYyxFQUFFaWtCLFNBQVMsRUFBRXBuQixLQUFLLEVBQUVxbkIsU0FBUztRQUN2RWhCLDRCQUE0QmxqQjtRQUM1QixJQUFJMmxCLG9CQUFvQjtRQUN4QixHQUFHO1lBQ0RmLDhDQUErQ2xKLENBQUFBLGdCQUFnQixJQUFHO1lBQ2xFNkosdUJBQXVCO1lBQ3ZCWCw2Q0FBNkMsQ0FBQztZQUM5QyxJQUFJZSxxQkFBcUJDLGlCQUN2QixNQUFNdG9CLE1BQ0o7WUFFSnFvQixxQkFBcUI7WUFDckI1Qiw2QkFBNkIsQ0FBQztZQUM5QnNCLHFCQUFxQkQsY0FBYztZQUNuQyxJQUFJLFFBQVFwbEIsZUFBZWdZLFdBQVcsRUFBRTtnQkFDdEMsSUFBSXJNLFdBQVczTCxlQUFlZ1ksV0FBVztnQkFDekNyTSxTQUFTa2EsVUFBVSxHQUFHO2dCQUN0QmxhLFNBQVNtYSxNQUFNLEdBQUc7Z0JBQ2xCbmEsU0FBU29hLE1BQU0sR0FBRztnQkFDbEIsUUFBUXBhLFNBQVNxYSxTQUFTLElBQUtyYSxDQUFBQSxTQUFTcWEsU0FBUyxDQUFDcnZCLEtBQUssR0FBRztZQUM1RDtZQUNBc3NCLDBCQUEwQixDQUFDO1lBQzNCNWtCLHFCQUFxQkMsQ0FBQyxHQUFHMm5CO1lBQ3pCdGEsV0FBV2daLG1CQUFtQlYsV0FBV3BuQixPQUFPcW5CO1FBQ2xELFFBQVNVLDRDQUE0QztRQUNyRCxPQUFPalo7SUFDVDtJQUNBLFNBQVN1YTtRQUNQLElBQUlDLGFBQWE5bkIscUJBQXFCQyxDQUFDLEVBQ3JDOG5CLGdCQUFnQkQsV0FBV0UsUUFBUSxFQUFFLENBQUMsRUFBRTtRQUMxQ0QsZ0JBQ0UsZUFBZSxPQUFPQSxjQUFjN08sSUFBSSxHQUNwQytPLFlBQVlGLGlCQUNaQTtRQUNORCxhQUFhQSxXQUFXRSxRQUFRLEVBQUUsQ0FBQyxFQUFFO1FBQ3BDLFVBQVNqQixjQUFjQSxZQUFZOXVCLGFBQWEsR0FBRyxJQUFHLE1BQ3JENnZCLGNBQWVqRCxDQUFBQSwwQkFBMEI3aEIsS0FBSyxJQUFJLElBQUc7UUFDdkQsT0FBTytrQjtJQUNUO0lBQ0EsU0FBU0c7UUFDUCxJQUFJQyxrQkFBa0IsTUFBTUM7UUFDNUJBLGlCQUFpQjtRQUNqQixPQUFPRDtJQUNUO0lBQ0EsU0FBU0UsYUFBYXh0QixPQUFPLEVBQUU4RyxjQUFjLEVBQUVrRCxLQUFLO1FBQ2xEbEQsZUFBZWdZLFdBQVcsR0FBRzllLFFBQVE4ZSxXQUFXO1FBQ2hEaFksZUFBZXFCLEtBQUssR0FDbEIsQ0FBQ3JCLGVBQWU5SCxJQUFJLEdBQUcsRUFBQyxNQUFPd3NCLFNBQzNCMWtCLGVBQWVxQixLQUFLLEdBQUcsQ0FBQyxZQUN4QnJCLGVBQWVxQixLQUFLLEdBQUcsQ0FBQztRQUM5Qm5JLFFBQVFnSyxLQUFLLElBQUksQ0FBQ0E7SUFDcEI7SUFDQSxTQUFTeWpCLG1CQUFtQjNtQixjQUFjO1FBQ3hDLElBQUlzbEIsOEJBQThCO1lBQ2hDLElBQ0V0bEIsaUJBQWlCQSxlQUFlMUosYUFBYSxFQUM3QyxTQUFTMEosZ0JBRVQ7Z0JBQ0EsSUFBSTJSLFFBQVEzUixlQUFlMlIsS0FBSztnQkFDaEMsU0FBU0EsU0FBVUEsQ0FBQUEsTUFBTUMsT0FBTyxHQUFHLElBQUc7Z0JBQ3RDNVIsaUJBQWlCQSxlQUFlekosSUFBSTtZQUN0QztZQUNBK3VCLCtCQUErQixDQUFDO1FBQ2xDO1FBQ0F4aEIsY0FBYztRQUNkaWYsZUFDRXNDLHFCQUNBRCxjQUNBbEMsNEJBQ0U7UUFDSkQsMEJBQTBCLENBQUM7UUFDM0JILHVCQUF1QjtRQUN2QjhCLDZDQUE2QyxDQUFDO1FBQzlDVyx1QkFBdUJrQixpQkFBaUI7UUFDeEMvSyxnQkFBZ0I7SUFDbEI7SUFDQSxTQUFTa0w7UUFDUCxJQUFJbGdCLE9BQU87WUFDVHBRLGVBQWU7WUFDZjJoQixXQUFXO1lBQ1g0TyxXQUFXO1lBQ1hsVixPQUFPO1lBQ1BwYixNQUFNO1FBQ1I7UUFDQSxTQUFTOHVCLHFCQUNKbkMsMEJBQTBCNXNCLGFBQWEsR0FBRyt1QixxQkFBcUIzZSxPQUMvRDJlLHFCQUFxQkEsbUJBQW1COXVCLElBQUksR0FBR21RO1FBQ3BELE9BQU8yZTtJQUNUO0lBQ0EsU0FBU3lCO1FBQ1AsSUFBSSxTQUFTMUIsYUFBYTtZQUN4QixJQUFJMkIsa0JBQWtCN0QsMEJBQTBCOWhCLFNBQVM7WUFDekQybEIsa0JBQ0UsU0FBU0Esa0JBQWtCQSxnQkFBZ0J6d0IsYUFBYSxHQUFHO1FBQy9ELE9BQU95d0Isa0JBQWtCM0IsWUFBWTd1QixJQUFJO1FBQ3pDLElBQUl5d0IseUJBQ0YsU0FBUzNCLHFCQUNMbkMsMEJBQTBCNXNCLGFBQWEsR0FDdkMrdUIsbUJBQW1COXVCLElBQUk7UUFDN0IsSUFBSSxTQUFTeXdCLHdCQUNYLHFCQUFzQkEsd0JBQ25CNUIsY0FBYzJCO2FBQ2Q7WUFDSCxJQUFJLFNBQVNBLGlCQUFpQjtnQkFDNUIsSUFBSSxTQUFTN0QsMEJBQTBCOWhCLFNBQVMsRUFDOUMsTUFBTTlELE1BQ0o7Z0JBRUosTUFBTUEsTUFBTTtZQUNkO1lBQ0E4bkIsY0FBYzJCO1lBQ2RBLGtCQUFrQjtnQkFDaEJ6d0IsZUFBZTh1QixZQUFZOXVCLGFBQWE7Z0JBQ3hDMmhCLFdBQVdtTixZQUFZbk4sU0FBUztnQkFDaEM0TyxXQUFXekIsWUFBWXlCLFNBQVM7Z0JBQ2hDbFYsT0FBT3lULFlBQVl6VCxLQUFLO2dCQUN4QnBiLE1BQU07WUFDUjtZQUNBLFNBQVM4dUIscUJBQ0puQywwQkFBMEI1c0IsYUFBYSxHQUFHK3VCLHFCQUN6QzBCLGtCQUNEMUIscUJBQXFCQSxtQkFBbUI5dUIsSUFBSSxHQUFHd3dCO1FBQ3REO1FBQ0EsT0FBTzFCO0lBQ1Q7SUFDQSxTQUFTaUIsWUFBWXRQLFFBQVE7UUFDM0IsSUFBSXJnQixRQUFRNHVCO1FBQ1pBLHdCQUF3QjtRQUN4QixTQUFTN0osaUJBQWtCQSxDQUFBQSxnQkFBZ0JOLHFCQUFvQjtRQUMvRHBFLFdBQVd5RSxrQkFBa0JDLGVBQWUxRSxVQUFVcmdCO1FBQ3REQSxRQUFRdXNCO1FBQ1IsU0FDRyxVQUFTbUMscUJBQ04xdUIsTUFBTUwsYUFBYSxHQUNuQit1QixtQkFBbUI5dUIsSUFBSSxLQUMxQixTQUFTSSxNQUFNeUssU0FBUyxFQUN4Qi9DLHFCQUFxQkMsQ0FBQyxHQUNyQixTQUFTM0gsU0FBUyxTQUFTQSxNQUFNTCxhQUFhLEdBQzFDZ3VCLCtCQUNBRSwyQkFBMkI7UUFDbkMsT0FBT3hOO0lBQ1Q7SUFDQSxTQUFTaVEsSUFBSUMsTUFBTTtRQUNqQixJQUFJLFNBQVNBLFVBQVUsYUFBYSxPQUFPQSxRQUFRO1lBQ2pELElBQUksZUFBZSxPQUFPQSxPQUFPM1AsSUFBSSxFQUFFLE9BQU8rTyxZQUFZWTtZQUMxRCxJQUFJQSxPQUFPNXNCLFFBQVEsS0FBS1Usb0JBQW9CLE9BQU9tc0IsWUFBWUQ7UUFDakU7UUFDQSxNQUFNNXBCLE1BQU0sOENBQThDZ1EsT0FBTzRaO0lBQ25FO0lBQ0EsU0FBU0UsYUFBYWpoQixJQUFJO1FBQ3hCLElBQUk2ZixZQUFZLE1BQ2RoTyxjQUFja0wsMEJBQTBCbEwsV0FBVztRQUNyRCxTQUFTQSxlQUFnQmdPLENBQUFBLFlBQVloTyxZQUFZZ08sU0FBUztRQUMxRCxJQUFJLFFBQVFBLFdBQVc7WUFDckIsSUFBSTlzQixVQUFVZ3FCLDBCQUEwQjloQixTQUFTO1lBQ2pELFNBQVNsSSxXQUNOLFdBQVdBLFFBQVE4ZSxXQUFXLEVBQy9CLFNBQVM5ZSxXQUNOLFdBQVdBLFFBQVE4c0IsU0FBUyxFQUM3QixRQUFROXNCLFdBQ0w4c0IsQ0FBQUEsWUFBWTtnQkFDWHFCLE1BQU1udUIsUUFBUW11QixJQUFJLENBQUNDLEdBQUcsQ0FBQyxTQUFVMXRCLEtBQUs7b0JBQ3BDLE9BQU9BLE1BQU0zQyxLQUFLO2dCQUNwQjtnQkFDQU4sT0FBTztZQUNULEVBQUMsQ0FBQztRQUNWO1FBQ0EsUUFBUXF2QixhQUFjQSxDQUFBQSxZQUFZO1lBQUVxQixNQUFNLEVBQUU7WUFBRTF3QixPQUFPO1FBQUU7UUFDdkQsU0FBU3FoQixlQUNOLGVBQWV1UCxzQ0FDZnJFLDBCQUEwQmxMLFdBQVcsR0FBR0EsV0FBVztRQUN0REEsWUFBWWdPLFNBQVMsR0FBR0E7UUFDeEJoTyxjQUFjZ08sVUFBVXFCLElBQUksQ0FBQ3JCLFVBQVVydkIsS0FBSyxDQUFDO1FBQzdDLElBQUksS0FBSyxNQUFNcWhCLGVBQWUrTCw0QkFDNUIsSUFDRS9MLGNBQWNnTyxVQUFVcUIsSUFBSSxDQUFDckIsVUFBVXJ2QixLQUFLLENBQUMsR0FBRzZ3QixNQUFNcmhCLE9BQ3BEak4sVUFBVSxHQUNaQSxVQUFVaU4sTUFDVmpOLFVBRUE4ZSxXQUFXLENBQUM5ZSxRQUFRLEdBQUd1dUI7YUFFekJ6UCxZQUFZbmhCLE1BQU0sS0FBS3NQLFFBQ3JCN08sUUFBUWdDLEtBQUssQ0FDWCxtSkFDQTBlLFlBQVluaEIsTUFBTSxFQUNsQnNQO1FBRU42ZixVQUFVcnZCLEtBQUs7UUFDZixPQUFPcWhCO0lBQ1Q7SUFDQSxTQUFTMFAsa0JBQWtCbEYsS0FBSyxFQUFFbUYsTUFBTTtRQUN0QyxPQUFPLGVBQWUsT0FBT0EsU0FBU0EsT0FBT25GLFNBQVNtRjtJQUN4RDtJQUNBLFNBQVNDLGFBQWFDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxJQUFJO1FBQzdDLElBQUlyaEIsT0FBT2tnQjtRQUNYLElBQUksS0FBSyxNQUFNbUIsTUFBTTtZQUNuQixJQUFJQyxlQUFlRCxLQUFLRDtZQUN4QixJQUFJckQscUNBQXFDO2dCQUN2QzdjLDJCQUEyQixDQUFDO2dCQUM1QixJQUFJO29CQUNGbWdCLEtBQUtEO2dCQUNQLFNBQVU7b0JBQ1JsZ0IsMkJBQTJCLENBQUM7Z0JBQzlCO1lBQ0Y7UUFDRixPQUFPb2dCLGVBQWVGO1FBQ3RCcGhCLEtBQUtwUSxhQUFhLEdBQUdvUSxLQUFLdVIsU0FBUyxHQUFHK1A7UUFDdENILFVBQVU7WUFDUmpXLFNBQVM7WUFDVDFPLE9BQU87WUFDUCtrQixVQUFVO1lBQ1ZDLHFCQUFxQkw7WUFDckJNLG1CQUFtQkg7UUFDckI7UUFDQXRoQixLQUFLaUwsS0FBSyxHQUFHa1c7UUFDYkEsVUFBVUEsUUFBUUksUUFBUSxHQUFHRyxzQkFBc0J2UyxJQUFJLENBQ3JELE1BQ0FxTiwyQkFDQTJFO1FBRUYsT0FBTztZQUFDbmhCLEtBQUtwUSxhQUFhO1lBQUV1eEI7U0FBUTtJQUN0QztJQUNBLFNBQVNRLGNBQWNSLE9BQU87UUFDNUIsSUFBSW5oQixPQUFPb2dCO1FBQ1gsT0FBT3dCLGtCQUFrQjVoQixNQUFNMGUsYUFBYXlDO0lBQzlDO0lBQ0EsU0FBU1Msa0JBQWtCNWhCLElBQUksRUFBRXhOLE9BQU8sRUFBRTJ1QixPQUFPO1FBQy9DLElBQUlsVyxRQUFRakwsS0FBS2lMLEtBQUs7UUFDdEIsSUFBSSxTQUFTQSxPQUNYLE1BQU1yVSxNQUNKO1FBRUpxVSxNQUFNdVcsbUJBQW1CLEdBQUdMO1FBQzVCLElBQUloQixZQUFZbmdCLEtBQUttZ0IsU0FBUyxFQUM1QmpOLGVBQWVqSSxNQUFNQyxPQUFPO1FBQzlCLElBQUksU0FBU2dJLGNBQWM7WUFDekIsSUFBSSxTQUFTaU4sV0FBVztnQkFDdEIsSUFBSTBCLFlBQVkxQixVQUFVdHdCLElBQUk7Z0JBQzlCc3dCLFVBQVV0d0IsSUFBSSxHQUFHcWpCLGFBQWFyakIsSUFBSTtnQkFDbENxakIsYUFBYXJqQixJQUFJLEdBQUdneUI7WUFDdEI7WUFDQXJ2QixRQUFRMnRCLFNBQVMsS0FBS0EsYUFDcEJ2dkIsUUFBUWdDLEtBQUssQ0FDWDtZQUVKSixRQUFRMnRCLFNBQVMsR0FBR0EsWUFBWWpOO1lBQ2hDakksTUFBTUMsT0FBTyxHQUFHO1FBQ2xCO1FBQ0FnSSxlQUFlbFQsS0FBS3VSLFNBQVM7UUFDN0IsSUFBSSxTQUFTNE8sV0FBV25nQixLQUFLcFEsYUFBYSxHQUFHc2pCO2FBQ3hDO1lBQ0gxZ0IsVUFBVTJ0QixVQUFVdHdCLElBQUk7WUFDeEIsSUFBSWl5QixvQkFBcUJELFlBQVksTUFDbkNFLG1CQUFtQixNQUNuQjd2QixTQUFTTSxTQUNUcWdCLGtDQUFrQyxDQUFDO1lBQ3JDLEdBQUc7Z0JBQ0QsSUFBSTlVLGFBQWE3TCxPQUFPb0ssSUFBSSxHQUFHLENBQUM7Z0JBQ2hDLElBQ0V5QixlQUFlN0wsT0FBT29LLElBQUksR0FDdEIsQ0FBQzZSLGdDQUFnQ3BRLFVBQVMsTUFBT0EsYUFDakQsQ0FBQ1gsY0FBY1csVUFBUyxNQUFPQSxZQUNuQztvQkFDQSxJQUFJaWtCLGFBQWE5dkIsT0FBTzh2QixVQUFVO29CQUNsQyxJQUFJLE1BQU1BLFlBQ1IsU0FBU0Qsb0JBQ05BLENBQUFBLG1CQUFtQkEsaUJBQWlCbHlCLElBQUksR0FDdkM7d0JBQ0V5TSxNQUFNO3dCQUNOMGxCLFlBQVk7d0JBQ1pmLFFBQVEvdUIsT0FBTyt1QixNQUFNO3dCQUNyQmdCLGVBQWUvdkIsT0FBTyt2QixhQUFhO3dCQUNuQ0MsWUFBWWh3QixPQUFPZ3dCLFVBQVU7d0JBQzdCcnlCLE1BQU07b0JBQ1IsSUFDRmtPLGVBQWUyUyx3QkFDWm1DLENBQUFBLGtDQUFrQyxDQUFDO3lCQUNyQyxJQUFJLENBQUN6VixjQUFjNGtCLFVBQVMsTUFBT0EsWUFBWTt3QkFDbEQ5dkIsU0FBU0EsT0FBT3JDLElBQUk7d0JBQ3BCbXlCLGVBQWV0Uix3QkFDWm1DLENBQUFBLGtDQUFrQyxDQUFDO3dCQUN0QztvQkFDRixPQUNFLGFBQWM7d0JBQ1p2VyxNQUFNO3dCQUNOMGxCLFlBQVk5dkIsT0FBTzh2QixVQUFVO3dCQUM3QmYsUUFBUS91QixPQUFPK3VCLE1BQU07d0JBQ3JCZ0IsZUFBZS92QixPQUFPK3ZCLGFBQWE7d0JBQ25DQyxZQUFZaHdCLE9BQU9nd0IsVUFBVTt3QkFDN0JyeUIsTUFBTTtvQkFDUixHQUNFLFNBQVNreUIsbUJBQ0oscUJBQXFCQSxtQkFBbUJoa0IsWUFDeEM4akIsWUFBWTNPLFlBQVksSUFDeEI2TyxtQkFBbUJBLGlCQUFpQmx5QixJQUFJLEdBQUdrTyxZQUMvQ3llLDBCQUEwQmhnQixLQUFLLElBQUl3bEIsWUFDbkNqTyxrQ0FBa0NpTztvQkFDdkNqa0IsYUFBYTdMLE9BQU8rdUIsTUFBTTtvQkFDMUJsRCx1Q0FDRW9ELFFBQVFqTyxjQUFjblY7b0JBQ3hCbVYsZUFBZWhoQixPQUFPK3ZCLGFBQWEsR0FDL0IvdkIsT0FBT2d3QixVQUFVLEdBQ2pCZixRQUFRak8sY0FBY25WO2dCQUM1QixPQUNFLGFBQWM7b0JBQ1p6QixNQUFNeUI7b0JBQ05pa0IsWUFBWTl2QixPQUFPOHZCLFVBQVU7b0JBQzdCZixRQUFRL3VCLE9BQU8rdUIsTUFBTTtvQkFDckJnQixlQUFlL3ZCLE9BQU8rdkIsYUFBYTtvQkFDbkNDLFlBQVlod0IsT0FBT2d3QixVQUFVO29CQUM3QnJ5QixNQUFNO2dCQUNSLEdBQ0UsU0FBU2t5QixtQkFDSixxQkFBcUJBLG1CQUFtQkMsWUFDeENILFlBQVkzTyxZQUFZLElBQ3hCNk8sbUJBQW1CQSxpQkFBaUJseUIsSUFBSSxHQUFHbXlCLFlBQy9DeEYsMEJBQTBCaGdCLEtBQUssSUFBSXVCLFlBQ25DZ1csa0NBQWtDaFc7Z0JBQ3ZDN0wsU0FBU0EsT0FBT3JDLElBQUk7WUFDdEIsUUFBUyxTQUFTcUMsVUFBVUEsV0FBV00sU0FBUztZQUNoRCxTQUFTdXZCLG1CQUNKRixZQUFZM08sZUFDWjZPLGlCQUFpQmx5QixJQUFJLEdBQUdpeUI7WUFDN0IsSUFDRSxDQUFDeE4sU0FBU3BCLGNBQWNsVCxLQUFLcFEsYUFBYSxLQUN6QyxvQkFBb0IsQ0FBQyxHQUN0QmlqQixtQ0FDRyxXQUFXbEMsZ0NBQWlDLFNBQVN3USxPQUFNLENBQUMsR0FFL0QsTUFBTUE7WUFDUm5oQixLQUFLcFEsYUFBYSxHQUFHc2pCO1lBQ3JCbFQsS0FBS3VSLFNBQVMsR0FBR3NRO1lBQ2pCN2hCLEtBQUttZ0IsU0FBUyxHQUFHNEI7WUFDakI5VyxNQUFNd1csaUJBQWlCLEdBQUd2TztRQUM1QjtRQUNBLFNBQVNpTixhQUFjbFYsQ0FBQUEsTUFBTXpPLEtBQUssR0FBRztRQUNyQyxPQUFPO1lBQUN3RCxLQUFLcFEsYUFBYTtZQUFFcWIsTUFBTXNXLFFBQVE7U0FBQztJQUM3QztJQUNBLFNBQVNZLGdCQUFnQmhCLE9BQU87UUFDOUIsSUFBSW5oQixPQUFPb2dCLDRCQUNUblYsUUFBUWpMLEtBQUtpTCxLQUFLO1FBQ3BCLElBQUksU0FBU0EsT0FDWCxNQUFNclUsTUFDSjtRQUVKcVUsTUFBTXVXLG1CQUFtQixHQUFHTDtRQUM1QixJQUFJSSxXQUFXdFcsTUFBTXNXLFFBQVEsRUFDM0JhLHdCQUF3Qm5YLE1BQU1DLE9BQU8sRUFDckNtSSxXQUFXclQsS0FBS3BRLGFBQWE7UUFDL0IsSUFBSSxTQUFTd3lCLHVCQUF1QjtZQUNsQ25YLE1BQU1DLE9BQU8sR0FBRztZQUNoQixJQUFJaFosU0FBVWt3Qix3QkFBd0JBLHNCQUFzQnZ5QixJQUFJO1lBQ2hFLEdBQ0UsV0FBWXN4QixRQUFROU4sVUFBVW5oQixPQUFPK3VCLE1BQU0sR0FBSy91QixTQUFTQSxPQUFPckMsSUFBSTttQkFDL0RxQyxXQUFXa3dCLHVCQUF1QjtZQUN6QzlOLFNBQVNqQixVQUFVclQsS0FBS3BRLGFBQWEsS0FBTWt2QixDQUFBQSxtQkFBbUIsQ0FBQztZQUMvRDllLEtBQUtwUSxhQUFhLEdBQUd5akI7WUFDckIsU0FBU3JULEtBQUttZ0IsU0FBUyxJQUFLbmdCLENBQUFBLEtBQUt1UixTQUFTLEdBQUc4QixRQUFPO1lBQ3BEcEksTUFBTXdXLGlCQUFpQixHQUFHcE87UUFDNUI7UUFDQSxPQUFPO1lBQUNBO1lBQVVrTztTQUFTO0lBQzdCO0lBQ0EsU0FBU2MsdUJBQXVCQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsaUJBQWlCO1FBQ3ZFLElBQUk5eUIsUUFBUThzQiwyQkFDVnhjLE9BQU9rZ0I7UUFDVCxJQUFJMWMsYUFBYTtZQUNmLElBQUksS0FBSyxNQUFNZ2YsbUJBQ2IsTUFBTTVyQixNQUNKO1lBRUosSUFBSTZyQixlQUFlRDtZQUNuQkUsOEJBQ0VELGlCQUFpQkQsdUJBQ2hCNXhCLENBQUFBLFFBQVFnQyxLQUFLLENBQ1osK0VBRUQ4dkIsNkJBQTZCLENBQUMsQ0FBQztRQUNwQyxPQUFPO1lBQ0xELGVBQWVGO1lBQ2ZHLDhCQUNHLHFCQUFxQkgsZUFDdEJqTyxTQUFTbU8sY0FBY0Qsc0JBQ3BCNXhCLENBQUFBLFFBQVFnQyxLQUFLLENBQ1oseUVBRUQ4dkIsNkJBQTZCLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksU0FBU3RVLG9CQUNYLE1BQU14WCxNQUNKO1lBRUosTUFBT3VYLENBQUFBLGdDQUFnQyxFQUFDLEtBQ3RDd1UsMEJBQTBCanpCLE9BQU82eUIsYUFBYUU7UUFDbEQ7UUFDQXppQixLQUFLcFEsYUFBYSxHQUFHNnlCO1FBQ3JCRCxvQkFBb0I7WUFBRXR5QixPQUFPdXlCO1lBQWNGLGFBQWFBO1FBQVk7UUFDcEV2aUIsS0FBS2lMLEtBQUssR0FBR3VYO1FBQ2JJLFlBQ0VDLGlCQUFpQjFULElBQUksQ0FBQyxNQUFNemYsT0FBTzh5QixtQkFBbUJGLFlBQ3REO1lBQUNBO1NBQVU7UUFFYjV5QixNQUFNaUwsS0FBSyxJQUFJO1FBQ2Ztb0IsV0FDRUMsWUFBWUMsU0FDWkMsb0JBQW9COVQsSUFBSSxDQUN0QixNQUNBemYsT0FDQTh5QixtQkFDQUMsY0FDQUYsY0FFRjtZQUFFVyxTQUFTLEtBQUs7UUFBRSxHQUNsQjtRQUVGLE9BQU9UO0lBQ1Q7SUFDQSxTQUFTVSx3QkFDUGIsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLGlCQUFpQjtRQUVqQixJQUFJOXlCLFFBQVE4c0IsMkJBQ1Z4YyxPQUFPb2dCLDRCQUNQZ0QsdUJBQXVCNWY7UUFDekIsSUFBSTRmLHNCQUFzQjtZQUN4QixJQUFJLEtBQUssTUFBTVosbUJBQ2IsTUFBTTVyQixNQUNKO1lBRUo0ckIsb0JBQW9CQTtRQUN0QixPQUFPLElBQ0osb0JBQXFCRCxlQUFnQixDQUFDRyw0QkFDdkM7WUFDQSxJQUFJVyxpQkFBaUJkO1lBQ3JCak8sU0FBU2tPLG1CQUFtQmEsbUJBQ3pCenlCLENBQUFBLFFBQVFnQyxLQUFLLENBQ1oseUVBRUQ4dkIsNkJBQTZCLENBQUMsQ0FBQztRQUNwQztRQUNBLElBQ0dXLGlCQUFpQixDQUFDL08sU0FDakIsQ0FBQ29LLGVBQWUxZSxJQUFHLEVBQUdwUSxhQUFhLEVBQ25DNHlCLG9CQUdGLEtBQU01eUIsYUFBYSxHQUFHNHlCLG1CQUFxQjFELG1CQUFtQixDQUFDO1FBQ2pFOWUsT0FBT0EsS0FBS2lMLEtBQUs7UUFDakIsSUFBSXFZLFNBQVNULGlCQUFpQjFULElBQUksQ0FBQyxNQUFNemYsT0FBT3NRLE1BQU1zaUI7UUFDdERpQixpQkFBaUIsTUFBTVAsU0FBU00sUUFBUTtZQUFDaEI7U0FBVTtRQUNuRCxJQUNFdGlCLEtBQUt1aUIsV0FBVyxLQUFLQSxlQUNyQmMsa0JBQ0MsU0FBUzFFLHNCQUNSQSxtQkFBbUIvdUIsYUFBYSxDQUFDMEIsR0FBRyxHQUFHeXhCLFdBQ3pDO1lBQ0FyekIsTUFBTWlMLEtBQUssSUFBSTtZQUNmbW9CLFdBQ0VDLFlBQVlDLFNBQ1pDLG9CQUFvQjlULElBQUksQ0FDdEIsTUFDQXpmLE9BQ0FzUSxNQUNBd2lCLG1CQUNBRCxjQUVGO2dCQUFFVyxTQUFTLEtBQUs7WUFBRSxHQUNsQjtZQUVGLElBQUksU0FBUzlVLG9CQUNYLE1BQU14WCxNQUNKO1lBRUp3c0Isd0JBQ0UsTUFBT2htQixDQUFBQSxjQUFjLEVBQUMsS0FDdEJ1bEIsMEJBQTBCanpCLE9BQU82eUIsYUFBYUM7UUFDbEQ7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsU0FBU0csMEJBQTBCanpCLEtBQUssRUFBRTZ5QixXQUFXLEVBQUVpQixnQkFBZ0I7UUFDckU5ekIsTUFBTWlMLEtBQUssSUFBSTtRQUNmakwsUUFBUTtZQUFFNnlCLGFBQWFBO1lBQWFyeUIsT0FBT3N6QjtRQUFpQjtRQUM1RGpCLGNBQWMvRiwwQkFBMEJsTCxXQUFXO1FBQ25ELFNBQVNpUixjQUNKLGVBQWUxQixzQ0FDZnJFLDBCQUEwQmxMLFdBQVcsR0FBR2lSLGFBQ3hDQSxZQUFZbEQsTUFBTSxHQUFHO1lBQUMzdkI7U0FBTSxJQUM1QixvQkFBb0I2eUIsWUFBWWxELE1BQU0sRUFDdkMsU0FBU21FLG1CQUNKakIsWUFBWWxELE1BQU0sR0FBRztZQUFDM3ZCO1NBQU0sR0FDN0I4ekIsaUJBQWlCcHdCLElBQUksQ0FBQzFELE1BQUs7SUFDckM7SUFDQSxTQUFTdXpCLG9CQUFvQnZ6QixLQUFLLEVBQUUrekIsSUFBSSxFQUFFaEIsWUFBWSxFQUFFRixXQUFXO1FBQ2pFa0IsS0FBS3Z6QixLQUFLLEdBQUd1eUI7UUFDYmdCLEtBQUtsQixXQUFXLEdBQUdBO1FBQ25CbUIsdUJBQXVCRCxTQUFTRSxtQkFBbUJqMEI7SUFDckQ7SUFDQSxTQUFTbXpCLGlCQUFpQm56QixLQUFLLEVBQUUrekIsSUFBSSxFQUFFbkIsU0FBUztRQUM5QyxPQUFPQSxVQUFVO1lBQ2ZvQix1QkFBdUJELFNBQVNFLG1CQUFtQmowQjtRQUNyRDtJQUNGO0lBQ0EsU0FBU2cwQix1QkFBdUJELElBQUk7UUFDbEMsSUFBSUcsb0JBQW9CSCxLQUFLbEIsV0FBVztRQUN4Q2tCLE9BQU9BLEtBQUt2ekIsS0FBSztRQUNqQixJQUFJO1lBQ0YsSUFBSTJ6QixZQUFZRDtZQUNoQixPQUFPLENBQUN0UCxTQUFTbVAsTUFBTUk7UUFDekIsRUFBRSxPQUFPanhCLE9BQU87WUFDZCxPQUFPLENBQUM7UUFDVjtJQUNGO0lBQ0EsU0FBUyt3QixtQkFBbUJqMEIsS0FBSztRQUMvQixJQUFJaUMsT0FBTzRaLCtCQUErQjdiLE9BQU87UUFDakQsU0FBU2lDLFFBQVFteUIsc0JBQXNCbnlCLE1BQU1qQyxPQUFPO0lBQ3REO0lBQ0EsU0FBU3EwQixlQUFlekMsWUFBWTtRQUNsQyxJQUFJdGhCLE9BQU9rZ0I7UUFDWCxJQUFJLGVBQWUsT0FBT29CLGNBQWM7WUFDdEMsSUFBSTBDLDBCQUEwQjFDO1lBQzlCQSxlQUFlMEM7WUFDZixJQUFJakcscUNBQXFDO2dCQUN2QzdjLDJCQUEyQixDQUFDO2dCQUM1QixJQUFJO29CQUNGOGlCO2dCQUNGLFNBQVU7b0JBQ1I5aUIsMkJBQTJCLENBQUM7Z0JBQzlCO1lBQ0Y7UUFDRjtRQUNBbEIsS0FBS3BRLGFBQWEsR0FBR29RLEtBQUt1UixTQUFTLEdBQUcrUDtRQUN0Q3RoQixLQUFLaUwsS0FBSyxHQUFHO1lBQ1hDLFNBQVM7WUFDVDFPLE9BQU87WUFDUCtrQixVQUFVO1lBQ1ZDLHFCQUFxQlI7WUFDckJTLG1CQUFtQkg7UUFDckI7UUFDQSxPQUFPdGhCO0lBQ1Q7SUFDQSxTQUFTaWtCLFdBQVczQyxZQUFZO1FBQzlCQSxlQUFleUMsZUFBZXpDO1FBQzlCLElBQUlyVyxRQUFRcVcsYUFBYXJXLEtBQUssRUFDNUJzVyxXQUFXMkMsaUJBQWlCL1UsSUFBSSxDQUM5QixNQUNBcU4sMkJBQ0F2UjtRQUVKQSxNQUFNc1csUUFBUSxHQUFHQTtRQUNqQixPQUFPO1lBQUNELGFBQWExeEIsYUFBYTtZQUFFMnhCO1NBQVM7SUFDL0M7SUFDQSxTQUFTNEMsZ0JBQWdCQyxXQUFXO1FBQ2xDLElBQUlwa0IsT0FBT2tnQjtRQUNYbGdCLEtBQUtwUSxhQUFhLEdBQUdvUSxLQUFLdVIsU0FBUyxHQUFHNlM7UUFDdEMsSUFBSW5aLFFBQVE7WUFDVkMsU0FBUztZQUNUMU8sT0FBTztZQUNQK2tCLFVBQVU7WUFDVkMscUJBQXFCO1lBQ3JCQyxtQkFBbUI7UUFDckI7UUFDQXpoQixLQUFLaUwsS0FBSyxHQUFHQTtRQUNiakwsT0FBT3FrQiwyQkFBMkJsVixJQUFJLENBQ3BDLE1BQ0FxTiwyQkFDQSxDQUFDLEdBQ0R2UjtRQUVGQSxNQUFNc1csUUFBUSxHQUFHdmhCO1FBQ2pCLE9BQU87WUFBQ29rQjtZQUFhcGtCO1NBQUs7SUFDNUI7SUFDQSxTQUFTc2tCLGlCQUFpQkYsV0FBVyxFQUFFakQsT0FBTztRQUM1QyxJQUFJbmhCLE9BQU9vZ0I7UUFDWCxPQUFPbUUscUJBQXFCdmtCLE1BQU0wZSxhQUFhMEYsYUFBYWpEO0lBQzlEO0lBQ0EsU0FBU29ELHFCQUFxQnZrQixJQUFJLEVBQUV4TixPQUFPLEVBQUU0eEIsV0FBVyxFQUFFakQsT0FBTztRQUMvRG5oQixLQUFLdVIsU0FBUyxHQUFHNlM7UUFDakIsT0FBT3hDLGtCQUNMNWhCLE1BQ0EwZSxhQUNBLGVBQWUsT0FBT3lDLFVBQVVBLFVBQVVIO0lBRTlDO0lBQ0EsU0FBU3dELG1CQUFtQkosV0FBVyxFQUFFakQsT0FBTztRQUM5QyxJQUFJbmhCLE9BQU9vZ0I7UUFDWCxJQUFJLFNBQVMxQixhQUNYLE9BQU82RixxQkFBcUJ2a0IsTUFBTTBlLGFBQWEwRixhQUFhakQ7UUFDOURuaEIsS0FBS3VSLFNBQVMsR0FBRzZTO1FBQ2pCLE9BQU87WUFBQ0E7WUFBYXBrQixLQUFLaUwsS0FBSyxDQUFDc1csUUFBUTtTQUFDO0lBQzNDO0lBQ0EsU0FBU2tELG9CQUNQLzBCLEtBQUssRUFDTGcxQixXQUFXLEVBQ1hDLGVBQWUsRUFDZkMsUUFBUSxFQUNSNVMsT0FBTztRQUVQLElBQUk2UyxvQkFBb0JuMUIsUUFDdEIsTUFBTWtILE1BQU07UUFDZGxILFFBQVFnMUIsWUFBWXpELE1BQU07UUFDMUIsSUFBSSxTQUFTdnhCLE9BQU87WUFDbEIsSUFBSW8xQixhQUFhO2dCQUNmOVMsU0FBU0E7Z0JBQ1RpUCxRQUFRdnhCO2dCQUNSRyxNQUFNO2dCQUNOazFCLGNBQWMsQ0FBQztnQkFDZm5VLFFBQVE7Z0JBQ1IxZ0IsT0FBTztnQkFDUGtoQixRQUFRO2dCQUNSSixXQUFXLEVBQUU7Z0JBQ2JILE1BQU0sU0FBVW1VLFFBQVE7b0JBQ3RCRixXQUFXOVQsU0FBUyxDQUFDNWQsSUFBSSxDQUFDNHhCO2dCQUM1QjtZQUNGO1lBQ0EsU0FBU3J0QixxQkFBcUJzdEIsQ0FBQyxHQUMzQk4sZ0JBQWdCLENBQUMsS0FDaEJHLFdBQVdDLFlBQVksR0FBRyxDQUFDO1lBQ2hDSCxTQUFTRTtZQUNUSCxrQkFBa0JELFlBQVl4WixPQUFPO1lBQ3JDLFNBQVN5WixrQkFDSixZQUFZOTBCLElBQUksR0FBRzYwQixZQUFZeFosT0FBTyxHQUFHNFosWUFDMUNJLHFCQUFxQlIsYUFBYUksV0FBVSxJQUMzQyxZQUFZajFCLElBQUksR0FBRzgwQixnQkFBZ0I5MEIsSUFBSSxFQUN2QzYwQixZQUFZeFosT0FBTyxHQUFHeVosZ0JBQWdCOTBCLElBQUksR0FBR2kxQixVQUFVO1FBQzlEO0lBQ0Y7SUFDQSxTQUFTSSxxQkFBcUJSLFdBQVcsRUFBRWxxQixJQUFJO1FBQzdDLElBQUl5bUIsU0FBU3ptQixLQUFLeW1CLE1BQU0sRUFDdEJqUCxVQUFVeFgsS0FBS3dYLE9BQU8sRUFDdEJtVCxZQUFZVCxZQUFZNUksS0FBSztRQUMvQixJQUFJdGhCLEtBQUt1cUIsWUFBWSxFQUFFO1lBQ3JCLElBQUlLLGlCQUFpQnp0QixxQkFBcUJzdEIsQ0FBQyxFQUN6Q0ksb0JBQW9CLENBQUM7WUFDdkIxdEIscUJBQXFCc3RCLENBQUMsR0FBR0k7WUFDekIxdEIscUJBQXFCc3RCLENBQUMsQ0FBQ0ssY0FBYyxHQUFHLElBQUl6TDtZQUM1QyxJQUFJO2dCQUNGLElBQUkwTCxjQUFjdEUsT0FBT2tFLFdBQVduVCxVQUNsQ3dULDBCQUEwQjd0QixxQkFBcUI4dEIsQ0FBQztnQkFDbEQsU0FBU0QsMkJBQ1BBLHdCQUF3QkgsbUJBQW1CRTtnQkFDN0NHLHdCQUF3QmhCLGFBQWFscUIsTUFBTStxQjtZQUM3QyxFQUFFLE9BQU8zeUIsT0FBTztnQkFDZCt5QixjQUFjakIsYUFBYWxxQixNQUFNNUg7WUFDbkMsU0FBVTtnQkFDUCtFLHFCQUFxQnN0QixDQUFDLEdBQUdHLGdCQUN4QixTQUFTQSxrQkFDUEMsa0JBQWtCQyxjQUFjLElBQy9CLGVBQWVELGtCQUFrQkMsY0FBYyxDQUFDN2xCLElBQUksRUFDckQ0bEIsa0JBQWtCQyxjQUFjLENBQUMzbEIsS0FBSyxJQUN0QyxLQUFLK2tCLGVBQ0g5ekIsUUFBUUMsSUFBSSxDQUNWLHNNQUNGO1lBQ1I7UUFDRixPQUNFLElBQUk7WUFDRHcwQixvQkFBb0JwRSxPQUFPa0UsV0FBV25ULFVBQ3JDMFQsd0JBQXdCaEIsYUFBYWxxQixNQUFNNnFCO1FBQy9DLEVBQUUsT0FBT08sU0FBUztZQUNoQkQsY0FBY2pCLGFBQWFscUIsTUFBTW9yQjtRQUNuQztJQUNKO0lBQ0EsU0FBU0Ysd0JBQXdCaEIsV0FBVyxFQUFFbHFCLElBQUksRUFBRStxQixXQUFXO1FBQzdELFNBQVNBLGVBQ1QsYUFBYSxPQUFPQSxlQUNwQixlQUFlLE9BQU9BLFlBQVkxVSxJQUFJLEdBQ2pDMFUsQ0FBQUEsWUFBWTFVLElBQUksQ0FDZixTQUFVK0MsU0FBUztZQUNqQmlTLGdCQUFnQm5CLGFBQWFscUIsTUFBTW9aO1FBQ3JDLEdBQ0EsU0FBVWhoQixLQUFLO1lBQ2IsT0FBTyt5QixjQUFjakIsYUFBYWxxQixNQUFNNUg7UUFDMUMsSUFFRjRILEtBQUt1cUIsWUFBWSxJQUNmbjBCLFFBQVFnQyxLQUFLLENBQ1gsaVBBQ0YsSUFDRml6QixnQkFBZ0JuQixhQUFhbHFCLE1BQU0rcUI7SUFDekM7SUFDQSxTQUFTTSxnQkFBZ0JuQixXQUFXLEVBQUVJLFVBQVUsRUFBRWxSLFNBQVM7UUFDekRrUixXQUFXbFUsTUFBTSxHQUFHO1FBQ3BCa1UsV0FBVzUwQixLQUFLLEdBQUcwakI7UUFDbkJrUyxzQkFBc0JoQjtRQUN0QkosWUFBWTVJLEtBQUssR0FBR2xJO1FBQ3BCa1IsYUFBYUosWUFBWXhaLE9BQU87UUFDaEMsU0FBUzRaLGNBQ04sYUFBYUEsV0FBV2oxQixJQUFJLEVBQzdCK2pCLGNBQWNrUixhQUNUSixZQUFZeFosT0FBTyxHQUFHLE9BQ3RCLGFBQWEwSSxVQUFVL2pCLElBQUksRUFDM0JpMUIsV0FBV2oxQixJQUFJLEdBQUcrakIsV0FDbkJzUixxQkFBcUJSLGFBQWE5USxVQUFTLENBQUM7SUFDcEQ7SUFDQSxTQUFTK1IsY0FBY2pCLFdBQVcsRUFBRUksVUFBVSxFQUFFbHlCLEtBQUs7UUFDbkQsSUFBSW16QixPQUFPckIsWUFBWXhaLE9BQU87UUFDOUJ3WixZQUFZeFosT0FBTyxHQUFHO1FBQ3RCLElBQUksU0FBUzZhLE1BQU07WUFDakJBLE9BQU9BLEtBQUtsMkIsSUFBSTtZQUNoQixHQUNFLFdBQVkrZ0IsTUFBTSxHQUFHLFlBQ2xCa1UsV0FBVzFULE1BQU0sR0FBR3hlLE9BQ3JCa3pCLHNCQUFzQmhCLGFBQ3JCQSxhQUFhQSxXQUFXajFCLElBQUk7bUJBQzFCaTFCLGVBQWVpQixNQUFNO1FBQzlCO1FBQ0FyQixZQUFZekQsTUFBTSxHQUFHO0lBQ3ZCO0lBQ0EsU0FBUzZFLHNCQUFzQmhCLFVBQVU7UUFDdkNBLGFBQWFBLFdBQVc5VCxTQUFTO1FBQ2pDLElBQUssSUFBSWxnQixJQUFJLEdBQUdBLElBQUlnMEIsV0FBVzMwQixNQUFNLEVBQUVXLElBQUssQ0FBQyxHQUFHZzBCLFVBQVUsQ0FBQ2gwQixFQUFFO0lBQy9EO0lBQ0EsU0FBU2sxQixtQkFBbUJDLFFBQVEsRUFBRTVTLFFBQVE7UUFDNUMsT0FBT0E7SUFDVDtJQUNBLFNBQVM2UyxpQkFBaUJqRixNQUFNLEVBQUVrRixnQkFBZ0I7UUFDaEQsSUFBSTNpQixhQUFhO1lBQ2YsSUFBSTRpQixlQUFlaFksbUJBQW1CaVksU0FBUztZQUMvQyxJQUFJLFNBQVNELGNBQWM7Z0JBQ3pCdHJCLEdBQUc7b0JBQ0QsSUFBSXdyQixhQUFhOUo7b0JBQ2pCLElBQUloWixhQUFhO3dCQUNmLElBQUkyRyx3QkFBd0I7NEJBQzFCLElBQUlvYyxpQkFBaUJDLDBCQUNuQnJjLHdCQUNBTjs0QkFFRixJQUFJMGMsZ0JBQWdCO2dDQUNsQnBjLHlCQUNFSSx5QkFBeUJnYztnQ0FDM0JELGFBQWFHLDBCQUEwQkY7Z0NBQ3ZDLE1BQU16ckI7NEJBQ1I7d0JBQ0Y7d0JBQ0FtTyx5QkFBeUJxZDtvQkFDM0I7b0JBQ0FBLGFBQWEsQ0FBQztnQkFDaEI7Z0JBQ0FBLGNBQWVILENBQUFBLG1CQUFtQkMsWUFBWSxDQUFDLEVBQUU7WUFDbkQ7UUFDRjtRQUNBQSxlQUFlbEc7UUFDZmtHLGFBQWF4MkIsYUFBYSxHQUFHdzJCLGFBQWE3VSxTQUFTLEdBQUc0VTtRQUN0REcsYUFBYTtZQUNYcGIsU0FBUztZQUNUMU8sT0FBTztZQUNQK2tCLFVBQVU7WUFDVkMscUJBQXFCd0U7WUFDckJ2RSxtQkFBbUIwRTtRQUNyQjtRQUNBQyxhQUFhbmIsS0FBSyxHQUFHcWI7UUFDckJGLGVBQWVsQyxpQkFBaUIvVSxJQUFJLENBQ2xDLE1BQ0FxTiwyQkFDQThKO1FBRUZBLFdBQVcvRSxRQUFRLEdBQUc2RTtRQUN0QkUsYUFBYXZDLGVBQWUsQ0FBQztRQUM3QixJQUFJWSxrQkFBa0JOLDJCQUEyQmxWLElBQUksQ0FDbkQsTUFDQXFOLDJCQUNBLENBQUMsR0FDRDhKLFdBQVdyYixLQUFLO1FBRWxCcWIsYUFBYXBHO1FBQ2JxRyxpQkFBaUI7WUFDZnpLLE9BQU9xSztZQUNQNUUsVUFBVTtZQUNWTixRQUFRQTtZQUNSL1YsU0FBUztRQUNYO1FBQ0FvYixXQUFXcmIsS0FBSyxHQUFHc2I7UUFDbkJILGVBQWUzQixvQkFBb0J0VixJQUFJLENBQ3JDLE1BQ0FxTiwyQkFDQStKLGdCQUNBNUIsaUJBQ0F5QjtRQUVGRyxlQUFlaEYsUUFBUSxHQUFHNkU7UUFDMUJFLFdBQVcxMkIsYUFBYSxHQUFHcXhCO1FBQzNCLE9BQU87WUFBQ2tGO1lBQWtCQztZQUFjLENBQUM7U0FBRTtJQUM3QztJQUNBLFNBQVNNLGtCQUFrQnpGLE1BQU07UUFDL0IsSUFBSTBGLFlBQVl2RztRQUNoQixPQUFPd0csc0JBQXNCRCxXQUFXakksYUFBYXVDO0lBQ3ZEO0lBQ0EsU0FBUzJGLHNCQUFzQkQsU0FBUyxFQUFFRSxnQkFBZ0IsRUFBRTVGLE1BQU07UUFDaEU0RixtQkFBbUJqRixrQkFDakIrRSxXQUNBRSxrQkFDQWIsbUJBQ0QsQ0FBQyxFQUFFO1FBQ0pXLFlBQVloRixjQUFjWCxrQkFBa0IsQ0FBQyxFQUFFO1FBQy9DNkYsbUJBQ0UsYUFBYSxPQUFPQSxvQkFDcEIsU0FBU0Esb0JBQ1QsZUFBZSxPQUFPQSxpQkFBaUJoVyxJQUFJLEdBQ3ZDK08sWUFBWWlILG9CQUNaQTtRQUNOLElBQUlDLGtCQUFrQjFHLDRCQUNwQnNFLGNBQWNvQyxnQkFBZ0I3YixLQUFLLEVBQ25Dc1csV0FBV21ELFlBQVluRCxRQUFRO1FBQ2pDTixXQUFXNkYsZ0JBQWdCbDNCLGFBQWEsSUFDckMsMkJBQTJCK0ssS0FBSyxJQUFJLE1BQ3JDbW9CLFdBQ0VDLFlBQVlDLFNBQ1orRCx3QkFBd0I1WCxJQUFJLENBQUMsTUFBTXVWLGFBQWF6RCxTQUNoRDtZQUFFaUMsU0FBUyxLQUFLO1FBQUUsR0FDbEIsS0FDRjtRQUNGLE9BQU87WUFBQzJEO1lBQWtCdEY7WUFBVW9GO1NBQVU7SUFDaEQ7SUFDQSxTQUFTSSx3QkFBd0JyQyxXQUFXLEVBQUV6RCxNQUFNO1FBQ2xEeUQsWUFBWXpELE1BQU0sR0FBR0E7SUFDdkI7SUFDQSxTQUFTK0Ysb0JBQW9CL0YsTUFBTTtRQUNqQyxJQUFJMEYsWUFBWXZHLDRCQUNkeUcsbUJBQW1Cbkk7UUFDckIsSUFBSSxTQUFTbUksa0JBQ1gsT0FBT0Qsc0JBQXNCRCxXQUFXRSxrQkFBa0I1RjtRQUM1RGI7UUFDQXVHLFlBQVlBLFVBQVUvMkIsYUFBYTtRQUNuQ2kzQixtQkFBbUJ6RztRQUNuQixJQUFJbUIsV0FBV3NGLGlCQUFpQjViLEtBQUssQ0FBQ3NXLFFBQVE7UUFDOUNzRixpQkFBaUJqM0IsYUFBYSxHQUFHcXhCO1FBQ2pDLE9BQU87WUFBQzBGO1lBQVdwRjtZQUFVLENBQUM7U0FBRTtJQUNsQztJQUNBLFNBQVN1QixXQUFXeHhCLEdBQUcsRUFBRWd5QixNQUFNLEVBQUVHLElBQUksRUFBRTNHLElBQUk7UUFDekN4ckIsTUFBTTtZQUFFQSxLQUFLQTtZQUFLZ3lCLFFBQVFBO1lBQVFHLE1BQU1BO1lBQU0zRyxNQUFNQTtZQUFNanRCLE1BQU07UUFBSztRQUNyRXl6QixTQUFTOUcsMEJBQTBCbEwsV0FBVztRQUM5QyxTQUFTZ1MsVUFDTixVQUFVekMsc0NBQ1ZyRSwwQkFBMEJsTCxXQUFXLEdBQUdnUyxNQUFNO1FBQ2pERyxPQUFPSCxPQUFPbkUsVUFBVTtRQUN4QixTQUFTc0UsT0FDSkgsT0FBT25FLFVBQVUsR0FBRzd0QixJQUFJekIsSUFBSSxHQUFHeUIsTUFDL0IsUUFBUW15QixLQUFLNXpCLElBQUksRUFDakI0ekIsS0FBSzV6QixJQUFJLEdBQUd5QixLQUNaQSxJQUFJekIsSUFBSSxHQUFHaXRCLE1BQ1h3RyxPQUFPbkUsVUFBVSxHQUFHN3RCLEdBQUc7UUFDNUIsT0FBT0E7SUFDVDtJQUNBLFNBQVMyMUIsU0FBU0MsWUFBWTtRQUM1QixJQUFJbG5CLE9BQU9rZ0I7UUFDWGdILGVBQWU7WUFBRTEwQixTQUFTMDBCO1FBQWE7UUFDdkMsT0FBUWxuQixLQUFLcFEsYUFBYSxHQUFHczNCO0lBQy9CO0lBQ0EsU0FBU0MsZ0JBQWdCQyxVQUFVLEVBQUVDLFNBQVMsRUFBRS9ELE1BQU0sRUFBRXhHLElBQUk7UUFDMUQsSUFBSTljLE9BQU9rZ0I7UUFDWDFELDBCQUEwQjdoQixLQUFLLElBQUl5c0I7UUFDbkNwbkIsS0FBS3BRLGFBQWEsR0FBR2t6QixXQUNuQkMsWUFBWXNFLFdBQ1ovRCxRQUNBO1lBQUVKLFNBQVMsS0FBSztRQUFFLEdBQ2xCLEtBQUssTUFBTXBHLE9BQU8sT0FBT0E7SUFFN0I7SUFDQSxTQUFTeUcsaUJBQWlCNkQsVUFBVSxFQUFFQyxTQUFTLEVBQUUvRCxNQUFNLEVBQUV4RyxJQUFJO1FBQzNELElBQUk5YyxPQUFPb2dCO1FBQ1h0RCxPQUFPLEtBQUssTUFBTUEsT0FBTyxPQUFPQTtRQUNoQyxJQUFJMkcsT0FBT3pqQixLQUFLcFEsYUFBYSxDQUFDNnpCLElBQUk7UUFDbEMsU0FBUy9FLGVBQ1QsU0FBUzVCLFFBQ1RJLG1CQUFtQkosTUFBTTRCLFlBQVk5dUIsYUFBYSxDQUFDa3RCLElBQUksSUFDbEQ5YyxLQUFLcFEsYUFBYSxHQUFHa3pCLFdBQVd1RSxXQUFXL0QsUUFBUUcsTUFBTTNHLFFBQ3pELDJCQUEyQm5pQixLQUFLLElBQUl5c0IsWUFDcENwbkIsS0FBS3BRLGFBQWEsR0FBR2t6QixXQUNwQkMsWUFBWXNFLFdBQ1ovRCxRQUNBRyxNQUNBM0csS0FDRDtJQUNQO0lBQ0EsU0FBUzhGLFlBQVlVLE1BQU0sRUFBRXhHLElBQUk7UUFDOUJOLENBQUFBLDBCQUEwQmhyQixJQUFJLEdBQUcsRUFBQyxNQUFPd3NCLFVBQzFDLENBQUN4QiwwQkFBMEJockIsSUFBSSxHQUFHLEVBQUMsTUFBT3dzQixTQUN0Q21KLGdCQUFnQixXQUFXbkUsU0FBU00sUUFBUXhHLFFBQzVDcUssZ0JBQWdCLFNBQVNuRSxTQUFTTSxRQUFReEc7SUFDaEQ7SUFDQSxTQUFTd0ssa0JBQWtCaEUsTUFBTSxFQUFFeEcsSUFBSTtRQUNyQyxJQUFJc0ssYUFBYTtRQUNoQjVLLENBQUFBLDBCQUEwQmhyQixJQUFJLEdBQUcsRUFBQyxNQUFPd3NCLFVBQ3ZDb0osQ0FBQUEsY0FBYyxRQUFPO1FBQ3hCLE9BQU9ELGdCQUFnQkMsWUFBWUcsUUFBUWpFLFFBQVF4RztJQUNyRDtJQUNBLFNBQVMwSyx1QkFBdUJsRSxNQUFNLEVBQUU5TSxHQUFHO1FBQ3pDLElBQUksZUFBZSxPQUFPQSxLQUFLO1lBQzdCOE0sU0FBU0E7WUFDVCxJQUFJbUUsYUFBYWpSLElBQUk4TTtZQUNyQixPQUFPO2dCQUNMLGVBQWUsT0FBT21FLGFBQWFBLGVBQWVqUixJQUFJO1lBQ3hEO1FBQ0Y7UUFDQSxJQUFJLFNBQVNBLE9BQU8sS0FBSyxNQUFNQSxLQUM3QixPQUNFQSxJQUFJOVAsY0FBYyxDQUFDLGNBQ2pCOVYsUUFBUWdDLEtBQUssQ0FDWCxnSUFDQSwwQkFBMEIyRCxPQUFPNFIsSUFBSSxDQUFDcU8sS0FBS2xqQixJQUFJLENBQUMsUUFBUSxNQUUzRGd3QixTQUFTQSxVQUNUOU0sSUFBSWhrQixPQUFPLEdBQUc4d0IsUUFDZjtZQUNFOU0sSUFBSWhrQixPQUFPLEdBQUc7UUFDaEI7SUFFTjtJQUNBLFNBQVNrMUIsc0JBQXNCbFIsR0FBRyxFQUFFOE0sTUFBTSxFQUFFeEcsSUFBSTtRQUM5QyxlQUFlLE9BQU93RyxVQUNwQjF5QixRQUFRZ0MsS0FBSyxDQUNYLGdIQUNBLFNBQVMwd0IsU0FBUyxPQUFPQSxTQUFTO1FBRXRDeEcsT0FBTyxTQUFTQSxRQUFRLEtBQUssTUFBTUEsT0FBT0EsS0FBSy9HLE1BQU0sQ0FBQztZQUFDUztTQUFJLElBQUk7UUFDL0QsSUFBSTRRLGFBQWE7UUFDaEI1SyxDQUFBQSwwQkFBMEJockIsSUFBSSxHQUFHLEVBQUMsTUFBT3dzQixVQUN2Q29KLENBQUFBLGNBQWMsUUFBTztRQUN4QkQsZ0JBQ0VDLFlBQ0FHLFFBQ0FDLHVCQUF1QnJZLElBQUksQ0FBQyxNQUFNbVUsUUFBUTlNLE1BQzFDc0c7SUFFSjtJQUNBLFNBQVM2Syx1QkFBdUJuUixHQUFHLEVBQUU4TSxNQUFNLEVBQUV4RyxJQUFJO1FBQy9DLGVBQWUsT0FBT3dHLFVBQ3BCMXlCLFFBQVFnQyxLQUFLLENBQ1gsZ0hBQ0EsU0FBUzB3QixTQUFTLE9BQU9BLFNBQVM7UUFFdEN4RyxPQUFPLFNBQVNBLFFBQVEsS0FBSyxNQUFNQSxPQUFPQSxLQUFLL0csTUFBTSxDQUFDO1lBQUNTO1NBQUksSUFBSTtRQUMvRCtNLGlCQUNFLEdBQ0FnRSxRQUNBQyx1QkFBdUJyWSxJQUFJLENBQUMsTUFBTW1VLFFBQVE5TSxNQUMxQ3NHO0lBRUo7SUFDQSxTQUFTOEssY0FBYzl0QixRQUFRLEVBQUVnakIsSUFBSTtRQUNuQ29ELDBCQUEwQnR3QixhQUFhLEdBQUc7WUFDeENrSztZQUNBLEtBQUssTUFBTWdqQixPQUFPLE9BQU9BO1NBQzFCO1FBQ0QsT0FBT2hqQjtJQUNUO0lBQ0EsU0FBUyt0QixlQUFlL3RCLFFBQVEsRUFBRWdqQixJQUFJO1FBQ3BDLElBQUk5YyxPQUFPb2dCO1FBQ1h0RCxPQUFPLEtBQUssTUFBTUEsT0FBTyxPQUFPQTtRQUNoQyxJQUFJcUksWUFBWW5sQixLQUFLcFEsYUFBYTtRQUNsQyxJQUFJLFNBQVNrdEIsUUFBUUksbUJBQW1CSixNQUFNcUksU0FBUyxDQUFDLEVBQUUsR0FDeEQsT0FBT0EsU0FBUyxDQUFDLEVBQUU7UUFDckJubEIsS0FBS3BRLGFBQWEsR0FBRztZQUFDa0s7WUFBVWdqQjtTQUFLO1FBQ3JDLE9BQU9oakI7SUFDVDtJQUNBLFNBQVNndUIsVUFBVUMsVUFBVSxFQUFFakwsSUFBSTtRQUNqQyxJQUFJOWMsT0FBT2tnQjtRQUNYcEQsT0FBTyxLQUFLLE1BQU1BLE9BQU8sT0FBT0E7UUFDaEMsSUFBSStHLFlBQVlrRTtRQUNoQixJQUFJaEsscUNBQXFDO1lBQ3ZDN2MsMkJBQTJCLENBQUM7WUFDNUIsSUFBSTtnQkFDRjZtQjtZQUNGLFNBQVU7Z0JBQ1I3bUIsMkJBQTJCLENBQUM7WUFDOUI7UUFDRjtRQUNBbEIsS0FBS3BRLGFBQWEsR0FBRztZQUFDaTBCO1lBQVcvRztTQUFLO1FBQ3RDLE9BQU8rRztJQUNUO0lBQ0EsU0FBU21FLFdBQVdELFVBQVUsRUFBRWpMLElBQUk7UUFDbEMsSUFBSTljLE9BQU9vZ0I7UUFDWHRELE9BQU8sS0FBSyxNQUFNQSxPQUFPLE9BQU9BO1FBQ2hDLElBQUlxSSxZQUFZbmxCLEtBQUtwUSxhQUFhO1FBQ2xDLElBQUksU0FBU2t0QixRQUFRSSxtQkFBbUJKLE1BQU1xSSxTQUFTLENBQUMsRUFBRSxHQUN4RCxPQUFPQSxTQUFTLENBQUMsRUFBRTtRQUNyQkEsWUFBWTRDO1FBQ1osSUFBSWhLLHFDQUFxQztZQUN2QzdjLDJCQUEyQixDQUFDO1lBQzVCLElBQUk7Z0JBQ0Y2bUI7WUFDRixTQUFVO2dCQUNSN21CLDJCQUEyQixDQUFDO1lBQzlCO1FBQ0Y7UUFDQWxCLEtBQUtwUSxhQUFhLEdBQUc7WUFBQ3UxQjtZQUFXckk7U0FBSztRQUN0QyxPQUFPcUk7SUFDVDtJQUNBLFNBQVM4QyxtQkFBbUIvM0IsS0FBSyxFQUFFZzNCLFlBQVk7UUFDN0MsSUFBSWxuQixPQUFPa2dCO1FBQ1gsT0FBT2dJLHVCQUF1QmxvQixNQUFNOVAsT0FBT2czQjtJQUM3QztJQUNBLFNBQVNpQixvQkFBb0JqNEIsS0FBSyxFQUFFZzNCLFlBQVk7UUFDOUMsSUFBSWxuQixPQUFPb2dCO1FBQ1gsT0FBT2dJLHdCQUNMcG9CLE1BQ0EwZSxZQUFZOXVCLGFBQWEsRUFDekJNLE9BQ0FnM0I7SUFFSjtJQUNBLFNBQVNtQixzQkFBc0JuNEIsS0FBSyxFQUFFZzNCLFlBQVk7UUFDaEQsSUFBSWxuQixPQUFPb2dCO1FBQ1gsT0FBTyxTQUFTMUIsY0FDWndKLHVCQUF1QmxvQixNQUFNOVAsT0FBT2czQixnQkFDcENrQix3QkFDRXBvQixNQUNBMGUsWUFBWTl1QixhQUFhLEVBQ3pCTSxPQUNBZzNCO0lBRVI7SUFDQSxTQUFTZ0IsdUJBQXVCbG9CLElBQUksRUFBRTlQLEtBQUssRUFBRWczQixZQUFZO1FBQ3ZELElBQUksS0FBSyxNQUFNQSxnQkFBZ0IsTUFBTzlwQixDQUFBQSxjQUFjLFVBQVMsR0FDM0QsT0FBUTRDLEtBQUtwUSxhQUFhLEdBQUdNO1FBQy9COFAsS0FBS3BRLGFBQWEsR0FBR3MzQjtRQUNyQmxuQixPQUFPc29CO1FBQ1A5TCwwQkFBMEJoZ0IsS0FBSyxJQUFJd0Q7UUFDbkMrVCxrQ0FBa0MvVDtRQUNsQyxPQUFPa25CO0lBQ1Q7SUFDQSxTQUFTa0Isd0JBQXdCcG9CLElBQUksRUFBRXVvQixTQUFTLEVBQUVyNEIsS0FBSyxFQUFFZzNCLFlBQVk7UUFDbkUsSUFBSTVTLFNBQVNwa0IsT0FBT3E0QixZQUFZLE9BQU9yNEI7UUFDdkMsSUFBSSxTQUFTOHFCLDZCQUE2QnhvQixPQUFPLEVBQy9DLE9BQ0UsT0FBUTAxQix1QkFBdUJsb0IsTUFBTTlQLE9BQU9nM0IsZUFDNUM1UyxTQUFTdFUsTUFBTXVvQixjQUFlekosQ0FBQUEsbUJBQW1CLENBQUMsSUFDbEQ5ZTtRQUVKLElBQUksTUFBTzVDLENBQUFBLGNBQWMsRUFBQyxHQUN4QixPQUFPLG1CQUFvQixDQUFDLEdBQUs0QyxLQUFLcFEsYUFBYSxHQUFHTTtRQUN4RDhQLE9BQU9zb0I7UUFDUDlMLDBCQUEwQmhnQixLQUFLLElBQUl3RDtRQUNuQytULGtDQUFrQy9UO1FBQ2xDLE9BQU91b0I7SUFDVDtJQUNBLFNBQVNDLGdCQUNQOTRCLEtBQUssRUFDTHViLEtBQUssRUFDTHdkLFlBQVksRUFDWkMsYUFBYSxFQUNiNXVCLFFBQVE7UUFFUixJQUFJNnVCLG1CQUFtQkM7UUFDdkJDLHlCQUNFLE1BQU1GLG9CQUFvQixJQUFJQSxtQkFBbUJBLG1CQUFtQjtRQUV0RSxJQUFJdkQsaUJBQWlCenRCLHFCQUFxQnN0QixDQUFDLEVBQ3pDSSxvQkFBb0IsQ0FBQztRQUN2QjF0QixxQkFBcUJzdEIsQ0FBQyxHQUFHSTtRQUN6QmhCLDJCQUEyQjMwQixPQUFPLENBQUMsR0FBR3ViLE9BQU93ZDtRQUM3Q3BELGtCQUFrQkMsY0FBYyxHQUFHLElBQUl6TDtRQUN2QyxJQUFJO1lBQ0YsSUFBSTBMLGNBQWN6ckIsWUFDaEIwckIsMEJBQTBCN3RCLHFCQUFxQjh0QixDQUFDO1lBQ2xELFNBQVNELDJCQUNQQSx3QkFBd0JILG1CQUFtQkU7WUFDN0MsSUFDRSxTQUFTQSxlQUNULGFBQWEsT0FBT0EsZUFDcEIsZUFBZSxPQUFPQSxZQUFZMVUsSUFBSSxFQUN0QztnQkFDQSxJQUFJaVksMkJBQTJCN1gsbUJBQzdCc1UsYUFDQW1EO2dCQUVGSyx5QkFDRXI1QixPQUNBdWIsT0FDQTZkLDBCQUNBRSxrQkFBa0J0NUI7WUFFdEIsT0FDRXE1Qix5QkFDRXI1QixPQUNBdWIsT0FDQXlkLGVBQ0FNLGtCQUFrQnQ1QjtRQUV4QixFQUFFLE9BQU9rRCxPQUFPO1lBQ2RtMkIseUJBQ0VyNUIsT0FDQXViLE9BQ0E7Z0JBQUU0RixNQUFNLFlBQWE7Z0JBQUdELFFBQVE7Z0JBQVlRLFFBQVF4ZTtZQUFNLEdBQzFEbzJCLGtCQUFrQnQ1QjtRQUV0QixTQUFVO1lBQ1JtNUIseUJBQXlCRixtQkFDdEJoeEIscUJBQXFCc3RCLENBQUMsR0FBR0csZ0JBQzFCLFNBQVNBLGtCQUNQQyxrQkFBa0JDLGNBQWMsSUFDL0IsU0FBU0Qsa0JBQWtCQyxjQUFjLENBQUM3bEIsSUFBSSxFQUMvQzRsQixrQkFBa0JDLGNBQWMsQ0FBQzNsQixLQUFLLElBQ3RDLEtBQUtqUSxTQUNIa0IsUUFBUUMsSUFBSSxDQUNWLHNNQUNGO1FBQ1I7SUFDRjtJQUNBLFNBQVNvNEIsOEJBQThCQyxTQUFTO1FBQzlDLElBQUlDLG9CQUFvQkQsVUFBVXQ1QixhQUFhO1FBQy9DLElBQUksU0FBU3U1QixtQkFBbUIsT0FBT0E7UUFDdkNBLG9CQUFvQjtZQUNsQnY1QixlQUFlK1U7WUFDZjRNLFdBQVc1TTtZQUNYd2IsV0FBVztZQUNYbFYsT0FBTztnQkFDTEMsU0FBUztnQkFDVDFPLE9BQU87Z0JBQ1Ara0IsVUFBVTtnQkFDVkMscUJBQXFCUjtnQkFDckJTLG1CQUFtQjljO1lBQ3JCO1lBQ0E5VSxNQUFNO1FBQ1I7UUFDQSxJQUFJdTVCLG9CQUFvQixDQUFDO1FBQ3pCRCxrQkFBa0J0NUIsSUFBSSxHQUFHO1lBQ3ZCRCxlQUFldzVCO1lBQ2Y3WCxXQUFXNlg7WUFDWGpKLFdBQVc7WUFDWGxWLE9BQU87Z0JBQ0xDLFNBQVM7Z0JBQ1QxTyxPQUFPO2dCQUNQK2tCLFVBQVU7Z0JBQ1ZDLHFCQUFxQlI7Z0JBQ3JCUyxtQkFBbUIySDtZQUNyQjtZQUNBdjVCLE1BQU07UUFDUjtRQUNBcTVCLFVBQVV0NUIsYUFBYSxHQUFHdTVCO1FBQzFCRCxZQUFZQSxVQUFVeHVCLFNBQVM7UUFDL0IsU0FBU3d1QixhQUFjQSxDQUFBQSxVQUFVdDVCLGFBQWEsR0FBR3U1QixpQkFBZ0I7UUFDakUsT0FBT0E7SUFDVDtJQUNBLFNBQVNFO1FBQ1AsSUFBSTFDLFlBQVk1QyxlQUFlLENBQUM7UUFDaEM0QyxZQUFZNkIsZ0JBQWdCclosSUFBSSxDQUM5QixNQUNBcU4sMkJBQ0FtSyxVQUFVMWIsS0FBSyxFQUNmLENBQUMsR0FDRCxDQUFDO1FBRUhpViwwQkFBMEJ0d0IsYUFBYSxHQUFHKzJCO1FBQzFDLE9BQU87WUFBQyxDQUFDO1lBQUdBO1NBQVU7SUFDeEI7SUFDQSxTQUFTMkM7UUFDUCxJQUFJQyxvQkFBb0I1SCxjQUFjWCxrQkFBa0IsQ0FBQyxFQUFFLEVBQ3pEd0ksUUFBUXBKLDJCQUEyQnh3QixhQUFhO1FBQ2xELE9BQU87WUFDTCxjQUFjLE9BQU8yNUIsb0JBQ2pCQSxvQkFDQTNKLFlBQVkySjtZQUNoQkM7U0FDRDtJQUNIO0lBQ0EsU0FBU0M7UUFDUCxJQUFJRixvQkFBb0JwSCxnQkFBZ0JuQixrQkFBa0IsQ0FBQyxFQUFFLEVBQzNEd0ksUUFBUXBKLDJCQUEyQnh3QixhQUFhO1FBQ2xELE9BQU87WUFDTCxjQUFjLE9BQU8yNUIsb0JBQ2pCQSxvQkFDQTNKLFlBQVkySjtZQUNoQkM7U0FDRDtJQUNIO0lBQ0EsU0FBU0U7UUFDUCxPQUFPakosWUFBWWhjO0lBQ3JCO0lBQ0EsU0FBU2tsQjtRQUNQLElBQUkzcEIsT0FBT2tnQiwyQkFDVDBKLG1CQUFtQnhiLG1CQUFtQndiLGdCQUFnQjtRQUN4RCxJQUFJcG1CLGFBQWE7WUFDZixJQUFJcW1CLFNBQVM3bUI7WUFDYixJQUFJOG1CLG1CQUFtQi9tQjtZQUN2QjhtQixTQUNFLENBQ0VDLG1CQUFtQixDQUFFLE1BQU0sS0FBS2pyQixNQUFNaXJCLG9CQUFvQixDQUFDLENBQUMsRUFDNUR6bUIsUUFBUSxDQUFDLE1BQU13bUI7WUFDbkJELG1CQUFtQixNQUFNQSxtQkFBbUIsTUFBTUM7WUFDbERBLFNBQVM5SjtZQUNULElBQUk4SixVQUFXRCxDQUFBQSxvQkFBb0IsTUFBTUMsT0FBT3htQixRQUFRLENBQUMsR0FBRTtZQUMzRHVtQixvQkFBb0I7UUFDdEIsT0FDRSxTQUFVRyx5QkFDUEgsbUJBQ0MsTUFBTUEsbUJBQW1CLE1BQU1DLE9BQU94bUIsUUFBUSxDQUFDLE1BQU07UUFDM0QsT0FBUXJELEtBQUtwUSxhQUFhLEdBQUdnNkI7SUFDL0I7SUFDQSxTQUFTSTtRQUNQLE9BQVE5SiwwQkFBMEJ0d0IsYUFBYSxHQUFHcTZCLGFBQWE5YSxJQUFJLENBQ2pFLE1BQ0FxTjtJQUVKO0lBQ0EsU0FBU3lOLGFBQWF2NkIsS0FBSyxFQUFFdzZCLE9BQU87UUFDbEMsSUFBSyxJQUFJQyxXQUFXejZCLE1BQU15RixNQUFNLEVBQUUsU0FBU2cxQixVQUFZO1lBQ3JELE9BQVFBLFNBQVM3NEIsR0FBRztnQkFDbEIsS0FBSztnQkFDTCxLQUFLO29CQUNILElBQUlnTCxPQUFPMHNCLGtCQUFrQm1CO29CQUM3Qno2QixRQUFRb2lCLGFBQWF4VjtvQkFDckIsSUFBSTNLLE9BQU9zZ0IsY0FBY2tZLFVBQVV6NkIsT0FBTzRNO29CQUMxQyxTQUFTM0ssUUFDTm15QixDQUFBQSxzQkFBc0JueUIsTUFBTXc0QixVQUFVN3RCLE9BQ3ZDK1Ysb0JBQW9CMWdCLE1BQU13NEIsVUFBVTd0QixLQUFJO29CQUMxQzZ0QixXQUFXQztvQkFDWCxTQUFTRixXQUNQLEtBQUssTUFBTUEsV0FDWCxTQUFTdjRCLFFBQ1RmLFFBQVFnQyxLQUFLLENBQ1g7b0JBRUpsRCxNQUFNc2lCLE9BQU8sR0FBRzt3QkFBRXFZLE9BQU9GO29CQUFTO29CQUNsQztZQUNKO1lBQ0FBLFdBQVdBLFNBQVNoMUIsTUFBTTtRQUM1QjtJQUNGO0lBQ0EsU0FBU3VzQixzQkFDUGh5QixLQUFLLEVBQ0x1YixLQUFLLEVBQ0xnVyxNQUFNLEVBQ05xSixvQ0FBb0M7UUFFcEMsZUFBZSxPQUFPQSx3Q0FDcEIxNUIsUUFBUWdDLEtBQUssQ0FDWDtRQUVKMDNCLHVDQUF1Q3RCLGtCQUFrQnQ1QjtRQUN6RHV4QixTQUFTO1lBQ1Aza0IsTUFBTWd1QjtZQUNOdEksWUFBWTtZQUNaZixRQUFRQTtZQUNSZ0IsZUFBZSxDQUFDO1lBQ2hCQyxZQUFZO1lBQ1pyeUIsTUFBTTtRQUNSO1FBQ0FnMUIsb0JBQW9CbjFCLFNBQ2hCNjZCLHlCQUF5QnRmLE9BQU9nVyxVQUMvQixVQUFVNVYsNEJBQ1QzYixPQUNBdWIsT0FDQWdXLFFBQ0FxSix1Q0FFRixTQUFTckosVUFDTjZDLENBQUFBLHNCQUNDN0MsUUFDQXZ4QixPQUNBNDZCLHVDQUVGRSx5QkFDRXZKLFFBQ0FoVyxPQUNBcWYscUNBQ0YsQ0FBQztRQUNQeG9CLHlCQUF5QnBTLE9BQU80NkI7SUFDbEM7SUFDQSxTQUFTcEcsaUJBQ1B4MEIsS0FBSyxFQUNMdWIsS0FBSyxFQUNMZ1csTUFBTSxFQUNOd0osb0NBQW9DO1FBRXBDLGVBQWUsT0FBT0Esd0NBQ3BCNzVCLFFBQVFnQyxLQUFLLENBQ1g7UUFFSjYzQix1Q0FBdUN6QixrQkFBa0J0NUI7UUFDekRxNUIseUJBQ0VyNUIsT0FDQXViLE9BQ0FnVyxRQUNBd0o7UUFFRjNvQix5QkFBeUJwUyxPQUFPKzZCO0lBQ2xDO0lBQ0EsU0FBUzFCLHlCQUF5QnI1QixLQUFLLEVBQUV1YixLQUFLLEVBQUVnVyxNQUFNLEVBQUUza0IsSUFBSTtRQUMxRCxJQUFJcEssU0FBUztZQUNYb0ssTUFBTUE7WUFDTjBsQixZQUFZO1lBQ1pmLFFBQVFBO1lBQ1JnQixlQUFlLENBQUM7WUFDaEJDLFlBQVk7WUFDWnJ5QixNQUFNO1FBQ1I7UUFDQSxJQUFJZzFCLG9CQUFvQm4xQixRQUFRNjZCLHlCQUF5QnRmLE9BQU8vWTthQUMzRDtZQUNILElBQUl3SSxZQUFZaEwsTUFBTWdMLFNBQVM7WUFDL0IsSUFDRSxNQUFNaEwsTUFBTThNLEtBQUssSUFDaEIsVUFBUzlCLGFBQWEsTUFBTUEsVUFBVThCLEtBQUssS0FDM0MsYUFBYXlPLE1BQU11VyxtQkFBbUIsRUFBRyxTQUFTOW1CLFNBQVEsR0FDM0Q7Z0JBQ0EsSUFBSWd3QixpQkFBaUIveUIscUJBQXFCQyxDQUFDO2dCQUMzQ0QscUJBQXFCQyxDQUFDLEdBQUcreUI7Z0JBQ3pCLElBQUk7b0JBQ0YsSUFBSUMsZUFBZTNmLE1BQU13VyxpQkFBaUIsRUFDeENTLGFBQWF4bkIsVUFBVWt3QixjQUFjM0o7b0JBQ3ZDL3VCLE9BQU8rdkIsYUFBYSxHQUFHLENBQUM7b0JBQ3hCL3ZCLE9BQU9nd0IsVUFBVSxHQUFHQTtvQkFDcEIsSUFBSTVOLFNBQVM0TixZQUFZMEksZUFDdkIsT0FDRXhmLGdCQUFnQjFiLE9BQU91YixPQUFPL1ksUUFBUSxJQUN0QyxTQUFTa2Msc0JBQ1B4RCxtQ0FDRixDQUFDO2dCQUVQLEVBQUUsT0FBT2hZLE9BQU8sQ0FDaEIsU0FBVTtvQkFDUitFLHFCQUFxQkMsQ0FBQyxHQUFHOHlCO2dCQUMzQjtZQUNGO1lBQ0F6SixTQUFTNVYsNEJBQTRCM2IsT0FBT3ViLE9BQU8vWSxRQUFRb0s7WUFDM0QsSUFBSSxTQUFTMmtCLFFBQ1gsT0FDRTZDLHNCQUFzQjdDLFFBQVF2eEIsT0FBTzRNLE9BQ3JDa3VCLHlCQUF5QnZKLFFBQVFoVyxPQUFPM08sT0FDeEMsQ0FBQztRQUVQO1FBQ0EsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxTQUFTK25CLDJCQUNQMzBCLEtBQUssRUFDTG03QixtQkFBbUIsRUFDbkI1ZixLQUFLLEVBQ0xnVyxNQUFNO1FBRU4sU0FBU3RwQixxQkFBcUJzdEIsQ0FBQyxJQUM3QixNQUFNdlUsd0JBQ045ZixRQUFRZ0MsS0FBSyxDQUNYO1FBRUpxdUIsU0FBUztZQUNQM2tCLE1BQU07WUFDTjBsQixZQUFZN1I7WUFDWjhRLFFBQVFBO1lBQ1JnQixlQUFlLENBQUM7WUFDaEJDLFlBQVk7WUFDWnJ5QixNQUFNO1FBQ1I7UUFDQSxJQUFJZzFCLG9CQUFvQm4xQixRQUFRO1lBQzlCLElBQUltN0IscUJBQ0YsTUFBTWowQixNQUFNO1lBQ2RoRyxRQUFRZ0MsS0FBSyxDQUFDO1FBQ2hCLE9BQ0Usc0JBQXVCeVksNEJBQ3JCM2IsT0FDQXViLE9BQ0FnVyxRQUNBLElBRUEsU0FBUzRKLHVCQUNQL0csc0JBQXNCK0cscUJBQXFCbjdCLE9BQU87UUFDeERvUyx5QkFBeUJwUyxPQUFPO0lBQ2xDO0lBQ0EsU0FBU20xQixvQkFBb0JuMUIsS0FBSztRQUNoQyxJQUFJZ0wsWUFBWWhMLE1BQU1nTCxTQUFTO1FBQy9CLE9BQ0VoTCxVQUFVOHNCLDZCQUNULFNBQVM5aEIsYUFBYUEsY0FBYzhoQjtJQUV6QztJQUNBLFNBQVMrTix5QkFBeUJ0ZixLQUFLLEVBQUUvWSxNQUFNO1FBQzdDZ3NCLDZDQUNFVSwrQkFBK0IsQ0FBQztRQUNsQyxJQUFJMVQsVUFBVUQsTUFBTUMsT0FBTztRQUMzQixTQUFTQSxVQUNKaFosT0FBT3JDLElBQUksR0FBR3FDLFNBQ2QsUUFBUXJDLElBQUksR0FBR3FiLFFBQVFyYixJQUFJLEVBQUlxYixRQUFRcmIsSUFBSSxHQUFHcUMsTUFBTTtRQUN6RCtZLE1BQU1DLE9BQU8sR0FBR2haO0lBQ2xCO0lBQ0EsU0FBU3M0Qix5QkFBeUI3NEIsSUFBSSxFQUFFc1osS0FBSyxFQUFFM08sSUFBSTtRQUNqRCxJQUFJLE1BQU9BLENBQUFBLE9BQU8sT0FBTSxHQUFJO1lBQzFCLElBQUlnVyxhQUFhckgsTUFBTXpPLEtBQUs7WUFDNUI4VixjQUFjM2dCLEtBQUtpTCxZQUFZO1lBQy9CTixRQUFRZ1c7WUFDUnJILE1BQU16TyxLQUFLLEdBQUdGO1lBQ2QyQyxrQkFBa0J0TixNQUFNMks7UUFDMUI7SUFDRjtJQUNBLFNBQVN3dUIsc0JBQXNCaHhCLFFBQVE7UUFDckMsSUFBSSxTQUFTQSxZQUFZLGVBQWUsT0FBT0EsVUFBVTtZQUN2RCxJQUFJMUosTUFBTXdXLE9BQU85TTtZQUNqQml4Qix5QkFBeUJyckIsR0FBRyxDQUFDdFAsUUFDMUIyNkIsQ0FBQUEseUJBQXlCenJCLEdBQUcsQ0FBQ2xQLE1BQzlCUSxRQUFRZ0MsS0FBSyxDQUNYLDBGQUNBa0gsU0FDRjtRQUNKO0lBQ0Y7SUFDQSxTQUFTa3hCLDJCQUNQMXhCLGNBQWMsRUFDZDJ4QixJQUFJLEVBQ0pDLHdCQUF3QixFQUN4QjFYLFNBQVM7UUFFVCxJQUFJMlIsWUFBWTdyQixlQUFlMUosYUFBYSxFQUMxQzJqQixlQUFlMlgseUJBQXlCMVgsV0FBVzJSO1FBQ3JELElBQUk3ckIsZUFBZTlILElBQUksR0FBRyxHQUFHO1lBQzNCMFAsMkJBQTJCLENBQUM7WUFDNUIsSUFBSTtnQkFDRnFTLGVBQWUyWCx5QkFBeUIxWCxXQUFXMlI7WUFDckQsU0FBVTtnQkFDUmprQiwyQkFBMkIsQ0FBQztZQUM5QjtRQUNGO1FBQ0EsS0FBSyxNQUFNcVMsZ0JBQ1IsUUFBUTdmLHlCQUF5QnUzQixTQUFTLGFBQzNDRSxrQ0FBa0N6ckIsR0FBRyxDQUFDdXJCLFNBQ25DRSxDQUFBQSxrQ0FBa0M3ckIsR0FBRyxDQUFDMnJCLE9BQ3ZDcjZCLFFBQVFnQyxLQUFLLENBQ1gsZ0hBQ0FxNEIsS0FDRixDQUFDO1FBQ0w5RixZQUNFLFNBQVM1UixnQkFBZ0IsS0FBSyxNQUFNQSxlQUNoQzRSLFlBQ0EzMEIsT0FBTyxDQUFDLEdBQUcyMEIsV0FBVzVSO1FBQzVCamEsZUFBZTFKLGFBQWEsR0FBR3UxQjtRQUMvQixNQUFNN3JCLGVBQWVrRCxLQUFLLElBQ3ZCbEQsQ0FBQUEsZUFBZWdZLFdBQVcsQ0FBQ0MsU0FBUyxHQUFHNFQsU0FBUTtJQUNwRDtJQUNBLFNBQVNpRywyQkFDUDl4QixjQUFjLEVBQ2QyeEIsSUFBSSxFQUNKSSxRQUFRLEVBQ1JDLFFBQVEsRUFDUnJGLFFBQVEsRUFDUjVTLFFBQVEsRUFDUmhQLFdBQVc7UUFFWCxJQUFJb1AsV0FBV25hLGVBQWVnQyxTQUFTO1FBQ3ZDLElBQUksZUFBZSxPQUFPbVksU0FBUzhYLHFCQUFxQixFQUFFO1lBQ3hERixXQUFXNVgsU0FBUzhYLHFCQUFxQixDQUN2Q0QsVUFDQWpZLFVBQ0FoUDtZQUVGLElBQUkvSyxlQUFlOUgsSUFBSSxHQUFHLEdBQUc7Z0JBQzNCMFAsMkJBQTJCLENBQUM7Z0JBQzVCLElBQUk7b0JBQ0ZtcUIsV0FBVzVYLFNBQVM4WCxxQkFBcUIsQ0FDdkNELFVBQ0FqWSxVQUNBaFA7Z0JBRUosU0FBVTtvQkFDUm5ELDJCQUEyQixDQUFDO2dCQUM5QjtZQUNGO1lBQ0EsS0FBSyxNQUFNbXFCLFlBQ1R6NkIsUUFBUWdDLEtBQUssQ0FDWCxpSEFDQWMseUJBQXlCdTNCLFNBQVM7WUFFdEMsT0FBT0k7UUFDVDtRQUNBLE9BQU9KLEtBQUtoekIsU0FBUyxJQUFJZ3pCLEtBQUtoekIsU0FBUyxDQUFDdXpCLG9CQUFvQixHQUN4RCxDQUFDclgsYUFBYWtYLFVBQVVDLGFBQWEsQ0FBQ25YLGFBQWE4UixVQUFVNVMsWUFDN0QsQ0FBQztJQUNQO0lBQ0EsU0FBU29ZLDhCQUNQbnlCLGNBQWMsRUFDZG1hLFFBQVEsRUFDUjZYLFFBQVEsRUFDUmpuQixXQUFXO1FBRVgsSUFBSTRoQixXQUFXeFMsU0FBU3FJLEtBQUs7UUFDN0IsZUFBZSxPQUFPckksU0FBU2lZLHlCQUF5QixJQUN0RGpZLFNBQVNpWSx5QkFBeUIsQ0FBQ0osVUFBVWpuQjtRQUMvQyxlQUFlLE9BQU9vUCxTQUFTa1ksZ0NBQWdDLElBQzdEbFksU0FBU2tZLGdDQUFnQyxDQUFDTCxVQUFVam5CO1FBQ3REb1AsU0FBU3FJLEtBQUssS0FBS21LLFlBQ2hCLGtCQUNDaHhCLDBCQUEwQnFFLG1CQUFtQixhQUMvQ3N5Qix3Q0FBd0Nsc0IsR0FBRyxDQUFDcEcsbUJBQ3pDc3lCLENBQUFBLHdDQUF3Q3RzQixHQUFHLENBQUNoRyxpQkFDN0MxSSxRQUFRZ0MsS0FBSyxDQUNYLG1KQUNBMEcsZUFDRixHQUNGdXlCLHNCQUFzQkMsbUJBQW1CLENBQ3ZDclksVUFDQUEsU0FBU3FJLEtBQUssRUFDZCxLQUNGO0lBQ0o7SUFDQSxTQUFTaVEsMkJBQTJCeE8sU0FBUyxFQUFFeU8sU0FBUztRQUN0RCxJQUFJVixXQUFXVTtRQUNmLElBQUksU0FBU0EsV0FBVztZQUN0QlYsV0FBVyxDQUFDO1lBQ1osSUFBSyxJQUFJN2tCLFlBQVl1bEIsVUFDbkIsVUFBVXZsQixZQUFhNmtCLENBQUFBLFFBQVEsQ0FBQzdrQixTQUFTLEdBQUd1bEIsU0FBUyxDQUFDdmxCLFNBQVM7UUFDbkU7UUFDQSxJQUFLOFcsWUFBWUEsVUFBVTBPLFlBQVksRUFBRztZQUN4Q1gsYUFBYVUsYUFBY1YsQ0FBQUEsV0FBVzk2QixPQUFPLENBQUMsR0FBRzg2QixTQUFRO1lBQ3pELElBQUssSUFBSTlqQixhQUFhK1YsVUFDcEIsS0FBSyxNQUFNK04sUUFBUSxDQUFDOWpCLFVBQVUsSUFDM0I4akIsQ0FBQUEsUUFBUSxDQUFDOWpCLFVBQVUsR0FBRytWLFNBQVMsQ0FBQy9WLFVBQVU7UUFDakQ7UUFDQSxPQUFPOGpCO0lBQ1Q7SUFDQSxTQUFTWSxpQkFBaUJ2NkIsSUFBSSxFQUFFdzZCLFNBQVM7UUFDdkMsSUFBSTtZQUNGL1osZ0JBQWdCK1osVUFBVWpxQixNQUFNLEdBQzVCak4sMEJBQTBCazNCLFVBQVVqcUIsTUFBTSxJQUMxQztZQUNKa3FCLG9CQUFvQjtZQUNwQixJQUFJeDVCLFFBQVF1NUIsVUFBVWo4QixLQUFLO1lBQzNCLElBQUksU0FBU3lILHFCQUFxQjZWLFFBQVEsRUFDeEM3VixxQkFBcUIwMEIsWUFBWSxDQUFDajVCLElBQUksQ0FBQ1I7aUJBQ3BDO2dCQUNILElBQUkwNUIsa0JBQWtCMzZCLEtBQUsyNkIsZUFBZTtnQkFDMUNBLGdCQUFnQjE1QixPQUFPO29CQUFFMjVCLGdCQUFnQkosVUFBVXIxQixLQUFLO2dCQUFDO1lBQzNEO1FBQ0YsRUFBRSxPQUFPMDFCLEdBQUc7WUFDVkMsV0FBVztnQkFDVCxNQUFNRDtZQUNSO1FBQ0Y7SUFDRjtJQUNBLFNBQVNFLGVBQWUvNkIsSUFBSSxFQUFFZzdCLFFBQVEsRUFBRVIsU0FBUztRQUMvQyxJQUFJO1lBQ0YvWixnQkFBZ0IrWixVQUFVanFCLE1BQU0sR0FDNUJqTiwwQkFBMEJrM0IsVUFBVWpxQixNQUFNLElBQzFDO1lBQ0prcUIsb0JBQW9CbjNCLDBCQUEwQjAzQjtZQUM5QyxJQUFJQyxnQkFBZ0JqN0IsS0FBS2k3QixhQUFhO1lBQ3RDQSxjQUFjVCxVQUFVajhCLEtBQUssRUFBRTtnQkFDN0JxOEIsZ0JBQWdCSixVQUFVcjFCLEtBQUs7Z0JBQy9CKzFCLGVBQWUsTUFBTUYsU0FBU3I3QixHQUFHLEdBQUdxN0IsU0FBU3J4QixTQUFTLEdBQUc7WUFDM0Q7UUFDRixFQUFFLE9BQU9reEIsR0FBRztZQUNWQyxXQUFXO2dCQUNULE1BQU1EO1lBQ1I7UUFDRjtJQUNGO0lBQ0EsU0FBU00sc0JBQXNCbjdCLElBQUksRUFBRXc2QixTQUFTLEVBQUU3dkIsSUFBSTtRQUNsREEsT0FBT3dWLGFBQWF4VjtRQUNwQkEsS0FBS2hMLEdBQUcsR0FBR3VpQjtRQUNYdlgsS0FBSzBWLE9BQU8sR0FBRztZQUFFcGdCLFNBQVM7UUFBSztRQUMvQjBLLEtBQUt4QyxRQUFRLEdBQUc7WUFDZEQsa0JBQWtCc3lCLFVBQVVqcUIsTUFBTSxFQUFFZ3FCLGtCQUFrQnY2QixNQUFNdzZCO1FBQzlEO1FBQ0EsT0FBTzd2QjtJQUNUO0lBQ0EsU0FBU3l3Qix1QkFBdUJ6d0IsSUFBSTtRQUNsQ0EsT0FBT3dWLGFBQWF4VjtRQUNwQkEsS0FBS2hMLEdBQUcsR0FBR3VpQjtRQUNYLE9BQU92WDtJQUNUO0lBQ0EsU0FBUzB3QiwyQkFBMkI5NkIsTUFBTSxFQUFFUCxJQUFJLEVBQUVqQyxLQUFLLEVBQUV5OEIsU0FBUztRQUNoRSxJQUFJYywyQkFBMkJ2OUIsTUFBTWlFLElBQUksQ0FBQ3M1Qix3QkFBd0I7UUFDbEUsSUFBSSxlQUFlLE9BQU9BLDBCQUEwQjtZQUNsRCxJQUFJcjZCLFFBQVF1NUIsVUFBVWo4QixLQUFLO1lBQzNCZ0MsT0FBTzhmLE9BQU8sR0FBRztnQkFDZixPQUFPaWIseUJBQXlCcjZCO1lBQ2xDO1lBQ0FWLE9BQU80SCxRQUFRLEdBQUc7Z0JBQ2hCb3pCLHVDQUF1Q3g5QjtnQkFDdkNtSyxrQkFDRXN5QixVQUFVanFCLE1BQU0sRUFDaEJ3cUIsZ0JBQ0EvNkIsTUFDQWpDLE9BQ0F5OEI7WUFFSjtRQUNGO1FBQ0EsSUFBSTFJLE9BQU8vekIsTUFBTTRMLFNBQVM7UUFDMUIsU0FBU21vQixRQUNQLGVBQWUsT0FBT0EsS0FBSzBKLGlCQUFpQixJQUMzQ2o3QixDQUFBQSxPQUFPNEgsUUFBUSxHQUFHO1lBQ2pCb3pCLHVDQUF1Q3g5QjtZQUN2Q21LLGtCQUNFc3lCLFVBQVVqcUIsTUFBTSxFQUNoQndxQixnQkFDQS82QixNQUNBakMsT0FDQXk4QjtZQUVGLGVBQWUsT0FBT2MsNEJBQ25CLFVBQVNHLHlDQUNMQSx5Q0FBeUMsSUFBSXZULElBQUk7Z0JBQUMsSUFBSTthQUFDLElBQ3hEdVQsdUNBQXVDOXRCLEdBQUcsQ0FBQyxJQUFJO1lBQ3JEK3RCLDJCQUEyQixJQUFJLEVBQUVsQjtZQUNqQyxlQUFlLE9BQU9jLDRCQUNuQixNQUFPdjlCLENBQUFBLE1BQU04TSxLQUFLLEdBQUcsTUFDcEI1TCxRQUFRZ0MsS0FBSyxDQUNYLHVKQUNBcUMsMEJBQTBCdkYsVUFBVTtRQUU1QztJQUNKO0lBQ0EsU0FBUzQ5QixlQUNQMzdCLElBQUksRUFDSnNrQixXQUFXLEVBQ1h6SyxXQUFXLEVBQ1h0YixLQUFLLEVBQ0xxOUIsZUFBZTtRQUVmL2hCLFlBQVk3USxLQUFLLElBQUk7UUFDckJ5RSxxQkFBcUJvdUIsdUJBQXVCNzdCLE1BQU00N0I7UUFDbEQsSUFDRSxTQUFTcjlCLFNBQ1QsYUFBYSxPQUFPQSxTQUNwQixlQUFlLE9BQU9BLE1BQU0yZ0IsSUFBSSxFQUNoQztZQUNBb0YsY0FBY3pLLFlBQVk5USxTQUFTO1lBQ25DLFNBQVN1YixlQUNQd1gsOEJBQ0V4WCxhQUNBekssYUFDQStoQixpQkFDQSxDQUFDO1lBRUwvcEIsZUFBZ0J1RixDQUFBQSx1QkFBdUIsQ0FBQztZQUN4Q3lDLGNBQWMrUCwyQkFBMkIvb0IsT0FBTztZQUNoRCxJQUFJLFNBQVNnWixhQUFhO2dCQUN4QixPQUFRQSxZQUFZbGEsR0FBRztvQkFDckIsS0FBSzt3QkFDSCxPQUNFLFNBQVNrcUIsZ0JBQ0xrUyxvQ0FDQSxTQUFTbGlCLFlBQVk5USxTQUFTLElBQzlCaXpCLGlDQUFpQ0Msa0JBQ2hDRCxDQUFBQSwrQkFBK0JFLGFBQVksR0FDL0NyaUIsWUFBWTdRLEtBQUssSUFBSSxDQUFDLEtBQ3RCNlEsWUFBWTdRLEtBQUssSUFBSSxPQUNyQjZRLFlBQVloUCxLQUFLLEdBQUcrd0IsaUJBQ3JCcjlCLFVBQVU0OUIsOEJBQ0x0aUIsWUFBWTdRLEtBQUssSUFBSSxRQUNyQixlQUFlNlEsWUFBWThGLFdBQVcsRUFDdkMsU0FBUzJFLGNBQ0p6SyxZQUFZOEYsV0FBVyxHQUFHLElBQUl1SSxJQUFJOzRCQUFDM3BCO3lCQUFNLElBQzFDK2xCLFlBQVkzVyxHQUFHLENBQUNwUCxRQUNwQjY5QixtQkFBbUJwOEIsTUFBTXpCLE9BQU9xOUIsZ0JBQWUsR0FDbkQsQ0FBQztvQkFFTCxLQUFLO3dCQUNILE9BQ0UsWUFBYTV5QixLQUFLLElBQUksT0FDdEJ6SyxVQUFVNDlCLDhCQUNMdGlCLFlBQVk3USxLQUFLLElBQUksUUFDckIsZUFBZTZRLFlBQVk4RixXQUFXLEVBQ3ZDLFNBQVMyRSxjQUNKLGVBQWU7NEJBQ2QrWCxhQUFhOzRCQUNiQyxpQkFBaUI7NEJBQ2pCQyxZQUFZLElBQUlyVSxJQUFJO2dDQUFDM3BCOzZCQUFNO3dCQUM3QixHQUNDc2IsWUFBWThGLFdBQVcsR0FBRzJFLFdBQVcsSUFDckMsZUFBZUEsWUFBWWlZLFVBQVUsRUFDdEMsU0FBUzFpQixjQUNKeUssWUFBWWlZLFVBQVUsR0FBRyxJQUFJclUsSUFBSTs0QkFBQzNwQjt5QkFBTSxJQUN6Q3NiLFlBQVlsTSxHQUFHLENBQUNwUCxNQUFLLEdBQzdCNjlCLG1CQUFtQnA4QixNQUFNekIsT0FBT3E5QixnQkFBZSxHQUNuRCxDQUFDO2dCQUVQO2dCQUNBLE1BQU0zMkIsTUFDSixzQ0FDRTRVLFlBQVlsYSxHQUFHLEdBQ2Y7WUFFTjtZQUNBeThCLG1CQUFtQnA4QixNQUFNekIsT0FBT3E5QjtZQUNoQ0c7WUFDQSxPQUFPLENBQUM7UUFDVjtRQUNBLElBQUlscUIsYUFDRixPQUNFLHVCQUF3QixDQUFDLEdBQ3hCeVMsY0FBY3NGLDJCQUEyQi9vQixPQUFPLEVBQ2pELFNBQVN5akIsY0FDSixPQUFPQSxDQUFBQSxZQUFZdGIsS0FBSyxHQUFHLEtBQUksS0FBT3NiLENBQUFBLFlBQVl0YixLQUFLLElBQUksR0FBRSxHQUM3RHNiLFlBQVl0YixLQUFLLElBQUksT0FDckJzYixZQUFZelosS0FBSyxHQUFHK3dCLGlCQUNyQnI5QixVQUFVbVosOEJBQ1JELG9CQUNFbkgsMkJBQ0VyTCxNQUNFLG9JQUNBO1lBQUV1M0IsT0FBT2orQjtRQUFNLElBRWpCc2IsYUFFSixJQUNEdGIsQ0FBQUEsVUFBVW1aLDhCQUNURCxvQkFDRW5ILDJCQUNFckwsTUFDRSxpSEFDQTtZQUFFdTNCLE9BQU9qK0I7UUFBTSxJQUVqQnNiLGVBR0w3WixPQUFPQSxLQUFLYSxPQUFPLENBQUNrSSxTQUFTLEVBQzdCL0ksS0FBS2dKLEtBQUssSUFBSSxPQUNkNHlCLG1CQUFtQixDQUFDQSxpQkFDcEI1N0IsS0FBSzZLLEtBQUssSUFBSSt3QixpQkFDZHI5QixRQUFRK1IsMkJBQTJCL1IsT0FBT3NiLGNBQzFDK2hCLGtCQUFrQlQsc0JBQ2pCbjdCLEtBQUsySixTQUFTLEVBQ2RwTCxPQUNBcTlCLGtCQUVGaGIsc0JBQXNCNWdCLE1BQU00N0Isa0JBQzVCSSxpQ0FBaUNTLDBCQUM5QlQsQ0FBQUEsK0JBQStCVSxXQUFVLENBQUMsR0FDakQsQ0FBQztRQUVMLElBQUl6N0IsUUFBUXFQLDJCQUNWckwsTUFDRSxvSUFDQTtZQUFFdTNCLE9BQU9qK0I7UUFBTSxJQUVqQnNiO1FBRUYsU0FBUzhpQixxQ0FDSkEscUNBQXFDO1lBQUMxN0I7U0FBTSxHQUM3QzA3QixtQ0FBbUNsN0IsSUFBSSxDQUFDUjtRQUM1Qys2QixpQ0FBaUNTLDBCQUM5QlQsQ0FBQUEsK0JBQStCVSxXQUFVO1FBQzVDLElBQUksU0FBU3BZLGFBQWEsT0FBTyxDQUFDO1FBQ2xDL2xCLFFBQVErUiwyQkFBMkIvUixPQUFPc2I7UUFDMUNBLGNBQWN5SztRQUNkLEdBQUc7WUFDRCxPQUFRekssWUFBWWxhLEdBQUc7Z0JBQ3JCLEtBQUs7b0JBQ0gsT0FDRSxZQUFhcUosS0FBSyxJQUFJLE9BQ3JCaEosT0FBTzQ3QixrQkFBa0IsQ0FBQ0EsaUJBQzFCL2hCLFlBQVloUCxLQUFLLElBQUk3SyxNQUNyQkEsT0FBT203QixzQkFDTnRoQixZQUFZbFEsU0FBUyxFQUNyQnBMLE9BQ0F5QixPQUVGNGdCLHNCQUFzQi9HLGFBQWE3WixPQUNuQyxDQUFDO2dCQUVMLEtBQUs7b0JBQ0gsSUFDRyxjQUFlNlosWUFBWTdYLElBQUksRUFDL0JmLFFBQVE0WSxZQUFZbFEsU0FBUyxFQUM5QixNQUFPa1EsQ0FBQUEsWUFBWTdRLEtBQUssR0FBRyxHQUFFLEtBQzFCLGdCQUFlLE9BQU9zYixZQUFZZ1gsd0JBQXdCLElBQ3hELFNBQVNyNkIsU0FDUixlQUFlLE9BQU9BLE1BQU11NkIsaUJBQWlCLElBQzVDLFVBQVNDLDBDQUNSLENBQUNBLHVDQUF1QzF0QixHQUFHLENBQUM5TSxNQUFLLENBQUUsR0FFM0QsT0FDRSxZQUFhK0gsS0FBSyxJQUFJLE9BQ3JCNHlCLG1CQUFtQixDQUFDQSxpQkFDcEIvaEIsWUFBWWhQLEtBQUssSUFBSSt3QixpQkFDckJBLGtCQUFrQlIsdUJBQXVCUSxrQkFDMUNQLDJCQUNFTyxpQkFDQTU3QixNQUNBNlosYUFDQXRiLFFBRUZxaUIsc0JBQXNCL0csYUFBYStoQixrQkFDbkMsQ0FBQztZQUVUO1lBQ0EvaEIsY0FBY0EsWUFBWXJXLE1BQU07UUFDbEMsUUFBUyxTQUFTcVcsYUFBYTtRQUMvQixPQUFPLENBQUM7SUFDVjtJQUNBLFNBQVMraUIsa0JBQ1AvN0IsT0FBTyxFQUNQOEcsY0FBYyxFQUNkazFCLFlBQVksRUFDWnB4QixXQUFXO1FBRVg5RCxlQUFlNEIsS0FBSyxHQUNsQixTQUFTMUksVUFDTGk4QixpQkFBaUJuMUIsZ0JBQWdCLE1BQU1rMUIsY0FBY3B4QixlQUNyRHN4QixxQkFDRXAxQixnQkFDQTlHLFFBQVEwSSxLQUFLLEVBQ2JzekIsY0FDQXB4QjtJQUVWO0lBQ0EsU0FBU3V4QixpQkFDUG44QixPQUFPLEVBQ1A4RyxjQUFjLEVBQ2Rpa0IsU0FBUyxFQUNUL0osU0FBUyxFQUNUcFcsV0FBVztRQUVYbWdCLFlBQVlBLFVBQVU1b0IsTUFBTTtRQUM1QixJQUFJNmhCLE1BQU1sZCxlQUFla2QsR0FBRztRQUM1QixJQUFJLFNBQVNoRCxXQUFXO1lBQ3RCLElBQUlvYixrQkFBa0IsQ0FBQztZQUN2QixJQUFLLElBQUl4K0IsT0FBT29qQixVQUNkLFVBQVVwakIsT0FBUXcrQixDQUFBQSxlQUFlLENBQUN4K0IsSUFBSSxHQUFHb2pCLFNBQVMsQ0FBQ3BqQixJQUFJO1FBQzNELE9BQU93K0Isa0JBQWtCcGI7UUFDekJxYixxQkFBcUJ2MUI7UUFDckJvSSwyQkFBMkJwSTtRQUMzQmthLFlBQVk4SixnQkFDVjlxQixTQUNBOEcsZ0JBQ0Fpa0IsV0FDQXFSLGlCQUNBcFksS0FDQXBaO1FBRUZoTixNQUFNeXZCO1FBQ05sZTtRQUNBLElBQUksU0FBU25QLFdBQVcsQ0FBQ3NzQixrQkFDdkIsT0FDRWtCLGFBQWF4dEIsU0FBUzhHLGdCQUFnQjhELGNBQ3RDMHhCLDZCQUE2QnQ4QixTQUFTOEcsZ0JBQWdCOEQ7UUFFMURvRyxlQUFlcFQsT0FBT2tULHVCQUF1QmhLO1FBQzdDQSxlQUFlcUIsS0FBSyxJQUFJO1FBQ3hCNHpCLGtCQUFrQi83QixTQUFTOEcsZ0JBQWdCa2EsV0FBV3BXO1FBQ3RELE9BQU85RCxlQUFlNEIsS0FBSztJQUM3QjtJQUNBLFNBQVM2ekIsb0JBQ1B2OEIsT0FBTyxFQUNQOEcsY0FBYyxFQUNkaWtCLFNBQVMsRUFDVC9KLFNBQVMsRUFDVHBXLFdBQVc7UUFFWCxJQUFJLFNBQVM1SyxTQUFTO1lBQ3BCLElBQUltQixPQUFPNHBCLFVBQVU1cEIsSUFBSTtZQUN6QixJQUNFLGVBQWUsT0FBT0EsUUFDdEIsQ0FBQ3E3QixnQkFBZ0JyN0IsU0FDakIsS0FBSyxNQUFNQSxLQUFLczRCLFlBQVksSUFDNUIsU0FBUzFPLFVBQVUwUixPQUFPLEVBRTFCLE9BQ0UsWUFBYUMsK0JBQStCdjdCLE9BQzNDMkYsZUFBZWhJLEdBQUcsR0FBRyxJQUNyQmdJLGVBQWUzRixJQUFJLEdBQUc0cEIsV0FDdkI0UiwrQkFBK0I3MUIsZ0JBQWdCM0YsT0FDL0N5N0IsMEJBQ0U1OEIsU0FDQThHLGdCQUNBaWtCLFdBQ0EvSixXQUNBcFc7WUFHTjVLLFVBQVU2OEIsNEJBQ1I5UixVQUFVNXBCLElBQUksRUFDZCxNQUNBNmYsV0FDQWxhLGdCQUNBQSxlQUFlOUgsSUFBSSxFQUNuQjRMO1lBRUY1SyxRQUFRZ2tCLEdBQUcsR0FBR2xkLGVBQWVrZCxHQUFHO1lBQ2hDaGtCLFFBQVEyQyxNQUFNLEdBQUdtRTtZQUNqQixPQUFRQSxlQUFlNEIsS0FBSyxHQUFHMUk7UUFDakM7UUFDQW1CLE9BQU9uQixRQUFRMEksS0FBSztRQUNwQixJQUFJLENBQUNvMEIsOEJBQThCOThCLFNBQVM0SyxjQUFjO1lBQ3hELElBQUlteUIsWUFBWTU3QixLQUFLK1YsYUFBYTtZQUNsQzZULFlBQVlBLFVBQVUwUixPQUFPO1lBQzdCMVIsWUFBWSxTQUFTQSxZQUFZQSxZQUFZcEo7WUFDN0MsSUFDRW9KLFVBQVVnUyxXQUFXL2IsY0FDckJoaEIsUUFBUWdrQixHQUFHLEtBQUtsZCxlQUFla2QsR0FBRyxFQUVsQyxPQUFPc1ksNkJBQ0x0OEIsU0FDQThHLGdCQUNBOEQ7UUFFTjtRQUNBOUQsZUFBZXFCLEtBQUssSUFBSTtRQUN4Qm5JLFVBQVVvbEIscUJBQXFCamtCLE1BQU02ZjtRQUNyQ2hoQixRQUFRZ2tCLEdBQUcsR0FBR2xkLGVBQWVrZCxHQUFHO1FBQ2hDaGtCLFFBQVEyQyxNQUFNLEdBQUdtRTtRQUNqQixPQUFRQSxlQUFlNEIsS0FBSyxHQUFHMUk7SUFDakM7SUFDQSxTQUFTNDhCLDBCQUNQNThCLE9BQU8sRUFDUDhHLGNBQWMsRUFDZGlrQixTQUFTLEVBQ1QvSixTQUFTLEVBQ1RwVyxXQUFXO1FBRVgsSUFBSSxTQUFTNUssU0FBUztZQUNwQixJQUFJKzhCLFlBQVkvOEIsUUFBUWtYLGFBQWE7WUFDckMsSUFDRXlLLGFBQWFvYixXQUFXL2IsY0FDeEJoaEIsUUFBUWdrQixHQUFHLEtBQUtsZCxlQUFla2QsR0FBRyxJQUNsQ2xkLGVBQWUzRixJQUFJLEtBQUtuQixRQUFRbUIsSUFBSSxFQUVwQyxJQUNHLG1CQUFvQixDQUFDLEdBQ3JCMkYsZUFBZS9ILFlBQVksR0FBR2lpQixZQUFZK2IsV0FDM0NELDhCQUE4Qjk4QixTQUFTNEssY0FFdkMsTUFBTzVLLENBQUFBLFFBQVFtSSxLQUFLLEdBQUcsTUFBSyxLQUFPbWtCLENBQUFBLG1CQUFtQixDQUFDO2lCQUV2RCxPQUNFLGVBQWdCdGlCLEtBQUssR0FBR2hLLFFBQVFnSyxLQUFLLEVBQ3JDc3lCLDZCQUE2QnQ4QixTQUFTOEcsZ0JBQWdCOEQ7UUFFOUQ7UUFDQSxPQUFPb3lCLHdCQUNMaDlCLFNBQ0E4RyxnQkFDQWlrQixXQUNBL0osV0FDQXBXO0lBRUo7SUFDQSxTQUFTcXlCLHlCQUF5Qmo5QixPQUFPLEVBQUU4RyxjQUFjLEVBQUU4RCxXQUFXO1FBQ3BFLElBQUlvVyxZQUFZbGEsZUFBZS9ILFlBQVksRUFDekNpOUIsZUFBZWhiLFVBQVV2TyxRQUFRLEVBQ2pDeXFCLGlCQUNFLE1BQU9wMkIsQ0FBQUEsZUFBZWdDLFNBQVMsQ0FBQ3EwQixrQkFBa0IsR0FBRyxJQUN2RHhLLFlBQVksU0FBUzN5QixVQUFVQSxRQUFRNUMsYUFBYSxHQUFHO1FBQ3pEZ2dDLFFBQVFwOUIsU0FBUzhHO1FBQ2pCLElBQUksYUFBYWthLFVBQVVoaUIsSUFBSSxJQUFJaytCLGdCQUFnQjtZQUNqRCxJQUFJLE1BQU9wMkIsQ0FBQUEsZUFBZXFCLEtBQUssR0FBRyxHQUFFLEdBQUk7Z0JBQ3RDNlksWUFDRSxTQUFTMlIsWUFDTEEsVUFBVWxLLFNBQVMsR0FBRzdkLGNBQ3RCQTtnQkFDTixJQUFJLFNBQVM1SyxTQUFTO29CQUNwQmc4QixlQUFlbDFCLGVBQWU0QixLQUFLLEdBQUcxSSxRQUFRMEksS0FBSztvQkFDbkQsSUFBS3cwQixpQkFBaUIsR0FBRyxTQUFTbEIsY0FDaEMsaUJBQ0VrQixpQkFBaUJsQixhQUFhaHlCLEtBQUssR0FBR2d5QixhQUFhOWlCLFVBQVUsRUFDNUQ4aUIsZUFBZUEsYUFBYXJ6QixPQUFPO29CQUN4QzdCLGVBQWVvUyxVQUFVLEdBQUdna0IsaUJBQWlCLENBQUNsYztnQkFDaEQsT0FBTyxlQUFnQjlILFVBQVUsR0FBRyxHQUFLcFMsZUFBZTRCLEtBQUssR0FBRztnQkFDaEUsT0FBTzIwQiw4QkFDTHI5QixTQUNBOEcsZ0JBQ0FrYSxXQUNBcFc7WUFFSjtZQUNBLElBQUksTUFBT0EsQ0FBQUEsY0FBYyxTQUFRLEdBQy9CLGVBQWdCeE4sYUFBYSxHQUFHO2dCQUFFcXJCLFdBQVc7Z0JBQUc2VSxXQUFXO1lBQUssR0FDOUQsU0FBU3Q5QixXQUNQdTlCLGVBQ0V6MkIsZ0JBQ0EsU0FBUzZyQixZQUFZQSxVQUFVMkssU0FBUyxHQUFHLE9BRS9DLFNBQVMzSyxZQUNMdkssa0JBQWtCdGhCLGdCQUFnQjZyQixhQUNsQ2pLLDBCQUEwQjVoQixpQkFDOUJtaUIsNkJBQTZCbmlCO2lCQUUvQixPQUNFLGVBQWdCa0QsS0FBSyxHQUFHbEQsZUFBZW9TLFVBQVUsR0FBRyxXQUNwRG1rQiw4QkFDRXI5QixTQUNBOEcsZ0JBQ0EsU0FBUzZyQixZQUNMQSxVQUFVbEssU0FBUyxHQUFHN2QsY0FDdEJBLGFBQ0pBO1FBR1IsT0FDRSxTQUFTK25CLFlBQ0o0SyxDQUFBQSxlQUFlejJCLGdCQUFnQjZyQixVQUFVMkssU0FBUyxHQUNuRGxWLGtCQUFrQnRoQixnQkFBZ0I2ckIsWUFDbEN6Siw0QkFBNEJwaUIsaUJBQzNCQSxlQUFlMUosYUFBYSxHQUFHLElBQUksSUFDbkMsVUFBUzRDLFdBQVd1OUIsZUFBZXoyQixnQkFBZ0IsT0FDcEQ0aEIsMEJBQTBCNWhCLGlCQUMxQm9pQiw0QkFBNEJwaUIsZUFBYztRQUNoRGkxQixrQkFBa0IvN0IsU0FBUzhHLGdCQUFnQmsxQixjQUFjcHhCO1FBQ3pELE9BQU85RCxlQUFlNEIsS0FBSztJQUM3QjtJQUNBLFNBQVMyMEIsOEJBQ1ByOUIsT0FBTyxFQUNQOEcsY0FBYyxFQUNkMDJCLGFBQWEsRUFDYjV5QixXQUFXO1FBRVgsSUFBSTFELDJCQUEyQnUyQjtRQUMvQnYyQiwyQkFDRSxTQUFTQSwyQkFDTCxPQUNBO1lBQ0U4QixRQUFRZ0osb0JBQ0owckIsYUFBYXhyQixhQUFhLEdBQzFCd3JCLGFBQWF0ckIsY0FBYztZQUMvQnVyQixNQUFNejJCO1FBQ1I7UUFDTkosZUFBZTFKLGFBQWEsR0FBRztZQUM3QnFyQixXQUFXK1U7WUFDWEYsV0FBV3AyQjtRQUNiO1FBQ0EsU0FBU2xILFdBQVd1OUIsZUFBZXoyQixnQkFBZ0I7UUFDbkQ0aEIsMEJBQTBCNWhCO1FBQzFCbWlCLDZCQUE2Qm5pQjtRQUM3QixTQUFTOUcsV0FDUGk3Qiw4QkFBOEJqN0IsU0FBUzhHLGdCQUFnQjhELGFBQWEsQ0FBQztRQUN2RSxPQUFPO0lBQ1Q7SUFDQSxTQUFTd3lCLFFBQVFwOUIsT0FBTyxFQUFFOEcsY0FBYztRQUN0QyxJQUFJa2QsTUFBTWxkLGVBQWVrZCxHQUFHO1FBQzVCLElBQUksU0FBU0EsS0FDWCxTQUFTaGtCLFdBQ1AsU0FBU0EsUUFBUWdrQixHQUFHLElBQ25CbGQsQ0FBQUEsZUFBZXFCLEtBQUssSUFBSSxPQUFNO2FBQzlCO1lBQ0gsSUFBSSxlQUFlLE9BQU82YixPQUFPLGFBQWEsT0FBT0EsS0FDbkQsTUFBTTVmLE1BQ0o7WUFFSixJQUFJLFNBQVNwRSxXQUFXQSxRQUFRZ2tCLEdBQUcsS0FBS0EsS0FDdENsZCxlQUFlcUIsS0FBSyxJQUFJO1FBQzVCO0lBQ0Y7SUFDQSxTQUFTNjBCLHdCQUNQaDlCLE9BQU8sRUFDUDhHLGNBQWMsRUFDZGlrQixTQUFTLEVBQ1QvSixTQUFTLEVBQ1RwVyxXQUFXO1FBRVgsSUFDRW1nQixVQUFVdGxCLFNBQVMsSUFDbkIsZUFBZSxPQUFPc2xCLFVBQVV0bEIsU0FBUyxDQUFDdEQsTUFBTSxFQUNoRDtZQUNBLElBQUl5ZCxnQkFBZ0IxZSx5QkFBeUI2cEIsY0FBYztZQUMzRDZTLG9CQUFvQixDQUFDaGUsY0FBYyxJQUNoQ3hoQixDQUFBQSxRQUFRZ0MsS0FBSyxDQUNaLDBLQUNBd2YsZUFDQUEsZ0JBRURnZSxvQkFBb0IsQ0FBQ2hlLGNBQWMsR0FBRyxDQUFDLENBQUM7UUFDN0M7UUFDQTlZLGVBQWU5SCxJQUFJLEdBQUcsS0FDcEI2K0Isd0JBQXdCQywwQkFBMEIsQ0FDaERoM0IsZ0JBQ0E7UUFFSixTQUFTOUcsV0FDTjI4QixDQUFBQSwrQkFBK0I3MUIsZ0JBQWdCQSxlQUFlM0YsSUFBSSxHQUNuRTRwQixVQUFVZ1QsWUFBWSxJQUNuQixpQkFBaUI3OEIseUJBQXlCNnBCLGNBQWMsV0FDekRpVCx3QkFBd0IsQ0FBQ3BlLGNBQWMsSUFDcEMseUJBQXlCLENBQUNBLGNBQWMsR0FBRyxDQUFDLEdBQzdDeGhCLFFBQVFnQyxLQUFLLENBQ1gseUtBQ0F3ZixjQUNGLENBQUMsQ0FBQztRQUNSeWMscUJBQXFCdjFCO1FBQ3JCb0ksMkJBQTJCcEk7UUFDM0Jpa0IsWUFBWUQsZ0JBQ1Y5cUIsU0FDQThHLGdCQUNBaWtCLFdBQ0EvSixXQUNBLEtBQUssR0FDTHBXO1FBRUZvVyxZQUFZcU07UUFDWmxlO1FBQ0EsSUFBSSxTQUFTblAsV0FBVyxDQUFDc3NCLGtCQUN2QixPQUNFa0IsYUFBYXh0QixTQUFTOEcsZ0JBQWdCOEQsY0FDdEMweEIsNkJBQTZCdDhCLFNBQVM4RyxnQkFBZ0I4RDtRQUUxRG9HLGVBQWVnUSxhQUFhbFEsdUJBQXVCaEs7UUFDbkRBLGVBQWVxQixLQUFLLElBQUk7UUFDeEI0ekIsa0JBQWtCLzdCLFNBQVM4RyxnQkFBZ0Jpa0IsV0FBV25nQjtRQUN0RCxPQUFPOUQsZUFBZTRCLEtBQUs7SUFDN0I7SUFDQSxTQUFTdTFCLHdCQUNQaitCLE9BQU8sRUFDUDhHLGNBQWMsRUFDZGthLFNBQVMsRUFDVCtKLFNBQVMsRUFDVEMsU0FBUyxFQUNUcGdCLFdBQVc7UUFFWHl4QixxQkFBcUJ2MUI7UUFDckJvSSwyQkFBMkJwSTtRQUMzQmlqQiwwQkFBMEIsQ0FBQztRQUMzQmMsNkJBQ0UsU0FBUzdxQixXQUFXQSxRQUFRbUIsSUFBSSxLQUFLMkYsZUFBZTNGLElBQUk7UUFDMUQyRixlQUFlZ1ksV0FBVyxHQUFHO1FBQzdCa0MsWUFBWTJLLHFCQUNWN2tCLGdCQUNBaWtCLFdBQ0EvSixXQUNBZ0s7UUFFRlkscUJBQXFCNXJCLFNBQVM4RztRQUM5QmlrQixZQUFZc0M7UUFDWmxlO1FBQ0EsSUFBSSxTQUFTblAsV0FBVyxDQUFDc3NCLGtCQUN2QixPQUNFa0IsYUFBYXh0QixTQUFTOEcsZ0JBQWdCOEQsY0FDdEMweEIsNkJBQTZCdDhCLFNBQVM4RyxnQkFBZ0I4RDtRQUUxRG9HLGVBQWUrWixhQUFhamEsdUJBQXVCaEs7UUFDbkRBLGVBQWVxQixLQUFLLElBQUk7UUFDeEI0ekIsa0JBQWtCLzdCLFNBQVM4RyxnQkFBZ0JrYSxXQUFXcFc7UUFDdEQsT0FBTzlELGVBQWU0QixLQUFLO0lBQzdCO0lBQ0EsU0FBU3cxQixxQkFDUEMsZ0JBQWdCLEVBQ2hCcjNCLGNBQWMsRUFDZGlrQixTQUFTLEVBQ1QvSixTQUFTLEVBQ1RwVyxXQUFXO1FBRVgsT0FBUWhNLGdCQUFnQmtJO1lBQ3RCLEtBQUssQ0FBQztnQkFDSixJQUFJczNCLFlBQVl0M0IsZUFBZWdDLFNBQVMsRUFDdEN3Z0IsUUFBUSxJQUFJeGlCLGVBQWUzRixJQUFJLENBQzdCMkYsZUFBZW9RLGFBQWEsRUFDNUJrbkIsVUFBVS8rQixPQUFPLEVBQ2pCaXFCLEtBQUs7Z0JBQ1Q4VSxVQUFVQyxPQUFPLENBQUNDLGVBQWUsQ0FBQ0YsV0FBVzlVLE9BQU87Z0JBQ3BEO1lBQ0YsS0FBSyxDQUFDO2dCQUNKeGlCLGVBQWVxQixLQUFLLElBQUk7Z0JBQ3hCckIsZUFBZXFCLEtBQUssSUFBSTtnQkFDeEJpMkIsWUFBWWg2QixNQUFNO2dCQUNsQixJQUFJMEYsT0FBT2MsY0FBYyxDQUFDQTtnQkFDMUI5RCxlQUFla0QsS0FBSyxJQUFJRjtnQkFDeEJ3ZixRQUFRMU47Z0JBQ1IsSUFBSSxTQUFTME4sT0FDWCxNQUFNbGxCLE1BQ0o7Z0JBRUowRixPQUFPeXdCLHVCQUF1Qnp3QjtnQkFDOUIwd0IsMkJBQ0Uxd0IsTUFDQXdmLE9BQ0F4aUIsZ0JBQ0EySSwyQkFBMkIydUIsV0FBV3QzQjtnQkFFeENpWixzQkFBc0JqWixnQkFBZ0JnRDtRQUMxQztRQUNBdXlCLHFCQUFxQnYxQjtRQUNyQixJQUFJLFNBQVNBLGVBQWVnQyxTQUFTLEVBQUU7WUFDckN3Z0IsUUFBUWhxQjtZQUNSOCtCLFlBQVlyVCxVQUFVd1QsV0FBVztZQUNqQyxpQkFBaUJ4VCxhQUNmLFNBQVNxVCxhQUNSLE1BQUssTUFBTUEsYUFBYUEsVUFBVWg5QixRQUFRLEtBQUtVLGtCQUFpQixLQUNqRSxDQUFDMDhCLGtDQUFrQ3R4QixHQUFHLENBQUM2ZCxjQUN0Q3lULENBQUFBLGtDQUFrQzF4QixHQUFHLENBQUNpZSxZQUN0Q2poQixPQUNDLEtBQUssTUFBTXMwQixZQUNQLDROQUNBLGFBQWEsT0FBT0EsWUFDbEIsOEJBQThCLE9BQU9BLFlBQVksTUFDakRBLFVBQVVoOUIsUUFBUSxLQUFLVyxzQkFDckIsNkRBQ0EsaURBQ0FnQyxPQUFPNFIsSUFBSSxDQUFDeW9CLFdBQVd0OUIsSUFBSSxDQUFDLFFBQzVCLE1BQ1YxQyxRQUFRZ0MsS0FBSyxDQUNYLDBIQUNBYyx5QkFBeUI2cEIsY0FBYyxhQUN2Q2poQixLQUNGO1lBQ0YsYUFBYSxPQUFPczBCLGFBQ2xCLFNBQVNBLGFBQ1I5VSxDQUFBQSxRQUFRMkUsWUFBWW1RLFVBQVM7WUFDaENBLFlBQVksSUFBSXJULFVBQVUvSixXQUFXc0k7WUFDckMsSUFBSXhpQixlQUFlOUgsSUFBSSxHQUFHLEdBQUc7Z0JBQzNCMFAsMkJBQTJCLENBQUM7Z0JBQzVCLElBQUk7b0JBQ0YwdkIsWUFBWSxJQUFJclQsVUFBVS9KLFdBQVdzSTtnQkFDdkMsU0FBVTtvQkFDUjVhLDJCQUEyQixDQUFDO2dCQUM5QjtZQUNGO1lBQ0E0YSxRQUFReGlCLGVBQWUxSixhQUFhLEdBQ2xDLFNBQVNnaEMsVUFBVTlVLEtBQUssSUFBSSxLQUFLLE1BQU04VSxVQUFVOVUsS0FBSyxHQUNsRDhVLFVBQVU5VSxLQUFLLEdBQ2Y7WUFDTjhVLFVBQVVDLE9BQU8sR0FBR2hGO1lBQ3BCdnlCLGVBQWVnQyxTQUFTLEdBQUdzMUI7WUFDM0JBLFVBQVVLLGVBQWUsR0FBRzMzQjtZQUM1QnMzQixVQUFVTSxzQkFBc0IsR0FBR0M7WUFDbkMsZUFBZSxPQUFPNVQsVUFBVTJOLHdCQUF3QixJQUN0RCxTQUFTcFAsU0FDUixTQUFTcG9CLHlCQUF5QjZwQixjQUFjLGFBQ2pENlQsK0JBQStCMXhCLEdBQUcsQ0FBQ29jLFVBQ2hDc1YsQ0FBQUEsK0JBQStCOXhCLEdBQUcsQ0FBQ3djLFFBQ3BDbHJCLFFBQVFnQyxLQUFLLENBQ1gsbVJBQ0FrcEIsT0FDQSxTQUFTOFUsVUFBVTlVLEtBQUssR0FBRyxTQUFTLGFBQ3BDQSxNQUNGLENBQUM7WUFDTCxJQUNFLGVBQWUsT0FBT3lCLFVBQVUyTix3QkFBd0IsSUFDeEQsZUFBZSxPQUFPMEYsVUFBVVMsdUJBQXVCLEVBQ3ZEO2dCQUNBLElBQUlDLHNCQUF1QmgxQixPQUFPd2YsUUFBUTtnQkFDMUMsZUFBZSxPQUFPOFUsVUFBVVcsa0JBQWtCLElBQ2xELENBQUMsTUFBTVgsVUFBVVcsa0JBQWtCLENBQUNDLDRCQUE0QixHQUMzRDFWLFFBQVEsdUJBQ1QsZUFBZSxPQUFPOFUsVUFBVWEseUJBQXlCLElBQ3hEM1YsQ0FBQUEsUUFBUSwyQkFBMEI7Z0JBQ3ZDLGVBQWUsT0FBTzhVLFVBQVVsRix5QkFBeUIsSUFDekQsQ0FBQyxNQUNDa0YsVUFBVWxGLHlCQUF5QixDQUFDOEYsNEJBQTRCLEdBQzdEbDFCLE9BQU8sOEJBQ1IsZUFDRSxPQUFPczBCLFVBQVVqRixnQ0FBZ0MsSUFDbERydkIsQ0FBQUEsT0FBTyxrQ0FBaUM7Z0JBQzdDLGVBQWUsT0FBT3MwQixVQUFVYyxtQkFBbUIsSUFDbkQsQ0FBQyxNQUFNZCxVQUFVYyxtQkFBbUIsQ0FBQ0YsNEJBQTRCLEdBQzVERixzQkFBc0Isd0JBQ3ZCLGVBQWUsT0FBT1YsVUFBVWUsMEJBQTBCLElBQ3pETCxDQUFBQSxzQkFBc0IsNEJBQTJCO2dCQUN0RCxJQUFJLFNBQVN4VixTQUFTLFNBQVN4ZixRQUFRLFNBQVNnMUIscUJBQXFCO29CQUNuRVYsWUFBWWw5Qix5QkFBeUI2cEIsY0FBYztvQkFDbkQsSUFBSXFVLGFBQ0YsZUFBZSxPQUFPclUsVUFBVTJOLHdCQUF3QixHQUNwRCwrQkFDQTtvQkFDTjJHLDRDQUE0Q255QixHQUFHLENBQUNreEIsY0FDN0NpQixDQUFBQSw0Q0FBNEN2eUIsR0FBRyxDQUFDc3hCLFlBQ2pEaGdDLFFBQVFnQyxLQUFLLENBQ1gsa1NBQ0FnK0IsV0FDQWdCLFlBQ0EsU0FBUzlWLFFBQVEsU0FBU0EsUUFBUSxJQUNsQyxTQUFTeGYsT0FBTyxTQUFTQSxPQUFPLElBQ2hDLFNBQVNnMUIsc0JBQXNCLFNBQVNBLHNCQUFzQixHQUNoRTtnQkFDSjtZQUNGO1lBQ0FWLFlBQVl0M0IsZUFBZWdDLFNBQVM7WUFDcEN3Z0IsUUFBUXBvQix5QkFBeUI2cEIsY0FBYztZQUMvQ3FULFVBQVVqOEIsTUFBTSxJQUNiNG9CLENBQUFBLFVBQVV0bEIsU0FBUyxJQUNwQixlQUFlLE9BQU9zbEIsVUFBVXRsQixTQUFTLENBQUN0RCxNQUFNLEdBQzVDL0QsUUFBUWdDLEtBQUssQ0FDWCw0R0FDQWtwQixTQUVGbHJCLFFBQVFnQyxLQUFLLENBQ1gsMkZBQ0FrcEIsTUFDRjtZQUNOLENBQUM4VSxVQUFVa0IsZUFBZSxJQUN4QmxCLFVBQVVrQixlQUFlLENBQUNDLG9CQUFvQixJQUM5Q25CLFVBQVU5VSxLQUFLLElBQ2ZsckIsUUFBUWdDLEtBQUssQ0FDWCxxTEFDQWtwQjtZQUVKOFUsVUFBVW9CLGVBQWUsSUFDdkIsQ0FBQ3BCLFVBQVVvQixlQUFlLENBQUNELG9CQUFvQixJQUMvQ25oQyxRQUFRZ0MsS0FBSyxDQUNYLDBMQUNBa3BCO1lBRUo4VSxVQUFVRyxXQUFXLElBQ25CbmdDLFFBQVFnQyxLQUFLLENBQ1gsK0dBQ0FrcEI7WUFFSnlCLFVBQVUwVSxpQkFBaUIsSUFDekIsQ0FBQ0MsOEJBQThCeHlCLEdBQUcsQ0FBQzZkLGNBQ2xDMlUsQ0FBQUEsOEJBQThCNXlCLEdBQUcsQ0FBQ2llLFlBQ25DM3NCLFFBQVFnQyxLQUFLLENBQ1gsc0pBQ0FrcEIsTUFDRjtZQUNGeUIsVUFBVWdULFlBQVksSUFDcEIsQ0FBQzRCLDJCQUEyQnp5QixHQUFHLENBQUM2ZCxjQUMvQjRVLENBQUFBLDJCQUEyQjd5QixHQUFHLENBQUNpZSxZQUNoQzNzQixRQUFRZ0MsS0FBSyxDQUNYLHlLQUNBa3BCLE1BQ0Y7WUFDRixlQUFlLE9BQU84VSxVQUFVd0IscUJBQXFCLElBQ25EeGhDLFFBQVFnQyxLQUFLLENBQ1gsK0tBQ0FrcEI7WUFFSnlCLFVBQVV0bEIsU0FBUyxJQUNqQnNsQixVQUFVdGxCLFNBQVMsQ0FBQ3V6QixvQkFBb0IsSUFDeEMsZ0JBQWdCLE9BQU9vRixVQUFVckYscUJBQXFCLElBQ3REMzZCLFFBQVFnQyxLQUFLLENBQ1gsZ01BQ0FjLHlCQUF5QjZwQixjQUFjO1lBRTNDLGVBQWUsT0FBT3FULFVBQVV5QixtQkFBbUIsSUFDakR6aEMsUUFBUWdDLEtBQUssQ0FDWCw2SEFDQWtwQjtZQUVKLGVBQWUsT0FBTzhVLFVBQVUwQix3QkFBd0IsSUFDdEQxaEMsUUFBUWdDLEtBQUssQ0FDWCxvVEFDQWtwQjtZQUVKLGVBQWUsT0FBTzhVLFVBQVUyQix5QkFBeUIsSUFDdkQzaEMsUUFBUWdDLEtBQUssQ0FDWCxpR0FDQWtwQjtZQUVKLGVBQWUsT0FBTzhVLFVBQVU0QixnQ0FBZ0MsSUFDOUQ1aEMsUUFBUWdDLEtBQUssQ0FDWCwrR0FDQWtwQjtZQUVKeGYsT0FBT3MwQixVQUFVejZCLEtBQUssS0FBS3FkO1lBQzNCLEtBQUssTUFBTW9kLFVBQVV6NkIsS0FBSyxJQUN4Qm1HLFFBQ0ExTCxRQUFRZ0MsS0FBSyxDQUNYLG1IQUNBa3BCO1lBRUo4VSxVQUFVM0UsWUFBWSxJQUNwQnI3QixRQUFRZ0MsS0FBSyxDQUNYLHFKQUNBa3BCLE9BQ0FBO1lBRUosZUFBZSxPQUFPOFUsVUFBVVMsdUJBQXVCLElBQ3JELGVBQWUsT0FBT1QsVUFBVTZCLGtCQUFrQixJQUNsREMsb0RBQW9EaHpCLEdBQUcsQ0FBQzZkLGNBQ3ZEbVYsQ0FBQUEsb0RBQW9EcHpCLEdBQUcsQ0FBQ2llLFlBQ3pEM3NCLFFBQVFnQyxLQUFLLENBQ1gsa0lBQ0FjLHlCQUF5QjZwQixXQUMzQjtZQUNGLGVBQWUsT0FBT3FULFVBQVUxRix3QkFBd0IsSUFDdER0NkIsUUFBUWdDLEtBQUssQ0FDWCxnSUFDQWtwQjtZQUVKLGVBQWUsT0FBTzhVLFVBQVUzRCx3QkFBd0IsSUFDdERyOEIsUUFBUWdDLEtBQUssQ0FDWCxnSUFDQWtwQjtZQUVKLGVBQWUsT0FBT3lCLFVBQVU4VCx1QkFBdUIsSUFDckR6Z0MsUUFBUWdDLEtBQUssQ0FDWCwrSEFDQWtwQjtZQUVIeGYsQ0FBQUEsT0FBT3MwQixVQUFVOVUsS0FBSyxLQUNwQixjQUFhLE9BQU94ZixRQUFRaE0sWUFBWWdNLEtBQUksS0FDN0MxTCxRQUFRZ0MsS0FBSyxDQUFDLDhDQUE4Q2twQjtZQUM5RCxlQUFlLE9BQU84VSxVQUFVK0IsZUFBZSxJQUM3QyxhQUFhLE9BQU9wVixVQUFVMFUsaUJBQWlCLElBQy9DcmhDLFFBQVFnQyxLQUFLLENBQ1gsOEZBQ0FrcEI7WUFFSjhVLFlBQVl0M0IsZUFBZWdDLFNBQVM7WUFDcENzMUIsVUFBVXo2QixLQUFLLEdBQUdxZDtZQUNsQm9kLFVBQVU5VSxLQUFLLEdBQUd4aUIsZUFBZTFKLGFBQWE7WUFDOUNnaEMsVUFBVWdDLElBQUksR0FBRyxDQUFDO1lBQ2xCdmhCLHNCQUFzQi9YO1lBQ3RCd2lCLFFBQVF5QixVQUFVd1QsV0FBVztZQUM3QkgsVUFBVS8rQixPQUFPLEdBQ2YsYUFBYSxPQUFPaXFCLFNBQVMsU0FBU0EsUUFDbEMyRSxZQUFZM0UsU0FDWmhxQjtZQUNOOCtCLFVBQVU5VSxLQUFLLEtBQUt0SSxhQUNqQixTQUFTOWYseUJBQXlCNnBCLGNBQWMsYUFDakRzViwwQ0FBMENuekIsR0FBRyxDQUFDb2MsVUFDM0MrVyxDQUFBQSwwQ0FBMEN2ekIsR0FBRyxDQUFDd2MsUUFDL0NsckIsUUFBUWdDLEtBQUssQ0FDWCx3S0FDQWtwQixNQUNGLENBQUM7WUFDTHhpQixlQUFlOUgsSUFBSSxHQUFHLEtBQ3BCNitCLHdCQUF3QkMsMEJBQTBCLENBQ2hEaDNCLGdCQUNBczNCO1lBRUpQLHdCQUF3QnlDLDZCQUE2QixDQUNuRHg1QixnQkFDQXMzQjtZQUVGQSxVQUFVOVUsS0FBSyxHQUFHeGlCLGVBQWUxSixhQUFhO1lBQzlDa3NCLFFBQVF5QixVQUFVMk4sd0JBQXdCO1lBQzFDLGVBQWUsT0FBT3BQLFNBQ25Ca1AsQ0FBQUEsMkJBQ0MxeEIsZ0JBQ0Fpa0IsV0FDQXpCLE9BQ0F0SSxZQUVEb2QsVUFBVTlVLEtBQUssR0FBR3hpQixlQUFlMUosYUFBYTtZQUNqRCxlQUFlLE9BQU8ydEIsVUFBVTJOLHdCQUF3QixJQUN0RCxlQUFlLE9BQU8wRixVQUFVUyx1QkFBdUIsSUFDdEQsZUFBZSxPQUFPVCxVQUFVYSx5QkFBeUIsSUFDeEQsZUFBZSxPQUFPYixVQUFVVyxrQkFBa0IsSUFDbkQsU0FBU1gsVUFBVTlVLEtBQUssRUFDekIsZUFBZSxPQUFPOFUsVUFBVVcsa0JBQWtCLElBQ2hEWCxVQUFVVyxrQkFBa0IsSUFDOUIsZUFBZSxPQUFPWCxVQUFVYSx5QkFBeUIsSUFDdkRiLFVBQVVhLHlCQUF5QixJQUNyQzNWLFVBQVU4VSxVQUFVOVUsS0FBSyxJQUN0QmxyQixDQUFBQSxRQUFRZ0MsS0FBSyxDQUNaLDRJQUNBcUMsMEJBQTBCcUUsbUJBQW1CLGNBRS9DdXlCLHNCQUFzQkMsbUJBQW1CLENBQ3ZDOEUsV0FDQUEsVUFBVTlVLEtBQUssRUFDZixLQUNGLEdBQ0YvSSxtQkFBbUJ6WixnQkFBZ0JrYSxXQUFXb2QsV0FBV3h6QixjQUN6RHdWLCtDQUNDZ2UsVUFBVTlVLEtBQUssR0FBR3hpQixlQUFlMUosYUFBYTtZQUNqRCxlQUFlLE9BQU9naEMsVUFBVW1DLGlCQUFpQixJQUM5Q3o1QixDQUFBQSxlQUFlcUIsS0FBSyxJQUFJLE9BQU07WUFDaENyQixDQUFBQSxlQUFlOUgsSUFBSSxHQUFHLEVBQUMsTUFBT3dzQixVQUM1QjFrQixDQUFBQSxlQUFlcUIsS0FBSyxJQUFJLFFBQU87WUFDbENpMkIsWUFBWSxDQUFDO1FBQ2YsT0FBTyxJQUFJLFNBQVNELGtCQUFrQjtZQUNwQ0MsWUFBWXQzQixlQUFlZ0MsU0FBUztZQUNwQyxJQUFJMDNCLHFCQUFxQjE1QixlQUFlb1EsYUFBYTtZQUNyRHBOLE9BQU95dkIsMkJBQTJCeE8sV0FBV3lWO1lBQzdDcEMsVUFBVXo2QixLQUFLLEdBQUdtRztZQUNsQixJQUFJMjJCLGFBQWFyQyxVQUFVLytCLE9BQU87WUFDbEN5L0Isc0JBQXNCL1QsVUFBVXdULFdBQVc7WUFDM0NqVixRQUFRaHFCO1lBQ1IsYUFBYSxPQUFPdy9CLHVCQUNsQixTQUFTQSx1QkFDUnhWLENBQUFBLFFBQVEyRSxZQUFZNlEsb0JBQW1CO1lBQzFDTSxhQUFhclUsVUFBVTJOLHdCQUF3QjtZQUMvQ29HLHNCQUNFLGVBQWUsT0FBT00sY0FDdEIsZUFBZSxPQUFPaEIsVUFBVVMsdUJBQXVCO1lBQ3pEMkIscUJBQXFCMTVCLGVBQWUvSCxZQUFZLEtBQUt5aEM7WUFDckQxQix1QkFDRyxlQUFlLE9BQU9WLFVBQVVqRixnQ0FBZ0MsSUFDL0QsZUFBZSxPQUFPaUYsVUFBVWxGLHlCQUF5QixJQUMxRCxDQUFDc0gsc0JBQXNCQyxlQUFlblgsS0FBSSxLQUN6QzJQLDhCQUNFbnlCLGdCQUNBczNCLFdBQ0FwZCxXQUNBc0k7WUFFTjdJLGlCQUFpQixDQUFDO1lBQ2xCLElBQUlnVCxXQUFXM3NCLGVBQWUxSixhQUFhO1lBQzNDZ2hDLFVBQVU5VSxLQUFLLEdBQUdtSztZQUNsQmxULG1CQUFtQnpaLGdCQUFnQmthLFdBQVdvZCxXQUFXeHpCO1lBQ3pEd1Y7WUFDQXFnQixhQUFhMzVCLGVBQWUxSixhQUFhO1lBQ3pDb2pDLHNCQUFzQi9NLGFBQWFnTixjQUFjaGdCLGlCQUM1QyxnQkFBZSxPQUFPMmUsY0FDcEI1RyxDQUFBQSwyQkFDQzF4QixnQkFDQWlrQixXQUNBcVUsWUFDQXBlLFlBRUR5ZixhQUFhMzVCLGVBQWUxSixhQUFhLEdBQzVDLENBQUMwTSxPQUNDMlcsa0JBQ0FtWSwyQkFDRTl4QixnQkFDQWlrQixXQUNBamhCLE1BQ0FrWCxXQUNBeVMsVUFDQWdOLFlBQ0FuWCxNQUNGLElBQ0d3VixDQUFBQSx1QkFDRSxlQUFlLE9BQU9WLFVBQVVhLHlCQUF5QixJQUN4RCxlQUFlLE9BQU9iLFVBQVVXLGtCQUFrQixJQUNuRCxnQkFBZSxPQUFPWCxVQUFVVyxrQkFBa0IsSUFDakRYLFVBQVVXLGtCQUFrQixJQUM5QixlQUFlLE9BQU9YLFVBQVVhLHlCQUF5QixJQUN2RGIsVUFBVWEseUJBQXlCLEVBQUMsR0FDeEMsZUFBZSxPQUFPYixVQUFVbUMsaUJBQWlCLElBQzlDejVCLENBQUFBLGVBQWVxQixLQUFLLElBQUksT0FBTSxHQUNqQyxDQUFDckIsZUFBZTlILElBQUksR0FBRyxFQUFDLE1BQU93c0IsVUFDNUIxa0IsQ0FBQUEsZUFBZXFCLEtBQUssSUFBSSxRQUFPLENBQUMsSUFDbEMsZ0JBQWUsT0FBT2kyQixVQUFVbUMsaUJBQWlCLElBQy9DejVCLENBQUFBLGVBQWVxQixLQUFLLElBQUksT0FBTSxHQUNqQyxDQUFDckIsZUFBZTlILElBQUksR0FBRyxFQUFDLE1BQU93c0IsVUFDNUIxa0IsQ0FBQUEsZUFBZXFCLEtBQUssSUFBSSxRQUFPLEdBQ2pDckIsZUFBZW9RLGFBQWEsR0FBRzhKLFdBQy9CbGEsZUFBZTFKLGFBQWEsR0FBR3FqQyxVQUFVLEdBQzdDckMsVUFBVXo2QixLQUFLLEdBQUdxZCxXQUNsQm9kLFVBQVU5VSxLQUFLLEdBQUdtWCxZQUNsQnJDLFVBQVUvK0IsT0FBTyxHQUFHaXFCLE9BQ3BCOFUsWUFBWXQwQixJQUFJLElBQ2hCLGdCQUFlLE9BQU9zMEIsVUFBVW1DLGlCQUFpQixJQUMvQ3o1QixDQUFBQSxlQUFlcUIsS0FBSyxJQUFJLE9BQU0sR0FDakMsQ0FBQ3JCLGVBQWU5SCxJQUFJLEdBQUcsRUFBQyxNQUFPd3NCLFVBQzVCMWtCLENBQUFBLGVBQWVxQixLQUFLLElBQUksUUFBTyxHQUNqQ2kyQixZQUFZLENBQUMsQ0FBQztRQUNyQixPQUFPO1lBQ0xBLFlBQVl0M0IsZUFBZWdDLFNBQVM7WUFDcEN1VyxpQkFBaUI4ZSxrQkFBa0JyM0I7WUFDbkN3aUIsUUFBUXhpQixlQUFlb1EsYUFBYTtZQUNwQzRuQixzQkFBc0J2RiwyQkFBMkJ4TyxXQUFXekI7WUFDNUQ4VSxVQUFVejZCLEtBQUssR0FBR203QjtZQUNsQk0sYUFBYXQ0QixlQUFlL0gsWUFBWTtZQUN4QzAwQixXQUFXMkssVUFBVS8rQixPQUFPO1lBQzVCb2hDLGFBQWExVixVQUFVd1QsV0FBVztZQUNsQ3owQixPQUFPeEs7WUFDUCxhQUFhLE9BQU9taEMsY0FDbEIsU0FBU0EsY0FDUjMyQixDQUFBQSxPQUFPbWtCLFlBQVl3UyxXQUFVO1lBQ2hDRCxxQkFBcUJ6VixVQUFVMk4sd0JBQXdCO1lBQ3REK0gsQ0FBQUEsYUFDQyxlQUFlLE9BQU9ELHNCQUN0QixlQUFlLE9BQU9wQyxVQUFVUyx1QkFBdUIsS0FDdEQsZUFBZSxPQUFPVCxVQUFVakYsZ0NBQWdDLElBQy9ELGVBQWUsT0FBT2lGLFVBQVVsRix5QkFBeUIsSUFDMUQsQ0FBQzVQLFVBQVU4VixjQUFjM0wsYUFBYTNwQixJQUFHLEtBQ3hDbXZCLDhCQUNFbnlCLGdCQUNBczNCLFdBQ0FwZCxXQUNBbFg7WUFFTjJXLGlCQUFpQixDQUFDO1lBQ2xCZ1QsV0FBVzNzQixlQUFlMUosYUFBYTtZQUN2Q2doQyxVQUFVOVUsS0FBSyxHQUFHbUs7WUFDbEJsVCxtQkFBbUJ6WixnQkFBZ0JrYSxXQUFXb2QsV0FBV3h6QjtZQUN6RHdWO1lBQ0EsSUFBSVMsV0FBVy9aLGVBQWUxSixhQUFhO1lBQzNDa3NCLFVBQVU4VixjQUNWM0wsYUFBYTVTLFlBQ2JKLGtCQUNDLFNBQVMwZCxvQkFDUixTQUFTQSxpQkFBaUJ0UyxZQUFZLElBQ3RDVSxzQkFBc0I0UixpQkFBaUJ0UyxZQUFZLElBQ2hELGdCQUFlLE9BQU8yVSxzQkFDcEJoSSxDQUFBQSwyQkFDQzF4QixnQkFDQWlrQixXQUNBeVYsb0JBQ0F4ZixZQUVESCxXQUFXL1osZUFBZTFKLGFBQWEsR0FDMUMsQ0FBQzBoQyxzQkFDQ3JlLGtCQUNBbVksMkJBQ0U5eEIsZ0JBQ0Fpa0IsV0FDQStULHFCQUNBOWQsV0FDQXlTLFVBQ0E1UyxVQUNBL1csU0FFRCxTQUFTcTBCLG9CQUNSLFNBQVNBLGlCQUFpQnRTLFlBQVksSUFDdENVLHNCQUFzQjRSLGlCQUFpQnRTLFlBQVksQ0FBQyxJQUNuRDRVLENBQUFBLGNBQ0UsZUFBZSxPQUFPckMsVUFBVWUsMEJBQTBCLElBQ3pELGVBQWUsT0FBT2YsVUFBVWMsbUJBQW1CLElBQ3BELGdCQUFlLE9BQU9kLFVBQVVjLG1CQUFtQixJQUNsRGQsVUFBVWMsbUJBQW1CLENBQUNsZSxXQUFXSCxVQUFVL1csT0FDckQsZUFBZSxPQUFPczBCLFVBQVVlLDBCQUEwQixJQUN4RGYsVUFBVWUsMEJBQTBCLENBQ2xDbmUsV0FDQUgsVUFDQS9XLEtBQ0YsR0FDSixlQUFlLE9BQU9zMEIsVUFBVTZCLGtCQUFrQixJQUMvQ241QixDQUFBQSxlQUFlcUIsS0FBSyxJQUFJLElBQzNCLGVBQWUsT0FBT2kyQixVQUFVUyx1QkFBdUIsSUFDcEQvM0IsQ0FBQUEsZUFBZXFCLEtBQUssSUFBSSxJQUFHLENBQUMsSUFDOUIsZ0JBQWUsT0FBT2kyQixVQUFVNkIsa0JBQWtCLElBQ2hEM1csVUFBVTZVLGlCQUFpQmpuQixhQUFhLElBQ3ZDdWMsYUFBYTBLLGlCQUFpQi9nQyxhQUFhLElBQzVDMEosQ0FBQUEsZUFBZXFCLEtBQUssSUFBSSxJQUMzQixlQUFlLE9BQU9pMkIsVUFBVVMsdUJBQXVCLElBQ3BEdlYsVUFBVTZVLGlCQUFpQmpuQixhQUFhLElBQ3ZDdWMsYUFBYTBLLGlCQUFpQi9nQyxhQUFhLElBQzVDMEosQ0FBQUEsZUFBZXFCLEtBQUssSUFBSSxJQUFHLEdBQzdCckIsZUFBZW9RLGFBQWEsR0FBRzhKLFdBQy9CbGEsZUFBZTFKLGFBQWEsR0FBR3lqQixRQUFRLEdBQzNDdWQsVUFBVXo2QixLQUFLLEdBQUdxZCxXQUNsQm9kLFVBQVU5VSxLQUFLLEdBQUd6SSxVQUNsQnVkLFVBQVUvK0IsT0FBTyxHQUFHeUssTUFDcEJzMEIsWUFBWVUsbUJBQW1CLElBQy9CLGdCQUFlLE9BQU9WLFVBQVU2QixrQkFBa0IsSUFDaEQzVyxVQUFVNlUsaUJBQWlCam5CLGFBQWEsSUFDdkN1YyxhQUFhMEssaUJBQWlCL2dDLGFBQWEsSUFDNUMwSixDQUFBQSxlQUFlcUIsS0FBSyxJQUFJLElBQzNCLGVBQWUsT0FBT2kyQixVQUFVUyx1QkFBdUIsSUFDcER2VixVQUFVNlUsaUJBQWlCam5CLGFBQWEsSUFDdkN1YyxhQUFhMEssaUJBQWlCL2dDLGFBQWEsSUFDNUMwSixDQUFBQSxlQUFlcUIsS0FBSyxJQUFJLElBQUcsR0FDN0JpMkIsWUFBWSxDQUFDLENBQUM7UUFDckI7UUFDQXQwQixPQUFPczBCO1FBQ1BoQixRQUFRZSxrQkFBa0JyM0I7UUFDMUJ3aUIsUUFBUSxNQUFPeGlCLENBQUFBLGVBQWVxQixLQUFLLEdBQUcsR0FBRTtRQUN4QyxJQUFJMkIsUUFBUXdmLE9BQU87WUFDakJ4ZixPQUFPaEQsZUFBZWdDLFNBQVM7WUFDL0IzRCxxQkFBcUIwQyxlQUFlLEdBQ2xDLFNBQVNmLGlCQUFpQixPQUFPTTtZQUNuQ1UsY0FBYyxDQUFDO1lBQ2Y5SCxVQUFVOEc7WUFDVixJQUFJd2lCLFNBQVMsZUFBZSxPQUFPeUIsVUFBVTBQLHdCQUF3QixFQUNuRSxZQUFhLE1BQVF2Z0Isb0JBQW9CLENBQUM7aUJBQ3ZDO2dCQUNIaEwsMkJBQTJCcEk7Z0JBQzNCaWtCLFlBQVkyVixnQkFBZ0I1MkI7Z0JBQzVCLElBQUloRCxlQUFlOUgsSUFBSSxHQUFHLEdBQUc7b0JBQzNCMFAsMkJBQTJCLENBQUM7b0JBQzVCLElBQUk7d0JBQ0ZneUIsZ0JBQWdCNTJCO29CQUNsQixTQUFVO3dCQUNSNEUsMkJBQTJCLENBQUM7b0JBQzlCO2dCQUNGO2dCQUNBUztZQUNGO1lBQ0FySSxlQUFlcUIsS0FBSyxJQUFJO1lBQ3hCLFNBQVNnMkIsb0JBQW9CN1UsUUFDeEIsZ0JBQWdCNWdCLEtBQUssR0FBR3d6QixxQkFDdkJwMUIsZ0JBQ0FxM0IsaUJBQWlCejFCLEtBQUssRUFDdEIsTUFDQWtDLGNBRUQ5RCxlQUFlNEIsS0FBSyxHQUFHd3pCLHFCQUN0QnAxQixnQkFDQSxNQUNBaWtCLFdBQ0FuZ0IsWUFDRCxJQUNEbXhCLGtCQUNFb0Msa0JBQ0FyM0IsZ0JBQ0Fpa0IsV0FDQW5nQjtZQUVOOUQsZUFBZTFKLGFBQWEsR0FBRzBNLEtBQUt3ZixLQUFLO1lBQ3pDNlUsbUJBQW1CcjNCLGVBQWU0QixLQUFLO1FBQ3pDLE9BQ0V5MUIsbUJBQW1CN0IsNkJBQ2pCNkIsa0JBQ0FyM0IsZ0JBQ0E4RDtRQUVKQSxjQUFjOUQsZUFBZWdDLFNBQVM7UUFDdENzMUIsYUFDRXh6QixZQUFZakgsS0FBSyxLQUFLcWQsYUFDckIyZixDQUFBQSxnQ0FDQ3ZpQyxRQUFRZ0MsS0FBSyxDQUNYLCtIQUNBcUMsMEJBQTBCcUUsbUJBQW1CLGdCQUVoRDY1QiwrQkFBK0IsQ0FBQyxDQUFDO1FBQ3BDLE9BQU94QztJQUNUO0lBQ0EsU0FBU3lDLDhCQUNQNWdDLE9BQU8sRUFDUDhHLGNBQWMsRUFDZGsxQixZQUFZLEVBQ1pweEIsV0FBVztRQUVYcU47UUFDQW5SLGVBQWVxQixLQUFLLElBQUk7UUFDeEI0ekIsa0JBQWtCLzdCLFNBQVM4RyxnQkFBZ0JrMUIsY0FBY3B4QjtRQUN6RCxPQUFPOUQsZUFBZTRCLEtBQUs7SUFDN0I7SUFDQSxTQUFTaTBCLCtCQUErQjcxQixjQUFjLEVBQUVpa0IsU0FBUztRQUMvREEsYUFDRUEsVUFBVTBVLGlCQUFpQixJQUMzQnJoQyxRQUFRZ0MsS0FBSyxDQUNYLDhGQUNBMnFCLFVBQVV6cEIsV0FBVyxJQUFJeXBCLFVBQVV4cEIsSUFBSSxJQUFJO1FBRS9DLGVBQWUsT0FBT3dwQixVQUFVMk4sd0JBQXdCLElBQ3JELGtCQUFrQngzQix5QkFBeUI2cEIsY0FBYyxXQUMxRDhWLDhDQUE4QyxDQUFDLzVCLGVBQWUsSUFDM0QxSSxDQUFBQSxRQUFRZ0MsS0FBSyxDQUNaLG9FQUNBMEcsaUJBRUQrNUIsOENBQThDLENBQUMvNUIsZUFBZSxHQUM3RCxDQUFDLENBQUMsQ0FBQztRQUNULGFBQWEsT0FBT2lrQixVQUFVd1QsV0FBVyxJQUN2QyxTQUFTeFQsVUFBVXdULFdBQVcsSUFDN0IsYUFBYXI5Qix5QkFBeUI2cEIsY0FBYyxXQUNyRCtWLDBDQUEwQyxDQUFDL1YsVUFBVSxJQUNsRDNzQixDQUFBQSxRQUFRZ0MsS0FBSyxDQUNaLHVEQUNBMnFCLFlBRUQrViwwQ0FBMEMsQ0FBQy9WLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNsRTtJQUNBLFNBQVNnVyw0QkFBNEJuMkIsV0FBVztRQUM5QyxPQUFPO1lBQUU2ZCxXQUFXN2Q7WUFBYTB5QixXQUFXMEQ7UUFBb0I7SUFDbEU7SUFDQSxTQUFTQyw4QkFDUGpoQyxPQUFPLEVBQ1BraEMsbUJBQW1CLEVBQ25CdDJCLFdBQVc7UUFFWDVLLFVBQVUsU0FBU0EsVUFBVUEsUUFBUWtaLFVBQVUsR0FBRyxDQUFDdE8sY0FBYztRQUNqRXMyQix1QkFBd0JsaEMsQ0FBQUEsV0FBV21oQywwQkFBeUI7UUFDNUQsT0FBT25oQztJQUNUO0lBQ0EsU0FBU29oQyx3QkFBd0JwaEMsT0FBTyxFQUFFOEcsY0FBYyxFQUFFOEQsV0FBVztRQUNuRSxJQUFJb1csWUFBWWxhLGVBQWUvSCxZQUFZO1FBQzNDSixrQkFBa0JtSSxtQkFBb0JBLENBQUFBLGVBQWVxQixLQUFLLElBQUksR0FBRTtRQUNoRSxJQUFJazVCLGVBQWUsQ0FBQyxHQUNsQkMsYUFBYSxNQUFPeDZCLENBQUFBLGVBQWVxQixLQUFLLEdBQUcsR0FBRSxHQUM3Q281QjtRQUNEQSxDQUFBQSxrQkFBa0JELFVBQVMsS0FDekJDLENBQUFBLGtCQUNDLFNBQVN2aEMsV0FBVyxTQUFTQSxRQUFRNUMsYUFBYSxHQUM5QyxDQUFDLElBQ0QsTUFBT3lyQixDQUFBQSxvQkFBb0I3b0IsT0FBTyxHQUFHd2hDLHFCQUFvQixDQUFDO1FBQ2xFRCxtQkFBb0IsZ0JBQWdCLENBQUMsR0FBS3o2QixlQUFlcUIsS0FBSyxJQUFJLENBQUMsR0FBRztRQUN0RW81QixrQkFBa0IsTUFBT3o2QixDQUFBQSxlQUFlcUIsS0FBSyxHQUFHLEVBQUM7UUFDakRyQixlQUFlcUIsS0FBSyxJQUFJLENBQUM7UUFDekIsSUFBSSxTQUFTbkksU0FBUztZQUNwQixJQUFJZ1IsYUFBYTtnQkFDZnF3QixlQUNJelksK0JBQStCOWhCLGtCQUMvQm9pQiw0QkFBNEJwaUI7Z0JBQ2hDLElBQUlrSyxhQUFhO29CQUNmLElBQUl5d0IsZUFBZTlwQix3QkFDakIrcEI7b0JBQ0RBLENBQUFBLDJCQUEyQixDQUFDRCxZQUFXLEtBQ3JDLDRCQUE0QkUsMkJBQzNCRixjQUNBcHFCLHlCQUVGLFNBQVNxcUIsMkJBQ0ozeEIsQ0FBQUEsc0JBQ0FqSixlQUFlMUosYUFBYSxHQUFHO3dCQUM5QjRhLFlBQVkwcEI7d0JBQ1pFLGFBQ0UsU0FBU254QixzQkFDTDs0QkFBRXRULElBQUlvVDs0QkFBZXN4QixVQUFVcnhCO3dCQUFvQixJQUNuRDt3QkFDTnN4QixXQUFXO29CQUNiLEdBQ0NSLGFBQWF6aUMsWUFBWSxJQUFJLE1BQU0sTUFBTTJzQixTQUN6QzhWLFdBQVd4NEIsU0FBUyxHQUFHNDRCLDBCQUN2QkosV0FBVzMrQixNQUFNLEdBQUdtRSxnQkFDcEJBLGVBQWU0QixLQUFLLEdBQUc0NEIsWUFDdkJscUIsdUJBQXVCdFEsZ0JBQ3ZCNlEseUJBQXlCLE1BQ3pCK3BCLDJCQUEyQixDQUFDLENBQUMsSUFDN0JBLDJCQUEyQixDQUFDLEdBQ2hDQSwyQkFBMkIsQ0FBQ0Esd0JBQXdCO29CQUN2REEsNEJBQ0dyckIsQ0FBQUEsd0JBQXdCdlAsZ0JBQWdCMjZCLGVBQ3pDaHJCLHlCQUF5QjNQLGVBQWM7Z0JBQzNDO2dCQUNBMjZCLGVBQWUzNkIsZUFBZTFKLGFBQWE7Z0JBQzNDLElBQ0UsU0FBU3FrQyxnQkFDUixnQkFBZ0JBLGFBQWF6cEIsVUFBVSxFQUFHLFNBQVN5cEIsWUFBVyxHQUUvRCxPQUNFalksMkJBQTJCaVksZ0JBQ3RCMzZCLGVBQWVrRCxLQUFLLEdBQUcsS0FDdkJsRCxlQUFla0QsS0FBSyxHQUFHLFdBQzVCO2dCQUVKbWYsbUJBQW1CcmlCO1lBQ3JCO1lBQ0EyNkIsZUFBZXpnQixVQUFVdk8sUUFBUTtZQUNqQ3VPLFlBQVlBLFVBQVUrZ0IsUUFBUTtZQUM5QixJQUFJVixjQUNGLE9BQ0VuWSw0QkFBNEJwaUIsaUJBQzNCdTZCLGVBQWV2NkIsZUFBZTlILElBQUksRUFDbEN5aUMsZUFBZU8sa0NBQ2Q7Z0JBQUVoakMsTUFBTTtnQkFBVXlULFVBQVVndkI7WUFBYSxHQUN6Q0osZUFFRHJnQixZQUFZMEYsd0JBQ1gxRixXQUNBcWdCLGNBQ0F6MkIsYUFDQSxPQUVENjJCLGFBQWE5K0IsTUFBTSxHQUFHbUUsZ0JBQ3RCa2EsVUFBVXJlLE1BQU0sR0FBR21FLGdCQUNuQjI2QixhQUFhOTRCLE9BQU8sR0FBR3FZLFdBQ3ZCbGEsZUFBZTRCLEtBQUssR0FBRys0QixjQUN2QkosZUFBZXY2QixlQUFlNEIsS0FBSyxFQUNuQzI0QixhQUFhamtDLGFBQWEsR0FDekIyakMsNEJBQTRCbjJCLGNBQzdCeTJCLGFBQWFub0IsVUFBVSxHQUFHK25CLDhCQUN6QmpoQyxTQUNBdWhDLGlCQUNBMzJCLGNBRUQ5RCxlQUFlMUosYUFBYSxHQUFHNmtDLGtCQUNoQ2poQjtZQUVKNEgsK0JBQStCOWhCO1lBQy9CLE9BQU9vN0IsNkJBQTZCcDdCLGdCQUFnQjI2QjtRQUN0RDtRQUNBQywyQkFBMkIxaEMsUUFBUTVDLGFBQWE7UUFDaEQsSUFDRSxTQUFTc2tDLDRCQUNSLGdCQUFnQkEseUJBQXlCMXBCLFVBQVUsRUFDcEQsU0FBU3lwQixZQUFXLEdBQ3BCO1lBQ0EsSUFBSUgsWUFDRng2QixlQUFlcUIsS0FBSyxHQUFHLE1BQ2xCeWdCLENBQUFBLCtCQUErQjloQixpQkFDL0JBLGVBQWVxQixLQUFLLElBQUksQ0FBQyxLQUN6QnJCLGlCQUFpQnE3Qix1Q0FDaEJuaUMsU0FDQThHLGdCQUNBOEQsWUFDRCxJQUNELFNBQVM5RCxlQUFlMUosYUFBYSxHQUNsQzhyQixDQUFBQSw0QkFBNEJwaUIsaUJBQzVCQSxlQUFlNEIsS0FBSyxHQUFHMUksUUFBUTBJLEtBQUssRUFDcEM1QixlQUFlcUIsS0FBSyxJQUFJLEtBQ3hCckIsaUJBQWlCLElBQUksSUFDckJvaUIsQ0FBQUEsNEJBQTRCcGlCLGlCQUM1QnU2QixlQUFlcmdCLFVBQVUrZ0IsUUFBUSxFQUNqQ04sZUFBZTM2QixlQUFlOUgsSUFBSSxFQUNsQ2dpQixZQUFZZ2hCLGtDQUNYO2dCQUFFaGpDLE1BQU07Z0JBQVd5VCxVQUFVdU8sVUFBVXZPLFFBQVE7WUFBQyxHQUNoRGd2QixlQUVESixlQUFlM2Esd0JBQ2QyYSxjQUNBSSxjQUNBNzJCLGFBQ0EsT0FFRHkyQixhQUFhbDVCLEtBQUssSUFBSSxHQUN0QjZZLFVBQVVyZSxNQUFNLEdBQUdtRSxnQkFDbkJ1NkIsYUFBYTErQixNQUFNLEdBQUdtRSxnQkFDdEJrYSxVQUFVclksT0FBTyxHQUFHMDRCLGNBQ3BCdjZCLGVBQWU0QixLQUFLLEdBQUdzWSxXQUN4QmtiLHFCQUNFcDFCLGdCQUNBOUcsUUFBUTBJLEtBQUssRUFDYixNQUNBa0MsY0FFRG9XLFlBQVlsYSxlQUFlNEIsS0FBSyxFQUNoQ3NZLFVBQVU1akIsYUFBYSxHQUN0QjJqQyw0QkFBNEJuMkIsY0FDN0JvVyxVQUFVOUgsVUFBVSxHQUFHK25CLDhCQUN0QmpoQyxTQUNBdWhDLGlCQUNBMzJCLGNBRUQ5RCxlQUFlMUosYUFBYSxHQUFHNmtDLGtCQUMvQm43QixpQkFBaUJ1NkIsWUFBWTtpQkFDakMsSUFDRnpZLCtCQUErQjloQixpQkFDaENrSyxlQUNFNVMsUUFBUWdDLEtBQUssQ0FDWCxnRkFFSm9wQiwyQkFBMkJpWSxlQUUzQixlQUNFVyx3Q0FBd0NYLGVBQ3ZDRixrQkFBa0JFLGFBQWFZLE1BQU0sRUFDckNoQixlQUFlSSxhQUFhdDZCLE9BQU8sRUFDbkM2WixZQUFZeWdCLGFBQWFuOUIsS0FBSyxFQUM5Qm05QixlQUFlQSxhQUFhMUgsY0FBYyxFQUMxQ3NILGVBQWVBLGVBQ1pqOUIsTUFBTWk5QixnQkFDTmo5QixNQUNFLHNJQUVMaTlCLGFBQWEvOEIsS0FBSyxHQUFHMGMsYUFBYSxJQUNsQ3FnQixhQUFhZ0IsTUFBTSxHQUFHZCxpQkFDdEJBLGtCQUFrQixLQUFLLE1BQU1FLGVBQWUsT0FBT0EsY0FDbkR6Z0IsWUFBWTtnQkFDWHRqQixPQUFPMmpDO2dCQUNQM3hCLFFBQVE7Z0JBQ1JwTCxPQUFPaTlCO1lBQ1QsR0FDQSxhQUFhLE9BQU9BLG1CQUNsQjN4QixlQUFlblAsR0FBRyxDQUFDNGdDLGNBQWNyZ0IsWUFDbkNwSyxvQkFBb0JvSyxZQUNuQmxhLGlCQUFpQnE3Qix1Q0FDaEJuaUMsU0FDQThHLGdCQUNBOEQ7aUJBRUQsSUFDRjBoQixvQkFDQzJPLDhCQUNFajdCLFNBQ0E4RyxnQkFDQThELGFBQ0EsQ0FBQyxJQUVKMjJCLGtCQUFrQixNQUFPMzJCLENBQUFBLGNBQWM1SyxRQUFRa1osVUFBVSxHQUMxRG9ULG9CQUFvQmlWLGlCQUNwQjtnQkFDQUEsa0JBQWtCM2xCO2dCQUNsQixJQUFJLFNBQVMybEIsaUJBQWlCO29CQUM1QnZnQixZQUFZcFcsY0FBYyxDQUFDQTtvQkFDM0IsSUFBSSxNQUFPb1csQ0FBQUEsWUFBWSxFQUFDLEdBQUlBLFlBQVk7eUJBRXRDLE9BQVFBO3dCQUNOLEtBQUs7NEJBQ0hBLFlBQVk7NEJBQ1o7d0JBQ0YsS0FBSzs0QkFDSEEsWUFBWTs0QkFDWjt3QkFDRixLQUFLOzRCQUNIQSxZQUFZOzRCQUNaO3dCQUNGLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7NEJBQ0hBLFlBQVk7NEJBQ1o7d0JBQ0YsS0FBSzs0QkFDSEEsWUFBWTs0QkFDWjt3QkFDRjs0QkFDRUEsWUFBWTtvQkFDaEI7b0JBQ0ZBLFlBQ0UsTUFBT0EsQ0FBQUEsWUFBYXVnQixDQUFBQSxnQkFBZ0JqM0IsY0FBYyxHQUFHTSxXQUFVLENBQUMsSUFDNUQsSUFDQW9XO29CQUNOLElBQ0UsTUFBTUEsYUFDTkEsY0FBYzBnQix5QkFBeUJJLFNBQVMsRUFFaEQsTUFDRyx5QkFBMEJBLFNBQVMsR0FBRzlnQixXQUN2Q2pJLCtCQUErQi9ZLFNBQVNnaEIsWUFDeENzUSxzQkFBc0JpUSxpQkFBaUJ2aEMsU0FBU2doQixZQUNoRHNoQjtnQkFFTjtnQkFDQS9ZLDBCQUEwQmtZLGlCQUN4QnZHO2dCQUNGcDBCLGlCQUFpQnE3Qix1Q0FDZm5pQyxTQUNBOEcsZ0JBQ0E4RDtZQUVKLE9BQ0UyZSwwQkFBMEJrWSxnQkFDckIsZ0JBQWdCdDVCLEtBQUssSUFBSSxLQUN6QnJCLGVBQWU0QixLQUFLLEdBQUcxSSxRQUFRMEksS0FBSyxFQUNwQzVCLGlCQUFpQnk3QixnQ0FBZ0M1bEIsSUFBSSxDQUNwRCxNQUNBM2MsVUFFRndpQyw4QkFBOEJmLGNBQWMzNkIsaUJBQzNDQSxpQkFBaUIsSUFBSSxJQUNyQixXQUFXNDZCLHlCQUF5QkUsV0FBVyxFQUNoRDVxQixxQkFDRywwQkFDQ3lyQiw4Q0FBOENoQixlQUMvQ3JxQix1QkFBdUJ0USxnQkFDdkJrSyxjQUFjLENBQUMsR0FDZmtILGtCQUFrQixNQUNsQjNCLHVCQUF1QixDQUFDLEdBQ3hCSix1QkFBdUIsTUFDdkJrQix5QkFBeUIsQ0FBQyxHQUMzQixTQUFTclgsV0FDTitQLENBQUFBLHNCQUNBTSxPQUFPLENBQUNDLGVBQWUsR0FBR0MsZUFDMUJGLE9BQU8sQ0FBQ0MsZUFBZSxHQUFHRSxxQkFDMUJILE9BQU8sQ0FBQ0MsZUFBZSxHQUFHRyxxQkFDMUJGLGdCQUFnQnZRLFFBQVE3QyxFQUFFLEVBQzFCcVQsc0JBQXNCeFEsUUFBUTZoQyxRQUFRLEVBQ3RDcHhCLHNCQUFzQjNKLGNBQWMsQ0FBQyxHQUN6Q0EsaUJBQWlCbzdCLDZCQUNoQnA3QixnQkFDQWthLFVBQVV2TyxRQUFRLEdBRW5CM0wsZUFBZXFCLEtBQUssSUFBSSxJQUFJO1lBQ25DLE9BQU9yQjtRQUNUO1FBQ0EsSUFBSXU2QixjQUNGLE9BQ0VuWSw0QkFBNEJwaUIsaUJBQzNCdTZCLGVBQWVyZ0IsVUFBVStnQixRQUFRLEVBQ2pDTixlQUFlMzZCLGVBQWU5SCxJQUFJLEVBQ2xDMGlDLDJCQUEyQjFoQyxRQUFRMEksS0FBSyxFQUN4QzQ0QixhQUFhSSx5QkFBeUIvNEIsT0FBTyxFQUM3Q3FZLFlBQVlvRSxxQkFBcUJzYywwQkFBMEI7WUFDMUQxaUMsTUFBTTtZQUNOeVQsVUFBVXVPLFVBQVV2TyxRQUFRO1FBQzlCLElBQ0N1TyxVQUFVMGhCLFlBQVksR0FDckJoQix5QkFBeUJnQixZQUFZLEdBQUcsVUFDMUMsU0FBU3BCLGFBQ0pELGVBQWVqYyxxQkFBcUJrYyxZQUFZRCxnQkFDaEQsZ0JBQWdCM2Esd0JBQ2YyYSxjQUNBSSxjQUNBNzJCLGFBQ0EsT0FFRHkyQixhQUFhbDVCLEtBQUssSUFBSSxDQUFDLEdBQzNCazVCLGFBQWExK0IsTUFBTSxHQUFHbUUsZ0JBQ3RCa2EsVUFBVXJlLE1BQU0sR0FBR21FLGdCQUNuQmthLFVBQVVyWSxPQUFPLEdBQUcwNEIsY0FDcEJ2NkIsZUFBZTRCLEtBQUssR0FBR3NZLFdBQ3ZCQSxZQUFZcWdCLGNBQ1pBLGVBQWV2NkIsZUFBZTRCLEtBQUssRUFDbkMrNEIsZUFBZXpoQyxRQUFRMEksS0FBSyxDQUFDdEwsYUFBYSxFQUMzQyxTQUFTcWtDLGVBQ0pBLGVBQWVWLDRCQUE0Qm4yQixlQUMzQyw0QkFBNEI2MkIsYUFBYW5FLFNBQVMsRUFDbkQsU0FBU29FLDJCQUNKLGNBQWMxdkIsb0JBQ1gwckIsYUFBYXhyQixhQUFhLEdBQzFCd3JCLGFBQWF0ckIsY0FBYyxFQUM5QnN2QiwyQkFDQ0EseUJBQXlCMTRCLE1BQU0sS0FBS3M0QixhQUNoQztZQUFFdDRCLFFBQVFzNEI7WUFBWTNELE1BQU0yRDtRQUFXLElBQ3ZDSSx3QkFBd0IsSUFDN0JBLDJCQUEyQlYscUJBQy9CUyxlQUFlO1lBQ2RoWixXQUFXZ1osYUFBYWhaLFNBQVMsR0FBRzdkO1lBQ3BDMHlCLFdBQVdvRTtRQUNiLENBQUMsR0FDSkwsYUFBYWprQyxhQUFhLEdBQUdxa0MsY0FDN0JKLGFBQWFub0IsVUFBVSxHQUFHK25CLDhCQUN6QmpoQyxTQUNBdWhDLGlCQUNBMzJCLGNBRUQ5RCxlQUFlMUosYUFBYSxHQUFHNmtDLGtCQUNoQ2poQjtRQUVKNEgsK0JBQStCOWhCO1FBQy9COEQsY0FBYzVLLFFBQVEwSSxLQUFLO1FBQzNCMUksVUFBVTRLLFlBQVlqQyxPQUFPO1FBQzdCaUMsY0FBY3dhLHFCQUFxQnhhLGFBQWE7WUFDOUM1TCxNQUFNO1lBQ055VCxVQUFVdU8sVUFBVXZPLFFBQVE7UUFDOUI7UUFDQTdILFlBQVlqSSxNQUFNLEdBQUdtRTtRQUNyQjhELFlBQVlqQyxPQUFPLEdBQUc7UUFDdEIsU0FBUzNJLFdBQ04sbUJBQW1COEcsZUFBZWdlLFNBQVMsRUFDNUMsU0FBU3ljLGtCQUNKLGdCQUFnQnpjLFNBQVMsR0FBRztZQUFDOWtCO1NBQVEsRUFDckM4RyxlQUFlcUIsS0FBSyxJQUFJLEVBQUUsSUFDM0JvNUIsZ0JBQWdCM2dDLElBQUksQ0FBQ1osUUFBTztRQUNsQzhHLGVBQWU0QixLQUFLLEdBQUdrQztRQUN2QjlELGVBQWUxSixhQUFhLEdBQUc7UUFDL0IsT0FBT3dOO0lBQ1Q7SUFDQSxTQUFTczNCLDZCQUE2QnA3QixjQUFjLEVBQUU2N0IsZUFBZTtRQUNuRUEsa0JBQWtCWCxrQ0FDaEI7WUFBRWhqQyxNQUFNO1lBQVd5VCxVQUFVa3dCO1FBQWdCLEdBQzdDNzdCLGVBQWU5SCxJQUFJO1FBRXJCMmpDLGdCQUFnQmhnQyxNQUFNLEdBQUdtRTtRQUN6QixPQUFRQSxlQUFlNEIsS0FBSyxHQUFHaTZCO0lBQ2pDO0lBQ0EsU0FBU1gsa0NBQWtDWSxjQUFjLEVBQUU1akMsSUFBSTtRQUM3RCxPQUFPNmpDLHlCQUF5QkQsZ0JBQWdCNWpDLE1BQU0sR0FBRztJQUMzRDtJQUNBLFNBQVNtakMsdUNBQ1BuaUMsT0FBTyxFQUNQOEcsY0FBYyxFQUNkOEQsV0FBVztRQUVYc3hCLHFCQUFxQnAxQixnQkFBZ0I5RyxRQUFRMEksS0FBSyxFQUFFLE1BQU1rQztRQUMxRDVLLFVBQVVraUMsNkJBQ1JwN0IsZ0JBQ0FBLGVBQWUvSCxZQUFZLENBQUMwVCxRQUFRO1FBRXRDelMsUUFBUW1JLEtBQUssSUFBSTtRQUNqQnJCLGVBQWUxSixhQUFhLEdBQUc7UUFDL0IsT0FBTzRDO0lBQ1Q7SUFDQSxTQUFTOGlDLDRCQUE0QjVsQyxLQUFLLEVBQUUwTixXQUFXLEVBQUVtNEIsZUFBZTtRQUN0RTdsQyxNQUFNOE0sS0FBSyxJQUFJWTtRQUNmLElBQUkxQyxZQUFZaEwsTUFBTWdMLFNBQVM7UUFDL0IsU0FBU0EsYUFBY0EsQ0FBQUEsVUFBVThCLEtBQUssSUFBSVksV0FBVTtRQUNwRG80QixnQ0FDRTlsQyxNQUFNeUYsTUFBTSxFQUNaaUksYUFDQW00QjtJQUVKO0lBQ0EsU0FBU0UsZ0NBQWdDQyxTQUFTLEVBQUV6bEMsS0FBSztRQUN2RCxJQUFJMGxDLFlBQVlybEMsWUFBWW9sQztRQUM1QkEsWUFBWSxDQUFDQyxhQUFhLGVBQWUsT0FBT3BpQyxjQUFjbWlDO1FBQzlELE9BQU9DLGFBQWFELFlBQ2YsYUFBYUMsWUFBWSxVQUFVLFlBQ3BDL2tDLFFBQVFnQyxLQUFLLENBQ1gsdU9BQ0EraUMsV0FDQTFsQyxPQUNBMGxDLFlBRUYsQ0FBQyxLQUNELENBQUM7SUFDUDtJQUNBLFNBQVNDLDRCQUNQdDhCLGNBQWMsRUFDZHU4QixXQUFXLEVBQ1hDLElBQUksRUFDSkMsY0FBYyxFQUNkQyxRQUFRO1FBRVIsSUFBSUMsY0FBYzM4QixlQUFlMUosYUFBYTtRQUM5QyxTQUFTcW1DLGNBQ0ozOEIsZUFBZTFKLGFBQWEsR0FBRztZQUM5QmltQyxhQUFhQTtZQUNiSyxXQUFXO1lBQ1hDLG9CQUFvQjtZQUNwQnBRLE1BQU1nUTtZQUNORCxNQUFNQTtZQUNORSxVQUFVQTtRQUNaLElBQ0MsYUFBYUgsV0FBVyxHQUFHQSxhQUMzQkksWUFBWUMsU0FBUyxHQUFHLE1BQ3hCRCxZQUFZRSxrQkFBa0IsR0FBRyxHQUNqQ0YsWUFBWWxRLElBQUksR0FBR2dRLGdCQUNuQkUsWUFBWUgsSUFBSSxHQUFHQSxNQUNuQkcsWUFBWUQsUUFBUSxHQUFHQSxRQUFRO0lBQ3RDO0lBQ0EsU0FBU0ksNEJBQTRCNWpDLE9BQU8sRUFBRThHLGNBQWMsRUFBRThELFdBQVc7UUFDdkUsSUFBSW9XLFlBQVlsYSxlQUFlL0gsWUFBWSxFQUN6QzBxQixjQUFjekksVUFBVXlJLFdBQVcsRUFDbkMrWixXQUFXeGlCLFVBQVVzaUIsSUFBSTtRQUMzQnRpQixZQUFZQSxVQUFVdk8sUUFBUTtRQUM5QixJQUNFLEtBQUssTUFBTWdYLGVBQ1gsZUFBZUEsZUFDZixnQkFBZ0JBLGVBQ2hCLGVBQWVBLGVBQ2YsQ0FBQ29hLHVCQUF1QixDQUFDcGEsWUFBWSxFQUVyQyxJQUNHLHVCQUF3QixDQUFDQSxZQUFZLEdBQUcsQ0FBQyxHQUMxQyxhQUFhLE9BQU9BLGFBRXBCLE9BQVFBLFlBQVluVSxXQUFXO1lBQzdCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSGxYLFFBQVFnQyxLQUFLLENBQ1gsOEZBQ0FxcEIsYUFDQUEsWUFBWW5VLFdBQVc7Z0JBRXpCO1lBQ0YsS0FBSztZQUNMLEtBQUs7Z0JBQ0hsWCxRQUFRZ0MsS0FBSyxDQUNYLCtIQUNBcXBCLGFBQ0FBLFlBQVluVSxXQUFXO2dCQUV6QjtZQUNGO2dCQUNFbFgsUUFBUWdDLEtBQUssQ0FDWCxnSEFDQXFwQjtRQUVOO2FBRUFyckIsUUFBUWdDLEtBQUssQ0FDWCx3SEFDQXFwQjtRQUVOLEtBQUssTUFBTStaLFlBQ1RNLHVCQUF1QixDQUFDTixTQUFTLElBQ2hDLGlCQUFnQkEsWUFBWSxhQUFhQSxXQUNyQyx3QkFBd0IsQ0FBQ0EsU0FBUyxHQUFHLENBQUMsR0FDdkNwbEMsUUFBUWdDLEtBQUssQ0FDWCxxR0FDQW9qQyxTQUNGLElBQ0EsZUFBZS9aLGVBQ2YsZ0JBQWdCQSxlQUNmLHdCQUF3QixDQUFDK1osU0FBUyxHQUFHLENBQUMsR0FDdkNwbEMsUUFBUWdDLEtBQUssQ0FDWCx5SUFDQW9qQyxTQUNGLENBQUM7UUFDUGw3QixHQUFHLElBQ0QsQ0FBQyxlQUFlbWhCLGVBQWUsZ0JBQWdCQSxXQUFVLEtBQ3pELEtBQUssTUFBTXpJLGFBQ1gsU0FBU0EsYUFDVCxDQUFDLE1BQU1BLFdBRVAsSUFBSWxqQixZQUFZa2pCLFlBQ2QsSUFBSyxJQUFJMWlCLElBQUksR0FBR0EsSUFBSTBpQixVQUFVcmpCLE1BQU0sRUFBRVcsSUFBSztZQUN6QyxJQUFJLENBQUMya0MsZ0NBQWdDamlCLFNBQVMsQ0FBQzFpQixFQUFFLEVBQUVBLElBQUksTUFBTWdLO1FBQy9EO2FBQ0csSUFBSyxJQUFLdkgsY0FBY2lnQixZQUFhLGVBQWUsT0FBTzFpQixHQUFJO1lBQ2xFLElBQUtBLElBQUlBLEVBQUVzSCxJQUFJLENBQUNvYixZQUNkLElBQUssSUFBSTRHLE9BQU90cEIsRUFBRWpCLElBQUksSUFBSTBtQyxLQUFLLEdBQUcsQ0FBQ25jLEtBQUtDLElBQUksRUFBRUQsT0FBT3RwQixFQUFFakIsSUFBSSxHQUFJO2dCQUM3RCxJQUFJLENBQUM0bEMsZ0NBQWdDcmIsS0FBS2xxQixLQUFLLEVBQUVxbUMsS0FBSyxNQUFNejdCO2dCQUM1RHk3QjtZQUNGO1FBQ0osT0FDRTNsQyxRQUFRZ0MsS0FBSyxDQUNYLHdLQUNBcXBCO1FBRU5zUyxrQkFBa0IvN0IsU0FBUzhHLGdCQUFnQmthLFdBQVdwVztRQUN0RG9XLFlBQVk2SCxvQkFBb0I3b0IsT0FBTztRQUN2QyxJQUFJLE1BQU9naEIsQ0FBQUEsWUFBWXdnQixxQkFBb0IsR0FDekMsWUFDRSxZQUFhMVksNkJBQThCMFksdUJBQzFDMTZCLGVBQWVxQixLQUFLLElBQUk7YUFDeEI7WUFDSCxJQUFJLFNBQVNuSSxXQUFXLE1BQU9BLENBQUFBLFFBQVFtSSxLQUFLLEdBQUcsR0FBRSxHQUMvQ0csR0FBRyxJQUFLdEksVUFBVThHLGVBQWU0QixLQUFLLEVBQUUsU0FBUzFJLFNBQVc7Z0JBQzFELElBQUksT0FBT0EsUUFBUWxCLEdBQUcsRUFDcEIsU0FBU2tCLFFBQVE1QyxhQUFhLElBQzVCMGxDLDRCQUNFOWlDLFNBQ0E0SyxhQUNBOUQ7cUJBRUQsSUFBSSxPQUFPOUcsUUFBUWxCLEdBQUcsRUFDekJna0MsNEJBQTRCOWlDLFNBQVM0SyxhQUFhOUQ7cUJBQy9DLElBQUksU0FBUzlHLFFBQVEwSSxLQUFLLEVBQUU7b0JBQy9CMUksUUFBUTBJLEtBQUssQ0FBQy9GLE1BQU0sR0FBRzNDO29CQUN2QkEsVUFBVUEsUUFBUTBJLEtBQUs7b0JBQ3ZCO2dCQUNGO2dCQUNBLElBQUkxSSxZQUFZOEcsZ0JBQWdCLE1BQU13QjtnQkFDdEMsTUFBTyxTQUFTdEksUUFBUTJJLE9BQU8sRUFBSTtvQkFDakMsSUFBSSxTQUFTM0ksUUFBUTJDLE1BQU0sSUFBSTNDLFFBQVEyQyxNQUFNLEtBQUttRSxnQkFDaEQsTUFBTXdCO29CQUNSdEksVUFBVUEsUUFBUTJDLE1BQU07Z0JBQzFCO2dCQUNBM0MsUUFBUTJJLE9BQU8sQ0FBQ2hHLE1BQU0sR0FBRzNDLFFBQVEyQyxNQUFNO2dCQUN2QzNDLFVBQVVBLFFBQVEySSxPQUFPO1lBQzNCO1lBQ0ZxWSxhQUFhOEg7UUFDZjtRQUNBbG9CLEtBQUtpb0IscUJBQXFCN0gsV0FBV2xhO1FBQ3JDLE9BQVEyaUI7WUFDTixLQUFLO2dCQUNIN2UsY0FBYzlELGVBQWU0QixLQUFLO2dCQUNsQyxJQUFLK2dCLGNBQWMsTUFBTSxTQUFTN2UsYUFDaEMsVUFBV0EsWUFBWTFDLFNBQVMsRUFDOUIsU0FBU2xJLFdBQ1AsU0FBU29wQixtQkFBbUJwcEIsWUFDM0J5cEIsQ0FBQUEsY0FBYzdlLFdBQVUsR0FDMUJBLGNBQWNBLFlBQVlqQyxPQUFPO2dCQUN0Q2lDLGNBQWM2ZTtnQkFDZCxTQUFTN2UsY0FDSixlQUFlOUQsZUFBZTRCLEtBQUssRUFDbkM1QixlQUFlNEIsS0FBSyxHQUFHLElBQUksSUFDM0IsZUFBZWtDLFlBQVlqQyxPQUFPLEVBQ2xDaUMsWUFBWWpDLE9BQU8sR0FBRyxJQUFJO2dCQUMvQnk2Qiw0QkFDRXQ4QixnQkFDQSxDQUFDLEdBQ0QyaUIsYUFDQTdlLGFBQ0E0NEI7Z0JBRUY7WUFDRixLQUFLO2dCQUNINTRCLGNBQWM7Z0JBQ2Q2ZSxjQUFjM2lCLGVBQWU0QixLQUFLO2dCQUNsQyxJQUFLNUIsZUFBZTRCLEtBQUssR0FBRyxNQUFNLFNBQVMrZ0IsYUFBZTtvQkFDeER6cEIsVUFBVXlwQixZQUFZdmhCLFNBQVM7b0JBQy9CLElBQUksU0FBU2xJLFdBQVcsU0FBU29wQixtQkFBbUJwcEIsVUFBVTt3QkFDNUQ4RyxlQUFlNEIsS0FBSyxHQUFHK2dCO3dCQUN2QjtvQkFDRjtvQkFDQXpwQixVQUFVeXBCLFlBQVk5Z0IsT0FBTztvQkFDN0I4Z0IsWUFBWTlnQixPQUFPLEdBQUdpQztvQkFDdEJBLGNBQWM2ZTtvQkFDZEEsY0FBY3pwQjtnQkFDaEI7Z0JBQ0FvakMsNEJBQ0V0OEIsZ0JBQ0EsQ0FBQyxHQUNEOEQsYUFDQSxNQUNBNDRCO2dCQUVGO1lBQ0YsS0FBSztnQkFDSEosNEJBQTRCdDhCLGdCQUFnQixDQUFDLEdBQUcsTUFBTSxNQUFNLEtBQUs7Z0JBQ2pFO1lBQ0Y7Z0JBQ0VBLGVBQWUxSixhQUFhLEdBQUc7UUFDbkM7UUFDQSxPQUFPMEosZUFBZTRCLEtBQUs7SUFDN0I7SUFDQSxTQUFTNHpCLDZCQUNQdDhCLE9BQU8sRUFDUDhHLGNBQWMsRUFDZDhELFdBQVc7UUFFWCxTQUFTNUssV0FBWThHLENBQUFBLGVBQWUra0IsWUFBWSxHQUFHN3JCLFFBQVE2ckIsWUFBWTtRQUN2RTNSLG9CQUFvQixDQUFDO1FBQ3JCcUgsa0NBQWtDemEsZUFBZWtELEtBQUs7UUFDdEQsSUFBSSxNQUFPWSxDQUFBQSxjQUFjOUQsZUFBZW9TLFVBQVUsR0FDaEQsSUFBSSxTQUFTbFosU0FBUztZQUNwQixJQUNHaTdCLDhCQUNDajdCLFNBQ0E4RyxnQkFDQThELGFBQ0EsQ0FBQyxJQUVILE1BQU9BLENBQUFBLGNBQWM5RCxlQUFlb1MsVUFBVSxHQUU5QyxPQUFPO1FBQ1gsT0FBTyxPQUFPO1FBQ2hCLElBQUksU0FBU2xaLFdBQVc4RyxlQUFlNEIsS0FBSyxLQUFLMUksUUFBUTBJLEtBQUssRUFDNUQsTUFBTXRFLE1BQU07UUFDZCxJQUFJLFNBQVMwQyxlQUFlNEIsS0FBSyxFQUFFO1lBQ2pDMUksVUFBVThHLGVBQWU0QixLQUFLO1lBQzlCa0MsY0FBY3dhLHFCQUFxQnBsQixTQUFTQSxRQUFRakIsWUFBWTtZQUNoRStILGVBQWU0QixLQUFLLEdBQUdrQztZQUN2QixJQUFLQSxZQUFZakksTUFBTSxHQUFHbUUsZ0JBQWdCLFNBQVM5RyxRQUFRMkksT0FBTyxFQUNoRSxVQUFXM0ksUUFBUTJJLE9BQU8sRUFDdkJpQyxjQUFjQSxZQUFZakMsT0FBTyxHQUNoQ3ljLHFCQUFxQnBsQixTQUFTQSxRQUFRakIsWUFBWSxHQUNuRDZMLFlBQVlqSSxNQUFNLEdBQUdtRTtZQUMxQjhELFlBQVlqQyxPQUFPLEdBQUc7UUFDeEI7UUFDQSxPQUFPN0IsZUFBZTRCLEtBQUs7SUFDN0I7SUFDQSxTQUFTbzBCLDhCQUE4Qjk4QixPQUFPLEVBQUU0SyxXQUFXO1FBQ3pELElBQUksTUFBTzVLLENBQUFBLFFBQVFnSyxLQUFLLEdBQUdZLFdBQVUsR0FBSSxPQUFPLENBQUM7UUFDakQ1SyxVQUFVQSxRQUFRNnJCLFlBQVk7UUFDOUIsT0FBTyxTQUFTN3JCLFdBQVd1c0Isc0JBQXNCdnNCLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDcEU7SUFDQSxTQUFTZ2tDLHVDQUNQaGtDLE9BQU8sRUFDUDhHLGNBQWMsRUFDZDhELFdBQVc7UUFFWCxPQUFROUQsZUFBZWhJLEdBQUc7WUFDeEIsS0FBSztnQkFDSHFTLGtCQUNFckssZ0JBQ0FBLGVBQWVnQyxTQUFTLENBQUN3ZCxhQUFhO2dCQUV4QzJkLGFBQ0VuOUIsZ0JBQ0E0MkIsY0FDQTE5QixRQUFRNUMsYUFBYSxDQUFDeTZCLEtBQUs7Z0JBRTdCNWY7Z0JBQ0E7WUFDRixLQUFLO1lBQ0wsS0FBSztnQkFDSHRHLGdCQUFnQjdLO2dCQUNoQjtZQUNGLEtBQUs7Z0JBQ0hxSyxrQkFDRXJLLGdCQUNBQSxlQUFlZ0MsU0FBUyxDQUFDd2QsYUFBYTtnQkFFeEM7WUFDRixLQUFLO2dCQUNIMmQsYUFDRW45QixnQkFDQUEsZUFBZTNGLElBQUksRUFDbkIyRixlQUFlb1EsYUFBYSxDQUFDeFosS0FBSztnQkFFcEM7WUFDRixLQUFLO2dCQUNILE1BQU9rTixDQUFBQSxjQUFjOUQsZUFBZW9TLFVBQVUsS0FDM0NwUyxDQUFBQSxlQUFlcUIsS0FBSyxJQUFJO2dCQUMzQnJCLGVBQWVxQixLQUFLLElBQUk7Z0JBQ3hCLElBQUlXLFlBQVloQyxlQUFlZ0MsU0FBUztnQkFDeENBLFVBQVVvN0IsY0FBYyxHQUFHLENBQUM7Z0JBQzVCcDdCLFVBQVVxN0IscUJBQXFCLEdBQUcsQ0FBQztnQkFDbkM7WUFDRixLQUFLO2dCQUNIcjdCLFlBQVloQyxlQUFlMUosYUFBYTtnQkFDeEMsSUFBSSxTQUFTMEwsV0FBVztvQkFDdEIsSUFBSSxTQUFTQSxVQUFVa1AsVUFBVSxFQUMvQixPQUNFNFEsK0JBQStCOWhCLGlCQUM5QkEsZUFBZXFCLEtBQUssSUFBSSxLQUN6QjtvQkFFSixJQUFJLE1BQU95QyxDQUFBQSxjQUFjOUQsZUFBZTRCLEtBQUssQ0FBQ3dRLFVBQVUsR0FDdEQsT0FBT2tvQix3QkFDTHBoQyxTQUNBOEcsZ0JBQ0E4RDtvQkFFSmdlLCtCQUErQjloQjtvQkFDL0I5RyxVQUFVczhCLDZCQUNSdDhCLFNBQ0E4RyxnQkFDQThEO29CQUVGLE9BQU8sU0FBUzVLLFVBQVVBLFFBQVEySSxPQUFPLEdBQUc7Z0JBQzlDO2dCQUNBaWdCLCtCQUErQjloQjtnQkFDL0I7WUFDRixLQUFLO2dCQUNILElBQUlzOUIsbUJBQW1CLE1BQU9wa0MsQ0FBQUEsUUFBUW1JLEtBQUssR0FBRyxHQUFFO2dCQUNoRFcsWUFBWSxNQUFPOEIsQ0FBQUEsY0FBYzlELGVBQWVvUyxVQUFVO2dCQUMxRHBRLGFBQ0dteUIsQ0FBQUEsOEJBQ0NqN0IsU0FDQThHLGdCQUNBOEQsYUFDQSxDQUFDLElBRUY5QixZQUFZLE1BQU84QixDQUFBQSxjQUFjOUQsZUFBZW9TLFVBQVUsQ0FBQztnQkFDOUQsSUFBSWtyQixrQkFBa0I7b0JBQ3BCLElBQUl0N0IsV0FDRixPQUFPODZCLDRCQUNMNWpDLFNBQ0E4RyxnQkFDQThEO29CQUVKOUQsZUFBZXFCLEtBQUssSUFBSTtnQkFDMUI7Z0JBQ0FpOEIsbUJBQW1CdDlCLGVBQWUxSixhQUFhO2dCQUMvQyxTQUFTZ25DLG9CQUNOLGtCQUFrQlYsU0FBUyxHQUFHLE1BQzlCVSxpQkFBaUJkLElBQUksR0FBRyxNQUN4QmMsaUJBQWlCelgsVUFBVSxHQUFHLElBQUk7Z0JBQ3JDL3JCLEtBQ0Vpb0IscUJBQ0FBLG9CQUFvQjdvQixPQUFPLEVBQzNCOEc7Z0JBRUYsSUFBSWdDLFdBQVc7cUJBQ1YsT0FBTztZQUNkLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQ0UsZUFBZ0JrQixLQUFLLEdBQUcsR0FDeEJpekIseUJBQXlCajlCLFNBQVM4RyxnQkFBZ0I4RDtZQUV0RCxLQUFLO2dCQUNIcTVCLGFBQ0VuOUIsZ0JBQ0E0MkIsY0FDQTE5QixRQUFRNUMsYUFBYSxDQUFDeTZCLEtBQUs7UUFFakM7UUFDQSxPQUFPeUUsNkJBQTZCdDhCLFNBQVM4RyxnQkFBZ0I4RDtJQUMvRDtJQUNBLFNBQVN5NUIsVUFBVXJrQyxPQUFPLEVBQUU4RyxjQUFjLEVBQUU4RCxXQUFXO1FBQ3JELElBQUk5RCxlQUFldzlCLGtCQUFrQixJQUFJLFNBQVN0a0MsU0FBUztZQUN6RDRLLGNBQWNpeUIsNEJBQ1ovMUIsZUFBZTNGLElBQUksRUFDbkIyRixlQUFlbEosR0FBRyxFQUNsQmtKLGVBQWUvSCxZQUFZLEVBQzNCK0gsZUFBZStlLFdBQVcsSUFBSSxNQUM5Qi9lLGVBQWU5SCxJQUFJLEVBQ25COEgsZUFBZWtELEtBQUs7WUFFdEIsSUFBSXlaLGNBQWMzYyxlQUFlbkUsTUFBTTtZQUN2QyxJQUFJLFNBQVM4Z0IsYUFBYSxNQUFNcmYsTUFBTTtZQUN0Q3BFLFFBQVFrSSxTQUFTLEdBQUc7WUFDcEJwQixlQUFlb0IsU0FBUyxHQUFHO1lBQzNCMEMsWUFBWW5OLEtBQUssR0FBR3FKLGVBQWVySixLQUFLO1lBQ3hDbU4sWUFBWWpDLE9BQU8sR0FBRzdCLGVBQWU2QixPQUFPO1lBQzVDaUMsWUFBWWpJLE1BQU0sR0FBR21FLGVBQWVuRSxNQUFNO1lBQzFDaUksWUFBWW9aLEdBQUcsR0FBR2xkLGVBQWVrZCxHQUFHO1lBQ3BDcFosWUFBWWxJLFVBQVUsR0FBR29FLGVBQWVwRSxVQUFVO1lBQ2xELElBQUlvRSxtQkFBbUIyYyxZQUFZL2EsS0FBSyxFQUN0QythLFlBQVkvYSxLQUFLLEdBQUdrQztpQkFDakI7Z0JBQ0gsSUFBSTI1QixjQUFjOWdCLFlBQVkvYSxLQUFLO2dCQUNuQyxJQUFJLFNBQVM2N0IsYUFDWCxNQUFNbmdDLE1BQU07Z0JBQ2QsTUFBT21nQyxZQUFZNTdCLE9BQU8sS0FBSzdCLGdCQUM3QixJQUFLLGNBQWV5OUIsWUFBWTU3QixPQUFPLEVBQUcsU0FBUzQ3QixhQUNqRCxNQUFNbmdDLE1BQU07Z0JBQ2hCbWdDLFlBQVk1N0IsT0FBTyxHQUFHaUM7WUFDeEI7WUFDQTlELGlCQUFpQjJjLFlBQVlxQixTQUFTO1lBQ3RDLFNBQVNoZSxpQkFDSixhQUFhZ2UsU0FBUyxHQUFHO2dCQUFDOWtCO2FBQVEsRUFBSXlqQixZQUFZdGIsS0FBSyxJQUFJLEVBQUUsSUFDOURyQixlQUFlbEcsSUFBSSxDQUFDWjtZQUN4QjRLLFlBQVl6QyxLQUFLLElBQUk7WUFDckIsT0FBT3lDO1FBQ1Q7UUFDQSxJQUFJLFNBQVM1SyxTQUNYLElBQ0VBLFFBQVFrWCxhQUFhLEtBQUtwUSxlQUFlL0gsWUFBWSxJQUNyRCtILGVBQWUzRixJQUFJLEtBQUtuQixRQUFRbUIsSUFBSSxFQUVwQ21yQixtQkFBbUIsQ0FBQzthQUNqQjtZQUNILElBQ0UsQ0FBQ3dRLDhCQUE4Qjk4QixTQUFTNEssZ0JBQ3hDLE1BQU85RCxDQUFBQSxlQUFlcUIsS0FBSyxHQUFHLEdBQUUsR0FFaEMsT0FDRSxtQkFBb0IsQ0FBQyxHQUNyQjY3Qix1Q0FDRWhrQyxTQUNBOEcsZ0JBQ0E4RDtZQUdOMGhCLG1CQUFtQixNQUFPdHNCLENBQUFBLFFBQVFtSSxLQUFLLEdBQUcsTUFBSyxJQUFLLENBQUMsSUFBSSxDQUFDO1FBQzVEO2FBQ0c7WUFDSG1rQixtQkFBbUIsQ0FBQztZQUNwQixJQUFLN0ksY0FBY3pTLGFBQ2pCakIsc0JBQ0cwVCxjQUFjLE1BQU8zYyxDQUFBQSxlQUFlcUIsS0FBSyxHQUFHLE9BQU07WUFDdkRzYixlQUNHLGVBQWUzYyxlQUFlckosS0FBSyxFQUNwQ3NTLHNCQUNBSyxXQUFXdEosZ0JBQWdCb0osZUFBZXVULFlBQVc7UUFDekQ7UUFDQTNjLGVBQWVrRCxLQUFLLEdBQUc7UUFDdkIsT0FBUWxELGVBQWVoSSxHQUFHO1lBQ3hCLEtBQUs7Z0JBQ0h3SixHQUFHLElBQ0EsY0FBZXhCLGVBQWUvSCxZQUFZLEVBQzFDaUIsVUFBVWttQixrQkFBa0JwZixlQUFlaWYsV0FBVyxHQUN0RGpmLGVBQWUzRixJQUFJLEdBQUduQixTQUN2QixlQUFlLE9BQU9BLFNBRXRCdzhCLGdCQUFnQng4QixXQUNYLGVBQWV1NUIsMkJBQ2R2NUIsU0FDQXlqQixjQUVEM2MsZUFBZWhJLEdBQUcsR0FBRyxHQUNyQmdJLGVBQWUzRixJQUFJLEdBQUduQixVQUNyQjA4QiwrQkFBK0IxOEIsVUFDaEM4RyxpQkFBaUJvM0IscUJBQ2hCLE1BQ0FwM0IsZ0JBQ0E5RyxTQUNBeWpCLGFBQ0E3WSxZQUNELElBQ0EsZ0JBQWdCOUwsR0FBRyxHQUFHLEdBQ3ZCNjlCLCtCQUErQjcxQixnQkFBZ0I5RyxVQUM5QzhHLGVBQWUzRixJQUFJLEdBQUduQixVQUNyQjA4QiwrQkFBK0IxOEIsVUFDaEM4RyxpQkFBaUJrMkIsd0JBQ2hCLE1BQ0FsMkIsZ0JBQ0E5RyxTQUNBeWpCLGFBQ0E3WSxZQUNEO3FCQUNGO29CQUNILElBQUksS0FBSyxNQUFNNUssV0FBVyxTQUFTQSxTQUNqQzt3QkFBQSxJQUNHLGNBQWVBLFFBQVFvQixRQUFRLEVBQ2hDbWpDLGdCQUFnQnRpQyx3QkFDaEI7NEJBQ0E2RSxlQUFlaEksR0FBRyxHQUFHOzRCQUNyQmdJLGVBQWUzRixJQUFJLEdBQUduQixVQUNwQndrQyxpQ0FBaUN4a0M7NEJBQ25DOEcsaUJBQWlCcTFCLGlCQUNmLE1BQ0FyMUIsZ0JBQ0E5RyxTQUNBeWpCLGFBQ0E3WTs0QkFFRixNQUFNdEM7d0JBQ1IsT0FBTyxJQUFJaThCLGdCQUFnQm5pQyxpQkFBaUI7NEJBQzFDMEUsZUFBZWhJLEdBQUcsR0FBRzs0QkFDckJnSSxpQkFBaUJ5MUIsb0JBQ2YsTUFDQXoxQixnQkFDQTlHLFNBQ0F5akIsYUFDQTdZOzRCQUVGLE1BQU10Qzt3QkFDUjtvQkFBQTtvQkFDRnhCLGlCQUFpQjtvQkFDakIsU0FBUzlHLFdBQ1AsYUFBYSxPQUFPQSxXQUNwQkEsUUFBUW9CLFFBQVEsS0FBS2lCLG1CQUNwQnlFLENBQUFBLGlCQUNDLDJEQUEwRDtvQkFDOUQ5RyxVQUFVa0IseUJBQXlCbEIsWUFBWUE7b0JBQy9DLE1BQU1vRSxNQUNKLG1FQUNFcEUsVUFDQSw2REFDQThHO2dCQUVOO2dCQUNBLE9BQU9BO1lBQ1QsS0FBSztnQkFDSCxPQUFPazJCLHdCQUNMaDlCLFNBQ0E4RyxnQkFDQUEsZUFBZTNGLElBQUksRUFDbkIyRixlQUFlL0gsWUFBWSxFQUMzQjZMO1lBRUosS0FBSztnQkFDSCxPQUNFLGNBQWU5RCxlQUFlM0YsSUFBSSxFQUNqQ29qQyxjQUFjaEwsMkJBQ2I5VixhQUNBM2MsZUFBZS9ILFlBQVksR0FFN0JtL0IscUJBQ0VsK0IsU0FDQThHLGdCQUNBMmMsYUFDQThnQixhQUNBMzVCO1lBR04sS0FBSztnQkFDSHRDLEdBQUc7b0JBQ0Q2SSxrQkFDRXJLLGdCQUNBQSxlQUFlZ0MsU0FBUyxDQUFDd2QsYUFBYTtvQkFFeEMsSUFBSSxTQUFTdG1CLFNBQ1gsTUFBTW9FLE1BQ0o7b0JBRUosSUFBSTRjLFlBQVlsYSxlQUFlL0gsWUFBWTtvQkFDM0N3bEMsY0FBY3o5QixlQUFlMUosYUFBYTtvQkFDMUNxbUIsY0FBYzhnQixZQUFZbmxDLE9BQU87b0JBQ2pDaWdCLGlCQUFpQnJmLFNBQVM4RztvQkFDMUJ5WixtQkFBbUJ6WixnQkFBZ0JrYSxXQUFXLE1BQU1wVztvQkFDcEQsSUFBSXdXLFlBQVl0YSxlQUFlMUosYUFBYTtvQkFDNUM0akIsWUFBWUksVUFBVXlXLEtBQUs7b0JBQzNCb00sYUFBYW45QixnQkFBZ0I0MkIsY0FBYzFjO29CQUMzQ0EsY0FBY3VqQixZQUFZMU0sS0FBSyxJQUM3QjRNLHdCQUNFMzlCLGdCQUNBO3dCQUFDNDJCO3FCQUFhLEVBQ2Q5eUIsYUFDQSxDQUFDO29CQUVMd1Y7b0JBQ0FZLFlBQVlJLFVBQVVoaUIsT0FBTztvQkFDN0IsSUFBSTRYLHFCQUFxQnV0QixZQUFZRyxZQUFZLEVBQy9DLElBQ0csY0FBZTt3QkFDZHRsQyxTQUFTNGhCO3dCQUNUMGpCLGNBQWMsQ0FBQzt3QkFDZjdNLE9BQU96VyxVQUFVeVcsS0FBSztvQkFDeEIsR0FDQy93QixlQUFlZ1ksV0FBVyxDQUFDQyxTQUFTLEdBQUd3bEIsYUFDdkN6OUIsZUFBZTFKLGFBQWEsR0FBR21uQyxhQUNoQ3o5QixlQUFlcUIsS0FBSyxHQUFHLEtBQ3ZCO3dCQUNBckIsaUJBQWlCODVCLDhCQUNmNWdDLFNBQ0E4RyxnQkFDQWthLFdBQ0FwVzt3QkFFRixNQUFNdEM7b0JBQ1IsT0FBTyxJQUFJMFksY0FBY3lDLGFBQWE7d0JBQ3BDQSxjQUFjaFUsMkJBQ1pyTCxNQUNFLHdIQUVGMEM7d0JBRUY4UCxvQkFBb0I2TTt3QkFDcEIzYyxpQkFBaUI4NUIsOEJBQ2Y1Z0MsU0FDQThHLGdCQUNBa2EsV0FDQXBXO3dCQUVGLE1BQU10QztvQkFDUixPQUNFLElBQ0UwTyxxQkFDRywwQkFDQzJ0Qix1Q0FDRTc5QixlQUFlZ0MsU0FBUyxDQUFDd2QsYUFBYSxHQUV6Q2xQLHVCQUF1QnRRLGdCQUN2QmtLLGNBQWMsQ0FBQyxHQUNma0gsa0JBQWtCLE1BQ2xCM0IsdUJBQXVCLENBQUMsR0FDeEJKLHVCQUF1QixNQUN2QmtCLHlCQUF5QixDQUFDLENBQUMsR0FDNUJyWCxVQUFVaThCLGlCQUNSbjFCLGdCQUNBLE1BQ0FrYSxXQUNBcFcsY0FFRjlELGVBQWU0QixLQUFLLEdBQUcxSSxTQUN6QkEsU0FHQSxRQUFTbUksS0FBSyxHQUFHLFFBQVNBLEtBQUssR0FBRyxDQUFDLElBQUssTUFDckNuSSxVQUFVQSxRQUFRMkksT0FBTzt5QkFDN0I7d0JBQ0hzUDt3QkFDQSxJQUFJK0ksY0FBY3lDLGFBQWE7NEJBQzdCM2MsaUJBQWlCdzFCLDZCQUNmdDhCLFNBQ0E4RyxnQkFDQThEOzRCQUVGLE1BQU10Qzt3QkFDUjt3QkFDQXl6QixrQkFDRS83QixTQUNBOEcsZ0JBQ0FrYSxXQUNBcFc7b0JBRUo7b0JBQ0E5RCxpQkFBaUJBLGVBQWU0QixLQUFLO2dCQUN2QztnQkFDQSxPQUFPNUI7WUFDVCxLQUFLO2dCQUNILElBQUk4OUIsbUJBQ0YsT0FDRXhILFFBQVFwOUIsU0FBUzhHLGlCQUNqQixTQUFTOUcsVUFDTCxDQUFDQSxVQUFVNmtDLFlBQ1QvOUIsZUFBZTNGLElBQUksRUFDbkIsTUFDQTJGLGVBQWUvSCxZQUFZLEVBQzNCLEtBQ0YsSUFDRytILGVBQWUxSixhQUFhLEdBQUc0QyxVQUNoQ2dSLGVBQ0NsSyxDQUFBQSxlQUFlZ0MsU0FBUyxHQUFHZzhCLHdCQUMxQmgrQixlQUFlM0YsSUFBSSxFQUNuQjJGLGVBQWUvSCxZQUFZLEVBQzNCa1MsZ0JBQWdCSSx3QkFBd0JyUixPQUFPLEdBQy9DOEcsZUFDRixJQUNEQSxlQUFlMUosYUFBYSxHQUFHeW5DLFlBQzlCLzlCLGVBQWUzRixJQUFJLEVBQ25CbkIsUUFBUWtYLGFBQWEsRUFDckJwUSxlQUFlL0gsWUFBWSxFQUMzQmlCLFFBQVE1QyxhQUFhLEdBRTNCO1lBRU4sS0FBSztnQkFDSCxJQUFJb2Esb0JBQ0YsT0FDRTdGLGdCQUFnQjdLLGlCQUNoQixTQUFTOUcsV0FDUHdYLHNCQUNBeEcsZUFDQyxlQUFlQyxnQkFDZEksd0JBQXdCclIsT0FBTyxHQUVoQ3lqQixjQUFjL1Isa0JBQ2Q2eUIsY0FBY3o5QixlQUFlZ0MsU0FBUyxHQUNyQ2k4Qix5QkFDRWorQixlQUFlM0YsSUFBSSxFQUNuQjJGLGVBQWUvSCxZQUFZLEVBQzNCd2xDLGFBQ0E5Z0IsYUFDQSxDQUFDLElBRUxsTix3QkFDRyxlQUFleXVCLGdDQUNkVCxhQUNBejlCLGVBQWUzRixJQUFJLEVBQ25CMkYsZUFBZS9ILFlBQVksRUFDM0Iwa0IsY0FFRixTQUFTQSxlQUNOdk4sQ0FBQUEsdUJBQXVCcFAsZ0JBQWdCLEdBQUd5TCxXQUFXLEdBQ3BEa1IsV0FBVSxDQUFDLEdBQ2hCck0sdUJBQXVCdFEsZ0JBQ3ZCdVEseUJBQXlCLENBQUMsR0FDMUJNLHlCQUNDc3RCLHdCQUF3QlYsWUFBWSxHQUN2QzlnQixjQUFjM2MsZUFBZS9ILFlBQVksQ0FBQzBULFFBQVEsRUFDbkQsU0FBU3pTLFdBQVdnUixjQUNoQitxQixrQkFDRS83QixTQUNBOEcsZ0JBQ0EyYyxhQUNBN1ksZUFFRDlELGVBQWU0QixLQUFLLEdBQUd3ekIscUJBQ3RCcDFCLGdCQUNBLE1BQ0EyYyxhQUNBN1ksY0FFTnd5QixRQUFRcDlCLFNBQVM4RyxpQkFDakJBLGVBQWU0QixLQUFLO1lBRTFCLEtBQUs7Z0JBQ0gsT0FDRSxTQUFTMUksV0FDUGdSLGVBQ0MsYUFBYVUsa0JBQ2IrUixjQUFjeWhCLDJCQUNicCtCLGVBQWUzRixJQUFJLEVBQ25CMkYsZUFBZS9ILFlBQVksRUFDM0JpaUIsWUFFRHVqQixjQUFjNXNCLHdCQUNmLENBQUN5SixZQUFZLENBQUNtakIsV0FBVSxLQUNyQixhQUFhWSxtQkFDWlosYUFDQXo5QixlQUFlM0YsSUFBSSxFQUNuQjJGLGVBQWUvSCxZQUFZLEVBQzNCc1kseUJBRUYsU0FBUytKLFlBQ0osZ0JBQWdCdFksU0FBUyxHQUFHc1ksV0FDN0I3Syx3QkFDRyxhQUFheXVCLGdDQUNaNWpCLFdBQ0F0YSxlQUFlM0YsSUFBSSxFQUNuQjJGLGVBQWUvSCxZQUFZLEVBQzNCaWlCLFlBRUYsU0FBU0EsYUFDTjlLLENBQUFBLHVCQUF1QnBQLGdCQUFnQixHQUFHeUwsV0FBVyxHQUNwRHlPLFNBQVEsQ0FBQyxHQUNkNUosdUJBQXVCdFEsZ0JBQ3ZCNlEseUJBQ0NzdEIsd0JBQXdCN2pCLFlBQ3pCL0oseUJBQXlCLENBQUMsR0FDMUIySixZQUFZLENBQUMsQ0FBQyxJQUNkQSxZQUFZLENBQUMsR0FDakJJLFlBQVksQ0FBQ0osU0FBUyxHQUN6QkksYUFDR3FDLENBQUFBLGVBQ0NwTix3QkFBd0J2UCxnQkFBZ0J5OUIsY0FDMUM5dEIseUJBQXlCM1AsZUFBYyxDQUFDLEdBQzVDNkssZ0JBQWdCN0ssaUJBQ2Z5OUIsY0FBY3o5QixlQUFlM0YsSUFBSSxFQUNqQzZmLFlBQVlsYSxlQUFlL0gsWUFBWSxFQUN2Q3FpQixZQUFZLFNBQVNwaEIsVUFBVUEsUUFBUWtYLGFBQWEsR0FBRyxNQUN2RHVNLGNBQWN6QyxVQUFVdk8sUUFBUSxFQUNqQ2lGLHFCQUFxQjZzQixhQUFhdmpCLGFBQzdCeUMsY0FBYyxPQUNmLFNBQVNyQyxhQUNUMUoscUJBQXFCNnNCLGFBQWFuakIsY0FDakN0YSxDQUFBQSxlQUFlcUIsS0FBSyxJQUFJLEVBQUMsR0FDOUIsU0FBU3JCLGVBQWUxSixhQUFhLElBQ2xDLGVBQWUwdEIsZ0JBQ2Q5cUIsU0FDQThHLGdCQUNBa21CLDhCQUNBLE1BQ0EsTUFDQXBpQixjQUVGb0gsb0JBQ0tDLHNCQUFzQkMsYUFBYSxHQUFHcXlCLGNBQ3RDdHlCLHNCQUFzQkcsY0FBYyxHQUFHbXlCLFdBQVcsR0FDekRuSCxRQUFRcDlCLFNBQVM4RyxpQkFDakJpMUIsa0JBQ0UvN0IsU0FDQThHLGdCQUNBMmMsYUFDQTdZLGNBRUY5RCxlQUFlNEIsS0FBSztZQUV4QixLQUFLO2dCQUNILE9BQ0UsU0FBUzFJLFdBQ1BnUixlQUNDLFdBQVdsSyxlQUFlL0gsWUFBWSxFQUN0QzZMLGNBQWM4RyxrQkFDZDFSLFVBQVVvbEMsK0JBQStCcGxDLFNBQVM0SyxjQUNsREEsY0FBYytNLHdCQUNmLENBQUM4TCxjQUFjLENBQUM3WSxXQUFVLEtBQ3ZCLGVBQWV5NkIsdUJBQ2R6NkIsYUFDQTlELGVBQWUvSCxZQUFZLEVBQzNCc1kseUJBRUYsU0FBU29NLGNBQ0osZ0JBQWdCM2EsU0FBUyxHQUFHMmEsYUFDNUJyTSx1QkFBdUJ0USxnQkFDdkI2USx5QkFBeUIsTUFDekI4TCxjQUFjLENBQUMsQ0FBQyxJQUNoQkEsY0FBYyxDQUFDLEdBQ25CQSxjQUFjLENBQUNBLFdBQVcsR0FDN0JBLGVBQ0d6akIsQ0FBQUEsV0FDQ3FXLHdCQUF3QnZQLGdCQUFnQjhELGNBQzFDNkwseUJBQXlCM1AsZUFBYyxDQUFDLEdBQzVDO1lBRUosS0FBSztnQkFDSCxPQUFPczZCLHdCQUF3QnBoQyxTQUFTOEcsZ0JBQWdCOEQ7WUFDMUQsS0FBSztnQkFDSCxPQUNFdUcsa0JBQ0VySyxnQkFDQUEsZUFBZWdDLFNBQVMsQ0FBQ3dkLGFBQWEsR0FFdkM3QyxjQUFjM2MsZUFBZS9ILFlBQVksRUFDMUMsU0FBU2lCLFVBQ0o4RyxlQUFlNEIsS0FBSyxHQUFHd3pCLHFCQUN0QnAxQixnQkFDQSxNQUNBMmMsYUFDQTdZLGVBRUZteEIsa0JBQ0UvN0IsU0FDQThHLGdCQUNBMmMsYUFDQTdZLGNBRU45RCxlQUFlNEIsS0FBSztZQUV4QixLQUFLO2dCQUNILE9BQU95ekIsaUJBQ0xuOEIsU0FDQThHLGdCQUNBQSxlQUFlM0YsSUFBSSxFQUNuQjJGLGVBQWUvSCxZQUFZLEVBQzNCNkw7WUFFSixLQUFLO2dCQUNILE9BQ0VteEIsa0JBQ0UvN0IsU0FDQThHLGdCQUNBQSxlQUFlL0gsWUFBWSxFQUMzQjZMLGNBRUY5RCxlQUFlNEIsS0FBSztZQUV4QixLQUFLO2dCQUNILE9BQ0VxekIsa0JBQ0UvN0IsU0FDQThHLGdCQUNBQSxlQUFlL0gsWUFBWSxDQUFDMFQsUUFBUSxFQUNwQzdILGNBRUY5RCxlQUFlNEIsS0FBSztZQUV4QixLQUFLO2dCQUNILE9BQ0UsZUFBZ0JQLEtBQUssSUFBSSxHQUN4QnJCLGVBQWVxQixLQUFLLElBQUksTUFDeEJzYixjQUFjM2MsZUFBZWdDLFNBQVMsRUFDdEMyYSxZQUFZeWdCLGNBQWMsR0FBRyxDQUFDLEdBQzlCemdCLFlBQVkwZ0IscUJBQXFCLEdBQUcsQ0FBQyxHQUN0Q3BJLGtCQUNFLzdCLFNBQ0E4RyxnQkFDQUEsZUFBZS9ILFlBQVksQ0FBQzBULFFBQVEsRUFDcEM3SCxjQUVGOUQsZUFBZTRCLEtBQUs7WUFFeEIsS0FBSztnQkFDSCxPQUNFLGNBQWU1QixlQUFlM0YsSUFBSSxFQUNqQ29qQyxjQUFjejlCLGVBQWUvSCxZQUFZLEVBQ3pDaWlCLFlBQVl1akIsWUFBWTdtQyxLQUFLLEVBQzlCLFdBQVc2bUMsZUFDVGUsbURBQ0MsbURBQW1ELENBQUMsR0FDckRsbkMsUUFBUWdDLEtBQUssQ0FDWCx1R0FDRixHQUNGNmpDLGFBQWFuOUIsZ0JBQWdCMmMsYUFBYXpDLFlBQzFDK2Esa0JBQ0UvN0IsU0FDQThHLGdCQUNBeTlCLFlBQVk5eEIsUUFBUSxFQUNwQjdILGNBRUY5RCxlQUFlNEIsS0FBSztZQUV4QixLQUFLO2dCQUNILE9BQ0UsY0FBZTVCLGVBQWUzRixJQUFJLENBQUNhLFFBQVEsRUFDMUN5aEIsY0FBYzNjLGVBQWUvSCxZQUFZLENBQUMwVCxRQUFRLEVBQ25ELGVBQWUsT0FBT2dSLGVBQ3BCcmxCLFFBQVFnQyxLQUFLLENBQ1gsd1BBRUppOEIscUJBQXFCdjFCLGlCQUNwQnk5QixjQUFjdFcsWUFBWXNXLGNBQzNCcjFCLDJCQUEyQnBJLGlCQUMxQjJjLGNBQWNnSSxtQkFDYmhJLGFBQ0E4Z0IsYUFDQSxLQUFLLElBRVBwMUIsOEJBQ0NySSxlQUFlcUIsS0FBSyxJQUFJLEdBQ3pCNHpCLGtCQUNFLzdCLFNBQ0E4RyxnQkFDQTJjLGFBQ0E3WSxjQUVGOUQsZUFBZTRCLEtBQUs7WUFFeEIsS0FBSztnQkFDSCxPQUFPNnpCLG9CQUNMdjhCLFNBQ0E4RyxnQkFDQUEsZUFBZTNGLElBQUksRUFDbkIyRixlQUFlL0gsWUFBWSxFQUMzQjZMO1lBRUosS0FBSztnQkFDSCxPQUFPZ3lCLDBCQUNMNThCLFNBQ0E4RyxnQkFDQUEsZUFBZTNGLElBQUksRUFDbkIyRixlQUFlL0gsWUFBWSxFQUMzQjZMO1lBRUosS0FBSztnQkFDSCxPQUFPZzVCLDRCQUNMNWpDLFNBQ0E4RyxnQkFDQThEO1lBRUosS0FBSztnQkFDSCxPQUFPcXlCLHlCQUF5Qmo5QixTQUFTOEcsZ0JBQWdCOEQ7WUFDM0QsS0FBSztnQkFDSCxPQUNFeXhCLHFCQUFxQnYxQixpQkFDcEIyYyxjQUFjd0ssWUFBWXlQLGVBQzNCLFNBQVMxOUIsVUFDSixlQUFleTlCLHFCQUNoQixTQUFTOEcsZUFDTixlQUFlM29CLG9CQUNmb0YsWUFBWTRXLGVBQ1oyTSxZQUFZZ0IsV0FBVyxHQUFHdmtCLFdBQzNCd2tCLFlBQVl4a0IsWUFDWixTQUFTQSxhQUNOdWpCLENBQUFBLFlBQVlrQixnQkFBZ0IsSUFBSTc2QixXQUFVLEdBQzVDMjVCLGNBQWN2akIsU0FBUyxHQUN6QmxhLGVBQWUxSixhQUFhLEdBQUc7b0JBQzlCNEwsUUFBUXlhO29CQUNSb1UsT0FBTzBNO2dCQUNULEdBQ0ExbEIsc0JBQXNCL1gsaUJBQ3RCbTlCLGFBQWFuOUIsZ0JBQWdCNDJCLGNBQWM2RyxZQUFXLElBQ3JELE9BQU92a0MsQ0FBQUEsUUFBUWdLLEtBQUssR0FBR1ksV0FBVSxLQUMvQnlVLENBQUFBLGlCQUFpQnJmLFNBQVM4RyxpQkFDM0J5WixtQkFBbUJ6WixnQkFBZ0IsTUFBTSxNQUFNOEQsY0FDL0N3Viw2Q0FBNEMsR0FDN0Nta0IsY0FBY3ZrQyxRQUFRNUMsYUFBYSxFQUNuQzRqQixZQUFZbGEsZUFBZTFKLGFBQWEsRUFDekNtbkMsWUFBWXY3QixNQUFNLEtBQUt5YSxjQUNsQixlQUFlO29CQUNkemEsUUFBUXlhO29CQUNSb1UsT0FBT3BVO2dCQUNULEdBQ0MzYyxlQUFlMUosYUFBYSxHQUFHbW5DLGFBQ2hDLE1BQU16OUIsZUFBZWtELEtBQUssSUFDdkJsRCxDQUFBQSxlQUFlMUosYUFBYSxHQUMzQjBKLGVBQWVnWSxXQUFXLENBQUNDLFNBQVMsR0FDbEN3bEIsV0FBVSxHQUNoQk4sYUFBYW45QixnQkFBZ0I0MkIsY0FBY2phLFlBQVcsSUFDckQsZUFBZXpDLFVBQVU2VyxLQUFLLEVBQy9Cb00sYUFBYW45QixnQkFBZ0I0MkIsY0FBY2phLGNBQzNDQSxnQkFBZ0I4Z0IsWUFBWTFNLEtBQUssSUFDL0I0TSx3QkFDRTM5QixnQkFDQTtvQkFBQzQyQjtpQkFBYSxFQUNkOXlCLGFBQ0EsQ0FBQyxFQUNILENBQUMsR0FDWG14QixrQkFDRS83QixTQUNBOEcsZ0JBQ0FBLGVBQWUvSCxZQUFZLENBQUMwVCxRQUFRLEVBQ3BDN0gsY0FFRjlELGVBQWU0QixLQUFLO1lBRXhCLEtBQUs7Z0JBQ0gsTUFBTTVCLGVBQWUvSCxZQUFZO1FBQ3JDO1FBQ0EsTUFBTXFGLE1BQ0osK0JBQ0UwQyxlQUFlaEksR0FBRyxHQUNsQjtJQUVOO0lBQ0EsU0FBUzRtQztRQUNQQyx3QkFBd0JDLDBCQUEwQjtRQUNsRHprQiwrQkFBK0IsQ0FBQztJQUNsQztJQUNBLFNBQVM4aUIsYUFBYTRCLGFBQWEsRUFBRXhtQyxPQUFPLEVBQUVneUIsU0FBUztRQUNyRHJmLG9CQUNLcFIsQ0FBQUEsS0FBS2tsQyxhQUFhem1DLFFBQVE2UyxhQUFhLEVBQUUyekIsZ0JBQ3pDeG1DLFFBQVE2UyxhQUFhLEdBQUdtZixXQUN6Qnp3QixLQUFLbWxDLG1CQUFtQjFtQyxRQUFRMm1DLGdCQUFnQixFQUFFSCxnQkFDbEQsS0FBSyxNQUFNeG1DLFFBQVEybUMsZ0JBQWdCLElBQ2pDLFNBQVMzbUMsUUFBUTJtQyxnQkFBZ0IsSUFDakMzbUMsUUFBUTJtQyxnQkFBZ0IsS0FBS0MsaUJBQzdCN25DLFFBQVFnQyxLQUFLLENBQ1gsaUhBRUhmLFFBQVEybUMsZ0JBQWdCLEdBQUdDLGFBQWEsSUFDeENybEMsQ0FBQUEsS0FBS2tsQyxhQUFhem1DLFFBQVErUyxjQUFjLEVBQUV5ekIsZ0JBQzFDeG1DLFFBQVErUyxjQUFjLEdBQUdpZixXQUMxQnp3QixLQUFLc2xDLG9CQUFvQjdtQyxRQUFROG1DLGlCQUFpQixFQUFFTixnQkFDcEQsS0FBSyxNQUFNeG1DLFFBQVE4bUMsaUJBQWlCLElBQ2xDLFNBQVM5bUMsUUFBUThtQyxpQkFBaUIsSUFDbEM5bUMsUUFBUThtQyxpQkFBaUIsS0FBS0YsaUJBQzlCN25DLFFBQVFnQyxLQUFLLENBQ1gsaUhBRUhmLFFBQVE4bUMsaUJBQWlCLEdBQUdGLGFBQWE7SUFDaEQ7SUFDQSxTQUFTRyxZQUFZL21DLE9BQU8sRUFBRXdtQyxhQUFhO1FBQ3pDLElBQUlRLGVBQWVQLFlBQVk5bEMsT0FBTztRQUN0Q2dTLG9CQUNLLFNBQVNFLGFBQWEsR0FBR20wQixjQUN6QkEsZUFBZU4sa0JBQWtCL2xDLE9BQU8sRUFDekNxSixJQUFJMDhCLG1CQUFtQkYsZ0JBQ3RCeG1DLFFBQVEybUMsZ0JBQWdCLEdBQUdLLFlBQVksSUFDdkMsU0FBU2owQixjQUFjLEdBQUdpMEIsY0FDMUJBLGVBQWVILG1CQUFtQmxtQyxPQUFPLEVBQzFDcUosSUFBSTY4QixvQkFBb0JMLGdCQUN2QnhtQyxRQUFROG1DLGlCQUFpQixHQUFHRSxZQUFZO1FBQzdDaDlCLElBQUl5OEIsYUFBYUQ7SUFDbkI7SUFDQSxTQUFTN0MsZ0NBQ1BoNkIsTUFBTSxFQUNONEIsV0FBVyxFQUNYbTRCLGVBQWU7UUFFZixNQUFPLFNBQVMvNUIsUUFBVTtZQUN4QixJQUFJZCxZQUFZYyxPQUFPZCxTQUFTO1lBQy9CYyxDQUFBQSxPQUFPa1EsVUFBVSxHQUFHdE8sV0FBVSxNQUFPQSxjQUNqQyxRQUFRc08sVUFBVSxJQUFJdE8sYUFDdkIsU0FBUzFDLGFBQWNBLENBQUFBLFVBQVVnUixVQUFVLElBQUl0TyxXQUFVLENBQUMsSUFDMUQsU0FBUzFDLGFBQ1QsQ0FBQ0EsVUFBVWdSLFVBQVUsR0FBR3RPLFdBQVUsTUFBT0EsZUFDeEMxQyxDQUFBQSxVQUFVZ1IsVUFBVSxJQUFJdE8sV0FBVTtZQUN2QyxJQUFJNUIsV0FBVys1QixpQkFBaUI7WUFDaEMvNUIsU0FBU0EsT0FBT3JHLE1BQU07UUFDeEI7UUFDQXFHLFdBQVcrNUIsbUJBQ1Qza0MsUUFBUWdDLEtBQUssQ0FDWDtJQUVOO0lBQ0EsU0FBU3FrQyx3QkFDUDM5QixjQUFjLEVBQ2R3L0IsUUFBUSxFQUNSMTdCLFdBQVcsRUFDWDI3Qix3QkFBd0I7UUFFeEIsSUFBSXJwQyxRQUFRNEosZUFBZTRCLEtBQUs7UUFDaEMsU0FBU3hMLFNBQVVBLENBQUFBLE1BQU15RixNQUFNLEdBQUdtRSxjQUFhO1FBQy9DLE1BQU8sU0FBUzVKLE9BQVM7WUFDdkIsSUFBSXNwQyxPQUFPdHBDLE1BQU0ydUIsWUFBWTtZQUM3QixJQUFJLFNBQVMyYSxNQUFNO2dCQUNqQixJQUFJQyxZQUFZdnBDLE1BQU13TCxLQUFLO2dCQUMzQjg5QixPQUFPQSxLQUFLMWEsWUFBWTtnQkFDeEJ4akIsR0FBRyxNQUFPLFNBQVNrK0IsTUFBUTtvQkFDekIsSUFBSUUsYUFBYUY7b0JBQ2pCQSxPQUFPdHBDO29CQUNQLElBQUssSUFBSW9CLElBQUksR0FBR0EsSUFBSWdvQyxTQUFTM29DLE1BQU0sRUFBRVcsSUFDbkMsSUFBSW9vQyxXQUFXcm5DLE9BQU8sS0FBS2luQyxRQUFRLENBQUNob0MsRUFBRSxFQUFFO3dCQUN0Q2tvQyxLQUFLeDhCLEtBQUssSUFBSVk7d0JBQ2Q4N0IsYUFBYUYsS0FBS3QrQixTQUFTO3dCQUMzQixTQUFTdytCLGNBQWVBLENBQUFBLFdBQVcxOEIsS0FBSyxJQUFJWSxXQUFVO3dCQUN0RG80QixnQ0FDRXdELEtBQUs3akMsTUFBTSxFQUNYaUksYUFDQTlEO3dCQUVGeS9CLDRCQUE2QkUsQ0FBQUEsWUFBWSxJQUFHO3dCQUM1QyxNQUFNbitCO29CQUNSO29CQUNGaytCLE9BQU9FLFdBQVdycEMsSUFBSTtnQkFDeEI7WUFDRixPQUFPLElBQUksT0FBT0gsTUFBTTRCLEdBQUcsRUFBRTtnQkFDM0IybkMsWUFBWXZwQyxNQUFNeUYsTUFBTTtnQkFDeEIsSUFBSSxTQUFTOGpDLFdBQ1gsTUFBTXJpQyxNQUNKO2dCQUVKcWlDLFVBQVV6OEIsS0FBSyxJQUFJWTtnQkFDbkI0N0IsT0FBT0MsVUFBVXYrQixTQUFTO2dCQUMxQixTQUFTcytCLFFBQVNBLENBQUFBLEtBQUt4OEIsS0FBSyxJQUFJWSxXQUFVO2dCQUMxQ280QixnQ0FDRXlELFdBQ0E3N0IsYUFDQTlEO2dCQUVGMi9CLFlBQVk7WUFDZCxPQUFPQSxZQUFZdnBDLE1BQU13TCxLQUFLO1lBQzlCLElBQUksU0FBUys5QixXQUFXQSxVQUFVOWpDLE1BQU0sR0FBR3pGO2lCQUV6QyxJQUFLdXBDLFlBQVl2cEMsT0FBTyxTQUFTdXBDLFdBQWE7Z0JBQzVDLElBQUlBLGNBQWMzL0IsZ0JBQWdCO29CQUNoQzIvQixZQUFZO29CQUNaO2dCQUNGO2dCQUNBdnBDLFFBQVF1cEMsVUFBVTk5QixPQUFPO2dCQUN6QixJQUFJLFNBQVN6TCxPQUFPO29CQUNsQkEsTUFBTXlGLE1BQU0sR0FBRzhqQyxVQUFVOWpDLE1BQU07b0JBQy9COGpDLFlBQVl2cEM7b0JBQ1o7Z0JBQ0Y7Z0JBQ0F1cEMsWUFBWUEsVUFBVTlqQyxNQUFNO1lBQzlCO1lBQ0Z6RixRQUFRdXBDO1FBQ1Y7SUFDRjtJQUNBLFNBQVN4TCw4QkFDUGo3QixPQUFPLEVBQ1A4RyxjQUFjLEVBQ2Q4RCxXQUFXLEVBQ1gyN0Isd0JBQXdCO1FBRXhCdm1DLFVBQVU7UUFDVixJQUNFLElBQUlnSixTQUFTbEMsZ0JBQWdCNi9CLDZCQUE2QixDQUFDLEdBQzNELFNBQVMzOUIsUUFFVDtZQUNBLElBQUksQ0FBQzI5Qiw0QkFDSDtnQkFBQSxJQUFJLE1BQU8zOUIsQ0FBQUEsT0FBT2IsS0FBSyxHQUFHLE1BQUssR0FBSXcrQiw2QkFBNkIsQ0FBQztxQkFDNUQsSUFBSSxNQUFPMzlCLENBQUFBLE9BQU9iLEtBQUssR0FBRyxNQUFLLEdBQUk7WUFBSztZQUMvQyxJQUFJLE9BQU9hLE9BQU9sSyxHQUFHLEVBQUU7Z0JBQ3JCLElBQUk4bkMsZ0JBQWdCNTlCLE9BQU9kLFNBQVM7Z0JBQ3BDLElBQUksU0FBUzArQixlQUNYLE1BQU14aUMsTUFBTTtnQkFDZHdpQyxnQkFBZ0JBLGNBQWMxdkIsYUFBYTtnQkFDM0MsSUFBSSxTQUFTMHZCLGVBQWU7b0JBQzFCLElBQUl2bkMsVUFBVTJKLE9BQU83SCxJQUFJO29CQUN6QjJnQixTQUFTOVksT0FBT2pLLFlBQVksQ0FBQ3JCLEtBQUssRUFBRWtwQyxjQUFjbHBDLEtBQUssS0FDcEQsVUFBU3NDLFVBQ05BLFFBQVFZLElBQUksQ0FBQ3ZCLFdBQ1pXLFVBQVU7d0JBQUNYO3FCQUFRO2dCQUM1QjtZQUNGLE9BQU8sSUFBSTJKLFdBQVc0SSw2QkFBNkI1UixPQUFPLEVBQUU7Z0JBQzFENG1DLGdCQUFnQjU5QixPQUFPZCxTQUFTO2dCQUNoQyxJQUFJLFNBQVMwK0IsZUFDWCxNQUFNeGlDLE1BQU07Z0JBQ2R3aUMsY0FBY3hwQyxhQUFhLENBQUNBLGFBQWEsS0FDdkM0TCxPQUFPNUwsYUFBYSxDQUFDQSxhQUFhLElBQ2pDLFVBQVM0QyxVQUNOQSxRQUFRWSxJQUFJLENBQUNxUix5QkFDWmpTLFVBQVU7b0JBQUNpUztpQkFBc0I7WUFDMUM7WUFDQWpKLFNBQVNBLE9BQU9yRyxNQUFNO1FBQ3hCO1FBQ0EsU0FBUzNDLFdBQ1B5a0Msd0JBQ0UzOUIsZ0JBQ0E5RyxTQUNBNEssYUFDQTI3QjtRQUVKei9CLGVBQWVxQixLQUFLLElBQUk7SUFDMUI7SUFDQSxTQUFTb2tCLHNCQUFzQnNhLG1CQUFtQjtRQUNoRCxJQUNFQSxzQkFBc0JBLG9CQUFvQi9hLFlBQVksRUFDdEQsU0FBUythLHFCQUVUO1lBQ0EsSUFBSXhuQyxVQUFVd25DLG9CQUFvQnhuQyxPQUFPO1lBQ3pDLElBQ0UsQ0FBQ3lpQixTQUNDOVAsb0JBQW9CM1MsUUFBUTZTLGFBQWEsR0FBRzdTLFFBQVErUyxjQUFjLEVBQ2xFeTBCLG9CQUFvQkMsYUFBYSxHQUduQyxPQUFPLENBQUM7WUFDVkQsc0JBQXNCQSxvQkFBb0J4cEMsSUFBSTtRQUNoRDtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBQ0EsU0FBU2cvQixxQkFBcUJ2MUIsY0FBYztRQUMxQzgrQiwwQkFBMEI5K0I7UUFDMUI2K0Isd0JBQXdCO1FBQ3hCNytCLGlCQUFpQkEsZUFBZStrQixZQUFZO1FBQzVDLFNBQVMva0Isa0JBQW1CQSxDQUFBQSxlQUFlZ2xCLFlBQVksR0FBRyxJQUFHO0lBQy9EO0lBQ0EsU0FBU21DLFlBQVk1dUIsT0FBTztRQUMxQjhoQixnQ0FDRS9pQixRQUFRZ0MsS0FBSyxDQUNYO1FBRUosT0FBTzJtQyx1QkFBdUJuQix5QkFBeUJ2bUM7SUFDekQ7SUFDQSxTQUFTd25CLGdDQUFnQ21nQixRQUFRLEVBQUUzbkMsT0FBTztRQUN4RCxTQUFTdW1DLDJCQUEyQnZKLHFCQUFxQjJLO1FBQ3pELE9BQU9ELHVCQUF1QkMsVUFBVTNuQztJQUMxQztJQUNBLFNBQVMwbkMsdUJBQXVCQyxRQUFRLEVBQUUzbkMsT0FBTztRQUMvQyxJQUFJM0IsUUFBUXNVLG9CQUNSM1MsUUFBUTZTLGFBQWEsR0FDckI3UyxRQUFRK1MsY0FBYztRQUMxQi9TLFVBQVU7WUFBRUEsU0FBU0E7WUFBU3luQyxlQUFlcHBDO1lBQU9MLE1BQU07UUFBSztRQUMvRCxJQUFJLFNBQVNzb0MsdUJBQXVCO1lBQ2xDLElBQUksU0FBU3FCLFVBQ1gsTUFBTTVpQyxNQUNKO1lBRUp1aEMsd0JBQXdCdG1DO1lBQ3hCMm5DLFNBQVNuYixZQUFZLEdBQUc7Z0JBQ3RCN2hCLE9BQU87Z0JBQ1A4aEIsY0FBY3pzQjtnQkFDZDBzQixxQkFBcUI7WUFDdkI7WUFDQWliLFNBQVM3K0IsS0FBSyxJQUFJO1FBQ3BCLE9BQU93OUIsd0JBQXdCQSxzQkFBc0J0b0MsSUFBSSxHQUFHZ0M7UUFDNUQsT0FBTzNCO0lBQ1Q7SUFDQSxTQUFTazZCO1FBQ1AsT0FBTztZQUNMcVAsWUFBWSxJQUFJQztZQUNoQi9ZLE1BQU0sSUFBSS9ZO1lBQ1YreEIsVUFBVTtRQUNaO0lBQ0Y7SUFDQSxTQUFTM0IsWUFBWTNOLEtBQUs7UUFDeEJBLE1BQU1vUCxVQUFVLENBQUNHLE1BQU0sQ0FBQ0MsT0FBTyxJQUM3QmpwQyxRQUFRQyxJQUFJLENBQ1Y7UUFFSnc1QixNQUFNc1AsUUFBUTtJQUNoQjtJQUNBLFNBQVNHLGFBQWF6UCxLQUFLO1FBQ3pCQSxNQUFNc1AsUUFBUTtRQUNkLElBQUl0UCxNQUFNc1AsUUFBUSxJQUNoQi9vQyxRQUFRQyxJQUFJLENBQ1Y7UUFFSixNQUFNdzVCLE1BQU1zUCxRQUFRLElBQ2xCSSxtQkFBbUJDLGdCQUFnQjtZQUNqQzNQLE1BQU1vUCxVQUFVLENBQUNRLEtBQUs7UUFDeEI7SUFDSjtJQUNBLFNBQVNoSztRQUNQLElBQUlpSyxpQ0FBaUNDLGFBQWEzbkMsT0FBTztRQUN6RCxPQUFPLFNBQVMwbkMsaUNBQ1pBLGlDQUNBOXJCLG1CQUFtQjJwQixXQUFXO0lBQ3BDO0lBQ0EsU0FBU2hJLGVBQWVxSyx1QkFBdUIsRUFBRUMsYUFBYTtRQUM1RCxTQUFTQSxnQkFDTGpuQyxLQUFLK21DLGNBQWNBLGFBQWEzbkMsT0FBTyxFQUFFNG5DLDJCQUN6Q2huQyxLQUFLK21DLGNBQWNFLGNBQWNsSyxJQUFJLEVBQUVpSztJQUM3QztJQUNBLFNBQVM1RztRQUNQLElBQUk4RyxnQkFBZ0JySztRQUNwQixPQUFPLFNBQVNxSyxnQkFDWixPQUNBO1lBQ0U5K0IsUUFBUWdKLG9CQUNKMHJCLGFBQWF4ckIsYUFBYSxHQUMxQndyQixhQUFhdHJCLGNBQWM7WUFDL0J1ckIsTUFBTW1LO1FBQ1I7SUFDTjtJQUNBLFNBQVNDLFdBQVdqaEMsY0FBYztRQUNoQ0EsZUFBZXFCLEtBQUssSUFBSTtJQUMxQjtJQUNBLFNBQVM2L0IsaUJBQWlCaG9DLE9BQU8sRUFBRWlvQyxhQUFhO1FBQzlDLElBQUksU0FBU2pvQyxXQUFXQSxRQUFRMEksS0FBSyxLQUFLdS9CLGNBQWN2L0IsS0FBSyxFQUFFLE9BQU8sQ0FBQztRQUN2RSxJQUFJLE1BQU91L0IsQ0FBQUEsY0FBYzkvQixLQUFLLEdBQUcsRUFBQyxHQUFJLE9BQU8sQ0FBQztRQUM5QyxJQUFLbkksVUFBVWlvQyxjQUFjdi9CLEtBQUssRUFBRSxTQUFTMUksU0FBVztZQUN0RCxJQUNFLE1BQU9BLENBQUFBLFFBQVFtSSxLQUFLLEdBQUcsS0FBSSxLQUMzQixNQUFPbkksQ0FBQUEsUUFBUTBpQyxZQUFZLEdBQUcsS0FBSSxHQUVsQyxPQUFPLENBQUM7WUFDVjFpQyxVQUFVQSxRQUFRMkksT0FBTztRQUMzQjtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBQ0EsU0FBU3UvQixrQkFDUGwvQixNQUFNLEVBQ05sQyxjQUFjLEVBQ2RxaEMscUJBQXFCLEVBQ3JCbHZCLFFBQVE7UUFFUixJQUFJbXZCLGtCQUNGLElBQ0VELHdCQUF3QnJoQyxlQUFlNEIsS0FBSyxFQUM1QyxTQUFTeS9CLHVCQUVUO1lBQ0EsSUFDRSxNQUFNQSxzQkFBc0JycEMsR0FBRyxJQUMvQixNQUFNcXBDLHNCQUFzQnJwQyxHQUFHLEVBRS9CdXBDLG1CQUFtQnIvQixRQUFRbS9CLHNCQUFzQnIvQixTQUFTO2lCQUN2RCxJQUNILENBQ0UsT0FBTXEvQixzQkFBc0JycEMsR0FBRyxJQUM5QjBZLHNCQUFzQixPQUFPMndCLHNCQUFzQnJwQyxHQUFHLEtBRXpELFNBQVNxcEMsc0JBQXNCei9CLEtBQUssRUFDcEM7Z0JBQ0F5L0Isc0JBQXNCei9CLEtBQUssQ0FBQy9GLE1BQU0sR0FBR3dsQztnQkFDckNBLHdCQUF3QkEsc0JBQXNCei9CLEtBQUs7Z0JBQ25EO1lBQ0Y7WUFDQSxJQUFJeS9CLDBCQUEwQnJoQyxnQkFBZ0I7WUFDOUMsTUFBTyxTQUFTcWhDLHNCQUFzQngvQixPQUFPLEVBQUk7Z0JBQy9DLElBQ0UsU0FBU3cvQixzQkFBc0J4bEMsTUFBTSxJQUNyQ3dsQyxzQkFBc0J4bEMsTUFBTSxLQUFLbUUsZ0JBRWpDO2dCQUNGcWhDLHdCQUF3QkEsc0JBQXNCeGxDLE1BQU07WUFDdEQ7WUFDQXdsQyxzQkFBc0J4L0IsT0FBTyxDQUFDaEcsTUFBTSxHQUFHd2xDLHNCQUFzQnhsQyxNQUFNO1lBQ25Fd2xDLHdCQUF3QkEsc0JBQXNCeC9CLE9BQU87UUFDdkQ7YUFDRyxJQUFJMi9CLHFCQUNQLElBQUssSUFBSUMsUUFBUXpoQyxlQUFlNEIsS0FBSyxFQUFFLFNBQVM2L0IsT0FBUztZQUN2RCxJQUFJLE1BQU1BLE1BQU16cEMsR0FBRyxFQUFFO2dCQUNuQixJQUFJbWlCLFdBQVdzbkIsTUFBTXovQixTQUFTO2dCQUM5QnEvQix5QkFDRWx2QixZQUNDZ0ksQ0FBQUEsV0FBV3VuQixvQkFDVnZuQixVQUNBc25CLE1BQU1wbkMsSUFBSSxFQUNWb25DLE1BQU1yeEIsYUFBYSxDQUNyQjtnQkFDRm14QixtQkFBbUJyL0IsUUFBUWlZO1lBQzdCLE9BQU8sSUFBSSxNQUFNc25CLE1BQU16cEMsR0FBRyxFQUN4QixXQUFZeXBDLE1BQU16L0IsU0FBUyxFQUN6QnEvQix5QkFDRWx2QixZQUNDZ0ksQ0FBQUEsV0FBV3duQix3QkFDVnhuQixVQUNBc25CLE1BQU1yeEIsYUFBYSxDQUNyQixHQUNGbXhCLG1CQUFtQnIvQixRQUFRaVk7aUJBQzFCLElBQUksTUFBTXNuQixNQUFNenBDLEdBQUcsRUFDdEI7Z0JBQUEsSUFBSSxPQUFPeXBDLE1BQU16cEMsR0FBRyxJQUFJLFNBQVN5cEMsTUFBTW5yQyxhQUFhLEVBQ2xELFdBQVltckMsTUFBTTcvQixLQUFLLEVBQ3JCLFNBQVN1WSxZQUFhQSxDQUFBQSxTQUFTdGUsTUFBTSxHQUFHNGxDLEtBQUksR0FDNUNMLGtCQUFrQmwvQixRQUFRdS9CLE9BQU8sQ0FBQyxHQUFHLENBQUM7cUJBQ3JDLElBQUksU0FBU0EsTUFBTTcvQixLQUFLLEVBQUU7b0JBQzdCNi9CLE1BQU03L0IsS0FBSyxDQUFDL0YsTUFBTSxHQUFHNGxDO29CQUNyQkEsUUFBUUEsTUFBTTcvQixLQUFLO29CQUNuQjtnQkFDRjtZQUFBO1lBQ0YsSUFBSTYvQixVQUFVemhDLGdCQUFnQjtZQUM5QixNQUFPLFNBQVN5aEMsTUFBTTUvQixPQUFPLEVBQUk7Z0JBQy9CLElBQUksU0FBUzQvQixNQUFNNWxDLE1BQU0sSUFBSTRsQyxNQUFNNWxDLE1BQU0sS0FBS21FLGdCQUM1QztnQkFDRnloQyxRQUFRQSxNQUFNNWxDLE1BQU07WUFDdEI7WUFDQTRsQyxNQUFNNS9CLE9BQU8sQ0FBQ2hHLE1BQU0sR0FBRzRsQyxNQUFNNWxDLE1BQU07WUFDbkM0bEMsUUFBUUEsTUFBTTUvQixPQUFPO1FBQ3ZCO0lBQ0o7SUFDQSxTQUFTKy9CLDZCQUNQQyxpQkFBaUIsRUFDakI3aEMsY0FBYyxFQUNkcWhDLHFCQUFxQixFQUNyQmx2QixRQUFRO1FBRVIsSUFBSXF2QixxQkFDRixJQUFLLElBQUl0Z0MsT0FBT2xCLGVBQWU0QixLQUFLLEVBQUUsU0FBU1YsTUFBUTtZQUNyRCxJQUFJLE1BQU1BLEtBQUtsSixHQUFHLEVBQUU7Z0JBQ2xCLElBQUltaUIsV0FBV2paLEtBQUtjLFNBQVM7Z0JBQzdCcS9CLHlCQUNFbHZCLFlBQ0NnSSxDQUFBQSxXQUFXdW5CLG9CQUNWdm5CLFVBQ0FqWixLQUFLN0csSUFBSSxFQUNUNkcsS0FBS2tQLGFBQWEsQ0FDcEI7Z0JBQ0YweEIsK0JBQStCRCxtQkFBbUIxbkI7WUFDcEQsT0FBTyxJQUFJLE1BQU1qWixLQUFLbEosR0FBRyxFQUN2QixXQUFZa0osS0FBS2MsU0FBUyxFQUN4QnEvQix5QkFDRWx2QixZQUNDZ0ksQ0FBQUEsV0FBV3duQix3QkFDVnhuQixVQUNBalosS0FBS2tQLGFBQWEsQ0FDcEIsR0FDRjB4QiwrQkFBK0JELG1CQUFtQjFuQjtpQkFDakQsSUFBSSxNQUFNalosS0FBS2xKLEdBQUcsRUFDckI7Z0JBQUEsSUFBSSxPQUFPa0osS0FBS2xKLEdBQUcsSUFBSSxTQUFTa0osS0FBSzVLLGFBQWEsRUFDaEQsV0FBWTRLLEtBQUtVLEtBQUssRUFDcEIsU0FBU3VZLFlBQWFBLENBQUFBLFNBQVN0ZSxNQUFNLEdBQUdxRixJQUFHLEdBQzNDMGdDLDZCQUNFQyxtQkFDQTNnQyxNQUNBLENBQ0UsVUFBU0EsS0FBS2tQLGFBQWEsSUFDM0IsYUFBYWxQLEtBQUtrUCxhQUFhLENBQUNsWSxJQUFJLEdBRXRDLENBQUM7cUJBRUYsSUFBSSxTQUFTZ0osS0FBS1UsS0FBSyxFQUFFO29CQUM1QlYsS0FBS1UsS0FBSyxDQUFDL0YsTUFBTSxHQUFHcUY7b0JBQ3BCQSxPQUFPQSxLQUFLVSxLQUFLO29CQUNqQjtnQkFDRjtZQUFBO1lBQ0YsSUFBSVYsU0FBU2xCLGdCQUFnQjtZQUM3QixNQUFPLFNBQVNrQixLQUFLVyxPQUFPLEVBQUk7Z0JBQzlCLElBQUksU0FBU1gsS0FBS3JGLE1BQU0sSUFBSXFGLEtBQUtyRixNQUFNLEtBQUttRSxnQkFBZ0I7Z0JBQzVEa0IsT0FBT0EsS0FBS3JGLE1BQU07WUFDcEI7WUFDQXFGLEtBQUtXLE9BQU8sQ0FBQ2hHLE1BQU0sR0FBR3FGLEtBQUtyRixNQUFNO1lBQ2pDcUYsT0FBT0EsS0FBS1csT0FBTztRQUNyQjtJQUNKO0lBQ0EsU0FBU2tnQyxvQkFBb0I3b0MsT0FBTyxFQUFFOEcsY0FBYztRQUNsRCxJQUFJd2hDLHVCQUF1Qk4saUJBQWlCaG9DLFNBQVM4RyxpQkFBaUI7WUFDcEU5RyxVQUFVOEcsZUFBZWdDLFNBQVM7WUFDbEMsSUFBSWdnQyxZQUFZOW9DLFFBQVFzbUIsYUFBYSxFQUNuQ3lpQixjQUFjQztZQUNoQk4sNkJBQTZCSyxhQUFhamlDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQztZQUMvRDlHLFFBQVFpcEMsZUFBZSxHQUFHRjtZQUMxQmhCLFdBQVdqaEM7WUFDWG9pQywwQkFBMEJKLFdBQVdDO1FBQ3ZDO0lBQ0Y7SUFDQSxTQUFTSSxvQkFBb0JucEMsT0FBTyxFQUFFOEcsY0FBYyxFQUFFM0YsSUFBSSxFQUFFMjNCLFFBQVE7UUFDbEUsSUFBSXNQLGtCQUNGcG9DLFFBQVFrWCxhQUFhLEtBQUs0aEIsWUFBWWlQLFdBQVdqaEM7YUFDOUMsSUFBSXdoQyxxQkFBcUI7WUFDNUIsSUFBSWMsa0JBQWtCcHBDLFFBQVE4SSxTQUFTLEVBQ3JDdWdDLFlBQVlycEMsUUFBUWtYLGFBQWE7WUFDbkMsSUFDRSxDQUFDbFgsVUFBVWdvQyxpQkFBaUJob0MsU0FBUzhHLGVBQWMsS0FDbkR1aUMsY0FBY3ZRLFVBQ2Q7Z0JBQ0EsSUFBSXdRLHFCQUFxQjUzQjtnQkFDekIyM0IsWUFBWUUsY0FDVkgsaUJBQ0Fqb0MsTUFDQWtvQyxXQUNBdlEsVUFDQSxDQUFDOTRCLFNBQ0Q7Z0JBRUZxcEMsY0FBY0Qsa0JBQ1R0aUMsZUFBZWdDLFNBQVMsR0FBR3NnQyxrQkFDM0JJLENBQUFBLHdCQUNDSCxXQUNBbG9DLE1BQ0EyM0IsVUFDQXdRLHVCQUNHdkIsV0FBV2poQyxpQkFDZkEsZUFBZWdDLFNBQVMsR0FBR3VnQyxXQUM1QnJwQyxVQUNJa29DLGtCQUFrQm1CLFdBQVd2aUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEtBQ2xEaWhDLFdBQVdqaEMsZUFBYztZQUNuQyxPQUFPQSxlQUFlZ0MsU0FBUyxHQUFHc2dDO1FBQ3BDO0lBQ0Y7SUFDQSxTQUFTSyxrQ0FBa0MzaUMsY0FBYyxFQUFFM0YsSUFBSSxFQUFFd0MsS0FBSztRQUNwRSxJQUFJK2xDLGlCQUFpQnZvQyxNQUFNd0MsUUFBUTtZQUNqQyxJQUFLLGVBQWdCd0UsS0FBSyxJQUFJLFVBQVcsQ0FBQ3doQyxnQkFBZ0J4b0MsTUFBTXdDLFFBQzlELElBQUlpbUMsZ0NBQWdDOWlDLGVBQWVxQixLQUFLLElBQUk7aUJBRTFELE1BQ0csb0JBQXFCbXpCLDZCQUN0QnVPO1FBRVIsT0FBTy9pQyxlQUFlcUIsS0FBSyxJQUFJLENBQUM7SUFDbEM7SUFDQSxTQUFTMmhDLGtDQUFrQ2hqQyxjQUFjLEVBQUVpakMsUUFBUTtRQUNqRSxJQUFJQyx5QkFBeUJELFdBQVc7WUFDdEMsSUFBSyxlQUFnQjVoQyxLQUFLLElBQUksVUFBVyxDQUFDOGhDLGdCQUFnQkYsV0FDeEQsSUFBSUgsZ0NBQWdDOWlDLGVBQWVxQixLQUFLLElBQUk7aUJBRTFELE1BQ0csb0JBQXFCbXpCLDZCQUN0QnVPO1FBRVIsT0FBTy9pQyxlQUFlcUIsS0FBSyxJQUFJLENBQUM7SUFDbEM7SUFDQSxTQUFTK2hDLG9CQUFvQnBqQyxjQUFjLEVBQUU0MEIsVUFBVTtRQUNyRCxTQUFTQSxjQUFlNTBCLENBQUFBLGVBQWVxQixLQUFLLElBQUk7UUFDaERyQixlQUFlcUIsS0FBSyxHQUFHLFNBQ3BCLGNBQ0MsT0FBT3JCLGVBQWVoSSxHQUFHLEdBQUdtTSx1QkFBdUIsV0FDcERuRSxlQUFla0QsS0FBSyxJQUFJMHhCLFlBQ3hCeU8scUNBQXFDek8sVUFBVTtJQUNwRDtJQUNBLFNBQVMwTyxtQkFBbUIzRyxXQUFXLEVBQUU0Ryx3QkFBd0I7UUFDL0QsSUFBSSxDQUFDcjVCLGFBQ0gsT0FBUXl5QixZQUFZRCxRQUFRO1lBQzFCLEtBQUs7Z0JBQ0g2RywyQkFBMkI1RyxZQUFZSCxJQUFJO2dCQUMzQyxJQUFLLElBQUlnSCxlQUFlLE1BQU0sU0FBU0QsMEJBQ3JDLFNBQVNBLHlCQUF5Qm5pQyxTQUFTLElBQ3hDb2lDLENBQUFBLGVBQWVELHdCQUF1QixHQUN0Q0EsMkJBQTJCQSx5QkFBeUIxaEMsT0FBTztnQkFDaEUsU0FBUzJoQyxlQUNKN0csWUFBWUgsSUFBSSxHQUFHLE9BQ25CZ0gsYUFBYTNoQyxPQUFPLEdBQUc7Z0JBQzVCO1lBQ0YsS0FBSztnQkFDSDJoQyxlQUFlN0csWUFBWUgsSUFBSTtnQkFDL0IsSUFBSyxJQUFJaUgsZ0JBQWdCLE1BQU0sU0FBU0QsY0FDdEMsU0FBU0EsYUFBYXBpQyxTQUFTLElBQUtxaUMsQ0FBQUEsZ0JBQWdCRCxZQUFXLEdBQzVEQSxlQUFlQSxhQUFhM2hDLE9BQU87Z0JBQ3hDLFNBQVM0aEMsZ0JBQ0xGLDRCQUE0QixTQUFTNUcsWUFBWUgsSUFBSSxHQUNsREcsWUFBWUgsSUFBSSxHQUFHLE9BQ25CRyxZQUFZSCxJQUFJLENBQUMzNkIsT0FBTyxHQUFHLE9BQzdCNGhDLGNBQWM1aEMsT0FBTyxHQUFHO1FBQ2pDO0lBQ0o7SUFDQSxTQUFTNmhDLGlCQUFpQnZDLGFBQWE7UUFDckMsSUFBSXdDLGFBQ0EsU0FBU3hDLGNBQWMvL0IsU0FBUyxJQUNoQysvQixjQUFjLy9CLFNBQVMsQ0FBQ1EsS0FBSyxLQUFLdS9CLGNBQWN2L0IsS0FBSyxFQUN2RGdpQyxnQkFBZ0IsR0FDaEJoSSxlQUFlO1FBQ2pCLElBQUkrSCxZQUNGLElBQUksQ0FBQ3hDLGNBQWNqcEMsSUFBSSxHQUFHLE9BQU93c0IsUUFBUTtZQUN2QyxJQUNFLElBQUltZixvQkFBb0IxQyxjQUFjMXRCLGdCQUFnQixFQUNwRHF3QixVQUFVM0MsY0FBY3YvQixLQUFLLEVBQy9CLFNBQVNraUMsU0FHVCxpQkFBa0JBLFFBQVE1Z0MsS0FBSyxHQUFHNGdDLFFBQVExeEIsVUFBVSxFQUNqRHdwQixnQkFBZ0JrSSxRQUFRbEksWUFBWSxHQUFHLFVBQ3ZDQSxnQkFBZ0JrSSxRQUFRemlDLEtBQUssR0FBRyxVQUNoQ3dpQyxxQkFBcUJDLFFBQVFDLGdCQUFnQixFQUM3Q0QsVUFBVUEsUUFBUWppQyxPQUFPO1lBQzlCcy9CLGNBQWM0QyxnQkFBZ0IsR0FBR0Y7UUFDbkMsT0FDRSxJQUNFQSxvQkFBb0IxQyxjQUFjdi9CLEtBQUssRUFDdkMsU0FBU2lpQyxtQkFHVCxpQkFDRUEsa0JBQWtCM2dDLEtBQUssR0FBRzJnQyxrQkFBa0J6eEIsVUFBVSxFQUNyRHdwQixnQkFBZ0JpSSxrQkFBa0JqSSxZQUFZLEdBQUcsVUFDakRBLGdCQUFnQmlJLGtCQUFrQnhpQyxLQUFLLEdBQUcsVUFDMUN3aUMsa0JBQWtCaG9DLE1BQU0sR0FBR3NsQyxlQUMzQjBDLG9CQUFvQkEsa0JBQWtCaGlDLE9BQU87YUFDakQsSUFBSSxDQUFDcy9CLGNBQWNqcEMsSUFBSSxHQUFHLE9BQU93c0IsUUFBUTtZQUM1Q21mLG9CQUFvQjFDLGNBQWMzdEIsY0FBYztZQUNoRHN3QixVQUFVM0MsY0FBYzF0QixnQkFBZ0I7WUFDeEMsSUFBSyxJQUFJN1IsUUFBUXUvQixjQUFjdi9CLEtBQUssRUFBRSxTQUFTQSxPQUM3QyxpQkFBa0JBLE1BQU1zQixLQUFLLEdBQUd0QixNQUFNd1EsVUFBVSxFQUM3Q3dwQixnQkFBZ0JoNkIsTUFBTWc2QixZQUFZLEVBQ2xDQSxnQkFBZ0JoNkIsTUFBTVAsS0FBSyxFQUMzQndpQyxxQkFBcUJqaUMsTUFBTTRSLGNBQWMsRUFDekNzd0IsV0FBV2xpQyxNQUFNbWlDLGdCQUFnQixFQUNqQ25pQyxRQUFRQSxNQUFNQyxPQUFPO1lBQzFCcy9CLGNBQWMzdEIsY0FBYyxHQUFHcXdCO1lBQy9CMUMsY0FBYzRDLGdCQUFnQixHQUFHRDtRQUNuQyxPQUNFLElBQ0VELG9CQUFvQjFDLGNBQWN2L0IsS0FBSyxFQUN2QyxTQUFTaWlDLG1CQUdULGlCQUNFQSxrQkFBa0IzZ0MsS0FBSyxHQUFHMmdDLGtCQUFrQnp4QixVQUFVLEVBQ3JEd3BCLGdCQUFnQmlJLGtCQUFrQmpJLFlBQVksRUFDOUNBLGdCQUFnQmlJLGtCQUFrQnhpQyxLQUFLLEVBQ3ZDd2lDLGtCQUFrQmhvQyxNQUFNLEdBQUdzbEMsZUFDM0IwQyxvQkFBb0JBLGtCQUFrQmhpQyxPQUFPO1FBQ3BEcy9CLGNBQWN2RixZQUFZLElBQUlBO1FBQzlCdUYsY0FBYy91QixVQUFVLEdBQUd3eEI7UUFDM0IsT0FBT0Q7SUFDVDtJQUNBLFNBQVNLLGFBQWE5cUMsT0FBTyxFQUFFOEcsY0FBYyxFQUFFOEQsV0FBVztRQUN4RCxJQUFJa3VCLFdBQVdoeUIsZUFBZS9ILFlBQVk7UUFDMUNnUyxlQUFlaks7UUFDZixPQUFRQSxlQUFlaEksR0FBRztZQUN4QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTzByQyxpQkFBaUIxakMsaUJBQWlCO1lBQzNDLEtBQUs7Z0JBQ0gsT0FBTzBqQyxpQkFBaUIxakMsaUJBQWlCO1lBQzNDLEtBQUs7Z0JBQ0g4RCxjQUFjOUQsZUFBZWdDLFNBQVM7Z0JBQ3RDZ3dCLFdBQVc7Z0JBQ1gsU0FBUzk0QixXQUFZODRCLENBQUFBLFdBQVc5NEIsUUFBUTVDLGFBQWEsQ0FBQ3k2QixLQUFLO2dCQUMzRC93QixlQUFlMUosYUFBYSxDQUFDeTZCLEtBQUssS0FBS2lCLFlBQ3BDaHlCLENBQUFBLGVBQWVxQixLQUFLLElBQUksSUFBRztnQkFDOUJpK0IsWUFBWTFJLGNBQWM1MkI7Z0JBQzFCMkssaUJBQWlCM0s7Z0JBQ2pCOEQsWUFBWW1nQyxjQUFjLElBQ3ZCLGFBQWExckMsT0FBTyxHQUFHdUwsWUFBWW1nQyxjQUFjLEVBQ2pEbmdDLFlBQVltZ0MsY0FBYyxHQUFHLElBQUk7Z0JBQ3BDLElBQUksU0FBUy9xQyxXQUFXLFNBQVNBLFFBQVEwSSxLQUFLLEVBQzVDNE8sa0JBQWtCeFEsa0JBQ2JxUixDQUFBQSxnQ0FBZ0M0dkIsV0FBV2poQyxlQUFjLElBQzFELFNBQVM5RyxXQUNSQSxRQUFRNUMsYUFBYSxDQUFDc25DLFlBQVksSUFDakMsTUFBTzU5QixDQUFBQSxlQUFlcUIsS0FBSyxHQUFHLEdBQUUsS0FDakMsZ0JBQWdCQSxLQUFLLElBQUksTUFDMUIsU0FBUytQLG1CQUNOOHlCLENBQUFBLHVCQUF1Qjl5QixrQkFDdkJBLGtCQUFrQixJQUFJLENBQUM7Z0JBQ2hDMndCLG9CQUFvQjdvQyxTQUFTOEc7Z0JBQzdCMGpDLGlCQUFpQjFqQztnQkFDakIsT0FBTztZQUNULEtBQUs7Z0JBQ0gsSUFBSTg5QixtQkFBbUI7b0JBQ3JCaDZCLGNBQWM5RCxlQUFlM0YsSUFBSTtvQkFDakMsSUFBSThwQyxlQUFlbmtDLGVBQWUxSixhQUFhO29CQUMvQyxTQUFTNEMsVUFDSituQyxDQUFBQSxXQUFXamhDLGlCQUNaLFNBQVNta0MsZUFDSlQsQ0FBQUEsaUJBQWlCMWpDLGlCQUNsQmdqQyxrQ0FDRWhqQyxnQkFDQW1rQyxhQUNGLElBQ0NULENBQUFBLGlCQUFpQjFqQyxpQkFDbEIyaUMsa0NBQ0UzaUMsZ0JBQ0E4RCxhQUNBa3VCLFNBQ0YsQ0FBQyxJQUNMbVMsZUFDRUEsaUJBQWlCanJDLFFBQVE1QyxhQUFhLEdBQ25DMnFDLENBQUFBLFdBQVdqaEMsaUJBQ1owakMsaUJBQWlCMWpDLGlCQUNqQmdqQyxrQ0FDRWhqQyxnQkFDQW1rQyxhQUNGLElBQ0NULENBQUFBLGlCQUFpQjFqQyxpQkFDakJBLGVBQWVxQixLQUFLLElBQUksQ0FBQyxRQUFRLElBQ25DaWdDLENBQUFBLG1CQUNHcG9DLFFBQVFrWCxhQUFhLEtBQUs0aEIsWUFDMUJpUCxXQUFXamhDLGtCQUNYcWlDLG9CQUNFbnBDLFNBQ0E4RyxnQkFDQThELGFBQ0FrdUIsV0FFTjBSLGlCQUFpQjFqQyxpQkFDakIyaUMsa0NBQ0UzaUMsZ0JBQ0E4RCxhQUNBa3VCLFNBQ0Y7b0JBQ04sT0FBTztnQkFDVDtZQUNGLEtBQUs7Z0JBQ0gsSUFBSXRoQixvQkFBb0I7b0JBQ3RCekYsZUFBZWpMO29CQUNmOEQsY0FBY3FHLGdCQUFnQkksd0JBQXdCclIsT0FBTztvQkFDN0RpckMsZUFBZW5rQyxlQUFlM0YsSUFBSTtvQkFDbEMsSUFBSSxTQUFTbkIsV0FBVyxRQUFROEcsZUFBZWdDLFNBQVMsRUFDdERzL0IsbUJBQ0lwb0MsUUFBUWtYLGFBQWEsS0FBSzRoQixZQUMxQmlQLFdBQVdqaEMsa0JBQ1hxaUMsb0JBQ0VucEMsU0FDQThHLGdCQUNBbWtDLGNBQ0FuUzt5QkFFSDt3QkFDSCxJQUFJLENBQUNBLFVBQVU7NEJBQ2IsSUFBSSxTQUFTaHlCLGVBQWVnQyxTQUFTLEVBQ25DLE1BQU0xRSxNQUNKOzRCQUVKb21DLGlCQUFpQjFqQzs0QkFDakIsT0FBTzt3QkFDVDt3QkFDQTlHLFVBQVUwUjt3QkFDVjRGLGtCQUFrQnhRLGtCQUNkZ1EsNkJBQTZCaFEsZ0JBQWdCOUcsV0FDNUMsV0FBVytrQyx5QkFDVmtHLGNBQ0FuUyxVQUNBbHVCLGFBQ0E1SyxTQUNBLENBQUMsSUFFRjhHLGVBQWVnQyxTQUFTLEdBQUc5SSxTQUM1QituQyxXQUFXamhDLGVBQWM7b0JBQy9CO29CQUNBMGpDLGlCQUFpQjFqQztvQkFDakIsT0FBTztnQkFDVDtZQUNGLEtBQUs7Z0JBQ0hpTCxlQUFlakw7Z0JBQ2Y4RCxjQUFjOUQsZUFBZTNGLElBQUk7Z0JBQ2pDLElBQUksU0FBU25CLFdBQVcsUUFBUThHLGVBQWVnQyxTQUFTLEVBQ3REcWdDLG9CQUFvQm5wQyxTQUFTOEcsZ0JBQWdCOEQsYUFBYWt1QjtxQkFDdkQ7b0JBQ0gsSUFBSSxDQUFDQSxVQUFVO3dCQUNiLElBQUksU0FBU2h5QixlQUFlZ0MsU0FBUyxFQUNuQyxNQUFNMUUsTUFDSjt3QkFFSm9tQyxpQkFBaUIxakM7d0JBQ2pCLE9BQU87b0JBQ1Q7b0JBQ0E5RyxVQUFVMFI7b0JBQ1Y0RixrQkFBa0J4USxrQkFDZGdRLDZCQUE2QmhRLGdCQUFnQjlHLFdBQzVDLGdCQUFnQmlSLGdCQUNmSSx3QkFBd0JyUixPQUFPLEdBRWhDaXJDLGVBQWVDLGVBQ2R0Z0MsYUFDQWt1QixVQUNBbVMsY0FDQWpyQyxTQUNBOEcsaUJBRUZvaEMsa0JBQWtCK0MsY0FBY25rQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsSUFDcERBLGVBQWVnQyxTQUFTLEdBQUdtaUMsY0FDNUJ6Qix3QkFDRXlCLGNBQ0FyZ0MsYUFDQWt1QixVQUNBOTRCLFlBQ0crbkMsV0FBV2poQyxlQUFjO2dCQUNwQztnQkFDQTBqQyxpQkFBaUIxakM7Z0JBQ2pCMmlDLGtDQUNFM2lDLGdCQUNBQSxlQUFlM0YsSUFBSSxFQUNuQjJGLGVBQWUvSCxZQUFZO2dCQUU3QixPQUFPO1lBQ1QsS0FBSztnQkFDSCxJQUFJaUIsV0FBVyxRQUFROEcsZUFBZWdDLFNBQVMsRUFDN0MsY0FBZTlJLFFBQVFrWCxhQUFhLEVBQ2xDa3hCLG1CQUNJeDlCLGdCQUFnQmt1QixZQUFZaVAsV0FBV2poQyxrQkFDdkN3aEMsdUJBQ0MxOUIsQ0FBQUEsZ0JBQWdCa3VCLFdBQ1osV0FBVzduQixnQkFDVkksd0JBQXdCclIsT0FBTyxHQUVoQzRLLGNBQWM4RyxrQkFDZDVLLGVBQWVnQyxTQUFTLEdBQUdxaUMsbUJBQzFCclMsVUFDQTk0QixTQUNBNEssYUFDQTlELGlCQUVGaWhDLFdBQVdqaEMsZUFBYyxJQUN4QkEsZUFBZWdDLFNBQVMsR0FBRzlJLFFBQVE4SSxTQUFTO3FCQUNwRDtvQkFDSCxJQUNFLGFBQWEsT0FBT2d3QixZQUNwQixTQUFTaHlCLGVBQWVnQyxTQUFTLEVBRWpDLE1BQU0xRSxNQUNKO29CQUVKcEUsVUFBVWlSLGdCQUFnQkksd0JBQXdCclIsT0FBTztvQkFDekQ0SyxjQUFjOEc7b0JBQ2QsSUFBSTRGLGtCQUFrQnhRLGlCQUFpQjt3QkFDckMsSUFBSSxDQUFDa1EsbUJBQ0gsTUFBTTVTLE1BQ0o7d0JBRUpwRSxVQUFVOEcsZUFBZWdDLFNBQVM7d0JBQ2xDOEIsY0FBYzlELGVBQWVvUSxhQUFhO3dCQUMxQyt6QixlQUFlLENBQUMxMEI7d0JBQ2hCdWlCLFdBQVc7d0JBQ1gsSUFBSXJWLGNBQWNyTTt3QkFDbEIsSUFBSSxTQUFTcU0sYUFDWCxPQUFRQSxZQUFZM2tCLEdBQUc7NEJBQ3JCLEtBQUs7Z0NBQ0htc0MsZ0JBQ0csZ0JBQWdCRywrQkFDZnByQyxTQUNBNEssYUFDQWt1QixXQUVGLFNBQVNtUyxnQkFDTi8wQixDQUFBQSx1QkFBdUJwUCxnQkFBZ0IsR0FBR3lMLFdBQVcsR0FDcEQwNEIsWUFBVyxDQUFDO2dDQUNsQjs0QkFDRixLQUFLOzRCQUNMLEtBQUs7Z0NBQ0ZuUyxXQUFXclYsWUFBWXZNLGFBQWEsRUFDbkMrekIsZ0JBQ0csZ0JBQWdCRywrQkFDZnByQyxTQUNBNEssYUFDQWt1QixXQUVGLFNBQVNtUyxnQkFDTi8wQixDQUFBQSx1QkFDQ3BQLGdCQUNBLEdBQ0F5TCxXQUFXLEdBQUcwNEIsWUFBVyxDQUFDO3dCQUN0Qzt3QkFDRkksb0JBQ0VyckMsU0FDQTRLLGFBQ0E5RCxnQkFDQWd5QixhQUNHcmlCLHlCQUF5QjNQO29CQUNoQyxPQUNFQSxlQUFlZ0MsU0FBUyxHQUFHcWlDLG1CQUN6QnJTLFVBQ0E5NEIsU0FDQTRLLGFBQ0E5RDtnQkFFTjtnQkFDQTBqQyxpQkFBaUIxakM7Z0JBQ2pCLE9BQU87WUFDVCxLQUFLO2dCQUNIZ3lCLFdBQVdoeUIsZUFBZTFKLGFBQWE7Z0JBQ3ZDLElBQ0UsU0FBUzRDLFdBQ1IsU0FBU0EsUUFBUTVDLGFBQWEsSUFDN0IsU0FBUzRDLFFBQVE1QyxhQUFhLENBQUM0YSxVQUFVLEVBQzNDO29CQUNBaXpCLGVBQWUzekIsa0JBQWtCeFE7b0JBQ2pDLElBQUksU0FBU2d5QixZQUFZLFNBQVNBLFNBQVM5Z0IsVUFBVSxFQUFFO3dCQUNyRCxJQUFJLFNBQVNoWSxTQUFTOzRCQUNwQixJQUFJLENBQUNpckMsY0FDSCxNQUFNN21DLE1BQ0o7NEJBRUosSUFBSSxDQUFDNFMsbUJBQ0gsTUFBTTVTLE1BQ0o7NEJBRUo2bUMsZUFBZW5rQyxlQUFlMUosYUFBYTs0QkFDM0M2dEMsZUFDRSxTQUFTQSxlQUFlQSxhQUFhanpCLFVBQVUsR0FBRzs0QkFDcEQsSUFBSSxDQUFDaXpCLGNBQ0gsTUFBTTdtQyxNQUNKOzRCQUVKa25DLHdCQUF3QkwsY0FBY25rQzs0QkFDdEMwakMsaUJBQWlCMWpDOzRCQUNoQkEsQ0FBQUEsZUFBZTlILElBQUksR0FBRyxPQUFPd3NCLFVBQzVCLFNBQVNzTixZQUNSLGdCQUFnQmh5QixlQUFlNEIsS0FBSyxFQUNyQyxTQUFTdWlDLGdCQUNObmtDLENBQUFBLGVBQWUrakMsZ0JBQWdCLElBQzlCSSxhQUFhSixnQkFBZ0I7d0JBQ3JDLE9BQ0UxeUIsZ0NBQ0VGLHVCQUNBLE1BQU9uUixDQUFBQSxlQUFlcUIsS0FBSyxHQUFHLEdBQUUsS0FDN0JyQixDQUFBQSxlQUFlMUosYUFBYSxHQUFHLElBQUcsR0FDcEMwSixlQUFlcUIsS0FBSyxJQUFJLEdBQ3pCcWlDLGlCQUFpQjFqQyxpQkFDakIsQ0FBQ0EsZUFBZTlILElBQUksR0FBRyxPQUFPd3NCLFVBQzVCLFNBQVNzTixZQUNSLGdCQUFnQmh5QixlQUFlNEIsS0FBSyxFQUNyQyxTQUFTdWlDLGdCQUNObmtDLENBQUFBLGVBQWUrakMsZ0JBQWdCLElBQzlCSSxhQUFhSixnQkFBZ0I7d0JBQ3ZDSSxlQUFlLENBQUM7b0JBQ2xCLE9BQ0UsU0FBUy95QixtQkFDTjh5QixDQUFBQSx1QkFBdUI5eUIsa0JBQ3ZCQSxrQkFBa0IsSUFBSSxHQUN0Qit5QixlQUFlLENBQUM7b0JBQ3JCLElBQUksQ0FBQ0EsY0FBYzt3QkFDakIsSUFBSW5rQyxlQUFlcUIsS0FBSyxHQUFHLEtBQ3pCLE9BQU9naEIsbUJBQW1CcmlCLGlCQUFpQkE7d0JBQzdDcWlCLG1CQUFtQnJpQjt3QkFDbkIsT0FBTztvQkFDVDtnQkFDRjtnQkFDQXFpQixtQkFBbUJyaUI7Z0JBQ25CLElBQUksTUFBT0EsQ0FBQUEsZUFBZXFCLEtBQUssR0FBRyxHQUFFLEdBQ2xDLE9BQ0UsZUFBZ0I2QixLQUFLLEdBQUdZLGFBQ3hCLENBQUM5RCxlQUFlOUgsSUFBSSxHQUFHLE9BQU93c0IsVUFDNUI3USx1QkFBdUI3VCxpQkFDekJBO2dCQUVKOEQsY0FBYyxTQUFTa3VCO2dCQUN2Qjk0QixVQUFVLFNBQVNBLFdBQVcsU0FBU0EsUUFBUTVDLGFBQWE7Z0JBQzVEd04sZUFDRyxZQUFZOUQsZUFBZTRCLEtBQUssRUFDaEN1aUMsZUFBZSxNQUNoQixTQUFTblMsU0FBUzV3QixTQUFTLElBQ3pCLFNBQVM0d0IsU0FBUzV3QixTQUFTLENBQUM5SyxhQUFhLElBQ3pDLFNBQVMwN0IsU0FBUzV3QixTQUFTLENBQUM5SyxhQUFhLENBQUNrZ0MsU0FBUyxJQUNsRDJOLENBQUFBLGVBQWVuUyxTQUFTNXdCLFNBQVMsQ0FBQzlLLGFBQWEsQ0FBQ2tnQyxTQUFTLENBQUNLLElBQUksR0FDaEVsYSxjQUFjLE1BQ2YsU0FBU3FWLFNBQVMxN0IsYUFBYSxJQUM3QixTQUFTMDdCLFNBQVMxN0IsYUFBYSxDQUFDa2dDLFNBQVMsSUFDeEM3WixDQUFBQSxjQUFjcVYsU0FBUzE3QixhQUFhLENBQUNrZ0MsU0FBUyxDQUFDSyxJQUFJLEdBQ3REbGEsZ0JBQWdCd25CLGdCQUFpQm5TLENBQUFBLFNBQVMzd0IsS0FBSyxJQUFJLElBQUcsQ0FBQztnQkFDekR5QyxnQkFBZ0I1SyxXQUNkNEssZUFDQzlELENBQUFBLGVBQWU0QixLQUFLLENBQUNQLEtBQUssSUFBSSxJQUFHO2dCQUNwQytoQyxvQkFBb0JwakMsZ0JBQWdCQSxlQUFlZ1ksV0FBVztnQkFDOUQwckIsaUJBQWlCMWpDO2dCQUNoQkEsQ0FBQUEsZUFBZTlILElBQUksR0FBRyxPQUFPd3NCLFVBQzVCNWdCLGVBQ0MsV0FBVzlELGVBQWU0QixLQUFLLEVBQ2hDLFNBQVMxSSxXQUNOOEcsQ0FBQUEsZUFBZStqQyxnQkFBZ0IsSUFBSTdxQyxRQUFRNnFDLGdCQUFnQjtnQkFDaEUsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FDRXA1QixpQkFBaUIzSyxpQkFDakIraEMsb0JBQW9CN29DLFNBQVM4RyxpQkFDN0IsU0FBUzlHLFdBQ1B1ckMsbUJBQW1CemtDLGVBQWVnQyxTQUFTLENBQUN3ZCxhQUFhLEdBQzNEa2tCLGlCQUFpQjFqQyxpQkFDakI7WUFFSixLQUFLO2dCQUNILE9BQ0VzL0IsWUFBWXQvQixlQUFlM0YsSUFBSSxFQUFFMkYsaUJBQ2pDMGpDLGlCQUFpQjFqQyxpQkFDakI7WUFFSixLQUFLO2dCQUNIdUMsSUFBSXdmLHFCQUFxQi9oQjtnQkFDekJta0MsZUFBZW5rQyxlQUFlMUosYUFBYTtnQkFDM0MsSUFBSSxTQUFTNnRDLGNBQ1gsT0FBT1QsaUJBQWlCMWpDLGlCQUFpQjtnQkFDM0NneUIsV0FBVyxNQUFPaHlCLENBQUFBLGVBQWVxQixLQUFLLEdBQUcsR0FBRTtnQkFDM0NzYixjQUFjd25CLGFBQWF2SCxTQUFTO2dCQUNwQyxJQUFJLFNBQVNqZ0IsYUFDWCxJQUFJcVYsVUFBVXNSLG1CQUFtQmEsY0FBYyxDQUFDO3FCQUMzQztvQkFDSCxJQUNFOVAsaUNBQWlDQyxrQkFDaEMsU0FBU3A3QixXQUFXLE1BQU9BLENBQUFBLFFBQVFtSSxLQUFLLEdBQUcsR0FBRSxHQUU5QyxJQUFLbkksVUFBVThHLGVBQWU0QixLQUFLLEVBQUUsU0FBUzFJLFNBQVc7d0JBQ3ZEeWpCLGNBQWMyRixtQkFBbUJwcEI7d0JBQ2pDLElBQUksU0FBU3lqQixhQUFhOzRCQUN4QjNjLGVBQWVxQixLQUFLLElBQUk7NEJBQ3hCaWlDLG1CQUFtQmEsY0FBYyxDQUFDOzRCQUNsQ2pyQyxVQUFVeWpCLFlBQVkzRSxXQUFXOzRCQUNqQ2hZLGVBQWVnWSxXQUFXLEdBQUc5ZTs0QkFDN0JrcUMsb0JBQW9CcGpDLGdCQUFnQjlHOzRCQUNwQzhHLGVBQWU0N0IsWUFBWSxHQUFHOzRCQUM5QjFpQyxVQUFVNEs7NEJBQ1YsSUFDRUEsY0FBYzlELGVBQWU0QixLQUFLLEVBQ2xDLFNBQVNrQyxhQUdUNGdDLG9CQUFvQjVnQyxhQUFhNUssVUFDOUI0SyxjQUFjQSxZQUFZakMsT0FBTzs0QkFDdEMvSCxLQUNFaW9CLHFCQUNBLG9CQUFxQjdvQixPQUFPLEdBQzFCOG9CLDZCQUNBMFksdUJBQ0YxNkI7NEJBRUYsT0FBT0EsZUFBZTRCLEtBQUs7d0JBQzdCO3dCQUNBMUksVUFBVUEsUUFBUTJJLE9BQU87b0JBQzNCO29CQUNGLFNBQVNzaUMsYUFBYTNILElBQUksSUFDeEJ2bkIsVUFBVTB2QixzQ0FDVCxnQkFBZ0J0akMsS0FBSyxJQUFJLEtBQ3pCMndCLFdBQVcsQ0FBQyxHQUNic1IsbUJBQW1CYSxjQUFjLENBQUMsSUFDakNua0MsZUFBZWtELEtBQUssR0FBRyxPQUFPO2dCQUNuQztxQkFDRztvQkFDSCxJQUFJLENBQUM4dUIsVUFDSCxJQUNHLFVBQVcxUCxtQkFBbUIzRixjQUFlLFNBQVN6akIsU0FDdkQ7d0JBQ0EsSUFDRyxlQUFnQm1JLEtBQUssSUFBSSxLQUN6QjJ3QixXQUFXLENBQUMsR0FDWjk0QixVQUFVQSxRQUFROGUsV0FBVyxFQUM3QmhZLGVBQWVnWSxXQUFXLEdBQUc5ZSxTQUM5QmtxQyxvQkFBb0JwakMsZ0JBQWdCOUcsVUFDcENvcUMsbUJBQW1CYSxjQUFjLENBQUMsSUFDbEMsU0FBU0EsYUFBYTNILElBQUksSUFDeEIsYUFBYTJILGFBQWF6SCxRQUFRLElBQ2xDLENBQUMvZixZQUFZdmIsU0FBUyxJQUN0QixDQUFDOEksYUFFSCxPQUFPdzVCLGlCQUFpQjFqQyxpQkFBaUI7b0JBQzdDLE9BQ0UsSUFBSWlWLFVBQVVrdkIsYUFBYXRILGtCQUFrQixHQUMzQzhILHNDQUNBLGNBQWM3Z0MsZUFDYixnQkFBZ0J6QyxLQUFLLElBQUksS0FDekIyd0IsV0FBVyxDQUFDLEdBQ2JzUixtQkFBbUJhLGNBQWMsQ0FBQyxJQUNqQ25rQyxlQUFla0QsS0FBSyxHQUFHLE9BQU87b0JBQ3JDaWhDLGFBQWE1SCxXQUFXLEdBQ25CLGFBQWExNkIsT0FBTyxHQUFHN0IsZUFBZTRCLEtBQUssRUFDM0M1QixlQUFlNEIsS0FBSyxHQUFHK2EsV0FBVyxJQUNsQyxXQUFXd25CLGFBQWExWCxJQUFJLEVBQzdCLFNBQVN2ekIsVUFDSkEsUUFBUTJJLE9BQU8sR0FBRzhhLGNBQ2xCM2MsZUFBZTRCLEtBQUssR0FBRythLGFBQzNCd25CLGFBQWExWCxJQUFJLEdBQUc5UCxXQUFXO2dCQUN0QztnQkFDQSxJQUFJLFNBQVN3bkIsYUFBYTNILElBQUksRUFDNUIsT0FDRSxVQUFXMkgsYUFBYTNILElBQUksRUFDM0IySCxhQUFhdkgsU0FBUyxHQUFHMWpDLFNBQ3pCaXJDLGFBQWEzSCxJQUFJLEdBQUd0akMsUUFBUTJJLE9BQU8sRUFDbkNzaUMsYUFBYXRILGtCQUFrQixHQUFHNW5CLFNBQ2xDL2IsUUFBUTJJLE9BQU8sR0FBRyxNQUNsQmlDLGNBQWNpZSxvQkFBb0I3b0IsT0FBTyxFQUN6QzRLLGNBQWNrdUIsV0FDWCxjQUFlaFEsNkJBQ2YwWSx3QkFDQTUyQixjQUFja2UsNEJBQ2xCbG9CLEtBQUtpb0IscUJBQXFCamUsYUFBYTlELGlCQUN2QzlHO2dCQUVKd3FDLGlCQUFpQjFqQztnQkFDakIsT0FBTztZQUNULEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQ0VxaUIsbUJBQW1CcmlCLGlCQUNuQjZoQixpQkFBaUI3aEIsaUJBQ2hCZ3lCLFdBQVcsU0FBU2h5QixlQUFlMUosYUFBYSxFQUNqRCxTQUFTNEMsVUFDTCxTQUFVQSxRQUFRNUMsYUFBYSxLQUFNMDdCLFlBQ3BDaHlCLENBQUFBLGVBQWVxQixLQUFLLElBQUksSUFBRyxJQUM1QjJ3QixZQUFhaHlCLENBQUFBLGVBQWVxQixLQUFLLElBQUksSUFBRyxHQUM1QzJ3QixXQUNJLE1BQU9sdUIsQ0FBQUEsY0FBYyxTQUFRLEtBQzdCLE1BQU85RCxDQUFBQSxlQUFlcUIsS0FBSyxHQUFHLEdBQUUsS0FDL0JxaUMsQ0FBQUEsaUJBQWlCMWpDLGlCQUNsQkEsZUFBZTQ3QixZQUFZLEdBQUcsS0FDM0I1N0IsQ0FBQUEsZUFBZXFCLEtBQUssSUFBSSxJQUFHLENBQUMsSUFDL0JxaUMsaUJBQWlCMWpDLGlCQUNwQjhELGNBQWM5RCxlQUFlZ1ksV0FBVyxFQUN6QyxTQUFTbFUsZUFDUHMvQixvQkFBb0JwakMsZ0JBQWdCOEQsWUFBWTh3QixVQUFVLEdBQzNEOXdCLGNBQWMsTUFDZixTQUFTNUssV0FDUCxTQUFTQSxRQUFRNUMsYUFBYSxJQUM5QixTQUFTNEMsUUFBUTVDLGFBQWEsQ0FBQ2tnQyxTQUFTLElBQ3ZDMXlCLENBQUFBLGNBQWM1SyxRQUFRNUMsYUFBYSxDQUFDa2dDLFNBQVMsQ0FBQ0ssSUFBSSxHQUNwRDdFLFdBQVcsTUFDWixTQUFTaHlCLGVBQWUxSixhQUFhLElBQ25DLFNBQVMwSixlQUFlMUosYUFBYSxDQUFDa2dDLFNBQVMsSUFDOUN4RSxDQUFBQSxXQUFXaHlCLGVBQWUxSixhQUFhLENBQUNrZ0MsU0FBUyxDQUFDSyxJQUFJLEdBQ3pEN0UsYUFBYWx1QixlQUFnQjlELENBQUFBLGVBQWVxQixLQUFLLElBQUksSUFBRyxHQUN4RCxTQUFTbkksV0FBV3FKLElBQUlzK0IsY0FBYzdnQyxpQkFDdEM7WUFFSixLQUFLO2dCQUNILE9BQ0UsY0FBZSxNQUNmLFNBQVM5RyxXQUFZNEssQ0FBQUEsY0FBYzVLLFFBQVE1QyxhQUFhLENBQUN5NkIsS0FBSyxHQUM5RC93QixlQUFlMUosYUFBYSxDQUFDeTZCLEtBQUssS0FBS2p0QixlQUNwQzlELENBQUFBLGVBQWVxQixLQUFLLElBQUksSUFBRyxHQUM5QmkrQixZQUFZMUksY0FBYzUyQixpQkFDMUIwakMsaUJBQWlCMWpDLGlCQUNqQjtZQUVKLEtBQUs7Z0JBQ0gsT0FBTztRQUNYO1FBQ0EsTUFBTTFDLE1BQ0osK0JBQ0UwQyxlQUFlaEksR0FBRyxHQUNsQjtJQUVOO0lBQ0EsU0FBUzRzQyxXQUFXMXJDLE9BQU8sRUFBRThHLGNBQWM7UUFDekNpSyxlQUFlaks7UUFDZixPQUFRQSxlQUFlaEksR0FBRztZQUN4QixLQUFLO2dCQUNILE9BQ0UsVUFBV2dJLGVBQWVxQixLQUFLLEVBQy9CbkksVUFBVSxRQUNMLGdCQUFnQm1JLEtBQUssR0FBRyxVQUFXLENBQUMsUUFBUyxLQUM5QyxDQUFDckIsZUFBZTlILElBQUksR0FBRyxPQUFPd3NCLFVBQzVCN1EsdUJBQXVCN1QsaUJBQ3pCQSxjQUFhLElBQ2I7WUFFUixLQUFLO2dCQUNILE9BQ0VzL0IsWUFBWTFJLGNBQWM1MkIsaUJBQzFCMkssaUJBQWlCM0ssaUJBQ2hCOUcsVUFBVThHLGVBQWVxQixLQUFLLEVBQy9CLE1BQU9uSSxDQUFBQSxVQUFVLEtBQUksS0FBTSxNQUFPQSxDQUFBQSxVQUFVLEdBQUUsSUFDekMsZ0JBQWdCbUksS0FBSyxHQUFHLFVBQVcsQ0FBQyxRQUFTLEtBQzlDckIsY0FBYSxJQUNiO1lBRVIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU9pTCxlQUFlakwsaUJBQWlCO1lBQ3pDLEtBQUs7Z0JBQ0hxaUIsbUJBQW1CcmlCO2dCQUNuQjlHLFVBQVU4RyxlQUFlMUosYUFBYTtnQkFDdEMsSUFBSSxTQUFTNEMsV0FBVyxTQUFTQSxRQUFRZ1ksVUFBVSxFQUFFO29CQUNuRCxJQUFJLFNBQVNsUixlQUFlb0IsU0FBUyxFQUNuQyxNQUFNOUQsTUFDSjtvQkFFSjZUO2dCQUNGO2dCQUNBalksVUFBVThHLGVBQWVxQixLQUFLO2dCQUM5QixPQUFPbkksVUFBVSxRQUNaLGdCQUFnQm1JLEtBQUssR0FBRyxVQUFXLENBQUMsUUFBUyxLQUM5QyxDQUFDckIsZUFBZTlILElBQUksR0FBRyxPQUFPd3NCLFVBQzVCN1EsdUJBQXVCN1QsaUJBQ3pCQSxjQUFhLElBQ2I7WUFDTixLQUFLO2dCQUNILE9BQU91QyxJQUFJd2YscUJBQXFCL2hCLGlCQUFpQjtZQUNuRCxLQUFLO2dCQUNILE9BQU8ySyxpQkFBaUIzSyxpQkFBaUI7WUFDM0MsS0FBSztnQkFDSCxPQUFPcy9CLFlBQVl0L0IsZUFBZTNGLElBQUksRUFBRTJGLGlCQUFpQjtZQUMzRCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUNFcWlCLG1CQUFtQnJpQixpQkFDbkI2aEIsaUJBQWlCN2hCLGlCQUNqQixTQUFTOUcsV0FBV3FKLElBQUlzK0IsY0FBYzdnQyxpQkFDckM5RyxVQUFVOEcsZUFBZXFCLEtBQUssRUFDL0JuSSxVQUFVLFFBQ0wsZ0JBQWdCbUksS0FBSyxHQUFHLFVBQVcsQ0FBQyxRQUFTLEtBQzlDLENBQUNyQixlQUFlOUgsSUFBSSxHQUFHLE9BQU93c0IsVUFDNUI3USx1QkFBdUI3VCxpQkFDekJBLGNBQWEsSUFDYjtZQUVSLEtBQUs7Z0JBQ0gsT0FBT3MvQixZQUFZMUksY0FBYzUyQixpQkFBaUI7WUFDcEQsS0FBSztnQkFDSCxPQUFPO1lBQ1Q7Z0JBQ0UsT0FBTztRQUNYO0lBQ0Y7SUFDQSxTQUFTNmtDLHNCQUFzQjNyQyxPQUFPLEVBQUU0ckMsZUFBZTtRQUNyRDc2QixlQUFlNjZCO1FBQ2YsT0FBUUEsZ0JBQWdCOXNDLEdBQUc7WUFDekIsS0FBSztnQkFDSHNuQyxZQUFZMUksY0FBY2tPO2dCQUMxQm42QixpQkFBaUJtNkI7Z0JBQ2pCO1lBQ0YsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNINzVCLGVBQWU2NUI7Z0JBQ2Y7WUFDRixLQUFLO2dCQUNIbjZCLGlCQUFpQm02QjtnQkFDakI7WUFDRixLQUFLO2dCQUNIemlCLG1CQUFtQnlpQjtnQkFDbkI7WUFDRixLQUFLO2dCQUNIdmlDLElBQUl3ZixxQkFBcUIraUI7Z0JBQ3pCO1lBQ0YsS0FBSztnQkFDSHhGLFlBQVl3RixnQkFBZ0J6cUMsSUFBSSxFQUFFeXFDO2dCQUNsQztZQUNGLEtBQUs7WUFDTCxLQUFLO2dCQUNIemlCLG1CQUFtQnlpQjtnQkFDbkJqakIsaUJBQWlCaWpCO2dCQUNqQixTQUFTNXJDLFdBQVdxSixJQUFJcytCLGNBQWNpRTtnQkFDdEM7WUFDRixLQUFLO2dCQUNIeEYsWUFBWTFJLGNBQWNrTztRQUM5QjtJQUNGO0lBQ0EsU0FBU0MsY0FBYzdyQyxPQUFPO1FBQzVCLE9BQU8sQ0FBQ0EsUUFBUWhCLElBQUksR0FBRyxPQUFPd3NCO0lBQ2hDO0lBQ0EsU0FBU3NnQix3QkFBd0JDLFlBQVksRUFBRWxYLFNBQVM7UUFDdERnWCxjQUFjRSxnQkFDVHJ4QixDQUFBQSxvQkFDRHN4QiwwQkFBMEJuWCxXQUFXa1gsZUFDckN0eEIsc0JBQXFCLElBQ3JCdXhCLDBCQUEwQm5YLFdBQVdrWDtJQUMzQztJQUNBLFNBQVNFLCtCQUNQRixZQUFZLEVBQ1pHLHNCQUFzQixFQUN0QnJYLFNBQVM7UUFFVGdYLGNBQWNFLGdCQUNUcnhCLENBQUFBLG9CQUNEeXhCLDRCQUNFdFgsV0FDQWtYLGNBQ0FHLHlCQUVGenhCLHNCQUFxQixJQUNyQjB4Qiw0QkFDRXRYLFdBQ0FrWCxjQUNBRztJQUVSO0lBQ0EsU0FBU0YsMEJBQTBCN2pDLEtBQUssRUFBRTRqQyxZQUFZO1FBQ3BELElBQUk7WUFDRixJQUFJanRCLGNBQWNpdEIsYUFBYWp0QixXQUFXLEVBQ3hDNk4sYUFBYSxTQUFTN04sY0FBY0EsWUFBWTZOLFVBQVUsR0FBRztZQUMvRCxJQUFJLFNBQVNBLFlBQVk7Z0JBQ3ZCLElBQUl5ZixjQUFjemYsV0FBV3R2QixJQUFJO2dCQUNqQ3loQixjQUFjc3RCO2dCQUNkLEdBQUc7b0JBQ0QsSUFDRSxDQUFDdHRCLFlBQVloZ0IsR0FBRyxHQUFHcUosS0FBSSxNQUFPQSxTQUM3QixFQUFDQSxRQUFRcW9CLE9BQU0sTUFBTzZiLFVBQ25CLFNBQVNyOUIsMEJBQ1QsZUFDRSxPQUFPQSx1QkFBdUJzOUIsc0NBQXNDLElBQ3RFdDlCLHVCQUF1QnM5QixzQ0FBc0MsQ0FDM0RQLGdCQUVGLENBQUM1akMsUUFBUTRzQixNQUFLLE1BQU9zWCxXQUNyQixTQUFTcjlCLDBCQUNULGVBQ0UsT0FBT0EsdUJBQXVCdTlCLHFDQUFxQyxJQUNyRXY5Qix1QkFBdUJ1OUIscUNBQXFDLENBQzFEUixlQUVMcGYsYUFBYSxLQUFLLEdBQ25CLENBQUN4a0IsUUFBUXFrQyxTQUFRLE1BQU9ILFdBQ3JCSSxDQUFBQSwyQkFBMkIsQ0FBQyxJQUM5QjlmLGFBQWF0bEIsa0JBQ1owa0MsY0FDQVcsaUJBQ0E1dEIsY0FFRixDQUFDM1csUUFBUXFrQyxTQUFRLE1BQU9ILFdBQ3JCSSxDQUFBQSwyQkFBMkIsQ0FBQyxJQUMvQixDQUFDdGtDLFFBQVFxb0IsT0FBTSxNQUFPNmIsVUFDbEIsU0FBU3I5QiwwQkFDVCxlQUNFLE9BQU9BLHVCQUF1QjI5QixzQ0FBc0MsSUFDdEUzOUIsdUJBQXVCMjlCLHNDQUFzQyxLQUM3RCxDQUFDeGtDLFFBQVE0c0IsTUFBSyxNQUFPc1gsV0FDckIsU0FBU3I5QiwwQkFDVCxlQUNFLE9BQU9BLHVCQUF1QjQ5QixxQ0FBcUMsSUFDckU1OUIsdUJBQXVCNDlCLHFDQUFxQyxJQUNoRSxLQUFLLE1BQU1qZ0IsY0FBYyxlQUFlLE9BQU9BLFVBQVMsR0FDeEQ7d0JBQ0EsSUFBSWhELFdBQVcsS0FBSzt3QkFDcEJBLFdBQ0UsTUFBTzdLLENBQUFBLFlBQVloZ0IsR0FBRyxHQUFHaTJCLE1BQUssSUFDMUIsb0JBQ0EsTUFBT2pXLENBQUFBLFlBQVloZ0IsR0FBRyxHQUFHMHRDLFNBQVEsSUFDL0IsdUJBQ0E7d0JBQ1IsSUFBSUssV0FBVyxLQUFLO3dCQUNwQkEsV0FDRSxTQUFTbGdCLGFBQ0wsaUdBQ0EsZUFBZSxPQUFPQSxXQUFXdE8sSUFBSSxHQUNuQyxpQ0FDQXNMLFdBQ0EsK0hBQ0FBLFdBQ0EsbVRBQ0Esb0JBQW9CZ0Q7d0JBQzVCdGxCLGtCQUNFMGtDLGNBQ0EsU0FBVWUsQ0FBQyxFQUFFeGtDLENBQUM7NEJBQ1psSyxRQUFRZ0MsS0FBSyxDQUNYLGlGQUNBMHNDLEdBQ0F4a0M7d0JBRUosR0FDQXFoQixVQUNBa2pCO29CQUVKO29CQUNBL3RCLGNBQWNBLFlBQVl6aEIsSUFBSTtnQkFDaEMsUUFBU3loQixnQkFBZ0JzdEIsYUFBYTtZQUN4QztRQUNGLEVBQUUsT0FBT2hzQyxPQUFPO1lBQ2Qyc0Msd0JBQXdCaEIsY0FBY0EsYUFBYXBwQyxNQUFNLEVBQUV2QztRQUM3RDtJQUNGO0lBQ0EsU0FBUytyQyw0QkFDUGhrQyxLQUFLLEVBQ0w0akMsWUFBWSxFQUNaRyxzQkFBc0I7UUFFdEIsSUFBSTtZQUNGLElBQUlwdEIsY0FBY2l0QixhQUFhanRCLFdBQVcsRUFDeEM2TixhQUFhLFNBQVM3TixjQUFjQSxZQUFZNk4sVUFBVSxHQUFHO1lBQy9ELElBQUksU0FBU0EsWUFBWTtnQkFDdkIsSUFBSXlmLGNBQWN6ZixXQUFXdHZCLElBQUk7Z0JBQ2pDeWhCLGNBQWNzdEI7Z0JBQ2QsR0FBRztvQkFDRCxJQUFJLENBQUN0dEIsWUFBWWhnQixHQUFHLEdBQUdxSixLQUFJLE1BQU9BLE9BQU87d0JBQ3ZDLElBQUk4b0IsT0FBT25TLFlBQVltUyxJQUFJLEVBQ3pCUCxVQUFVTyxLQUFLUCxPQUFPO3dCQUN4QixLQUFLLE1BQU1BLFdBQ1IsTUFBTUEsT0FBTyxHQUFHLEtBQUssR0FDdEIsQ0FBQ3ZvQixRQUFRcW9CLE9BQU0sTUFBTzZiLFVBQ2xCLFNBQVNyOUIsMEJBQ1QsZUFDRSxPQUFPQSx1QkFBdUJnK0Isd0NBQXdDLElBQ3hFaCtCLHVCQUF1QmcrQix3Q0FBd0MsQ0FDN0RqQixnQkFFRixDQUFDNWpDLFFBQVE0c0IsTUFBSyxNQUFPc1gsV0FDckIsU0FBU3I5QiwwQkFDVCxlQUNFLE9BQU9BLHVCQUF1QmkrQix1Q0FBdUMsSUFDdkVqK0IsdUJBQXVCaStCLHVDQUF1QyxDQUM1RGxCLGVBRU4sQ0FBQzVqQyxRQUFRcWtDLFNBQVEsTUFBT0gsV0FDckJJLENBQUFBLDJCQUEyQixDQUFDLElBQy9CcGxDLGtCQUNFMGtDLGNBQ0FtQixrQkFDQW5CLGNBQ0FHLHdCQUNBeGIsVUFFRixDQUFDdm9CLFFBQVFxa0MsU0FBUSxNQUFPSCxXQUNyQkksQ0FBQUEsMkJBQTJCLENBQUMsSUFDL0IsQ0FBQ3RrQyxRQUFRcW9CLE9BQU0sTUFBTzZiLFVBQ2xCLFNBQVNyOUIsMEJBQ1QsZUFDRSxPQUFPQSx1QkFBdUJtK0Isd0NBQXdDLElBQ3hFbitCLHVCQUF1Qm0rQix3Q0FBd0MsS0FDL0QsQ0FBQ2hsQyxRQUFRNHNCLE1BQUssTUFBT3NYLFdBQ3JCLFNBQVNyOUIsMEJBQ1QsZUFDRSxPQUFPQSx1QkFBdUJvK0IsdUNBQXVDLElBQ3ZFcCtCLHVCQUF1Qm8rQix1Q0FBdUMsRUFBQztvQkFDdkU7b0JBQ0F0dUIsY0FBY0EsWUFBWXpoQixJQUFJO2dCQUNoQyxRQUFTeWhCLGdCQUFnQnN0QixhQUFhO1lBQ3hDO1FBQ0YsRUFBRSxPQUFPaHNDLE9BQU87WUFDZDJzQyx3QkFBd0JoQixjQUFjQSxhQUFhcHBDLE1BQU0sRUFBRXZDO1FBQzdEO0lBQ0Y7SUFDQSxTQUFTaXRDLDhCQUE4QnRCLFlBQVksRUFBRWxYLFNBQVM7UUFDNURnWCxjQUFjRSxnQkFDVHJ4QixDQUFBQSxvQkFDRHN4QiwwQkFBMEJuWCxXQUFXa1gsZUFDckN0eEIsc0JBQXFCLElBQ3JCdXhCLDBCQUEwQm5YLFdBQVdrWDtJQUMzQztJQUNBLFNBQVN1QixnQ0FDUHZCLFlBQVksRUFDWkcsc0JBQXNCLEVBQ3RCclgsU0FBUztRQUVUZ1gsY0FBY0UsZ0JBQ1RyeEIsQ0FBQUEsb0JBQ0R5eEIsNEJBQ0V0WCxXQUNBa1gsY0FDQUcseUJBRUZ6eEIsc0JBQXFCLElBQ3JCMHhCLDRCQUNFdFgsV0FDQWtYLGNBQ0FHO0lBRVI7SUFDQSxTQUFTcUIscUJBQXFCeEIsWUFBWTtRQUN4QyxJQUFJanRCLGNBQWNpdEIsYUFBYWp0QixXQUFXO1FBQzFDLElBQUksU0FBU0EsYUFBYTtZQUN4QixJQUFJbUMsV0FBVzhxQixhQUFhampDLFNBQVM7WUFDckNpakMsYUFBYTVxQyxJQUFJLENBQUNzNEIsWUFBWSxJQUM1QixTQUFTc1MsYUFBYTcwQixhQUFhLElBQ25DeXBCLGdDQUNDMWYsQ0FBQUEsU0FBU3RkLEtBQUssS0FBS29vQyxhQUFhNzBCLGFBQWEsSUFDNUM5WSxRQUFRZ0MsS0FBSyxDQUNYLDhNQUNBcUMsMEJBQTBCc3BDLGlCQUFpQixhQUUvQzlxQixTQUFTcUksS0FBSyxLQUFLeWlCLGFBQWEzdUMsYUFBYSxJQUMzQ2dCLFFBQVFnQyxLQUFLLENBQ1gsOE1BQ0FxQywwQkFBMEJzcEMsaUJBQWlCLFdBQzdDO1lBQ0osSUFBSTtnQkFDRjFrQyxrQkFDRTBrQyxjQUNBcnFCLGlCQUNBNUMsYUFDQW1DO1lBRUosRUFBRSxPQUFPN2dCLE9BQU87Z0JBQ2Qyc0Msd0JBQXdCaEIsY0FBY0EsYUFBYXBwQyxNQUFNLEVBQUV2QztZQUM3RDtRQUNGO0lBQ0Y7SUFDQSxTQUFTb3RDLDZCQUE2QnZzQixRQUFRLEVBQUU4YixTQUFTLEVBQUVwSyxTQUFTO1FBQ2xFLE9BQU8xUixTQUFTNGQsdUJBQXVCLENBQUM5QixXQUFXcEs7SUFDckQ7SUFDQSxTQUFTOGEsb0JBQW9CMUIsWUFBWSxFQUFFL3JDLE9BQU87UUFDaEQsSUFBSSs4QixZQUFZLzhCLFFBQVFrWCxhQUFhLEVBQ25DeWIsWUFBWTN5QixRQUFRNUMsYUFBYTtRQUNuQzRDLFVBQVUrckMsYUFBYWpqQyxTQUFTO1FBQ2hDaWpDLGFBQWE1cUMsSUFBSSxDQUFDczRCLFlBQVksSUFDNUIsU0FBU3NTLGFBQWE3MEIsYUFBYSxJQUNuQ3lwQixnQ0FDQzNnQyxDQUFBQSxRQUFRMkQsS0FBSyxLQUFLb29DLGFBQWE3MEIsYUFBYSxJQUMzQzlZLFFBQVFnQyxLQUFLLENBQ1gsME1BQ0FxQywwQkFBMEJzcEMsaUJBQWlCLGFBRS9DL3JDLFFBQVFzcEIsS0FBSyxLQUFLeWlCLGFBQWEzdUMsYUFBYSxJQUMxQ2dCLFFBQVFnQyxLQUFLLENBQ1gsME1BQ0FxQywwQkFBMEJzcEMsaUJBQWlCLFdBQzdDO1FBQ0osSUFBSTtZQUNGLElBQUkyQixvQkFBb0JuVSwyQkFDdEJ3UyxhQUFhNXFDLElBQUksRUFDakI0N0IsV0FDQWdQLGFBQWFobUIsV0FBVyxLQUFLZ21CLGFBQWE1cUMsSUFBSTtZQUVoRCxJQUFJd3NDLFdBQVd0bUMsa0JBQ2Iwa0MsY0FDQXlCLDhCQUNBeHRDLFNBQ0EwdEMsbUJBQ0EvYTtZQUVGb0ssWUFBWTZRO1lBQ1osS0FBSyxNQUFNRCxZQUNUNVEsVUFBVTd2QixHQUFHLENBQUM2K0IsYUFBYTVxQyxJQUFJLEtBQzlCNDdCLENBQUFBLFVBQVVqd0IsR0FBRyxDQUFDaS9CLGFBQWE1cUMsSUFBSSxHQUNoQ2tHLGtCQUFrQjBrQyxjQUFjO2dCQUM5QjN0QyxRQUFRZ0MsS0FBSyxDQUNYLDJHQUNBcUMsMEJBQTBCc3BDO1lBRTlCLEVBQUM7WUFDSC9yQyxRQUFRNnRDLG1DQUFtQyxHQUFHRjtRQUNoRCxFQUFFLE9BQU92dEMsT0FBTztZQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7UUFDN0Q7SUFDRjtJQUNBLFNBQVMwdEMsK0JBQ1A5dEMsT0FBTyxFQUNQa3NDLHNCQUFzQixFQUN0QmpyQixRQUFRO1FBRVJBLFNBQVN0ZCxLQUFLLEdBQUc0MUIsMkJBQ2Z2NUIsUUFBUW1CLElBQUksRUFDWm5CLFFBQVFrWCxhQUFhO1FBRXZCK0osU0FBU3FJLEtBQUssR0FBR3RwQixRQUFRNUMsYUFBYTtRQUN0Q3l1QyxjQUFjN3JDLFdBQ1QwYSxDQUFBQSxvQkFDRHJULGtCQUNFckgsU0FDQSt0QywrQkFDQS90QyxTQUNBa3NDLHdCQUNBanJCLFdBRUZ4RyxzQkFBcUIsSUFDckJwVCxrQkFDRXJILFNBQ0ErdEMsK0JBQ0EvdEMsU0FDQWtzQyx3QkFDQWpyQjtJQUVSO0lBQ0EsU0FBUytzQixnQkFBZ0JqQyxZQUFZO1FBQ25DLElBQUkvbkIsTUFBTStuQixhQUFhL25CLEdBQUc7UUFDMUIsSUFBSSxTQUFTQSxLQUFLO1lBQ2hCLElBQUkvQyxXQUFXOHFCLGFBQWFqakMsU0FBUztZQUNyQyxPQUFRaWpDLGFBQWFqdEMsR0FBRztnQkFDdEIsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0htaUIsV0FBV2d0QixrQkFBa0JodEI7WUFDakM7WUFDQSxJQUFJLGVBQWUsT0FBTytDLEtBQ3hCLElBQUk2bkIsY0FBY0UsZUFDaEIsSUFBSTtnQkFDRnJ4QixvQkFBcUJxeEIsYUFBYTlXLFVBQVUsR0FBR2pSLElBQUkvQztZQUNyRCxTQUFVO2dCQUNSeEc7WUFDRjtpQkFDR3N4QixhQUFhOVcsVUFBVSxHQUFHalIsSUFBSS9DO2lCQUVuQyxhQUFhLE9BQU8rQyxNQUNoQjVsQixRQUFRZ0MsS0FBSyxDQUFDLDBDQUNkNGpCLElBQUk5UCxjQUFjLENBQUMsY0FDbkI5VixRQUFRZ0MsS0FBSyxDQUNYLGlHQUNBcUMsMEJBQTBCc3BDLGdCQUU3Qi9uQixJQUFJaGtCLE9BQU8sR0FBR2loQjtRQUNyQjtJQUNGO0lBQ0EsU0FBU2l0QixnQkFBZ0JsdUMsT0FBTyxFQUFFa3NDLHNCQUFzQjtRQUN0RCxJQUFJO1lBQ0Y3a0Msa0JBQWtCckgsU0FBU2d1QyxpQkFBaUJodUM7UUFDOUMsRUFBRSxPQUFPSSxPQUFPO1lBQ2Qyc0Msd0JBQXdCL3NDLFNBQVNrc0Msd0JBQXdCOXJDO1FBQzNEO0lBQ0Y7SUFDQSxTQUFTK3RDLGdCQUFnQm51QyxPQUFPLEVBQUVrc0Msc0JBQXNCO1FBQ3RELElBQUlsb0IsTUFBTWhrQixRQUFRZ2tCLEdBQUcsRUFDbkJpUixhQUFhajFCLFFBQVFpMUIsVUFBVTtRQUNqQyxJQUFJLFNBQVNqUixLQUNYLElBQUksZUFBZSxPQUFPaVIsWUFDeEIsSUFBSTtZQUNGLElBQUk0VyxjQUFjN3JDLFVBQ2hCLElBQUk7Z0JBQ0YwYSxvQkFBb0JyVCxrQkFBa0JySCxTQUFTaTFCO1lBQ2pELFNBQVU7Z0JBQ1J4YSxxQkFBcUJ6YTtZQUN2QjtpQkFDR3FILGtCQUFrQnJILFNBQVNpMUI7UUFDbEMsRUFBRSxPQUFPNzBCLE9BQU87WUFDZDJzQyx3QkFBd0Ivc0MsU0FBU2tzQyx3QkFBd0I5ckM7UUFDM0QsU0FBVTtZQUNQSixRQUFRaTFCLFVBQVUsR0FBRyxNQUNuQmoxQixVQUFVQSxRQUFRa0ksU0FBUyxFQUM1QixRQUFRbEksV0FBWUEsQ0FBQUEsUUFBUWkxQixVQUFVLEdBQUcsSUFBRztRQUNoRDthQUNHLElBQUksZUFBZSxPQUFPalIsS0FDN0IsSUFBSTtZQUNGLElBQUk2bkIsY0FBYzdyQyxVQUNoQixJQUFJO2dCQUNGMGEsb0JBQW9CclQsa0JBQWtCckgsU0FBU2drQixLQUFLO1lBQ3RELFNBQVU7Z0JBQ1J2SixxQkFBcUJ6YTtZQUN2QjtpQkFDR3FILGtCQUFrQnJILFNBQVNna0IsS0FBSztRQUN2QyxFQUFFLE9BQU9vcUIsU0FBUztZQUNoQnJCLHdCQUF3Qi9zQyxTQUFTa3NDLHdCQUF3QmtDO1FBQzNEO2FBQ0dwcUIsSUFBSWhrQixPQUFPLEdBQUc7SUFDdkI7SUFDQSxTQUFTcXVDLGVBQ1B0QyxZQUFZLEVBQ1ovckMsT0FBTyxFQUNQc3VDLGVBQWUsRUFDZnBLLGNBQWM7UUFFZCxJQUFJcUssd0JBQXdCeEMsYUFBYTcwQixhQUFhLEVBQ3BEL1osS0FBS294QyxzQkFBc0JweEMsRUFBRSxFQUM3QnF4QyxXQUFXRCxzQkFBc0JDLFFBQVE7UUFDM0NELHdCQUF3QkEsc0JBQXNCRSxRQUFRO1FBQ3REenVDLFVBQVUsU0FBU0EsVUFBVSxVQUFVO1FBQ3ZDK2MseUJBQTBCL2MsQ0FBQUEsVUFBVSxlQUFjO1FBQ2xELGVBQWUsT0FBT3V1Qyx5QkFDcEJBLHNCQUNFcHhDLElBQ0E2QyxTQUNBK3JDLGFBQWF6eEIsY0FBYyxFQUMzQnl4QixhQUFhbEIsZ0JBQWdCLEVBQzdCa0IsYUFBYTN4QixlQUFlLEVBQzVCazBCO1FBRUosZUFBZSxPQUFPRSxZQUNwQkEsU0FDRXpDLGFBQWE3MEIsYUFBYSxDQUFDL1osRUFBRSxFQUM3QjZDLFNBQ0Fra0MsZ0JBQ0FvSztJQUVOO0lBQ0EsU0FBU0ksNkJBQ1AzQyxZQUFZLEVBQ1ovckMsT0FBTyxFQUNQc3VDLGVBQWUsRUFDZm5LLHFCQUFxQjtRQUVyQixJQUFJd0sseUJBQXlCNUMsYUFBYTcwQixhQUFhO1FBQ3ZENjBCLGVBQWU0Qyx1QkFBdUJ4eEMsRUFBRTtRQUN4Q3d4Qyx5QkFBeUJBLHVCQUF1QkMsWUFBWTtRQUM1RDV1QyxVQUFVLFNBQVNBLFVBQVUsVUFBVTtRQUN2QytjLHlCQUEwQi9jLENBQUFBLFVBQVUsZUFBYztRQUNsRCxlQUFlLE9BQU8ydUMsMEJBQ3BCQSx1QkFDRTVDLGNBQ0EvckMsU0FDQW1rQyx1QkFDQW1LO0lBRU47SUFDQSxTQUFTTyxnQkFBZ0I5QyxZQUFZO1FBQ25DLElBQUk1cUMsT0FBTzRxQyxhQUFhNXFDLElBQUksRUFDMUJ3QyxRQUFRb29DLGFBQWE3MEIsYUFBYSxFQUNsQytKLFdBQVc4cUIsYUFBYWpqQyxTQUFTO1FBQ25DLElBQUk7WUFDRnpCLGtCQUNFMGtDLGNBQ0ErQyxhQUNBN3RCLFVBQ0E5ZixNQUNBd0MsT0FDQW9vQztRQUVKLEVBQUUsT0FBTzNyQyxPQUFPO1lBQ2Qyc0Msd0JBQXdCaEIsY0FBY0EsYUFBYXBwQyxNQUFNLEVBQUV2QztRQUM3RDtJQUNGO0lBQ0EsU0FBUzJ1QyxpQkFBaUJoRCxZQUFZLEVBQUVqVCxRQUFRLEVBQUVELFFBQVE7UUFDeEQsSUFBSTtZQUNGeHhCLGtCQUNFMGtDLGNBQ0FpRCxjQUNBakQsYUFBYWpqQyxTQUFTLEVBQ3RCaWpDLGFBQWE1cUMsSUFBSSxFQUNqQjAzQixVQUNBQyxVQUNBaVQ7UUFFSixFQUFFLE9BQU8zckMsT0FBTztZQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7UUFDN0Q7SUFDRjtJQUNBLFNBQVM2dUMsYUFBYS94QyxLQUFLO1FBQ3pCLE9BQ0UsTUFBTUEsTUFBTTRCLEdBQUcsSUFDZixNQUFNNUIsTUFBTTRCLEdBQUcsSUFDZDhsQyxDQUFBQSxvQkFBb0IsT0FBTzFuQyxNQUFNNEIsR0FBRyxHQUFHLENBQUMsTUFDeEMwWSxDQUFBQSxxQkFBcUIsT0FBT3RhLE1BQU00QixHQUFHLEdBQUcsQ0FBQyxNQUMxQyxNQUFNNUIsTUFBTTRCLEdBQUc7SUFFbkI7SUFDQSxTQUFTb3dDLGVBQWVoeUMsS0FBSztRQUMzQm9MLEdBQUcsT0FBUztZQUNWLE1BQU8sU0FBU3BMLE1BQU15TCxPQUFPLEVBQUk7Z0JBQy9CLElBQUksU0FBU3pMLE1BQU15RixNQUFNLElBQUlzc0MsYUFBYS94QyxNQUFNeUYsTUFBTSxHQUFHLE9BQU87Z0JBQ2hFekYsUUFBUUEsTUFBTXlGLE1BQU07WUFDdEI7WUFDQXpGLE1BQU15TCxPQUFPLENBQUNoRyxNQUFNLEdBQUd6RixNQUFNeUYsTUFBTTtZQUNuQyxJQUNFekYsUUFBUUEsTUFBTXlMLE9BQU8sRUFDckIsTUFBTXpMLE1BQU00QixHQUFHLElBQ2YsTUFBTTVCLE1BQU00QixHQUFHLElBQ2QwWSxDQUFBQSxxQkFBcUIsT0FBT3RhLE1BQU00QixHQUFHLEdBQUcsTUFDekMsT0FBTzVCLE1BQU00QixHQUFHLEVBRWhCO2dCQUNBLElBQUk1QixNQUFNaUwsS0FBSyxHQUFHLEdBQUcsU0FBU0c7Z0JBQzlCLElBQUksU0FBU3BMLE1BQU13TCxLQUFLLElBQUksTUFBTXhMLE1BQU00QixHQUFHLEVBQUUsU0FBU3dKO3FCQUNqRCxNQUFPSSxLQUFLLENBQUMvRixNQUFNLEdBQUd6RixPQUFTQSxRQUFRQSxNQUFNd0wsS0FBSztZQUN6RDtZQUNBLElBQUksQ0FBRXhMLENBQUFBLE1BQU1pTCxLQUFLLEdBQUcsSUFBSSxPQUFPakwsTUFBTTRMLFNBQVM7UUFDaEQ7SUFDRjtJQUNBLFNBQVNxbUMseUNBQXlDbm5DLElBQUksRUFBRW9uQyxNQUFNLEVBQUVwbUMsTUFBTTtRQUNwRSxJQUFJbEssTUFBTWtKLEtBQUtsSixHQUFHO1FBQ2xCLElBQUksTUFBTUEsT0FBTyxNQUFNQSxLQUNyQixPQUFRa0osS0FBS2MsU0FBUyxFQUNwQnNtQyxTQUNJQyx3QkFBd0JybUMsUUFBUWhCLE1BQU1vbkMsVUFDdENFLHVCQUF1QnRtQyxRQUFRaEI7YUFDbEMsSUFDSCxDQUFFLE9BQU1sSixPQUFRMFksc0JBQXNCLE9BQU8xWSxHQUFHLEtBQy9DLFFBQVFrSixLQUFLVSxLQUFLLEVBQUcsU0FBU1YsSUFBRyxHQUVsQyxJQUNFbW5DLHlDQUF5Q25uQyxNQUFNb25DLFFBQVFwbUMsU0FDckRoQixPQUFPQSxLQUFLVyxPQUFPLEVBQ3JCLFNBQVNYLE1BR1RtbkMseUNBQXlDbm5DLE1BQU1vbkMsUUFBUXBtQyxTQUNwRGhCLE9BQU9BLEtBQUtXLE9BQU87SUFDNUI7SUFDQSxTQUFTNG1DLDRCQUE0QnZuQyxJQUFJLEVBQUVvbkMsTUFBTSxFQUFFcG1DLE1BQU07UUFDdkQsSUFBSWxLLE1BQU1rSixLQUFLbEosR0FBRztRQUNsQixJQUFJLE1BQU1BLE9BQU8sTUFBTUEsS0FDckIsT0FBUWtKLEtBQUtjLFNBQVMsRUFDcEJzbUMsU0FDSUksYUFBYXhtQyxRQUFRaEIsTUFBTW9uQyxVQUMzQkssWUFBWXptQyxRQUFRaEI7YUFDdkIsSUFDSCxDQUFFLE9BQU1sSixPQUFRMFksc0JBQXNCLE9BQU8xWSxHQUFHLEtBQy9DLFFBQVFrSixLQUFLVSxLQUFLLEVBQUcsU0FBU1YsSUFBRyxHQUVsQyxJQUNFdW5DLDRCQUE0QnZuQyxNQUFNb25DLFFBQVFwbUMsU0FDeENoQixPQUFPQSxLQUFLVyxPQUFPLEVBQ3JCLFNBQVNYLE1BR1R1bkMsNEJBQTRCdm5DLE1BQU1vbkMsUUFBUXBtQyxTQUN2Q2hCLE9BQU9BLEtBQUtXLE9BQU87SUFDNUI7SUFDQSxTQUFTK21DLGdCQUFnQjNELFlBQVk7UUFDbkMsSUFDRTNELG9CQUNDLEVBQUM1d0Isc0JBQXNCLE9BQU91MEIsYUFBYWp0QyxHQUFHLEdBQy9DO1lBQ0F3SixHQUFHO2dCQUNELElBQUssSUFBSVUsU0FBUytpQyxhQUFhcHBDLE1BQU0sRUFBRSxTQUFTcUcsUUFBVTtvQkFDeEQsSUFBSWltQyxhQUFham1DLFNBQVM7d0JBQ3hCLElBQUkybUMsY0FBYzNtQzt3QkFDbEIsTUFBTVY7b0JBQ1I7b0JBQ0FVLFNBQVNBLE9BQU9yRyxNQUFNO2dCQUN4QjtnQkFDQSxNQUFNeUIsTUFDSjtZQUVKO1lBQ0EsT0FBUXVyQyxZQUFZN3dDLEdBQUc7Z0JBQ3JCLEtBQUs7b0JBQ0gsSUFBSTBZLG9CQUFvQjt3QkFDdEJ4TyxTQUFTMm1DLFlBQVk3bUMsU0FBUzt3QkFDOUI2bUMsY0FBY1QsZUFBZW5EO3dCQUM3QndELDRCQUE0QnhELGNBQWM0RCxhQUFhM21DO3dCQUN2RDtvQkFDRjtnQkFDRixLQUFLO29CQUNIQSxTQUFTMm1DLFlBQVk3bUMsU0FBUztvQkFDOUI2bUMsWUFBWXhuQyxLQUFLLEdBQUcsTUFDakJ5bkMsQ0FBQUEsaUJBQWlCNW1DLFNBQVUybUMsWUFBWXhuQyxLQUFLLElBQUksQ0FBQyxFQUFFO29CQUN0RHduQyxjQUFjVCxlQUFlbkQ7b0JBQzdCd0QsNEJBQTRCeEQsY0FBYzRELGFBQWEzbUM7b0JBQ3ZEO2dCQUNGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSEEsU0FBUzJtQyxZQUFZN21DLFNBQVMsQ0FBQ3dkLGFBQWE7b0JBQzVDcXBCLGNBQWNULGVBQWVuRDtvQkFDN0JvRCx5Q0FDRXBELGNBQ0E0RCxhQUNBM21DO29CQUVGO2dCQUNGO29CQUNFLE1BQU01RSxNQUNKO1lBRU47UUFDRjtJQUNGO0lBQ0EsU0FBU3lyQyxrQ0FDUHhwQixNQUFNLEVBQ04wbEIsWUFBWSxFQUNaOUMsZUFBZTtRQUVmNWlCLFNBQVNBLE9BQU9DLGFBQWE7UUFDN0IsSUFBSTtZQUNGamYsa0JBQ0Uwa0MsY0FDQStELDBCQUNBenBCLFFBQ0E0aUI7UUFFSixFQUFFLE9BQU83b0MsT0FBTztZQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7UUFDN0Q7SUFDRjtJQUNBLFNBQVMydkMsNEJBQTRCNXdDLElBQUksRUFBRTZ3QyxVQUFVO1FBQ25EQyxpQkFBaUI5d0MsS0FBS21uQixhQUFhO1FBQ25DLElBQUs0cEIsYUFBYUYsWUFBWSxTQUFTRSxZQUNyQyxJQUNHLE9BQVFBLFlBQ1JGLGFBQWE3d0MsS0FBS3VKLEtBQUssRUFDeEIsTUFBT3ZKLENBQUFBLEtBQUt1akMsWUFBWSxHQUFHLElBQUcsS0FBTSxTQUFTc04sWUFFN0MsV0FBWXJ0QyxNQUFNLEdBQUd4RCxNQUFRK3dDLGFBQWFGO2FBRTFDLE1BQU8sU0FBU0UsWUFBYztZQUM1QkYsYUFBYTd3QyxPQUFPK3dDO1lBQ3BCLElBQUlsd0MsVUFBVWd3QyxXQUFXOW5DLFNBQVMsRUFDaENDLFFBQVE2bkMsV0FBVzduQyxLQUFLO1lBQzFCLE9BQVE2bkMsV0FBV2x4QyxHQUFHO2dCQUNwQixLQUFLO29CQUNIO2dCQUNGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDtnQkFDRixLQUFLO29CQUNILE1BQU9xSixDQUFBQSxRQUFRLElBQUcsS0FDaEIsU0FBU25JLFdBQ1R5dEMsb0JBQW9CdUMsWUFBWWh3QztvQkFDbEM7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPbUksQ0FBQUEsUUFBUSxJQUFHLEtBQ2hCaWdDLG9CQUNBK0gsZUFBZUgsV0FBV2xuQyxTQUFTLENBQUN3ZCxhQUFhO29CQUNuRDtnQkFDRixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDtnQkFDRjtvQkFDRSxJQUFJLE1BQU9uZSxDQUFBQSxRQUFRLElBQUcsR0FDcEIsTUFBTS9ELE1BQ0o7WUFFUjtZQUNBNHJDLGFBQWE3d0MsS0FBS3dKLE9BQU87WUFDekIsSUFBSSxTQUFTcW5DLFlBQVk7Z0JBQ3ZCQSxXQUFXcnRDLE1BQU0sR0FBR3hELEtBQUt3RCxNQUFNO2dCQUMvQnV0QyxhQUFhRjtnQkFDYjtZQUNGO1lBQ0FFLGFBQWEvd0MsS0FBS3dELE1BQU07UUFDMUI7UUFDSnhELE9BQU9peEM7UUFDUEEsb0NBQW9DLENBQUM7UUFDckMsT0FBT2p4QztJQUNUO0lBQ0EsU0FBU2t4QywwQkFBMEJDLFlBQVksRUFBRXR3QyxPQUFPLEVBQUUrckMsWUFBWTtRQUNwRSxJQUFJNWpDLFFBQVE0akMsYUFBYTVqQyxLQUFLO1FBQzlCLE9BQVE0akMsYUFBYWp0QyxHQUFHO1lBQ3RCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSHl4QyxpQ0FBaUNELGNBQWN2RTtnQkFDL0M1akMsUUFBUSxLQUNOMmpDLHdCQUF3QkMsY0FBY2hYLFNBQVN4RTtnQkFDakQ7WUFDRixLQUFLO2dCQUNIZ2dCLGlDQUFpQ0QsY0FBY3ZFO2dCQUMvQyxJQUFJNWpDLFFBQVEsR0FDVixJQUFLLGVBQWdCNGpDLGFBQWFqakMsU0FBUyxFQUFHLFNBQVM5SSxTQUNyRCtyQyxhQUFhNXFDLElBQUksQ0FBQ3M0QixZQUFZLElBQzVCLFNBQVNzUyxhQUFhNzBCLGFBQWEsSUFDbkN5cEIsZ0NBQ0MyUCxDQUFBQSxhQUFhM3NDLEtBQUssS0FBS29vQyxhQUFhNzBCLGFBQWEsSUFDaEQ5WSxRQUFRZ0MsS0FBSyxDQUNYLG9NQUNBcUMsMEJBQTBCc3BDLGlCQUFpQixhQUUvQ3VFLGFBQWFobkIsS0FBSyxLQUFLeWlCLGFBQWEzdUMsYUFBYSxJQUMvQ2dCLFFBQVFnQyxLQUFLLENBQ1gsb01BQ0FxQywwQkFBMEJzcEMsaUJBQWlCLFdBQzdDLEdBQ0ZGLGNBQWNFLGdCQUNUcnhCLENBQUFBLG9CQUNEclQsa0JBQ0Uwa0MsY0FDQXlFLDRCQUNBekUsY0FDQXVFLGVBRUY3MUIsc0JBQXFCLElBQ3JCcFQsa0JBQ0Uwa0MsY0FDQXlFLDRCQUNBekUsY0FDQXVFO3FCQUVMO29CQUNILElBQUl2VCxZQUFZeEQsMkJBQ2R3UyxhQUFhNXFDLElBQUksRUFDakJuQixRQUFRa1gsYUFBYTtvQkFFdkJsWCxVQUFVQSxRQUFRNUMsYUFBYTtvQkFDL0IydUMsYUFBYTVxQyxJQUFJLENBQUNzNEIsWUFBWSxJQUM1QixTQUFTc1MsYUFBYTcwQixhQUFhLElBQ25DeXBCLGdDQUNDMlAsQ0FBQUEsYUFBYTNzQyxLQUFLLEtBQUtvb0MsYUFBYTcwQixhQUFhLElBQ2hEOVksUUFBUWdDLEtBQUssQ0FDWCxxTUFDQXFDLDBCQUEwQnNwQyxpQkFBaUIsYUFFL0N1RSxhQUFhaG5CLEtBQUssS0FBS3lpQixhQUFhM3VDLGFBQWEsSUFDL0NnQixRQUFRZ0MsS0FBSyxDQUNYLHFNQUNBcUMsMEJBQTBCc3BDLGlCQUFpQixXQUM3QztvQkFDSkYsY0FBY0UsZ0JBQ1RyeEIsQ0FBQUEsb0JBQ0RyVCxrQkFDRTBrQyxjQUNBMEUsNkJBQ0ExRSxjQUNBdUUsY0FDQXZULFdBQ0EvOEIsU0FDQXN3QyxhQUFhekMsbUNBQW1DLEdBRWxEcHpCLHNCQUFxQixJQUNyQnBULGtCQUNFMGtDLGNBQ0EwRSw2QkFDQTFFLGNBQ0F1RSxjQUNBdlQsV0FDQS84QixTQUNBc3dDLGFBQWF6QyxtQ0FBbUM7Z0JBRXhEO2dCQUNGMWxDLFFBQVEsTUFBTW9sQyxxQkFBcUJ4QjtnQkFDbkM1akMsUUFBUSxPQUFPK2xDLGdCQUFnQm5DLGNBQWNBLGFBQWFwcEMsTUFBTTtnQkFDaEU7WUFDRixLQUFLO2dCQUNIM0MsVUFBVTJaO2dCQUNWNDJCLGlDQUFpQ0QsY0FBY3ZFO2dCQUMvQyxJQUNFNWpDLFFBQVEsTUFDUCxTQUFTNGpDLGFBQWFqdEIsV0FBVyxFQUFHLFNBQVMzVyxLQUFJLEdBQ2xEO29CQUNBNDBCLFlBQVk7b0JBQ1osSUFBSSxTQUFTZ1AsYUFBYXJqQyxLQUFLLEVBQzdCLE9BQVFxakMsYUFBYXJqQyxLQUFLLENBQUM1SixHQUFHO3dCQUM1QixLQUFLO3dCQUNMLEtBQUs7NEJBQ0hpK0IsWUFBWWtSLGtCQUFrQmxDLGFBQWFyakMsS0FBSyxDQUFDSSxTQUFTOzRCQUMxRDt3QkFDRixLQUFLOzRCQUNIaTBCLFlBQVlnUCxhQUFhcmpDLEtBQUssQ0FBQ0ksU0FBUztvQkFDNUM7b0JBQ0YsSUFBSTt3QkFDRnpCLGtCQUNFMGtDLGNBQ0FycUIsaUJBQ0F2WixPQUNBNDBCO29CQUVKLEVBQUUsT0FBTzM4QixPQUFPO3dCQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7b0JBQzdEO2dCQUNGO2dCQUNBa3dDLGFBQWFwTSxjQUFjLElBQUlwcUIseUJBQXlCOVo7Z0JBQ3hEO1lBQ0YsS0FBSztnQkFDSCxJQUFJNGtDLG1CQUFtQjtvQkFDckIyTCxpQ0FBaUNELGNBQWN2RTtvQkFDL0M1akMsUUFBUSxPQUFPK2xDLGdCQUFnQm5DLGNBQWNBLGFBQWFwcEMsTUFBTTtvQkFDaEU7Z0JBQ0Y7WUFDRixLQUFLO1lBQ0wsS0FBSztnQkFDSDR0QyxpQ0FBaUNELGNBQWN2RTtnQkFDL0MsU0FBUy9yQyxXQUFXbUksUUFBUSxLQUFLMG1DLGdCQUFnQjlDO2dCQUNqRDVqQyxRQUFRLE9BQU8rbEMsZ0JBQWdCbkMsY0FBY0EsYUFBYXBwQyxNQUFNO2dCQUNoRTtZQUNGLEtBQUs7Z0JBQ0gsSUFBSXdGLFFBQVEsR0FBRztvQkFDYkEsUUFBUXdSO29CQUNSNDJCLGlDQUFpQ0QsY0FBY3ZFO29CQUMvQ3VFLGVBQWV2RSxhQUFhampDLFNBQVM7b0JBQ3JDd25DLGFBQWFwTSxjQUFjLElBQUlscUIsNEJBQTRCN1I7b0JBQzNELElBQUk7d0JBQ0ZkLGtCQUNFMGtDLGNBQ0FzQyxnQkFDQXRDLGNBQ0EvckMsU0FDQXN1QyxpQkFDQWdDLGFBQWFwTSxjQUFjO29CQUUvQixFQUFFLE9BQU85akMsT0FBTzt3QkFDZDJzQyx3QkFBd0JoQixjQUFjQSxhQUFhcHBDLE1BQU0sRUFBRXZDO29CQUM3RDtnQkFDRixPQUFPbXdDLGlDQUFpQ0QsY0FBY3ZFO2dCQUN0RDtZQUNGLEtBQUs7Z0JBQ0h3RSxpQ0FBaUNELGNBQWN2RTtnQkFDL0M1akMsUUFBUSxLQUNOdW9DLGlDQUFpQ0osY0FBY3ZFO2dCQUNqRDtZQUNGLEtBQUs7Z0JBQ0hoUCxZQUNFLFNBQVNnUCxhQUFhM3VDLGFBQWEsSUFBSXV6QztnQkFDekMsSUFBSSxDQUFDNVQsV0FBVztvQkFDZC84QixVQUNFLFNBQVVBLFdBQVcsU0FBU0EsUUFBUTVDLGFBQWEsSUFDbkR3ekM7b0JBQ0YsSUFBSUMsK0JBQStCRiwwQkFDakNHLGdDQUFnQ0Y7b0JBQ2xDRCwyQkFBMkI1VDtvQkFDMUI2VCxDQUFBQSw0QkFBNEI1d0MsT0FBTSxLQUNuQyxDQUFDOHdDLGdDQUNHQyx5Q0FDRVQsY0FDQXZFLGNBQ0EsTUFBT0EsQ0FBQUEsYUFBYXJKLFlBQVksR0FBRyxJQUFHLEtBRXhDNk4saUNBQWlDRCxjQUFjdkU7b0JBQ25ENEUsMkJBQTJCRTtvQkFDM0JELDRCQUE0QkU7Z0JBQzlCO2dCQUNBM29DLFFBQVEsT0FDTCxjQUFhNGpDLGFBQWE3MEIsYUFBYSxDQUFDbFksSUFBSSxHQUN6Q2t2QyxnQkFBZ0JuQyxjQUFjQSxhQUFhcHBDLE1BQU0sSUFDakR3ckMsZ0JBQWdCcEMsY0FBY0EsYUFBYXBwQyxNQUFNO2dCQUN2RDtZQUNGO2dCQUNFNHRDLGlDQUFpQ0QsY0FBY3ZFO1FBQ25EO0lBQ0Y7SUFDQSxTQUFTaUYsd0JBQXdCOXpDLEtBQUs7UUFDcEMsSUFBSWdMLFlBQVloTCxNQUFNZ0wsU0FBUztRQUMvQixTQUFTQSxhQUNOLE9BQU9BLFNBQVMsR0FBRyxNQUFPOG9DLHdCQUF3QjlvQyxVQUFTO1FBQzlEaEwsTUFBTXdMLEtBQUssR0FBRztRQUNkeEwsTUFBTTRuQixTQUFTLEdBQUc7UUFDbEI1bkIsTUFBTXlMLE9BQU8sR0FBRztRQUNoQixNQUFNekwsTUFBTTRCLEdBQUcsSUFDWixhQUFhNUIsTUFBTTRMLFNBQVMsRUFDN0IsU0FBU1osYUFBYStvQyxzQkFBc0Ivb0MsVUFBUztRQUN2RGhMLE1BQU00TCxTQUFTLEdBQUc7UUFDbEI1TCxNQUFNMm9CLFdBQVcsR0FBRztRQUNwQjNvQixNQUFNeUYsTUFBTSxHQUFHO1FBQ2Z6RixNQUFNMnVCLFlBQVksR0FBRztRQUNyQjN1QixNQUFNZ2EsYUFBYSxHQUFHO1FBQ3RCaGEsTUFBTUUsYUFBYSxHQUFHO1FBQ3RCRixNQUFNNkIsWUFBWSxHQUFHO1FBQ3JCN0IsTUFBTTRMLFNBQVMsR0FBRztRQUNsQjVMLE1BQU00aEIsV0FBVyxHQUFHO0lBQ3RCO0lBQ0EsU0FBU295QixtQ0FDUFosWUFBWSxFQUNacEUsc0JBQXNCLEVBQ3RCbGpDLE1BQU07UUFFTixJQUFLQSxTQUFTQSxPQUFPTixLQUFLLEVBQUUsU0FBU00sUUFDbkNtb0MsNkJBQ0ViLGNBQ0FwRSx3QkFDQWxqQyxTQUVDQSxTQUFTQSxPQUFPTCxPQUFPO0lBQzlCO0lBQ0EsU0FBU3dvQyw2QkFDUGIsWUFBWSxFQUNacEUsc0JBQXNCLEVBQ3RCa0YsWUFBWTtRQUVaLElBQ0V2akMsZ0JBQ0EsZUFBZSxPQUFPQSxhQUFhd2pDLG9CQUFvQixFQUV2RCxJQUFJO1lBQ0Z4akMsYUFBYXdqQyxvQkFBb0IsQ0FBQzFqQyxZQUFZeWpDO1FBQ2hELEVBQUUsT0FBT3RqQyxLQUFLO1lBQ1pXLGtCQUNHLGtCQUFrQixDQUFDLEdBQ3BCclEsUUFBUWdDLEtBQUssQ0FDWCxrREFDQTBOLElBQ0Y7UUFDSjtRQUNGLE9BQVFzakMsYUFBYXR5QyxHQUFHO1lBQ3RCLEtBQUs7Z0JBQ0gsSUFBSThsQyxtQkFBbUI7b0JBQ3JCZ00sNkJBQ0V6QyxnQkFBZ0JpRCxjQUFjbEY7b0JBQ2hDZ0YsbUNBQ0VaLGNBQ0FwRSx3QkFDQWtGO29CQUVGQSxhQUFhaDBDLGFBQWEsR0FDdEJrMEMsZ0JBQWdCRixhQUFhaDBDLGFBQWEsSUFDMUNnMEMsYUFBYXRvQyxTQUFTLElBQ3RCeW9DLGlCQUFpQkgsYUFBYXRvQyxTQUFTO29CQUMzQztnQkFDRjtZQUNGLEtBQUs7Z0JBQ0gsSUFBSTBPLG9CQUFvQjtvQkFDdEJvNUIsNkJBQ0V6QyxnQkFBZ0JpRCxjQUFjbEY7b0JBQ2hDLElBQUlzRixpQkFBaUJDLFlBQ25CQyw0QkFBNEJDO29CQUM5QkYsYUFBYUwsYUFBYXRvQyxTQUFTO29CQUNuQ29vQyxtQ0FDRVosY0FDQXBFLHdCQUNBa0Y7b0JBRUZRLHlCQUF5QlIsYUFBYXRvQyxTQUFTO29CQUMvQzJvQyxhQUFhRDtvQkFDYkcsd0JBQXdCRDtvQkFDeEI7Z0JBQ0Y7WUFDRixLQUFLO2dCQUNIZCw2QkFDRXpDLGdCQUFnQmlELGNBQWNsRjtZQUNsQyxLQUFLO2dCQUNILElBQUk5RCxrQkFBa0I7b0JBQ3BCLElBQ0csaUJBQWtCcUosWUFDbEJDLDRCQUE0QkMsdUJBQzVCRixhQUFhLE1BQ2RQLG1DQUNFWixjQUNBcEUsd0JBQ0FrRixlQUVESyxhQUFhRCxnQkFDYkcsd0JBQXdCRCwyQkFDekIsU0FBU0QsWUFFVCxJQUFJRSx1QkFDRixJQUFJO3dCQUNGdHFDLGtCQUNFK3BDLGNBQ0FTLDBCQUNBSixZQUNBTCxhQUFhdG9DLFNBQVM7b0JBRTFCLEVBQUUsT0FBTzFJLE9BQU87d0JBQ2Qyc0Msd0JBQ0VxRSxjQUNBbEYsd0JBQ0E5ckM7b0JBRUo7eUJBRUEsSUFBSTt3QkFDRmlILGtCQUNFK3BDLGNBQ0FVLGFBQ0FMLFlBQ0FMLGFBQWF0b0MsU0FBUztvQkFFMUIsRUFBRSxPQUFPMUksT0FBTzt3QkFDZDJzQyx3QkFDRXFFLGNBQ0FsRix3QkFDQTlyQztvQkFFSjtnQkFDTixPQUNFOHdDLG1DQUNFWixjQUNBcEUsd0JBQ0FrRjtnQkFFSjtZQUNGLEtBQUs7Z0JBQ0hoSixvQkFDRSxTQUFTcUosY0FDUkUsQ0FBQUEsd0JBQ0dJLG1DQUNFTixZQUNBTCxhQUFhdG9DLFNBQVMsSUFFeEJrcEMsc0JBQXNCUCxZQUFZTCxhQUFhdG9DLFNBQVM7Z0JBQzlEO1lBQ0YsS0FBSztnQkFDSHMvQixtQkFDSyxrQkFBa0JxSixZQUNsQkMsNEJBQTRCQyx1QkFDNUJGLGFBQWFMLGFBQWF0b0MsU0FBUyxDQUFDd2QsYUFBYSxFQUNqRHFyQix3QkFBd0IsQ0FBQyxHQUMxQlQsbUNBQ0VaLGNBQ0FwRSx3QkFDQWtGLGVBRURLLGFBQWFELGdCQUNiRyx3QkFBd0JELHlCQUF5QixJQUNqRHBKLENBQUFBLHVCQUNDdUgsa0NBQ0V1QixhQUFhdG9DLFNBQVMsRUFDdEJzb0MsY0FDQXBJLDRCQUVKa0ksbUNBQ0VaLGNBQ0FwRSx3QkFDQWtGLGFBQ0Y7Z0JBQ0o7WUFDRixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIUiw2QkFDRXpFLDRCQUNFSyxXQUNBNEUsY0FDQWxGO2dCQUVKMEUsNkJBQ0UzRSwrQkFDRW1GLGNBQ0FsRix3QkFDQW5YO2dCQUVKbWMsbUNBQ0VaLGNBQ0FwRSx3QkFDQWtGO2dCQUVGO1lBQ0YsS0FBSztnQkFDSFIsNkJBQ0d6QyxDQUFBQSxnQkFBZ0JpRCxjQUFjbEYseUJBQzlCc0YsaUJBQWlCSixhQUFhdG9DLFNBQVMsRUFDeEMsZUFBZSxPQUFPMG9DLGVBQWVTLG9CQUFvQixJQUN2RG5FLCtCQUNFc0QsY0FDQWxGLHdCQUNBc0YsZUFDRjtnQkFDSk4sbUNBQ0VaLGNBQ0FwRSx3QkFDQWtGO2dCQUVGO1lBQ0YsS0FBSztnQkFDSEYsbUNBQ0VaLGNBQ0FwRSx3QkFDQWtGO2dCQUVGO1lBQ0YsS0FBSztnQkFDSFIsNkJBQ0V6QyxnQkFBZ0JpRCxjQUFjbEY7Z0JBQ2hDMEUsNEJBQ0UsQ0FBQ1ksaUJBQWlCWix5QkFBd0IsS0FDMUMsU0FBU1EsYUFBYWgwQyxhQUFhO2dCQUNyQzh6QyxtQ0FDRVosY0FDQXBFLHdCQUNBa0Y7Z0JBRUZSLDRCQUE0Qlk7Z0JBQzVCO1lBQ0Y7Z0JBQ0VOLG1DQUNFWixjQUNBcEUsd0JBQ0FrRjtRQUVOO0lBQ0Y7SUFDQSxTQUFTVixpQ0FBaUNKLFlBQVksRUFBRXZFLFlBQVk7UUFDbEUsSUFDRS8wQixxQkFDQSxTQUFTKzBCLGFBQWEzdUMsYUFBYSxJQUNsQyxnQkFBZ0IydUMsYUFBYTdqQyxTQUFTLEVBQ3ZDLFNBQVNvb0MsZ0JBQ04sZ0JBQWdCQSxhQUFhbHpDLGFBQWEsRUFDM0MsU0FBU2t6QyxnQkFDTixnQkFBZ0JBLGFBQWF0NEIsVUFBVSxFQUFHLFNBQVNzNEIsWUFBVyxDQUFDLENBQUMsR0FFckUsSUFBSTtZQUNGanBDLGtCQUNFMGtDLGNBQ0FtRyxnQ0FDQTVCO1FBRUosRUFBRSxPQUFPbHdDLE9BQU87WUFDZDJzQyx3QkFBd0JoQixjQUFjQSxhQUFhcHBDLE1BQU0sRUFBRXZDO1FBQzdEO0lBQ0o7SUFDQSxTQUFTK3hDLGNBQWNwRyxZQUFZO1FBQ2pDLE9BQVFBLGFBQWFqdEMsR0FBRztZQUN0QixLQUFLO1lBQ0wsS0FBSztnQkFDSCxJQUFJc3pDLGFBQWFyRyxhQUFhampDLFNBQVM7Z0JBQ3ZDLFNBQVNzcEMsY0FDTkEsQ0FBQUEsYUFBYXJHLGFBQWFqakMsU0FBUyxHQUFHLElBQUl1cEMsaUJBQWdCO2dCQUM3RCxPQUFPRDtZQUNULEtBQUs7Z0JBQ0gsT0FDRSxlQUFnQnJHLGFBQWFqakMsU0FBUyxFQUNyQ3NwQyxhQUFhckcsYUFBYXVHLFdBQVcsRUFDdEMsU0FBU0YsY0FDTkEsQ0FBQUEsYUFBYXJHLGFBQWF1RyxXQUFXLEdBQUcsSUFBSUQsaUJBQWdCLEdBQy9ERDtZQUVKO2dCQUNFLE1BQU1odUMsTUFDSixzQ0FDRTJuQyxhQUFhanRDLEdBQUcsR0FDaEI7UUFFUjtJQUNGO0lBQ0EsU0FBU3l6Qyw2QkFBNkJ4RyxZQUFZLEVBQUV5RyxTQUFTO1FBQzNELElBQUlKLGFBQWFELGNBQWNwRztRQUMvQnlHLFVBQVU3eEMsT0FBTyxDQUFDLFNBQVU4eEMsUUFBUTtZQUNsQyxJQUFJQyxRQUFRQyxxQkFBcUJoMkIsSUFBSSxDQUFDLE1BQU1vdkIsY0FBYzBHO1lBQzFELElBQUksQ0FBQ0wsV0FBV2xsQyxHQUFHLENBQUN1bEMsV0FBVztnQkFDN0JMLFdBQVd0bEMsR0FBRyxDQUFDMmxDO2dCQUNmLElBQUk3bEMsbUJBQ0YsSUFBSSxTQUFTZ21DLG1CQUFtQixTQUFTQyxnQkFDdkM3WCx1QkFBdUI2WCxnQkFBZ0JEO3FCQUV2QyxNQUFNeHVDLE1BQ0o7Z0JBRU5xdUMsU0FBU3AwQixJQUFJLENBQUNxMEIsT0FBT0E7WUFDdkI7UUFDRjtJQUNGO0lBQ0EsU0FBU0ksc0JBQXNCM3pDLElBQUksRUFBRTRzQyxZQUFZLEVBQUVnSCxjQUFjO1FBQy9ESCxrQkFBa0JHO1FBQ2xCRixpQkFBaUIxekM7UUFDakI2ekMsNkJBQTZCakgsY0FBYzVzQztRQUMzQzB6QyxpQkFBaUJELGtCQUFrQjtJQUNyQztJQUNBLFNBQVNLLG1DQUFtQ0MsYUFBYSxFQUFFdkQsV0FBVztRQUNwRSxJQUFJN3FCLFlBQVk2cUIsWUFBWTdxQixTQUFTO1FBQ3JDLElBQUksU0FBU0EsV0FDWCxJQUFLLElBQUl4bUIsSUFBSSxHQUFHQSxJQUFJd21CLFVBQVVubkIsTUFBTSxFQUFFVyxJQUFLO1lBQ3pDLElBQUlhLE9BQU8rekMsZUFDVHp2QixjQUFja3NCLGFBQ2R5QixlQUFldHNCLFNBQVMsQ0FBQ3htQixFQUFFO1lBQzdCLElBQUk4cEMsa0JBQWtCO2dCQUNwQixJQUFJcC9CLFNBQVN5YTtnQkFDYm5iLEdBQUcsTUFBTyxTQUFTVSxRQUFVO29CQUMzQixPQUFRQSxPQUFPbEssR0FBRzt3QkFDaEIsS0FBSzt3QkFDTCxLQUFLOzRCQUNIMnlDLGFBQWF6b0MsT0FBT0YsU0FBUzs0QkFDN0I2b0Msd0JBQXdCLENBQUM7NEJBQ3pCLE1BQU1ycEM7d0JBQ1IsS0FBSzs0QkFDSG1wQyxhQUFhem9DLE9BQU9GLFNBQVMsQ0FBQ3dkLGFBQWE7NEJBQzNDcXJCLHdCQUF3QixDQUFDOzRCQUN6QixNQUFNcnBDO3dCQUNSLEtBQUs7NEJBQ0htcEMsYUFBYXpvQyxPQUFPRixTQUFTLENBQUN3ZCxhQUFhOzRCQUMzQ3FyQix3QkFBd0IsQ0FBQzs0QkFDekIsTUFBTXJwQztvQkFDVjtvQkFDQVUsU0FBU0EsT0FBT3JHLE1BQU07Z0JBQ3hCO2dCQUNBLElBQUksU0FBUzh1QyxZQUNYLE1BQU1ydEMsTUFDSjtnQkFFSitzQyw2QkFBNkJoeUMsTUFBTXNrQixhQUFhMnRCO2dCQUNoREssYUFBYTtnQkFDYkUsd0JBQXdCLENBQUM7WUFDM0IsT0FBT1IsNkJBQTZCaHlDLE1BQU1za0IsYUFBYTJ0QjtZQUN2RGp5QyxPQUFPaXlDO1lBQ1AzdEIsY0FBY3RrQixLQUFLK0ksU0FBUztZQUM1QixTQUFTdWIsZUFBZ0JBLENBQUFBLFlBQVk5Z0IsTUFBTSxHQUFHLElBQUc7WUFDakR4RCxLQUFLd0QsTUFBTSxHQUFHO1FBQ2hCO1FBQ0YsSUFBSWd0QyxZQUFZak4sWUFBWSxHQUFHLE9BQzdCLElBQUtpTixjQUFjQSxZQUFZam5DLEtBQUssRUFBRSxTQUFTaW5DLGFBQzdDcUQsNkJBQTZCckQsYUFBYXVELGdCQUN2Q3ZELGNBQWNBLFlBQVlobkMsT0FBTztJQUMxQztJQUNBLFNBQVNxcUMsNkJBQTZCakgsWUFBWSxFQUFFNXNDLElBQUk7UUFDdEQsSUFBSWEsVUFBVStyQyxhQUFhN2pDLFNBQVMsRUFDbENDLFFBQVE0akMsYUFBYTVqQyxLQUFLO1FBQzVCLE9BQVE0akMsYUFBYWp0QyxHQUFHO1lBQ3RCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0htMEMsbUNBQW1DOXpDLE1BQU00c0M7Z0JBQ3pDb0gsNEJBQTRCcEg7Z0JBQzVCNWpDLFFBQVEsS0FDTGdrQyxDQUFBQSw0QkFDQ0ssWUFBWWpjLFdBQ1p3YixjQUNBQSxhQUFhcHBDLE1BQU0sR0FFckJxcEMsMEJBQTBCUSxZQUFZamMsV0FBV3diLGVBQ2pERSwrQkFDRUYsY0FDQUEsYUFBYXBwQyxNQUFNLEVBQ25Cb3lCLFNBQVN4RSxVQUNYO2dCQUNGO1lBQ0YsS0FBSztnQkFDSDBpQixtQ0FBbUM5ekMsTUFBTTRzQztnQkFDekNvSCw0QkFBNEJwSDtnQkFDNUI1akMsUUFBUSxPQUNMeW9DLENBQUFBLDZCQUNDLFNBQVM1d0MsV0FDVG11QyxnQkFBZ0JudUMsU0FBU0EsUUFBUTJDLE1BQU07Z0JBQzNDd0YsUUFBUSxNQUNOd29DLDRCQUNDLGdCQUFnQjVFLGFBQWFqdEIsV0FBVyxFQUN6QyxTQUFTaXRCLGdCQUNOLFNBQVNBLGFBQWEzc0IsU0FBUyxFQUNoQyxTQUFTalgsU0FDTixXQUFXNGpDLGFBQWE3c0IsTUFBTSxDQUFDQyxlQUFlLEVBQzlDNHNCLGFBQWE3c0IsTUFBTSxDQUFDQyxlQUFlLEdBQ2xDLFNBQVNuZixVQUFVbUksUUFBUW5JLFFBQVF1akIsTUFBTSxDQUFDcGIsTUFBTSxDQUFDLENBQUM7Z0JBQzFEO1lBQ0YsS0FBSztnQkFDSCxJQUFJeThCLG1CQUFtQjtvQkFDckIsSUFBSXdPLGdCQUFnQkM7b0JBQ3BCSixtQ0FBbUM5ekMsTUFBTTRzQztvQkFDekNvSCw0QkFBNEJwSDtvQkFDNUI1akMsUUFBUSxPQUNMeW9DLENBQUFBLDZCQUNDLFNBQVM1d0MsV0FDVG11QyxnQkFBZ0JudUMsU0FBU0EsUUFBUTJDLE1BQU07b0JBQzNDd0YsUUFBUSxLQUNMLFNBQVMsU0FBU25JLFVBQVVBLFFBQVE1QyxhQUFhLEdBQUcsTUFDcEQrQixPQUFPNHNDLGFBQWEzdUMsYUFBYSxFQUNsQyxTQUFTNEMsVUFDTCxTQUFTYixPQUNQLFNBQVM0c0MsYUFBYWpqQyxTQUFTLEdBQzVCaWpDLGFBQWFqakMsU0FBUyxHQUFHd3FDLGlCQUN4QkYsZUFDQXJILGFBQWE1cUMsSUFBSSxFQUNqQjRxQyxhQUFhNzBCLGFBQWEsRUFDMUI2MEIsZ0JBRUZ3SCxlQUNFSCxlQUNBckgsYUFBYTVxQyxJQUFJLEVBQ2pCNHFDLGFBQWFqakMsU0FBUyxJQUV6QmlqQyxhQUFhampDLFNBQVMsR0FBRzBxQyxnQkFDeEJKLGVBQ0FqMEMsTUFDQTRzQyxhQUFhNzBCLGFBQWEsSUFFOUIvTyxVQUFVaEosT0FDUCxVQUFTZ0osUUFDTixTQUFTbkksUUFBUThJLFNBQVMsSUFDMUJ5b0MsaUJBQWlCdnhDLFFBQVE4SSxTQUFTLElBQ2xDd29DLGdCQUFnQm5wQyxRQUNwQixTQUFTaEosT0FDTG8wQyxlQUNFSCxlQUNBckgsYUFBYTVxQyxJQUFJLEVBQ2pCNHFDLGFBQWFqakMsU0FBUyxJQUV4QjBxQyxnQkFDRUosZUFDQWowQyxNQUNBNHNDLGFBQWE3MEIsYUFBYSxDQUM1QixJQUNKLFNBQVMvWCxRQUNULFNBQVM0c0MsYUFBYWpqQyxTQUFTLElBQy9CaW1DLGlCQUNFaEQsY0FDQUEsYUFBYTcwQixhQUFhLEVBQzFCbFgsUUFBUWtYLGFBQWEsQ0FDdkI7b0JBQ1I7Z0JBQ0Y7WUFDRixLQUFLO2dCQUNILElBQ0VNLHNCQUNBclAsUUFBUSxLQUNSLFNBQVM0akMsYUFBYTdqQyxTQUFTLEVBQy9CO29CQUNBa3JDLGdCQUFnQnJILGFBQWFqakMsU0FBUztvQkFDdEMsSUFBSW5GLFFBQVFvb0MsYUFBYTcwQixhQUFhO29CQUN0QyxJQUFJO3dCQUNGdThCLGVBQWVMLGdCQUNiL3JDLGtCQUNFMGtDLGNBQ0EySCwwQkFDQTNILGFBQWE1cUMsSUFBSSxFQUNqQndDLE9BQ0F5dkMsZUFDQXJIO29CQUVOLEVBQUUsT0FBTzNyQyxPQUFPO3dCQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7b0JBQzdEO2dCQUNGO1lBQ0YsS0FBSztnQkFDSDZ5QyxtQ0FBbUM5ekMsTUFBTTRzQztnQkFDekNvSCw0QkFBNEJwSDtnQkFDNUI1akMsUUFBUSxPQUNMeW9DLENBQUFBLDZCQUNDLFNBQVM1d0MsV0FDVG11QyxnQkFBZ0JudUMsU0FBU0EsUUFBUTJDLE1BQU07Z0JBQzNDLElBQUl5bEMsa0JBQWtCO29CQUNwQixJQUFJMkQsYUFBYTVqQyxLQUFLLEdBQUcsSUFBSTt3QkFDM0JoSixPQUFPNHNDLGFBQWFqakMsU0FBUzt3QkFDN0IsSUFBSTs0QkFDRnpCLGtCQUFrQjBrQyxjQUFjNkQsa0JBQWtCendDO3dCQUNwRCxFQUFFLE9BQU9pQixPQUFPOzRCQUNkMnNDLHdCQUNFaEIsY0FDQUEsYUFBYXBwQyxNQUFNLEVBQ25CdkM7d0JBRUo7b0JBQ0Y7b0JBQ0ErSCxRQUFRLEtBQ04sUUFBUTRqQyxhQUFhampDLFNBQVMsSUFDN0IsUUFBUWlqQyxhQUFhNzBCLGFBQWEsRUFDbkM2M0IsaUJBQ0VoRCxjQUNBNXNDLE1BQ0EsU0FBU2EsVUFBVUEsUUFBUWtYLGFBQWEsR0FBRy9YLEtBQzdDO29CQUNGZ0osUUFBUSxRQUNMLGtCQUFrQixDQUFDLEdBQ3BCLFdBQVc0akMsYUFBYTVxQyxJQUFJLElBQzFCL0MsUUFBUWdDLEtBQUssQ0FDWCwyRUFDRjtnQkFDTjtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0g2eUMsbUNBQW1DOXpDLE1BQU00c0M7Z0JBQ3pDb0gsNEJBQTRCcEg7Z0JBQzVCLElBQUk1akMsUUFBUSxLQUFLaWdDLGtCQUFrQjtvQkFDakMsSUFBSSxTQUFTMkQsYUFBYWpqQyxTQUFTLEVBQ2pDLE1BQU0xRSxNQUNKO29CQUVKK0QsUUFBUTRqQyxhQUFhNzBCLGFBQWE7b0JBQ2xDbFgsVUFBVSxTQUFTQSxVQUFVQSxRQUFRa1gsYUFBYSxHQUFHL087b0JBQ3JEaEosT0FBTzRzQyxhQUFhampDLFNBQVM7b0JBQzdCLElBQUk7d0JBQ0Z6QixrQkFDRTBrQyxjQUNBNkgsa0JBQ0F6MEMsTUFDQWEsU0FDQW1JO29CQUVKLEVBQUUsT0FBTy9ILE9BQU87d0JBQ2Qyc0Msd0JBQXdCaEIsY0FBY0EsYUFBYXBwQyxNQUFNLEVBQUV2QztvQkFDN0Q7Z0JBQ0Y7Z0JBQ0E7WUFDRixLQUFLO2dCQUNIZ3pDLGdCQUFnQno1QjtnQkFDaEJpckIsb0JBQ0tpUCxDQUFBQSw2QkFDQWx3QyxRQUFRMHZDLHNCQUNSQSx1QkFBdUJTLGlCQUFpQjMwQyxLQUFLbW5CLGFBQWEsR0FDM0Qyc0IsbUNBQW1DOXpDLE1BQU00c0MsZUFDeENzSCx1QkFBdUIxdkMsS0FBSyxJQUM3QnN2QyxtQ0FBbUM5ekMsTUFBTTRzQztnQkFDN0NvSCw0QkFBNEJwSDtnQkFDNUIsSUFBSTVqQyxRQUFRLEdBQUc7b0JBQ2IsSUFDRWlnQyxvQkFDQXB4QixxQkFDQSxTQUFTaFgsV0FDVEEsUUFBUTVDLGFBQWEsQ0FBQ3NuQyxZQUFZLEVBRWxDLElBQUk7d0JBQ0ZyOUIsa0JBQ0Uwa0MsY0FDQWdJLHlCQUNBNTBDLEtBQUttbkIsYUFBYTtvQkFFdEIsRUFBRSxPQUFPbG1CLE9BQU87d0JBQ2Qyc0Msd0JBQ0VoQixjQUNBQSxhQUFhcHBDLE1BQU0sRUFDbkJ2QztvQkFFSjtvQkFDRixJQUFJa29DLHFCQUFxQjt3QkFDdkJuZ0MsUUFBUWhKLEtBQUttbkIsYUFBYTt3QkFDMUJ0bUIsVUFBVWIsS0FBSzhwQyxlQUFlO3dCQUM5QixJQUFJOzRCQUNGNWhDLGtCQUNFMGtDLGNBQ0ErRCwwQkFDQTNuQyxPQUNBbkk7d0JBRUosRUFBRSxPQUFPSSxPQUFPOzRCQUNkMnNDLHdCQUNFaEIsY0FDQUEsYUFBYXBwQyxNQUFNLEVBQ25CdkM7d0JBRUo7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0F1ekMsa0JBQ0csa0JBQWtCLENBQUMsR0FBSUssc0JBQXNCakksYUFBWTtnQkFDNUQ1c0MsS0FBSytrQyxjQUFjLElBQUlwcUIseUJBQXlCczVCO2dCQUNoRDtZQUNGLEtBQUs7Z0JBQ0h4TyxvQkFDSyxXQUFXeU8sc0JBQ1hBLHVCQUF1QlMsaUJBQ3RCL0gsYUFBYWpqQyxTQUFTLENBQUN3ZCxhQUFhLEdBRXRDMnNCLG1DQUFtQzl6QyxNQUFNNHNDLGVBQ3pDb0gsNEJBQTRCcEgsZUFDM0JzSCx1QkFBdUJyekMsT0FBTyxJQUM5Qml6QyxDQUFBQSxtQ0FBbUM5ekMsTUFBTTRzQyxlQUMxQ29ILDRCQUE0QnBILGFBQVk7Z0JBQzVDNWpDLFFBQVEsS0FDTm1nQyx1QkFDQXVILGtDQUNFOUQsYUFBYWpqQyxTQUFTLEVBQ3RCaWpDLGNBQ0FBLGFBQWFqakMsU0FBUyxDQUFDbWdDLGVBQWU7Z0JBRTFDO1lBQ0YsS0FBSztnQkFDSDlnQyxRQUFRd1I7Z0JBQ1JzNUIsbUNBQW1DOXpDLE1BQU00c0M7Z0JBQ3pDb0gsNEJBQTRCcEg7Z0JBQzVCQSxhQUFhampDLFNBQVMsQ0FBQ283QixjQUFjLElBQ25DbHFCLDRCQUE0QjdSO2dCQUM5QjtZQUNGLEtBQUs7Z0JBQ0g4cUMsbUNBQW1DOXpDLE1BQU00c0M7Z0JBQ3pDb0gsNEJBQTRCcEg7Z0JBQzVCQSxhQUFhcmpDLEtBQUssQ0FBQ1AsS0FBSyxHQUFHLFFBQ3pCLFNBQVU0akMsYUFBYTN1QyxhQUFhLEtBQ2pDLFVBQVM0QyxXQUFXLFNBQVNBLFFBQVE1QyxhQUFhLEtBQ3BENjJDLENBQUFBLCtCQUErQmw0QixPQUFNO2dCQUN4QzVULFFBQVEsS0FDTCxTQUFTNGpDLGFBQWFqdEIsV0FBVyxFQUNsQyxTQUFTM1csU0FDTixjQUFjMlcsV0FBVyxHQUFHLE1BQzdCeXpCLDZCQUE2QnhHLGNBQWM1akMsTUFBSyxDQUFDO2dCQUNyRDtZQUNGLEtBQUs7Z0JBQ0hBLFFBQVEsT0FDTHlvQyxDQUFBQSw2QkFDQyxTQUFTNXdDLFdBQ1RtdUMsZ0JBQWdCbnVDLFNBQVNBLFFBQVEyQyxNQUFNO2dCQUMzQ3l3QyxnQkFBZ0IsU0FBU3JILGFBQWEzdUMsYUFBYTtnQkFDbkQsSUFBSTgyQyxZQUFZLFNBQVNsMEMsV0FBVyxTQUFTQSxRQUFRNUMsYUFBYSxFQUNoRXl6QywrQkFBK0JGLDBCQUMvQkcsZ0NBQWdDRjtnQkFDbENELDJCQUNFRSxnQ0FBZ0N1QztnQkFDbEN4Qyw0QkFDRUUsaUNBQWlDb0Q7Z0JBQ25DakIsbUNBQW1DOXpDLE1BQU00c0M7Z0JBQ3pDNkUsNEJBQTRCRTtnQkFDNUJILDJCQUEyQkU7Z0JBQzNCc0MsNEJBQTRCcEg7Z0JBQzVCNXNDLE9BQU80c0MsYUFBYWpqQyxTQUFTO2dCQUM3QjNKLEtBQUtnMUMsUUFBUSxHQUFHcEk7Z0JBQ2hCNXNDLEtBQUtnYSxXQUFXLElBQUksQ0FBQztnQkFDckJoYSxLQUFLZ2EsV0FBVyxJQUFJaGEsS0FBS2crQixrQkFBa0IsR0FBRztnQkFDOUMsSUFDRWgxQixRQUFRLFFBQ1AsTUFBTWdSLFdBQVcsR0FBR2k2QixnQkFDakJqMEMsS0FBS2dhLFdBQVcsR0FBRyxDQUFDLElBQ3BCaGEsS0FBS2dhLFdBQVcsR0FBRyxHQUN2Qmk2QixpQkFDRyxRQUFRekMsNEJBQTRCQywyQkFDckMsU0FBUzV3QyxXQUNQazBDLGFBQ0EvMEMsUUFDQWkxQywwQ0FBMENySSxhQUFZLEdBQzFEM0Qsb0JBQ0csVUFBUzJELGFBQWE3MEIsYUFBYSxJQUNsQyxhQUFhNjBCLGFBQWE3MEIsYUFBYSxDQUFDbFksSUFBSSxJQUVoRHNKO29CQUFBQSxHQUFHLElBQUssVUFBVyxNQUFPOC9CLGtCQUN4QixJQUFLanBDLE9BQU80c0MsZUFBa0I7d0JBQzVCLElBQ0UsTUFBTTVzQyxLQUFLTCxHQUFHLElBQ2I4bEMscUJBQXFCLE9BQU96bEMsS0FBS0wsR0FBRyxJQUNwQzBZLHNCQUFzQixPQUFPclksS0FBS0wsR0FBRyxFQUN0Qzs0QkFDQSxJQUFJLFNBQVNrQixTQUFTO2dDQUNwQmswQyxZQUFZbDBDLFVBQVViO2dDQUN0QixJQUFJO29DQUNEd0UsUUFBUXV3QyxVQUFVcHJDLFNBQVMsRUFDMUJzcUMsZ0JBQ0kvckMsa0JBQWtCNnNDLFdBQVdHLGNBQWMxd0MsU0FDM0MwRCxrQkFDRTZzQyxXQUNBSSxnQkFDQUosVUFBVXByQyxTQUFTLEVBQ25Cb3JDLFVBQVVoOUIsYUFBYTtnQ0FFakMsRUFBRSxPQUFPOVcsT0FBTztvQ0FDZDJzQyx3QkFDRW1ILFdBQ0FBLFVBQVV2eEMsTUFBTSxFQUNoQnZDO2dDQUVKOzRCQUNGO3dCQUNGLE9BQU8sSUFBSSxNQUFNakIsS0FBS0wsR0FBRyxFQUFFOzRCQUN6QixJQUFJLFNBQVNrQixTQUFTO2dDQUNwQmswQyxZQUFZLzBDO2dDQUNaLElBQUk7b0NBQ0YsSUFBSThoQixXQUFXaXpCLFVBQVVwckMsU0FBUztvQ0FDbENzcUMsZ0JBQ0kvckMsa0JBQ0U2c0MsV0FDQUssa0JBQ0F0ekIsWUFFRjVaLGtCQUNFNnNDLFdBQ0FNLG9CQUNBdnpCLFVBQ0FpekIsVUFBVWg5QixhQUFhO2dDQUUvQixFQUFFLE9BQU85VyxPQUFPO29DQUNkMnNDLHdCQUNFbUgsV0FDQUEsVUFBVXZ4QyxNQUFNLEVBQ2hCdkM7Z0NBRUo7NEJBQ0Y7d0JBQ0YsT0FBTyxJQUNMLENBQUMsT0FBUWpCLEtBQUtMLEdBQUcsSUFBSSxPQUFPSyxLQUFLTCxHQUFHLElBQ2xDLFNBQVNLLEtBQUsvQixhQUFhLElBQzNCK0IsU0FBUzRzQyxZQUFXLEtBQ3RCLFNBQVM1c0MsS0FBS3VKLEtBQUssRUFDbkI7NEJBQ0F2SixLQUFLdUosS0FBSyxDQUFDL0YsTUFBTSxHQUFHeEQ7NEJBQ3BCQSxPQUFPQSxLQUFLdUosS0FBSzs0QkFDakI7d0JBQ0Y7d0JBQ0EsSUFBSXZKLFNBQVM0c0MsY0FBYyxNQUFNempDO3dCQUNqQyxNQUFPLFNBQVNuSixLQUFLd0osT0FBTyxFQUFJOzRCQUM5QixJQUFJLFNBQVN4SixLQUFLd0QsTUFBTSxJQUFJeEQsS0FBS3dELE1BQU0sS0FBS29wQyxjQUMxQyxNQUFNempDOzRCQUNSdEksWUFBWWIsUUFBU2EsQ0FBQUEsVUFBVSxJQUFHOzRCQUNsQ2IsT0FBT0EsS0FBS3dELE1BQU07d0JBQ3BCO3dCQUNBM0MsWUFBWWIsUUFBU2EsQ0FBQUEsVUFBVSxJQUFHO3dCQUNsQ2IsS0FBS3dKLE9BQU8sQ0FBQ2hHLE1BQU0sR0FBR3hELEtBQUt3RCxNQUFNO3dCQUNqQ3hELE9BQU9BLEtBQUt3SixPQUFPO29CQUNyQjtnQkFBQTtnQkFDSlIsUUFBUSxLQUNMLFNBQVM0akMsYUFBYWp0QixXQUFXLEVBQ2xDLFNBQVMzVyxTQUNOLFdBQVdBLE1BQU11ekIsVUFBVSxFQUM1QixTQUFTMTdCLFdBQ04sT0FBTzA3QixVQUFVLEdBQUcsTUFDckI2Vyw2QkFBNkJ4RyxjQUFjL3JDLFFBQU8sQ0FBQyxDQUFDO2dCQUMxRDtZQUNGLEtBQUs7Z0JBQ0hpekMsbUNBQW1DOXpDLE1BQU00c0M7Z0JBQ3pDb0gsNEJBQTRCcEg7Z0JBQzVCNWpDLFFBQVEsS0FDTCxTQUFTNGpDLGFBQWFqdEIsV0FBVyxFQUNsQyxTQUFTM1csU0FDTixjQUFjMlcsV0FBVyxHQUFHLE1BQzdCeXpCLDZCQUE2QnhHLGNBQWM1akMsTUFBSyxDQUFDO2dCQUNyRDtZQUNGLEtBQUs7Z0JBQ0g7WUFDRjtnQkFDRThxQyxtQ0FBbUM5ekMsTUFBTTRzQyxlQUN2Q29ILDRCQUE0QnBIO1FBQ2xDO0lBQ0Y7SUFDQSxTQUFTb0gsNEJBQTRCcEgsWUFBWTtRQUMvQyxJQUFJNWpDLFFBQVE0akMsYUFBYTVqQyxLQUFLO1FBQzlCLElBQUlBLFFBQVEsR0FBRztZQUNiLElBQUk7Z0JBQ0ZkLGtCQUFrQjBrQyxjQUFjMkQsaUJBQWlCM0Q7WUFDbkQsRUFBRSxPQUFPM3JDLE9BQU87Z0JBQ2Qyc0Msd0JBQXdCaEIsY0FBY0EsYUFBYXBwQyxNQUFNLEVBQUV2QztZQUM3RDtZQUNBMnJDLGFBQWE1akMsS0FBSyxJQUFJLENBQUM7UUFDekI7UUFDQUEsUUFBUSxRQUFTNGpDLENBQUFBLGFBQWE1akMsS0FBSyxJQUFJLENBQUMsSUFBRztJQUM3QztJQUNBLFNBQVM2ckMsc0JBQXNCckUsV0FBVztRQUN4QyxJQUFJQSxZQUFZak4sWUFBWSxHQUFHLE1BQzdCLElBQUtpTixjQUFjQSxZQUFZam5DLEtBQUssRUFBRSxTQUFTaW5DLGFBQWU7WUFDNUQsSUFBSXp5QyxRQUFReXlDO1lBQ1pxRSxzQkFBc0I5MkM7WUFDdEIsTUFBTUEsTUFBTTRCLEdBQUcsSUFDYjVCLE1BQU1pTCxLQUFLLEdBQUcsUUFDZHNzQyxrQkFBa0J2M0MsTUFBTTRMLFNBQVM7WUFDbkM2bUMsY0FBY0EsWUFBWWhuQyxPQUFPO1FBQ25DO0lBQ0o7SUFDQSxTQUFTK3JDLG9CQUFvQjNJLFlBQVksRUFBRTVzQyxJQUFJLEVBQUU0ekMsY0FBYztRQUM3REgsa0JBQWtCRztRQUNsQkYsaUJBQWlCMXpDO1FBQ2pCa3hDLDBCQUEwQmx4QyxNQUFNNHNDLGFBQWE3akMsU0FBUyxFQUFFNmpDO1FBQ3hEOEcsaUJBQWlCRCxrQkFBa0I7SUFDckM7SUFDQSxTQUFTckMsaUNBQWlDcHhDLElBQUksRUFBRXd3QyxXQUFXO1FBQ3pELElBQUlBLFlBQVlqTixZQUFZLEdBQUcsTUFDN0IsSUFBS2lOLGNBQWNBLFlBQVlqbkMsS0FBSyxFQUFFLFNBQVNpbkMsYUFDN0NVLDBCQUEwQmx4QyxNQUFNd3dDLFlBQVl6bkMsU0FBUyxFQUFFeW5DLGNBQ3BEQSxjQUFjQSxZQUFZaG5DLE9BQU87SUFDMUM7SUFDQSxTQUFTZ3NDLHVCQUF1QjVJLFlBQVk7UUFDMUMsT0FBUUEsYUFBYWp0QyxHQUFHO1lBQ3RCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0htdEMsK0JBQ0VGLGNBQ0FBLGFBQWFwcEMsTUFBTSxFQUNuQm95QjtnQkFFRnFmLDBDQUEwQ3JJO2dCQUMxQztZQUNGLEtBQUs7Z0JBQ0hvQyxnQkFBZ0JwQyxjQUFjQSxhQUFhcHBDLE1BQU07Z0JBQ2pELElBQUlzZSxXQUFXOHFCLGFBQWFqakMsU0FBUztnQkFDckMsZUFBZSxPQUFPbVksU0FBU2d4QixvQkFBb0IsSUFDakRuRSwrQkFDRS9CLGNBQ0FBLGFBQWFwcEMsTUFBTSxFQUNuQnNlO2dCQUVKbXpCLDBDQUEwQ3JJO2dCQUMxQztZQUNGLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSG9DLGdCQUFnQnBDLGNBQWNBLGFBQWFwcEMsTUFBTTtnQkFDakR5eEMsMENBQTBDckk7Z0JBQzFDO1lBQ0YsS0FBSztnQkFDSG9DLGdCQUFnQnBDLGNBQWNBLGFBQWFwcEMsTUFBTTtnQkFDakQsU0FBU29wQyxhQUFhM3VDLGFBQWEsSUFDakNnM0MsMENBQTBDckk7Z0JBQzVDO1lBQ0Y7Z0JBQ0VxSSwwQ0FBMENySTtRQUM5QztJQUNGO0lBQ0EsU0FBU3FJLDBDQUEwQ3pFLFdBQVc7UUFDNUQsSUFBS0EsY0FBY0EsWUFBWWpuQyxLQUFLLEVBQUUsU0FBU2luQyxhQUM3Q2dGLHVCQUF1QmhGLGNBQ3BCQSxjQUFjQSxZQUFZaG5DLE9BQU87SUFDeEM7SUFDQSxTQUFTaXNDLHNCQUNQdEUsWUFBWSxFQUNadHdDLE9BQU8sRUFDUCtyQyxZQUFZLEVBQ1o4SSw0QkFBNEI7UUFFNUIsSUFBSTFzQyxRQUFRNGpDLGFBQWE1akMsS0FBSztRQUM5QixPQUFRNGpDLGFBQWFqdEMsR0FBRztZQUN0QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0hpeUMseUNBQ0VULGNBQ0F2RSxjQUNBOEk7Z0JBRUYvSSx3QkFBd0JDLGNBQWNoWDtnQkFDdEM7WUFDRixLQUFLO2dCQUNIZ2MseUNBQ0VULGNBQ0F2RSxjQUNBOEk7Z0JBRUY3MEMsVUFBVStyQyxhQUFhampDLFNBQVM7Z0JBQ2hDLGVBQWUsT0FBTzlJLFFBQVF1Z0MsaUJBQWlCLElBQzdDbDVCLGtCQUNFMGtDLGNBQ0F5RSw0QkFDQXpFLGNBQ0EvckM7Z0JBRUpBLFVBQVUrckMsYUFBYWp0QixXQUFXO2dCQUNsQyxJQUFJLFNBQVM5ZSxTQUFTO29CQUNwQnN3QyxlQUFldkUsYUFBYWpqQyxTQUFTO29CQUNyQyxJQUFJO3dCQUNGekIsa0JBQ0Uwa0MsY0FDQXRxQix1QkFDQXpoQixTQUNBc3dDO29CQUVKLEVBQUUsT0FBT2x3QyxPQUFPO3dCQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7b0JBQzdEO2dCQUNGO2dCQUNBeTBDLGdDQUNFMXNDLFFBQVEsTUFDUm9sQyxxQkFBcUJ4QjtnQkFDdkJtQyxnQkFBZ0JuQyxjQUFjQSxhQUFhcHBDLE1BQU07Z0JBQ2pEO1lBQ0YsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIb3VDLHlDQUNFVCxjQUNBdkUsY0FDQThJO2dCQUVGQSxnQ0FDRSxTQUFTNzBDLFdBQ1RtSSxRQUFRLEtBQ1IwbUMsZ0JBQWdCOUM7Z0JBQ2xCbUMsZ0JBQWdCbkMsY0FBY0EsYUFBYXBwQyxNQUFNO2dCQUNqRDtZQUNGLEtBQUs7Z0JBQ0gsSUFBSWt5QyxnQ0FBZ0Mxc0MsUUFBUSxHQUFHO29CQUM3Q0EsUUFBUXdSO29CQUNSbzNCLHlDQUNFVCxjQUNBdkUsY0FDQThJO29CQUVGQSwrQkFBK0I5SSxhQUFhampDLFNBQVM7b0JBQ3JEK3JDLDZCQUE2QjNRLGNBQWMsSUFDekNscUIsNEJBQTRCN1I7b0JBQzlCLElBQUk7d0JBQ0ZkLGtCQUNFMGtDLGNBQ0FzQyxnQkFDQXRDLGNBQ0EvckMsU0FDQXN1QyxpQkFDQXVHLDZCQUE2QjNRLGNBQWM7b0JBRS9DLEVBQUUsT0FBTzlqQyxPQUFPO3dCQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7b0JBQzdEO2dCQUNGLE9BQ0Uyd0MseUNBQ0VULGNBQ0F2RSxjQUNBOEk7Z0JBRUo7WUFDRixLQUFLO2dCQUNIOUQseUNBQ0VULGNBQ0F2RSxjQUNBOEk7Z0JBRUZBLGdDQUNFMXNDLFFBQVEsS0FDUnVvQyxpQ0FBaUNKLGNBQWN2RTtnQkFDakQ7WUFDRixLQUFLO2dCQUNILFNBQVNBLGFBQWEzdUMsYUFBYSxJQUNqQzJ6Qyx5Q0FDRVQsY0FDQXZFLGNBQ0E4STtnQkFFSjNHLGdCQUFnQm5DLGNBQWNBLGFBQWFwcEMsTUFBTTtnQkFDakQ7WUFDRjtnQkFDRW91Qyx5Q0FDRVQsY0FDQXZFLGNBQ0E4STtRQUVOO0lBQ0Y7SUFDQSxTQUFTOUQseUNBQ1BULFlBQVksRUFDWlgsV0FBVyxFQUNYa0YsNEJBQTRCO1FBRTVCQSwrQkFDRUEsZ0NBQWdDLE1BQU9sRixDQUFBQSxZQUFZak4sWUFBWSxHQUFHLElBQUc7UUFDdkUsSUFBS2lOLGNBQWNBLFlBQVlqbkMsS0FBSyxFQUFFLFNBQVNpbkMsYUFDN0NpRixzQkFDRXRFLGNBQ0FYLFlBQVl6bkMsU0FBUyxFQUNyQnluQyxhQUNBa0YsK0JBRUNsRixjQUFjQSxZQUFZaG5DLE9BQU87SUFDeEM7SUFDQSxTQUFTbXNDLG1DQUFtQzkwQyxPQUFPLEVBQUUrckMsWUFBWTtRQUMvRCxJQUFJZ0osZ0JBQWdCO1FBQ3BCLFNBQVMvMEMsV0FDUCxTQUFTQSxRQUFRNUMsYUFBYSxJQUM5QixTQUFTNEMsUUFBUTVDLGFBQWEsQ0FBQ2tnQyxTQUFTLElBQ3ZDeVgsQ0FBQUEsZ0JBQWdCLzBDLFFBQVE1QyxhQUFhLENBQUNrZ0MsU0FBUyxDQUFDSyxJQUFJO1FBQ3ZEMzlCLFVBQVU7UUFDVixTQUFTK3JDLGFBQWEzdUMsYUFBYSxJQUNqQyxTQUFTMnVDLGFBQWEzdUMsYUFBYSxDQUFDa2dDLFNBQVMsSUFDNUN0OUIsQ0FBQUEsVUFBVStyQyxhQUFhM3VDLGFBQWEsQ0FBQ2tnQyxTQUFTLENBQUNLLElBQUk7UUFDdEQzOUIsWUFBWSswQyxpQkFDVCxTQUFRLzBDLFdBQVd3bEMsWUFBWXhsQyxVQUNoQyxRQUFRKzBDLGlCQUFpQnpOLGFBQWF5TixjQUFhO0lBQ3ZEO0lBQ0EsU0FBU0MsOEJBQThCaDFDLE9BQU8sRUFBRStyQyxZQUFZO1FBQzFEL3JDLFVBQVU7UUFDVixTQUFTK3JDLGFBQWE3akMsU0FBUyxJQUM1QmxJLENBQUFBLFVBQVUrckMsYUFBYTdqQyxTQUFTLENBQUM5SyxhQUFhLENBQUN5NkIsS0FBSztRQUN2RGtVLGVBQWVBLGFBQWEzdUMsYUFBYSxDQUFDeTZCLEtBQUs7UUFDL0NrVSxpQkFBaUIvckMsV0FDZHdsQyxDQUFBQSxZQUFZdUcsZUFBZSxRQUFRL3JDLFdBQVdzbkMsYUFBYXRuQyxRQUFPO0lBQ3ZFO0lBQ0EsU0FBU2kxQyx1Q0FDUDkxQyxJQUFJLEVBQ0p3d0MsV0FBVyxFQUNYb0QsY0FBYyxFQUNkbUMsb0JBQW9CO1FBRXBCLElBQUl2RixZQUFZak4sWUFBWSxHQUFHLE9BQzdCLElBQUtpTixjQUFjQSxZQUFZam5DLEtBQUssRUFBRSxTQUFTaW5DLGFBQzdDd0YsMEJBQ0VoMkMsTUFDQXd3QyxhQUNBb0QsZ0JBQ0FtQyx1QkFFQ3ZGLGNBQWNBLFlBQVlobkMsT0FBTztJQUMxQztJQUNBLFNBQVN3c0MsMEJBQ1A3RSxZQUFZLEVBQ1p2RSxZQUFZLEVBQ1pnSCxjQUFjLEVBQ2RtQyxvQkFBb0I7UUFFcEIsSUFBSS9zQyxRQUFRNGpDLGFBQWE1akMsS0FBSztRQUM5QixPQUFRNGpDLGFBQWFqdEMsR0FBRztZQUN0QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0htMkMsdUNBQ0UzRSxjQUNBdkUsY0FDQWdILGdCQUNBbUM7Z0JBRUYvc0MsUUFBUSxRQUNOa2xDLDhCQUE4QnRCLGNBQWN2YixVQUFVRDtnQkFDeEQ7WUFDRixLQUFLO2dCQUNILElBQUkzVyxxQkFBcUJEO2dCQUN6QnM3Qix1Q0FDRTNFLGNBQ0F2RSxjQUNBZ0gsZ0JBQ0FtQztnQkFFRi9zQyxRQUFRLFFBQ0wsa0JBQWtCLE1BQ25CLFNBQVM0akMsYUFBYTdqQyxTQUFTLElBQzVCNnFDLENBQUFBLGlCQUFpQmhILGFBQWE3akMsU0FBUyxDQUFDOUssYUFBYSxDQUFDeTZCLEtBQUssR0FDN0RrVSxlQUFlQSxhQUFhM3VDLGFBQWEsQ0FBQ3k2QixLQUFLLEVBQ2hEa1UsaUJBQWlCZ0gsa0JBQ2R2TixDQUFBQSxZQUFZdUcsZUFDYixRQUFRZ0gsa0JBQWtCekwsYUFBYXlMLGVBQWMsQ0FBQztnQkFDMUR6QyxhQUFhbk0scUJBQXFCLElBQ2hDcnFCLHlCQUF5QkY7Z0JBQzNCO1lBQ0YsS0FBSztnQkFDSCxJQUFJelIsUUFBUSxNQUFNO29CQUNoQnlSLHFCQUFxQkQ7b0JBQ3JCczdCLHVDQUNFM0UsY0FDQXZFLGNBQ0FnSCxnQkFDQW1DO29CQUVGNUUsZUFBZXZFLGFBQWFqakMsU0FBUztvQkFDckN3bkMsYUFBYW5NLHFCQUFxQixJQUNoQ25xQiw0QkFBNEJKO29CQUM5QixJQUFJO3dCQUNGdlMsa0JBQ0Uwa0MsY0FDQTJDLDhCQUNBM0MsY0FDQUEsYUFBYTdqQyxTQUFTLEVBQ3RCb21DLGlCQUNBZ0MsYUFBYW5NLHFCQUFxQjtvQkFFdEMsRUFBRSxPQUFPL2pDLE9BQU87d0JBQ2Qyc0Msd0JBQXdCaEIsY0FBY0EsYUFBYXBwQyxNQUFNLEVBQUV2QztvQkFDN0Q7Z0JBQ0YsT0FDRTYwQyx1Q0FDRTNFLGNBQ0F2RSxjQUNBZ0gsZ0JBQ0FtQztnQkFFSjtZQUNGLEtBQUs7Z0JBQ0g7WUFDRixLQUFLO2dCQUNIdDdCLHFCQUFxQm15QixhQUFhampDLFNBQVM7Z0JBQzNDLFNBQVNpakMsYUFBYTN1QyxhQUFhLEdBQy9Cd2MsbUJBQW1CVCxXQUFXLEdBQUcsSUFDL0I4N0IsdUNBQ0UzRSxjQUNBdkUsY0FDQWdILGdCQUNBbUMsd0JBRUZFLHdDQUNFOUUsY0FDQXZFLGdCQUVKbnlCLG1CQUFtQlQsV0FBVyxHQUFHLElBQy9CODdCLHVDQUNFM0UsY0FDQXZFLGNBQ0FnSCxnQkFDQW1DLHdCQUVELG9CQUFvQi83QixXQUFXLElBQUksR0FDcENrOEIsMkNBQ0UvRSxjQUNBdkUsY0FDQWdILGdCQUNBbUMsc0JBQ0EsTUFBT25KLENBQUFBLGFBQWFySixZQUFZLEdBQUcsS0FBSSxFQUN6QztnQkFDTnY2QixRQUFRLFFBQ04yc0MsbUNBQ0UvSSxhQUFhN2pDLFNBQVMsRUFDdEI2akM7Z0JBRUo7WUFDRixLQUFLO2dCQUNIa0osdUNBQ0UzRSxjQUNBdkUsY0FDQWdILGdCQUNBbUM7Z0JBRUYvc0MsUUFBUSxRQUNONnNDLDhCQUE4QmpKLGFBQWE3akMsU0FBUyxFQUFFNmpDO2dCQUN4RDtZQUNGO2dCQUNFa0osdUNBQ0UzRSxjQUNBdkUsY0FDQWdILGdCQUNBbUM7UUFFTjtJQUNGO0lBQ0EsU0FBU0csMkNBQ1AvRSxZQUFZLEVBQ1pYLFdBQVcsRUFDWG9ELGNBQWMsRUFDZG1DLG9CQUFvQixFQUNwQkwsNEJBQTRCO1FBRTVCQSwrQkFDRUEsZ0NBQ0EsTUFBT2xGLENBQUFBLFlBQVlqTixZQUFZLEdBQUcsS0FBSTtRQUN4QyxJQUFLaU4sY0FBY0EsWUFBWWpuQyxLQUFLLEVBQUUsU0FBU2luQyxhQUM3QzJGLHdCQUNFaEYsY0FDQVgsYUFDQW9ELGdCQUNBbUMsc0JBQ0FMLCtCQUVDbEYsY0FBY0EsWUFBWWhuQyxPQUFPO0lBQ3hDO0lBQ0EsU0FBUzJzQyx3QkFDUGhGLFlBQVksRUFDWnZFLFlBQVksRUFDWmdILGNBQWMsRUFDZG1DLG9CQUFvQixFQUNwQkwsNEJBQTRCO1FBRTVCLElBQUkxc0MsUUFBUTRqQyxhQUFhNWpDLEtBQUs7UUFDOUIsT0FBUTRqQyxhQUFhanRDLEdBQUc7WUFDdEIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIdTJDLDJDQUNFL0UsY0FDQXZFLGNBQ0FnSCxnQkFDQW1DLHNCQUNBTDtnQkFFRnhILDhCQUE4QnRCLGNBQWN2YjtnQkFDNUM7WUFDRixLQUFLO2dCQUNIO1lBQ0YsS0FBSztnQkFDSCxJQUFJK2tCLGFBQWF4SixhQUFhampDLFNBQVM7Z0JBQ3ZDLFNBQVNpakMsYUFBYTN1QyxhQUFhLEdBQy9CbTRDLFdBQVdwOEIsV0FBVyxHQUFHLElBQ3ZCazhCLDJDQUNFL0UsY0FDQXZFLGNBQ0FnSCxnQkFDQW1DLHNCQUNBTCxnQ0FFRk8sd0NBQ0U5RSxjQUNBdkUsZ0JBRUgsWUFBWTV5QixXQUFXLElBQUksR0FDNUJrOEIsMkNBQ0UvRSxjQUNBdkUsY0FDQWdILGdCQUNBbUMsc0JBQ0FMLDZCQUNGO2dCQUNKQSxnQ0FDRTFzQyxRQUFRLFFBQ1Iyc0MsbUNBQ0UvSSxhQUFhN2pDLFNBQVMsRUFDdEI2akM7Z0JBRUo7WUFDRixLQUFLO2dCQUNIc0osMkNBQ0UvRSxjQUNBdkUsY0FDQWdILGdCQUNBbUMsc0JBQ0FMO2dCQUVGQSxnQ0FDRTFzQyxRQUFRLFFBQ1I2c0MsOEJBQThCakosYUFBYTdqQyxTQUFTLEVBQUU2akM7Z0JBQ3hEO1lBQ0Y7Z0JBQ0VzSiwyQ0FDRS9FLGNBQ0F2RSxjQUNBZ0gsZ0JBQ0FtQyxzQkFDQUw7UUFFTjtJQUNGO0lBQ0EsU0FBU08sd0NBQ1BJLHFCQUFxQixFQUNyQjdGLFdBQVc7UUFFWCxJQUFJQSxZQUFZak4sWUFBWSxHQUFHLE9BQzdCLElBQUtpTixjQUFjQSxZQUFZam5DLEtBQUssRUFBRSxTQUFTaW5DLGFBQWU7WUFDNUQsSUFBSVcsZUFBZWtGLHVCQUNqQnpKLGVBQWU0RCxhQUNmeG5DLFFBQVE0akMsYUFBYTVqQyxLQUFLO1lBQzVCLE9BQVE0akMsYUFBYWp0QyxHQUFHO2dCQUN0QixLQUFLO29CQUNIczJDLHdDQUNFOUUsY0FDQXZFO29CQUVGNWpDLFFBQVEsUUFDTjJzQyxtQ0FDRS9JLGFBQWE3akMsU0FBUyxFQUN0QjZqQztvQkFFSjtnQkFDRixLQUFLO29CQUNIcUosd0NBQ0U5RSxjQUNBdkU7b0JBRUY1akMsUUFBUSxRQUNONnNDLDhCQUNFakosYUFBYTdqQyxTQUFTLEVBQ3RCNmpDO29CQUVKO2dCQUNGO29CQUNFcUosd0NBQ0U5RSxjQUNBdkU7WUFFTjtZQUNBNEQsY0FBY0EsWUFBWWhuQyxPQUFPO1FBQ25DO0lBQ0o7SUFDQSxTQUFTOHNDLHFDQUFxQzlGLFdBQVc7UUFDdkQsSUFBSUEsWUFBWWpOLFlBQVksR0FBR2dULHFCQUM3QixJQUFLL0YsY0FBY0EsWUFBWWpuQyxLQUFLLEVBQUUsU0FBU2luQyxhQUM3Q2dHLGlDQUFpQ2hHLGNBQzlCQSxjQUFjQSxZQUFZaG5DLE9BQU87SUFDMUM7SUFDQSxTQUFTZ3RDLGlDQUFpQ3o0QyxLQUFLO1FBQzdDLE9BQVFBLE1BQU00QixHQUFHO1lBQ2YsS0FBSztnQkFDSDIyQyxxQ0FBcUN2NEM7Z0JBQ3JDQSxNQUFNaUwsS0FBSyxHQUFHdXRDLHVCQUNYLFVBQVN4NEMsTUFBTUUsYUFBYSxHQUN6Qnc0QyxnQkFDRXZDLHNCQUNBbjJDLE1BQU1FLGFBQWEsRUFDbkJGLE1BQU1nYSxhQUFhLElBRXJCMitCLGdCQUFnQjM0QyxNQUFNaUUsSUFBSSxFQUFFakUsTUFBTWdhLGFBQWE7Z0JBQ3JEO1lBQ0YsS0FBSztnQkFDSHUrQixxQ0FBcUN2NEM7Z0JBQ3JDQSxNQUFNaUwsS0FBSyxHQUFHdXRDLHVCQUNaRyxnQkFBZ0IzNEMsTUFBTWlFLElBQUksRUFBRWpFLE1BQU1nYSxhQUFhO2dCQUNqRDtZQUNGLEtBQUs7WUFDTCxLQUFLO2dCQUNILElBQUkwdEIsbUJBQW1CO29CQUNyQixJQUFJa1Isd0JBQXdCekM7b0JBQzVCQSx1QkFBdUJTLGlCQUNyQjUyQyxNQUFNNEwsU0FBUyxDQUFDd2QsYUFBYTtvQkFFL0JtdkIscUNBQXFDdjRDO29CQUNyQ20yQyx1QkFBdUJ5QztnQkFDekIsT0FBT0wscUNBQXFDdjRDO2dCQUM1QztZQUNGLEtBQUs7Z0JBQ0gsU0FBU0EsTUFBTUUsYUFBYSxJQUN6Qix5QkFBeUJGLE1BQU1nTCxTQUFTLEVBQ3pDLFNBQVM0dEMseUJBQ1QsU0FBU0Esc0JBQXNCMTRDLGFBQWEsR0FDdkMseUJBQXlCczRDLHFCQUN6QkEsc0JBQXNCLFVBQ3ZCRCxxQ0FBcUN2NEMsUUFDcEN3NEMsc0JBQXNCSSxxQkFBcUIsSUFDNUNMLHFDQUFxQ3Y0QyxNQUFLO2dCQUNoRDtZQUNGO2dCQUNFdTRDLHFDQUFxQ3Y0QztRQUN6QztJQUNGO0lBQ0EsU0FBUzY0Qyx3QkFBd0JwRyxXQUFXO1FBQzFDLElBQUkvbkMsZ0JBQWdCK25DLFlBQVl6bkMsU0FBUztRQUN6QyxJQUNFLFNBQVNOLGlCQUNSLGVBQWVBLGNBQWNjLEtBQUssRUFBRyxTQUFTaW5DLFdBQVUsR0FDekQ7WUFDQS9uQyxjQUFjYyxLQUFLLEdBQUc7WUFDdEIsR0FDRSxnQkFBaUJpbkMsWUFBWWhuQyxPQUFPLEVBQ2pDZ25DLFlBQVlobkMsT0FBTyxHQUFHLE1BQ3RCZ25DLGNBQWMvbkM7bUJBQ1osU0FBUytuQyxhQUFhO1FBQy9CO0lBQ0Y7SUFDQSxTQUFTcUcseUNBQXlDckcsV0FBVztRQUMzRCxJQUFJN3FCLFlBQVk2cUIsWUFBWTdxQixTQUFTO1FBQ3JDLElBQUksTUFBTzZxQixDQUFBQSxZQUFZeG5DLEtBQUssR0FBRyxFQUFDLEdBQUk7WUFDbEMsSUFBSSxTQUFTMmMsV0FDWCxJQUFLLElBQUl4bUIsSUFBSSxHQUFHQSxJQUFJd21CLFVBQVVubkIsTUFBTSxFQUFFVyxJQUFLO2dCQUN6QyxJQUFJdW1CLGdCQUFnQkMsU0FBUyxDQUFDeG1CLEVBQUU7Z0JBQ2hDNHhDLGFBQWFyckI7Z0JBQ2JveEIscURBQ0VweEIsZUFDQThxQjtZQUVKO1lBQ0ZvRyx3QkFBd0JwRztRQUMxQjtRQUNBLElBQUlBLFlBQVlqTixZQUFZLEdBQUcsT0FDN0IsSUFBS2lOLGNBQWNBLFlBQVlqbkMsS0FBSyxFQUFFLFNBQVNpbkMsYUFDN0N1Ryw0QkFBNEJ2RyxjQUN6QkEsY0FBY0EsWUFBWWhuQyxPQUFPO0lBQzFDO0lBQ0EsU0FBU3V0Qyw0QkFBNEJuSyxZQUFZO1FBQy9DLE9BQVFBLGFBQWFqdEMsR0FBRztZQUN0QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0hrM0MseUNBQXlDaks7Z0JBQ3pDQSxhQUFhNWpDLEtBQUssR0FBRyxRQUNuQm1sQyxnQ0FDRXZCLGNBQ0FBLGFBQWFwcEMsTUFBTSxFQUNuQjZ0QixVQUFVRDtnQkFFZDtZQUNGLEtBQUs7Z0JBQ0gsSUFBSTNXLHFCQUFxQkQ7Z0JBQ3pCcThCLHlDQUF5Q2pLO2dCQUN6Q0EsYUFBYWpqQyxTQUFTLENBQUNxN0IscUJBQXFCLElBQzFDcnFCLHlCQUF5QkY7Z0JBQzNCO1lBQ0YsS0FBSztnQkFDSEEscUJBQXFCRDtnQkFDckJxOEIseUNBQXlDaks7Z0JBQ3pDQSxhQUFhampDLFNBQVMsQ0FBQ3E3QixxQkFBcUIsSUFDMUNucUIsNEJBQTRCSjtnQkFDOUI7WUFDRixLQUFLO2dCQUNIQSxxQkFBcUJteUIsYUFBYWpqQyxTQUFTO2dCQUMzQyxTQUFTaWpDLGFBQWEzdUMsYUFBYSxJQUNuQ3djLG1CQUFtQlQsV0FBVyxHQUFHLEtBQ2hDLFVBQVM0eUIsYUFBYXBwQyxNQUFNLElBQUksT0FBT29wQyxhQUFhcHBDLE1BQU0sQ0FBQzdELEdBQUcsSUFDMUQsb0JBQW9CcWEsV0FBVyxJQUFJLENBQUMsR0FDckNnOUIsNENBQTRDcEssYUFBWSxJQUN4RGlLLHlDQUF5Q2pLO2dCQUM3QztZQUNGO2dCQUNFaUsseUNBQXlDaks7UUFDN0M7SUFDRjtJQUNBLFNBQVNvSyw0Q0FBNEN4RyxXQUFXO1FBQzlELElBQUk3cUIsWUFBWTZxQixZQUFZN3FCLFNBQVM7UUFDckMsSUFBSSxNQUFPNnFCLENBQUFBLFlBQVl4bkMsS0FBSyxHQUFHLEVBQUMsR0FBSTtZQUNsQyxJQUFJLFNBQVMyYyxXQUNYLElBQUssSUFBSXhtQixJQUFJLEdBQUdBLElBQUl3bUIsVUFBVW5uQixNQUFNLEVBQUVXLElBQUs7Z0JBQ3pDLElBQUl1bUIsZ0JBQWdCQyxTQUFTLENBQUN4bUIsRUFBRTtnQkFDaEM0eEMsYUFBYXJyQjtnQkFDYm94QixxREFDRXB4QixlQUNBOHFCO1lBRUo7WUFDRm9HLHdCQUF3QnBHO1FBQzFCO1FBQ0EsSUFBS0EsY0FBY0EsWUFBWWpuQyxLQUFLLEVBQUUsU0FBU2luQyxhQUM3Q3lHLHdCQUF3QnpHLGNBQ3JCQSxjQUFjQSxZQUFZaG5DLE9BQU87SUFDeEM7SUFDQSxTQUFTeXRDLHdCQUF3QnJLLFlBQVk7UUFDM0MsT0FBUUEsYUFBYWp0QyxHQUFHO1lBQ3RCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSHd1QyxnQ0FDRXZCLGNBQ0FBLGFBQWFwcEMsTUFBTSxFQUNuQjZ0QjtnQkFFRjJsQiw0Q0FBNENwSztnQkFDNUM7WUFDRixLQUFLO2dCQUNILElBQUk5cUIsV0FBVzhxQixhQUFhampDLFNBQVM7Z0JBQ3JDbVksU0FBUzlILFdBQVcsR0FBRyxLQUNwQixVQUFVQSxXQUFXLElBQUksQ0FBQyxHQUMzQmc5Qiw0Q0FBNENwSyxhQUFZO2dCQUMxRDtZQUNGO2dCQUNFb0ssNENBQTRDcEs7UUFDaEQ7SUFDRjtJQUNBLFNBQVNrSyxxREFDUEksa0JBQWtCLEVBQ2xCbkssc0JBQXNCO1FBRXRCLE1BQU8sU0FBU2dFLFlBQWM7WUFDNUIsSUFBSWh6QyxRQUFRZ3pDLFlBQ1Zsd0MsVUFBVTlDO1lBQ1osT0FBUThDLFFBQVFsQixHQUFHO2dCQUNqQixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSHd1QyxnQ0FDRXR0QyxTQUNBa3NDLHdCQUNBMWI7b0JBRUY7Z0JBQ0YsS0FBSztnQkFDTCxLQUFLO29CQUNILFNBQVN4d0IsUUFBUTVDLGFBQWEsSUFDNUIsU0FBUzRDLFFBQVE1QyxhQUFhLENBQUNrZ0MsU0FBUyxJQUN2QyxXQUFXdDlCLFFBQVE1QyxhQUFhLENBQUNrZ0MsU0FBUyxDQUFDSyxJQUFJLEVBQ2hELFFBQVEzOUIsV0FBV3dsQyxZQUFZeGxDLFFBQU87b0JBQ3hDO2dCQUNGLEtBQUs7b0JBQ0hzbkMsYUFBYXRuQyxRQUFRNUMsYUFBYSxDQUFDeTZCLEtBQUs7WUFDNUM7WUFDQTczQixVQUFVOUMsTUFBTXdMLEtBQUs7WUFDckIsSUFBSSxTQUFTMUksU0FBUyxRQUFTMkMsTUFBTSxHQUFHekYsT0FBU2d6QyxhQUFhbHdDO2lCQUU1RHNJLEdBQUcsSUFBS3BMLFFBQVFtNUMsb0JBQW9CLFNBQVNuRyxZQUFjO2dCQUN6RGx3QyxVQUFVa3dDO2dCQUNWLElBQUl2bkMsVUFBVTNJLFFBQVEySSxPQUFPLEVBQzNCOGEsY0FBY3pqQixRQUFRMkMsTUFBTTtnQkFDOUJxdUMsd0JBQXdCaHhDO2dCQUN4QixJQUFJQSxZQUFZOUMsT0FBTztvQkFDckJnekMsYUFBYTtvQkFDYixNQUFNNW5DO2dCQUNSO2dCQUNBLElBQUksU0FBU0ssU0FBUztvQkFDcEJBLFFBQVFoRyxNQUFNLEdBQUc4Z0I7b0JBQ2pCeXNCLGFBQWF2bkM7b0JBQ2IsTUFBTUw7Z0JBQ1I7Z0JBQ0E0bkMsYUFBYXpzQjtZQUNmO1FBQ0o7SUFDRjtJQUNBLFNBQVM2eUIseUJBQXlCQyxRQUFRO1FBQ3hDLElBQUlDLGFBQWFDLG9CQUFvQkY7UUFDckMsSUFBSSxRQUFRQyxZQUFZO1lBQ3RCLElBQUksYUFBYSxPQUFPQSxXQUFXdC9CLGFBQWEsQ0FBQyxnQkFBZ0IsRUFDL0QsTUFBTTlTLE1BQ0o7WUFFSixPQUFPb3lDO1FBQ1Q7UUFDQUQsV0FBV0csY0FBY0g7UUFDekIsSUFBSSxTQUFTQSxVQUNYLE1BQU1ueUMsTUFDSjtRQUVKLE9BQU9teUMsU0FBU3p0QyxTQUFTLENBQUM5SSxPQUFPO0lBQ25DO0lBQ0EsU0FBUzIyQyxjQUFjQyxjQUFjLEVBQUVDLFFBQVE7UUFDN0MsSUFBSS8zQyxNQUFNODNDLGVBQWU5M0MsR0FBRztRQUM1QixPQUFRKzNDLFNBQVN6MUMsUUFBUTtZQUN2QixLQUFLMDFDO2dCQUNILElBQUlGLGVBQWV6MUMsSUFBSSxLQUFLMDFDLFNBQVNuNUMsS0FBSyxFQUFFLE9BQU8sQ0FBQztnQkFDcEQ7WUFDRixLQUFLcTVDO2dCQUNIenVDLEdBQUc7b0JBQ0R1dUMsV0FBV0EsU0FBU241QyxLQUFLO29CQUN6Qms1QyxpQkFBaUI7d0JBQUNBO3dCQUFnQjtxQkFBRTtvQkFDcEMsSUFBSzkzQyxNQUFNLEdBQUdBLE1BQU04M0MsZUFBZWo1QyxNQUFNLEVBQUk7d0JBQzNDLElBQUlULFFBQVEwNUMsY0FBYyxDQUFDOTNDLE1BQU0sRUFDL0JrNEMsZUFBZTk1QyxNQUFNNEIsR0FBRyxFQUN4Qm00QyxnQkFBZ0JMLGNBQWMsQ0FBQzkzQyxNQUFNLEVBQ3JDbzRDLG9CQUFvQkwsUUFBUSxDQUFDSSxjQUFjO3dCQUM3QyxJQUNFLE1BQU9ELGdCQUNMLE9BQU9BLGdCQUNQLE9BQU9BLGdCQUNULENBQUNHLGdCQUFnQmo2QyxRQUNqQjs0QkFDQSxNQUVFLFFBQVFnNkMscUJBQ1JQLGNBQWN6NUMsT0FBT2c2QyxvQkFHckJELGlCQUNHQyxvQkFBb0JMLFFBQVEsQ0FBQ0ksY0FBYzs0QkFDaEQsSUFBSUEsa0JBQWtCSixTQUFTbDVDLE1BQU0sRUFBRTtnQ0FDckNrNUMsV0FBVyxDQUFDO2dDQUNaLE1BQU12dUM7NEJBQ1IsT0FDRSxJQUFLcEwsUUFBUUEsTUFBTXdMLEtBQUssRUFBRSxTQUFTeEwsT0FDakMwNUMsZUFBZWgyQyxJQUFJLENBQUMxRCxPQUFPKzVDLGdCQUN4Qi81QyxRQUFRQSxNQUFNeUwsT0FBTzt3QkFDOUI7b0JBQ0Y7b0JBQ0FrdUMsV0FBVyxDQUFDO2dCQUNkO2dCQUNBLE9BQU9BO1lBQ1QsS0FBS087Z0JBQ0gsSUFDRSxDQUFDLE1BQU10NEMsT0FBTyxPQUFPQSxPQUFPLE9BQU9BLEdBQUUsS0FDckN1NEMsdUJBQXVCVCxlQUFlOXRDLFNBQVMsRUFBRSt0QyxTQUFTbjVDLEtBQUssR0FFL0QsT0FBTyxDQUFDO2dCQUNWO1lBQ0YsS0FBSzQ1QztnQkFDSCxJQUFJLE1BQU14NEMsT0FBTyxNQUFNQSxPQUFPLE9BQU9BLE9BQU8sT0FBT0EsS0FDakQ7b0JBQUEsSUFDRyxpQkFBa0J5NEMsZUFBZVgsaUJBQ2xDLFNBQVNBLGtCQUNQLEtBQUtBLGVBQWVueUMsT0FBTyxDQUFDb3lDLFNBQVNuNUMsS0FBSyxHQUU1QyxPQUFPLENBQUM7Z0JBQUM7Z0JBQ2I7WUFDRixLQUFLODVDO2dCQUNILElBQUksTUFBTTE0QyxPQUFPLE9BQU9BLE9BQU8sT0FBT0EsS0FDcEM7b0JBQUEsSUFDRyxpQkFBa0I4M0MsZUFBZTEvQixhQUFhLENBQUMsZ0JBQWdCLEVBQ2hFLGFBQWEsT0FBTzAvQixrQkFDbEJBLGVBQWV0aEMsV0FBVyxPQUFPdWhDLFNBQVNuNUMsS0FBSyxDQUFDNFgsV0FBVyxJQUU3RCxPQUFPLENBQUM7Z0JBQUM7Z0JBQ2I7WUFDRjtnQkFDRSxNQUFNbFIsTUFBTTtRQUNoQjtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBQ0EsU0FBU3F6QyxpQkFBaUJaLFFBQVE7UUFDaEMsT0FBUUEsU0FBU3oxQyxRQUFRO1lBQ3ZCLEtBQUswMUM7Z0JBQ0gsT0FDRSxNQUFPNTFDLENBQUFBLHlCQUF5QjIxQyxTQUFTbjVDLEtBQUssS0FBSyxTQUFRLElBQUs7WUFFcEUsS0FBS3E1QztnQkFDSCxPQUFPLFVBQVdVLENBQUFBLGlCQUFpQlosYUFBYSxFQUFDLElBQUs7WUFDeEQsS0FBS087Z0JBQ0gsT0FBTyxZQUFZUCxTQUFTbjVDLEtBQUssR0FBRztZQUN0QyxLQUFLNDVDO2dCQUNILE9BQU8sTUFBTVQsU0FBU241QyxLQUFLLEdBQUc7WUFDaEMsS0FBSzg1QztnQkFDSCxPQUFPLHFCQUFxQlgsU0FBU241QyxLQUFLLEdBQUc7WUFDL0M7Z0JBQ0UsTUFBTTBHLE1BQU07UUFDaEI7SUFDRjtJQUNBLFNBQVNzekMsVUFBVXY0QyxJQUFJLEVBQUV3NEMsU0FBUztRQUNoQyxJQUFJQyxpQkFBaUIsRUFBRTtRQUN2Qno0QyxPQUFPO1lBQUNBO1lBQU07U0FBRTtRQUNoQixJQUFLLElBQUkxQixRQUFRLEdBQUdBLFFBQVEwQixLQUFLeEIsTUFBTSxFQUFJO1lBQ3pDLElBQUlULFFBQVFpQyxJQUFJLENBQUMxQixRQUFRLEVBQ3ZCcUIsTUFBTTVCLE1BQU00QixHQUFHLEVBQ2ZtNEMsZ0JBQWdCOTNDLElBQUksQ0FBQzFCLFFBQVEsRUFDN0JvNUMsV0FBV2MsU0FBUyxDQUFDVixjQUFjO1lBQ3JDLElBQ0UsTUFBT240QyxPQUFPLE9BQU9BLE9BQU8sT0FBT0EsT0FDbkMsQ0FBQ3E0QyxnQkFBZ0JqNkMsUUFDakI7Z0JBQ0EsTUFBTyxRQUFRMjVDLFlBQVlGLGNBQWN6NUMsT0FBTzI1QyxXQUM5Q0ksaUJBQWtCSixXQUFXYyxTQUFTLENBQUNWLGNBQWM7Z0JBQ3ZELElBQUlBLGtCQUFrQlUsVUFBVWg2QyxNQUFNLEVBQUVpNkMsZUFBZWgzQyxJQUFJLENBQUMxRDtxQkFFMUQsSUFBS0EsUUFBUUEsTUFBTXdMLEtBQUssRUFBRSxTQUFTeEwsT0FDakNpQyxLQUFLeUIsSUFBSSxDQUFDMUQsT0FBTys1QyxnQkFBaUIvNUMsUUFBUUEsTUFBTXlMLE9BQU87WUFDN0Q7UUFDRjtRQUNBLE9BQU9pdkM7SUFDVDtJQUNBLFNBQVNDLGFBQWF0QixRQUFRLEVBQUVvQixTQUFTO1FBQ3ZDLElBQUksQ0FBQ0csdUJBQ0gsTUFBTTF6QyxNQUFNO1FBQ2RteUMsV0FBV0QseUJBQXlCQztRQUNwQ0EsV0FBV21CLFVBQVVuQixVQUFVb0I7UUFDL0JBLFlBQVksRUFBRTtRQUNkcEIsV0FBV2pvQixNQUFNeXBCLElBQUksQ0FBQ3hCO1FBQ3RCLElBQUssSUFBSTk0QyxRQUFRLEdBQUdBLFFBQVE4NEMsU0FBUzU0QyxNQUFNLEVBQUk7WUFDN0MsSUFBSXFLLE9BQU91dUMsUUFBUSxDQUFDOTRDLFFBQVEsRUFDMUJxQixNQUFNa0osS0FBS2xKLEdBQUc7WUFDaEIsSUFBSSxNQUFNQSxPQUFPLE9BQU9BLE9BQU8sT0FBT0EsS0FDcENxNEMsZ0JBQWdCbnZDLFNBQVMydkMsVUFBVS8yQyxJQUFJLENBQUNvSCxLQUFLYyxTQUFTO2lCQUV0RCxJQUFLZCxPQUFPQSxLQUFLVSxLQUFLLEVBQUUsU0FBU1YsTUFDL0J1dUMsU0FBUzMxQyxJQUFJLENBQUNvSCxPQUFRQSxPQUFPQSxLQUFLVyxPQUFPO1FBQy9DO1FBQ0EsT0FBT2d2QztJQUNUO0lBQ0EsU0FBU0s7UUFDUEYseUJBQ0VHLFlBQVl0M0MsT0FBTyxDQUFDLFNBQVV1M0MsVUFBVTtZQUN0QyxPQUFPQTtRQUNUO0lBQ0o7SUFDQSxTQUFTQztRQUNQLElBQUlDLDhCQUNGLGdCQUFnQixPQUFPQywyQkFDbkJBLDJCQUNBLEtBQUs7UUFDWEQsK0JBQ0UsU0FBU2p6QyxxQkFBcUI2VixRQUFRLElBQ3RDNWMsUUFBUWdDLEtBQUssQ0FDWDtRQUVKLE9BQU9nNEM7SUFDVDtJQUNBLFNBQVM1aEIsa0JBQWtCdDVCLEtBQUs7UUFDOUIsSUFDRSxDQUFDcWdCLG1CQUFtQkMsYUFBWSxNQUFPRSxhQUN2QyxNQUFNL0IsK0JBRU4sT0FBT0EsZ0NBQWdDLENBQUNBO1FBQzFDLElBQUlrQyxhQUFhMVkscUJBQXFCc3RCLENBQUM7UUFDdkMsT0FBTyxTQUFTNVUsYUFDWEEsQ0FBQUEsV0FBV2lWLGNBQWMsSUFBS2pWLENBQUFBLFdBQVdpVixjQUFjLEdBQUcsSUFBSXpMLEtBQUksR0FDbkV4SixXQUFXaVYsY0FBYyxDQUFDaG1CLEdBQUcsQ0FBQzVQLFFBQzdCQSxRQUFRZ2hCLHNCQUNULE1BQU1oaEIsUUFBUUEsUUFBUXlnQix1QkFBc0IsSUFDNUMyNkI7SUFDTjtJQUNBLFNBQVN4aUI7UUFDUCxNQUFNcUwsOEJBQ0hBLENBQUFBLDZCQUNDLE1BQU94bEIsQ0FBQUEsZ0NBQWdDLFNBQVEsS0FBTTNLLGNBQ2pEakcsNEJBQ0EsU0FBUTtRQUNoQixJQUFJd3RDLGtCQUFrQnh2QiwyQkFBMkIvb0IsT0FBTztRQUN4RCxTQUFTdTRDLG1CQUFvQkEsQ0FBQUEsZ0JBQWdCcHdDLEtBQUssSUFBSSxFQUFDO1FBQ3ZELE9BQU9nNUI7SUFDVDtJQUNBLFNBQVM3UCxzQkFBc0JueUIsSUFBSSxFQUFFakMsS0FBSyxFQUFFNE0sSUFBSTtRQUM5QzJpQyw0QkFDRXJ1QyxRQUFRZ0MsS0FBSyxDQUFDO1FBQ2hCbzRDLDRCQUE2QkMsQ0FBQUEsd0NBQXdDLENBQUM7UUFDdEUsSUFDRSxTQUFVNzhCLHNCQUNSUSxrQ0FBa0NDLG1CQUNwQyxTQUFTbGQsS0FBS21kLG1CQUFtQixFQUVqQ284QixrQkFBa0J2NUMsTUFBTSxJQUN0Qnc1QyxrQkFDRXg1QyxNQUNBd2MsK0JBQ0F3bEIsNEJBQ0EsQ0FBQztRQUVQNzFCLGtCQUFrQm5NLE1BQU0ySztRQUN4QixJQUNFLE1BQU95VCxDQUFBQSxtQkFBbUJDLGFBQVksS0FDdENyZSxTQUFTeWMsb0JBQ1Q7WUFDQSxJQUFJOVQsYUFDRixPQUFRNUssTUFBTTRCLEdBQUc7Z0JBQ2YsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0hLLE9BQ0Usa0JBQW1Cc0QsMEJBQTBCcUUsbUJBQzdDO29CQUNGOHhDLDhDQUE4QzFyQyxHQUFHLENBQUMvTixTQUMvQ3k1QyxDQUFBQSw4Q0FBOEM5ckMsR0FBRyxDQUFDM04sT0FDbERqQyxRQUFRdUYsMEJBQTBCdkYsVUFBVSxXQUM3Q2tCLFFBQVFnQyxLQUFLLENBQ1gsa05BQ0FsRCxPQUNBaUMsTUFDQUEsS0FDRjtvQkFDRjtnQkFDRixLQUFLO29CQUNIMDVDLDhCQUNHejZDLENBQUFBLFFBQVFnQyxLQUFLLENBQ1osOElBRUR5NEMsNkJBQTZCLENBQUMsQ0FBQztZQUN0QztRQUNKLE9BQ0Vqc0MscUJBQXFCRCxtQkFBbUJ4TixNQUFNakMsT0FBTzRNLE9BQ25EZ3ZDLGtDQUFrQzU3QyxRQUNsQ2lDLFNBQVN5YyxzQkFDTixFQUFDMkIsbUJBQW1CQyxhQUFZLE1BQU9FLGFBQ3JDcTdCLENBQUFBLDZDQUE2Q2p2QyxJQUFHLEdBQ25EcXhCLGlDQUFpQ1MsMEJBQy9CK2Msa0JBQ0V4NUMsTUFDQXdjLCtCQUNBd2xCLDRCQUNBLENBQUMsRUFDSCxHQUNKdm1CLHNCQUFzQnpiO0lBQzVCO0lBQ0EsU0FBUytkLGtCQUFrQi9kLElBQUksRUFBRTZLLEtBQUssRUFBRWd2QyxTQUFTO1FBQy9DLElBQUksQ0FBQ3o3QixtQkFBb0JDLENBQUFBLGdCQUFnQkMsYUFBWSxDQUFDLE1BQU9DLFdBQzNELE1BQU10WixNQUFNO1FBQ2QsSUFBSTYwQyxrQkFDQSxDQUFFRCxhQUNBLE1BQU9odkMsQ0FBQUEsUUFBUSxFQUFDLEtBQ2hCLE1BQU9BLENBQUFBLFFBQVE3SyxLQUFLMk0sWUFBWSxLQUNsQ25CLDBCQUEwQnhMLE1BQU02SyxRQUNsQ2t2QyxhQUFhRCxrQkFDVEUscUJBQXFCaDZDLE1BQU02SyxTQUMzQm92QyxlQUFlajZDLE1BQU02SyxPQUFPLENBQUMsSUFDakNxdkMsc0JBQXNCSjtRQUN4QixHQUFHO1lBQ0QsSUFBSUMsZUFBZTlkLGdCQUFnQjtnQkFDakNrZSxvQ0FDRSxDQUFDTCxtQkFDRE4sa0JBQWtCeDVDLE1BQU02SyxPQUFPLEdBQUcsQ0FBQztnQkFDckM7WUFDRixPQUFPLElBQUlrdkMsZUFBZUssb0JBQ3hCWixrQkFDRXg1QyxNQUNBNkssT0FDQSxHQUNBLENBQUN3dkM7aUJBRUE7Z0JBQ0hSLFlBQVk3NUMsS0FBS2EsT0FBTyxDQUFDa0ksU0FBUztnQkFDbEMsSUFDRW14Qyx1QkFDQSxDQUFDSSxxQ0FBcUNULFlBQ3RDO29CQUNBRSxhQUFhRSxlQUFlajZDLE1BQU02SyxPQUFPLENBQUM7b0JBQzFDcXZDLHNCQUFzQixDQUFDO29CQUN2QjtnQkFDRjtnQkFDQSxJQUFJSCxlQUFlcmQsYUFBYTtvQkFDOUJ3ZCxzQkFBc0JydkM7b0JBQ3RCLElBQUk3SyxLQUFLNk0sMEJBQTBCLEdBQUdxdEMscUJBQ3BDLElBQUlLLGtCQUFrQjt5QkFFdEIsa0JBQW1CdjZDLEtBQUtpTCxZQUFZLEdBQUcsQ0FBQyxXQUNyQ3N2QyxrQkFDQyxNQUFNQSxrQkFDRkEsa0JBQ0FBLGtCQUFrQixZQUNoQixZQUNBO29CQUNaLElBQUksTUFBTUEsaUJBQWlCO3dCQUN6QjF2QyxRQUFRMHZDO3dCQUNScHhDLEdBQUc7NEJBQ0Q0d0MsYUFBYS81Qzs0QkFDYixJQUFJdzZDLDJCQUEyQkQ7NEJBQy9CQSxrQkFBa0I1ZDs0QkFDbEIsSUFBSThkLG9CQUNGNWlDLHFCQUNBa2lDLFdBQVdsNUMsT0FBTyxDQUFDNUMsYUFBYSxDQUFDc25DLFlBQVk7NEJBQy9Da1YscUJBQ0dsQixDQUFBQSxrQkFDQ1EsWUFDQVMsMEJBQ0F4eEMsS0FBSyxJQUFJLEdBQUU7NEJBQ2Z3eEMsMkJBQTJCUCxlQUN6QkYsWUFDQVMsMEJBQ0EsQ0FBQzs0QkFFSCxJQUFJQSw2QkFBNkI5ZCxhQUFhO2dDQUM1QyxJQUNFZ2UsMkNBQ0EsQ0FBQ0QsbUJBQ0Q7b0NBQ0FWLFdBQVdsdEMsMEJBQTBCLElBQ25DcXRDO29DQUNGTiw2Q0FDRU07b0NBQ0ZILGFBQWF0ZDtvQ0FDYixNQUFNdHpCO2dDQUNSO2dDQUNBNHdDLGFBQWFZO2dDQUNiQSxzQ0FBc0NKO2dDQUN0QyxTQUFTUixjQUFjbE8sdUJBQXVCa087NEJBQ2hEOzRCQUNBQSxhQUFhUzt3QkFDZjt3QkFDQU4sc0JBQXNCLENBQUM7d0JBQ3ZCLElBQUlILGVBQWVyZCxhQUFhO29CQUNsQztnQkFDRjtnQkFDQSxJQUFJcWQsZUFBZWEsa0JBQWtCO29CQUNuQ3JCLGtCQUFrQnY1QyxNQUFNO29CQUN4Qnc1QyxrQkFBa0J4NUMsTUFBTTZLLE9BQU8sR0FBRyxDQUFDO29CQUNuQztnQkFDRjtnQkFDQTFCLEdBQUc7b0JBQ0Qyd0Msa0JBQWtCOTVDO29CQUNsQixPQUFRKzVDO3dCQUNOLEtBQUs5ZDt3QkFDTCxLQUFLMmU7NEJBQ0gsTUFBTTMxQyxNQUFNO3dCQUNkLEtBQUt3M0I7NEJBQ0gsSUFBSSxDQUFDNXhCLFFBQVEsT0FBTSxNQUFPQSxPQUFPO2dDQUMvQjJ1QyxrQkFDRU0saUJBQ0FqdkMsT0FDQW0zQiw0QkFDQSxDQUFDcVk7Z0NBRUgsTUFBTWx4Qzs0QkFDUjs0QkFDQTt3QkFDRixLQUFLdXpCOzRCQUNIaWUsc0NBQXNDOzRCQUN0Qzt3QkFDRixLQUFLemU7d0JBQ0wsS0FBSzJlOzRCQUNIO3dCQUNGOzRCQUNFLE1BQU01MUMsTUFBTTtvQkFDaEI7b0JBQ0E2MEMsZ0JBQWdCbE4sWUFBWSxHQUFHaU47b0JBQy9CQyxnQkFBZ0J4dUMsYUFBYSxHQUFHVDtvQkFDaEMsSUFBSSxTQUFTN0UscUJBQXFCNlYsUUFBUSxFQUN4Q2kvQixXQUNFaEIsaUJBQ0FhLHFDQUNBSSwyQkFDQUMsbURBQ0FoWiw0QkFDQTRYLDJDQUNBNU8sbUNBQ0FpUSxrQkFDQSxDQUFDLEdBQ0Q7eUJBRUM7d0JBQ0gsSUFDRSxDQUFDcHdDLFFBQVEsUUFBTyxNQUFPQSxTQUN0QixjQUNDaXFDLCtCQUNBb0csdUJBQ0F0K0IsU0FDRixLQUFLbTlCLFVBQVMsR0FDZDs0QkFDQVAsa0JBQ0VNLGlCQUNBanZDLE9BQ0FtM0IsNEJBQ0EsQ0FBQ3FZOzRCQUVILElBQUksTUFBTXR2QyxhQUFhK3VDLGlCQUFpQixJQUFJLE1BQU0zd0M7NEJBQ2xEMndDLGdCQUFnQnFCLGFBQWEsR0FBR0MsZ0JBQzlCQyxvQkFBb0I3OUIsSUFBSSxDQUN0QixNQUNBczhCLGlCQUNBRCxXQUNBYyxxQ0FDQUksMkJBQ0FDLG1EQUNBbndDLE9BQ0FtM0IsNEJBQ0E0WCwyQ0FDQTVPLG1DQUNBcVAsNENBQ0FpQixrQkFDQSxDQUFDLEdBQ0QsSUFFRnZCOzRCQUVGLE1BQU01d0M7d0JBQ1I7d0JBQ0FreUMsb0JBQ0V2QixpQkFDQUQsV0FDQWMscUNBQ0FJLDJCQUNBQyxtREFDQW53QyxPQUNBbTNCLDRCQUNBNFgsMkNBQ0E1TyxtQ0FDQXFQLDRDQUNBWSxrQkFDQSxDQUFDLEdBQ0Q7b0JBRUo7Z0JBQ0Y7WUFDRjtZQUNBO1FBQ0YsUUFBUyxHQUFHO1FBQ1p4L0Isc0JBQXNCemI7SUFDeEI7SUFDQSxTQUFTNnJDLHVCQUF1QjBQLE1BQU07UUFDcEMsU0FBU1osc0NBQ0pBLHNDQUFzQ1ksU0FDdkNaLG9DQUFvQ2w1QyxJQUFJLENBQUMrNUMsS0FBSyxDQUM1Q2IscUNBQ0FZO0lBRVI7SUFDQSxTQUFTRixvQkFDUHI3QyxJQUFJLEVBQ0o0c0MsWUFBWSxFQUNaNk8saUJBQWlCLEVBQ2pCcGYsV0FBVyxFQUNYcWYsMkJBQTJCLEVBQzNCN3dDLEtBQUssRUFDTDBCLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxtQkFBbUIsRUFDbkJrdkMsd0JBQXdCLEVBQ3hCQyxxQkFBcUIsRUFDckJDLHdCQUF3QixFQUN4QkMsc0JBQXNCO1FBRXRCLElBQUl2WSxlQUFlcUosYUFBYXJKLFlBQVk7UUFDNUMsSUFBSUEsZUFBZSxRQUFRLGFBQWNBLENBQUFBLGVBQWUsUUFBTyxHQUM3RDtZQUFBLElBQ0d3WSx5QkFDRHZGLGlDQUFpQzVKLGVBQ2hDQSxlQUFlb1AsMEJBQ2hCLFNBQVNwUCxjQUNUO2dCQUNBNXNDLEtBQUttZCxtQkFBbUIsR0FBR3l2QixhQUN6QmtPLFdBQVd0OUIsSUFBSSxDQUNiLE1BQ0F4ZCxNQUNBeTdDLG1CQUNBcGYsYUFDQXFmLDZCQUNBbnZDLGFBQ0FDLGNBQ0FDLHFCQUNBd3ZDLGtCQUNBSiwwQkFDQUM7Z0JBR0p0QyxrQkFDRXg1QyxNQUNBNkssT0FDQTBCLGFBQ0EsQ0FBQ292QztnQkFFSDtZQUNGO1FBQUE7UUFDRmIsV0FDRTk2QyxNQUNBeTdDLG1CQUNBcGYsYUFDQXFmLDZCQUNBbnZDLGFBQ0FDLGNBQ0FDLHFCQUNBbXZDLHVCQUNBQywwQkFDQUM7SUFFSjtJQUNBLFNBQVN4QixxQ0FBcUMxTixZQUFZO1FBQ3hELElBQUssSUFBSS9qQyxPQUFPK2pDLGVBQWtCO1lBQ2hDLElBQUlqdEMsTUFBTWtKLEtBQUtsSixHQUFHO1lBQ2xCLElBQ0UsQ0FBQyxNQUFNQSxPQUFPLE9BQU9BLE9BQU8sT0FBT0EsR0FBRSxLQUNyQ2tKLEtBQUtHLEtBQUssR0FBRyxTQUNaLE9BQU9ILEtBQUs4VyxXQUFXLEVBQ3hCLFNBQVNoZ0IsT0FBUSxPQUFPQSxJQUFJK3RCLE1BQU0sRUFBRyxTQUFTL3RCLEdBQUUsQ0FBQyxHQUVqRCxJQUFLLElBQUlSLElBQUksR0FBR0EsSUFBSVEsSUFBSW5CLE1BQU0sRUFBRVcsSUFBSztnQkFDbkMsSUFBSSs4QyxRQUFRdjhDLEdBQUcsQ0FBQ1IsRUFBRSxFQUNoQnl4QixjQUFjc3JCLE1BQU10ckIsV0FBVztnQkFDakNzckIsUUFBUUEsTUFBTTM5QyxLQUFLO2dCQUNuQixJQUFJO29CQUNGLElBQUksQ0FBQ29rQixTQUFTaU8sZUFBZXNyQixRQUFRLE9BQU8sQ0FBQztnQkFDL0MsRUFBRSxPQUFPajdDLE9BQU87b0JBQ2QsT0FBTyxDQUFDO2dCQUNWO1lBQ0Y7WUFDRnRCLE1BQU1rSixLQUFLVSxLQUFLO1lBQ2hCLElBQUlWLEtBQUswNkIsWUFBWSxHQUFHLFNBQVMsU0FBUzVqQyxLQUN4QyxJQUFLNkQsTUFBTSxHQUFHcUYsTUFBUUEsT0FBT2xKO2lCQUMxQjtnQkFDSCxJQUFJa0osU0FBUytqQyxjQUFjO2dCQUMzQixNQUFPLFNBQVMvakMsS0FBS1csT0FBTyxFQUFJO29CQUM5QixJQUFJLFNBQVNYLEtBQUtyRixNQUFNLElBQUlxRixLQUFLckYsTUFBTSxLQUFLb3BDLGNBQWMsT0FBTyxDQUFDO29CQUNsRS9qQyxPQUFPQSxLQUFLckYsTUFBTTtnQkFDcEI7Z0JBQ0FxRixLQUFLVyxPQUFPLENBQUNoRyxNQUFNLEdBQUdxRixLQUFLckYsTUFBTTtnQkFDakNxRixPQUFPQSxLQUFLVyxPQUFPO1lBQ3JCO1FBQ0Y7UUFDQSxPQUFPLENBQUM7SUFDVjtJQUNBLFNBQVNnd0Msa0JBQ1B4NUMsSUFBSSxFQUNKbUwsY0FBYyxFQUNkb0IsV0FBVyxFQUNYNHZDLG9CQUFvQjtRQUVwQmh4QyxrQkFBa0IsQ0FBQ2l4QztRQUNuQmp4QyxrQkFBa0IsQ0FBQ3l1QztRQUNuQjU1QyxLQUFLbUwsY0FBYyxJQUFJQTtRQUN2Qm5MLEtBQUtvTCxXQUFXLElBQUksQ0FBQ0Q7UUFDckJneEMsd0JBQXlCbjhDLENBQUFBLEtBQUtxTCxTQUFTLElBQUlGLGNBQWE7UUFDeERneEMsdUJBQXVCbjhDLEtBQUtnTixlQUFlO1FBQzNDLElBQUssSUFBSW5DLFFBQVFNLGdCQUFnQixJQUFJTixPQUFTO1lBQzVDLElBQUl2TSxRQUFRLEtBQUs0TyxNQUFNckMsUUFDckJGLE9BQU8sS0FBS3JNO1lBQ2Q2OUMsb0JBQW9CLENBQUM3OUMsTUFBTSxHQUFHLENBQUM7WUFDL0J1TSxTQUFTLENBQUNGO1FBQ1o7UUFDQSxNQUFNNEIsZUFDSmEsd0JBQXdCcE4sTUFBTXVNLGFBQWFwQjtJQUMvQztJQUNBLFNBQVM5SztRQUNQLE9BQU8sQ0FBQytkLG1CQUFvQkMsQ0FBQUEsZ0JBQWdCQyxhQUFZLENBQUMsTUFBT0MsWUFDM0RyQyxDQUFBQSw4QkFBOEIsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUN4QyxDQUFDO0lBQ1A7SUFDQSxTQUFTbWdDO1FBQ1AsSUFBSSxTQUFTMTBDLGdCQUFnQjtZQUMzQixJQUFJc1Ysa0NBQWtDcS9CLGNBQ3BDLElBQUk3UCxrQkFBa0I5a0MsZUFBZW5FLE1BQU07aUJBRTNDLGtCQUFtQm1FLGdCQUNqQjQrQiw0QkFDQWpZLG1CQUFtQm1lLGtCQUNsQjluQixrQkFBa0IsTUFDbEJELHlCQUF5QixHQUN6QituQixrQkFBa0I5a0M7WUFDdkIsTUFBTyxTQUFTOGtDLGlCQUNkRCxzQkFBc0JDLGdCQUFnQjFqQyxTQUFTLEVBQUUwakMsa0JBQzlDQSxrQkFBa0JBLGdCQUFnQmpwQyxNQUFNO1lBQzdDbUUsaUJBQWlCO1FBQ25CO0lBQ0Y7SUFDQSxTQUFTNHhDLGtCQUFrQnY1QyxJQUFJLEVBQUU2SyxLQUFLO1FBQ3BDN0ssS0FBSzRzQyxZQUFZLEdBQUc7UUFDcEI1c0MsS0FBS3NMLGFBQWEsR0FBRztRQUNyQixJQUFJNnZDLGdCQUFnQm43QyxLQUFLbTdDLGFBQWE7UUFDdENBLGtCQUFrQm9CLGFBQ2YsTUFBTXBCLGFBQWEsR0FBR29CLFdBQVlDLGNBQWNyQixjQUFhO1FBQ2hFQSxnQkFBZ0JuN0MsS0FBS21kLG1CQUFtQjtRQUN4QyxTQUFTZytCLGlCQUNOLE1BQU1oK0IsbUJBQW1CLEdBQUcsTUFBT2crQixlQUFjO1FBQ3BEa0I7UUFDQTUvQixxQkFBcUJ6YztRQUNyQjJILGlCQUFpQnd6QyxnQkFBZ0JsMUIscUJBQXFCam1CLEtBQUthLE9BQU8sRUFBRTtRQUNwRTJiLGdDQUFnQzNSO1FBQ2hDb1MsZ0NBQWdDcS9CO1FBQ2hDRyw0QkFBNEI7UUFDNUJwQyw2Q0FBNkMsQ0FBQztRQUM5Q0YsbUNBQW1DM3VDLDBCQUEwQnhMLE1BQU02SztRQUNuRTZ2QywwQ0FBMEMsQ0FBQztRQUMzQzFlLCtCQUErQkM7UUFDL0IrTyxvQ0FDRWhKLDZCQUNBb2EsZ0NBQ0F4Qyw0Q0FDQXgzQixpQ0FDRTtRQUNKdTRCLHNDQUFzQ2hlLHFDQUNwQztRQUNGcWUsb0RBQW9ELENBQUM7UUFDckQsTUFBT253QyxDQUFBQSxRQUFRLE1BQU9BLENBQUFBLFNBQVNBLFFBQVEsRUFBQztRQUN4QyxJQUFJNnhDLG9CQUFvQjE4QyxLQUFLNE0sY0FBYztRQUMzQyxJQUFJLE1BQU04dkMsbUJBQ1IsSUFDRTE4QyxPQUFPQSxLQUFLK00sYUFBYSxFQUFFMnZDLHFCQUFxQjd4QyxPQUNoRCxJQUFJNnhDLG1CQUVKO1lBQ0EsSUFBSXArQyxRQUFRLEtBQUs0TyxNQUFNd3ZDLG9CQUNyQi94QyxPQUFPLEtBQUtyTTtZQUNkdU0sU0FBUzdLLElBQUksQ0FBQzFCLE1BQU07WUFDcEJvK0MscUJBQXFCLENBQUMveEM7UUFDeEI7UUFDRndlLHVCQUF1QnRlO1FBQ3ZCb087UUFDQXlsQix3QkFBd0JpZSxzQkFBc0I7UUFDOUMsT0FBT3hCO0lBQ1Q7SUFDQSxTQUFTeUIsWUFBWTU4QyxJQUFJLEVBQUU2OEMsV0FBVztRQUNwQ2h5Qiw0QkFBNEI7UUFDNUI3a0IscUJBQXFCQyxDQUFDLEdBQUc0bUI7UUFDekI3bUIscUJBQXFCMEMsZUFBZSxHQUFHO1FBQ3ZDQyxjQUFjLENBQUM7UUFDZjlILFVBQVU7UUFDVmc4QyxnQkFBZ0IvNEIsb0JBQ1gsZUFBZUMsd0JBQ2Y5RyxnQ0FBZ0M2L0Isb0JBQW9CLElBQ3JERCxnQkFBZ0JuUywyQkFDYixlQUFlM21CLHdCQUNmOUcsZ0NBQWdDOC9CLG1CQUFtQixJQUNuRDkvQixnQ0FDQzQvQixnQkFBZ0IxWiw4QkFDWjZaLHVCQUNBLFNBQVNILGVBQ1AsYUFBYSxPQUFPQSxlQUNwQixlQUFlLE9BQU9BLFlBQVkzOUIsSUFBSSxHQUN0Qys5QixvQ0FDQUM7UUFDZFQsNEJBQTRCSTtRQUM1QixJQUFJTSxjQUFjeDFDO1FBQ2xCLElBQUksU0FBU3cxQyxhQUNYLCtCQUFnQ3ZDLGtCQUM5QnJnQixpQkFDRXY2QixNQUNBc1EsMkJBQTJCdXNDLGFBQWE3OEMsS0FBS2EsT0FBTzthQUd4RCxPQUNHczhDLFlBQVl0OUMsSUFBSSxHQUFHLEtBQ2xCcWIsNENBQTRDaWlDLGNBQzlDbnRDLDhCQUNBaU47WUFFQSxLQUFLaWdDO2dCQUNILFNBQVNydEMsMEJBQ1AsZUFDRSxPQUFPQSx1QkFBdUJ1dEMsb0JBQW9CLElBQ3BEdnRDLHVCQUF1QnV0QyxvQkFBb0IsQ0FDekNELGFBQ0FOLGFBQ0FyZ0M7Z0JBRUo7WUFDRixLQUFLVTtZQUNMLEtBQUs0L0I7WUFDTCxLQUFLRztZQUNMLEtBQUtJO2dCQUNILFNBQVN4dEMsMEJBQ1AsZUFDRSxPQUFPQSx1QkFBdUJ5dEMsc0JBQXNCLElBQ3REenRDLHVCQUF1Qnl0QyxzQkFBc0IsQ0FDM0NILGFBQ0FOLGFBQ0FyZ0M7UUFFUjtJQUNKO0lBQ0EsU0FBU2l1QjtRQUNQLElBQUkxcEMsVUFBVTZvQiwyQkFBMkIvb0IsT0FBTztRQUNoRCxPQUFPLFNBQVNFLFVBQ1osQ0FBQyxJQUNELENBQUN5YixnQ0FBZ0MsT0FBTSxNQUNyQ0EsZ0NBQ0EsU0FBU3FOLGdCQUNQLENBQUMsSUFDRCxDQUFDLElBQ0gsQ0FBQ3JOLGdDQUFnQyxRQUFPLE1BQ3BDQSxpQ0FDRixNQUFPQSxDQUFBQSxnQ0FBZ0MsU0FBUSxJQUMvQ3piLFlBQVk4b0IsZ0JBQ1osQ0FBQztJQUNYO0lBQ0EsU0FBUzB6QjtRQUNQLElBQUl4a0IsaUJBQWlCL3lCLHFCQUFxQkMsQ0FBQztRQUMzQ0QscUJBQXFCQyxDQUFDLEdBQUc0bUI7UUFDekIsT0FBTyxTQUFTa00saUJBQWlCbE0sd0JBQXdCa007SUFDM0Q7SUFDQSxTQUFTeWtCO1FBQ1AsSUFBSUMsc0JBQXNCejNDLHFCQUFxQjAzQyxDQUFDO1FBQ2hEMTNDLHFCQUFxQjAzQyxDQUFDLEdBQUdDO1FBQ3pCLE9BQU9GO0lBQ1Q7SUFDQSxTQUFTMWhCO1FBQ1BDLCtCQUErQlM7UUFDL0I0ZCw4Q0FDRyxDQUFDNzlCLGdDQUFnQyxPQUFNLE1BQ3RDQSxpQ0FDQSxTQUFTb04sMkJBQTJCL29CLE9BQU8sSUFDNUNzNUMsQ0FBQUEsbUNBQW1DLENBQUM7UUFDdEMsTUFBTy8zQixDQUFBQSxpQ0FBaUMsU0FBUSxLQUMvQyxNQUFPdzNCLENBQUFBLDRDQUE0QyxTQUFRLEtBQzNELFNBQVNuOUIsc0JBQ1QrOEIsa0JBQ0UvOEIsb0JBQ0FELCtCQUNBd2xCLDRCQUNBLENBQUM7SUFFUDtJQUNBLFNBQVNpWSxlQUFlajZDLElBQUksRUFBRTZLLEtBQUssRUFBRSt5QywwQkFBMEI7UUFDN0QsSUFBSUMsdUJBQXVCei9CO1FBQzNCQSxvQkFBb0JDO1FBQ3BCLElBQUkwYSxpQkFBaUJ3a0Isa0JBQ25CRSxzQkFBc0JEO1FBQ3hCLElBQ0UvZ0MsdUJBQXVCemMsUUFDdkJ3YyxrQ0FBa0MzUixPQUNsQztZQUNBLElBQUk0QyxtQkFBbUI7Z0JBQ3JCLElBQUlJLG1CQUFtQjdOLEtBQUs2TixnQkFBZ0I7Z0JBQzVDLElBQUlBLGlCQUFpQkMsSUFBSSxJQUN0Qit0QixDQUFBQSx1QkFBdUI3N0IsTUFBTXdjLGdDQUM5QjNPLGlCQUFpQkcsS0FBSyxFQUFDO2dCQUN6QkosNEJBQTRCNU4sTUFBTTZLO1lBQ3BDO1lBQ0Frd0MsNEJBQTRCO1lBQzVCeEIsa0JBQWtCdjVDLE1BQU02SztRQUMxQjtRQUNBb0Ysa0JBQWtCcEY7UUFDbEJBLFFBQVEsQ0FBQztRQUNUZ0QsbUJBQW1CbXVCO1FBQ25CN3lCLEdBQUcsR0FDRCxJQUFJO1lBQ0YsSUFDRThULGtDQUFrQ3EvQixnQkFDbEMsU0FBUzMwQyxnQkFDVDtnQkFDQSxJQUFJbTJDLGFBQWFuMkMsZ0JBQ2ZrMUMsY0FBY0o7Z0JBQ2hCLE9BQVF4L0I7b0JBQ04sS0FBSysvQjt3QkFDSFg7d0JBQ0F4dUMsbUJBQW1CdXNDO3dCQUNuQixNQUFNanhDO29CQUNSLEtBQUsyekM7b0JBQ0wsS0FBSzUvQjtvQkFDTCxLQUFLKy9CO3dCQUNILFNBQVNyekIsMkJBQTJCL29CLE9BQU8sSUFBS2dLLENBQUFBLFFBQVEsQ0FBQzt3QkFDekQsSUFBSTRVLFNBQVN4Qzt3QkFDYkEsZ0NBQWdDcS9CO3dCQUNoQ0csNEJBQTRCO3dCQUM1QnNCLHVCQUF1Qi85QyxNQUFNODlDLFlBQVlqQixhQUFhcDlCO3dCQUN0RCxJQUNFbStCLDhCQUNBekQsa0NBQ0E7NEJBQ0F0c0MsbUJBQW1Cb3VCOzRCQUNuQixNQUFNOXlCO3dCQUNSO3dCQUNBO29CQUNGO3dCQUNHc1csU0FBU3hDLCtCQUNQQSxnQ0FBZ0NxL0IsY0FDaENHLDRCQUE0QixNQUM3QnNCLHVCQUF1Qi85QyxNQUFNODlDLFlBQVlqQixhQUFhcDlCO2dCQUM1RDtZQUNGO1lBQ0F1K0I7WUFDQW53QyxtQkFBbUJtdUI7WUFDbkI7UUFDRixFQUFFLE9BQU9paUIsZUFBZTtZQUN0QnJCLFlBQVk1OEMsTUFBTWkrQztRQUNwQjtlQUNLLEdBQUc7UUFDVnB6QyxTQUFTN0ssS0FBSzhNLG1CQUFtQjtRQUNqQ3k1QjtRQUNBbm9CLG1CQUFtQnkvQjtRQUNuQjczQyxxQkFBcUJDLENBQUMsR0FBRzh5QjtRQUN6Qi95QixxQkFBcUIwM0MsQ0FBQyxHQUFHRDtRQUN6QnZ0QztRQUNBLFNBQVN2SSxrQkFDTixzQkFBc0IsTUFDdEI2VSxnQ0FBZ0MsR0FDakN2RCxpQ0FBZ0M7UUFDbEMsT0FBT3BMO0lBQ1Q7SUFDQSxTQUFTbXdDO1FBQ1AsTUFBTyxTQUFTcjJDLGdCQUFrQnUyQyxrQkFBa0J2MkM7SUFDdEQ7SUFDQSxTQUFTcXlDLHFCQUFxQmg2QyxJQUFJLEVBQUU2SyxLQUFLO1FBQ3ZDLElBQUlnekMsdUJBQXVCei9CO1FBQzNCQSxvQkFBb0JDO1FBQ3BCLElBQUkwYSxpQkFBaUJ3a0Isa0JBQ25CRSxzQkFBc0JEO1FBQ3hCLElBQ0UvZ0MsdUJBQXVCemMsUUFDdkJ3YyxrQ0FBa0MzUixPQUNsQztZQUNBLElBQUk0QyxtQkFBbUI7Z0JBQ3JCLElBQUlJLG1CQUFtQjdOLEtBQUs2TixnQkFBZ0I7Z0JBQzVDLElBQUlBLGlCQUFpQkMsSUFBSSxJQUN0Qit0QixDQUFBQSx1QkFBdUI3N0IsTUFBTXdjLGdDQUM5QjNPLGlCQUFpQkcsS0FBSyxFQUFDO2dCQUN6QkosNEJBQTRCNU4sTUFBTTZLO1lBQ3BDO1lBQ0Frd0MsNEJBQTRCO1lBQzVCek8scUNBQXFDMXZCLFVBQVV1aEM7WUFDL0M1RSxrQkFBa0J2NUMsTUFBTTZLO1FBQzFCLE9BQ0VzdkMsbUNBQW1DM3VDLDBCQUNqQ3hMLE1BQ0E2SztRQUVKb0Ysa0JBQWtCcEY7UUFDbEIxQixHQUFHLEdBQ0QsSUFBSTtZQUNGLElBQ0U4VCxrQ0FBa0NxL0IsZ0JBQ2xDLFNBQVMzMEMsZ0JBRVR5QixHQUFHLE9BQ0EsUUFBU3pCLGdCQUNUa0csbUJBQW1CNHVDLDJCQUNwQngvQjtnQkFFQSxLQUFLaWdDO29CQUNIamdDLGdDQUFnQ3EvQjtvQkFDaENHLDRCQUE0QjtvQkFDNUJzQix1QkFDRS85QyxNQUNBNkssT0FDQWdELGtCQUNBcXZDO29CQUVGO2dCQUNGLEtBQUtoZ0M7b0JBQ0gsSUFBSWdHLG1CQUFtQnJWLG1CQUFtQjt3QkFDeENvUCxnQ0FBZ0NxL0I7d0JBQ2hDRyw0QkFBNEI7d0JBQzVCMkIsMEJBQTBCdnpDO3dCQUMxQjtvQkFDRjtvQkFDQUEsUUFBUTt3QkFDTm9TLGtDQUFrQ0MsbUJBQ2hDVCx1QkFBdUJ6YyxRQUN0QmlkLENBQUFBLGdDQUNDb2dDLDJCQUEwQjt3QkFDOUI1aEMsc0JBQXNCemI7b0JBQ3hCO29CQUNBNk4saUJBQWlCcVIsSUFBSSxDQUFDclUsT0FBT0E7b0JBQzdCLE1BQU0xQjtnQkFDUixLQUFLMnpDO29CQUNINy9CLGdDQUFnQ29nQztvQkFDaEMsTUFBTWwwQztnQkFDUixLQUFLNHpDO29CQUNIOS9CLGdDQUNFb2hDO29CQUNGLE1BQU1sMUM7Z0JBQ1IsS0FBS2swQztvQkFDSG42QixtQkFBbUJyVixvQkFDZCxpQ0FBaUN5dUMsY0FDakNHLDRCQUE0QixNQUM3QjJCLDBCQUEwQnZ6QyxNQUFLLElBQzlCLGlDQUFpQ3l4QyxjQUNqQ0csNEJBQTRCLE1BQzdCc0IsdUJBQ0UvOUMsTUFDQTZLLE9BQ0FnRCxrQkFDQXd2Qyw0QkFDRjtvQkFDSjtnQkFDRixLQUFLZ0I7b0JBQ0gsSUFBSXpULFdBQVc7b0JBQ2YsT0FBUWpqQyxlQUFlaEksR0FBRzt3QkFDeEIsS0FBSzs0QkFDSGlyQyxXQUFXampDLGVBQWUxSixhQUFhO3dCQUN6QyxLQUFLO3dCQUNMLEtBQUs7NEJBQ0gsSUFBSXFnRCxZQUFZMzJDLGdCQUNkM0YsT0FBT3M4QyxVQUFVdDhDLElBQUksRUFDckJ3QyxRQUFRODVDLFVBQVUxK0MsWUFBWTs0QkFDaEMsSUFDRWdyQyxXQUNJRSxnQkFBZ0JGLFlBQ2hCSixnQkFBZ0J4b0MsTUFBTXdDLFFBQzFCO2dDQUNBeVksZ0NBQWdDcS9CO2dDQUNoQ0csNEJBQTRCO2dDQUM1QixJQUFJanpDLFVBQVU4MEMsVUFBVTkwQyxPQUFPO2dDQUMvQixJQUFJLFNBQVNBLFNBQVM3QixpQkFBaUI2QjtxQ0FDbEM7b0NBQ0gsSUFBSThhLGNBQWNnNkIsVUFBVTk2QyxNQUFNO29DQUNsQyxTQUFTOGdCLGNBQ0osa0JBQWtCQSxhQUNuQmk2QixtQkFBbUJqNkIsWUFBVyxJQUM3QjNjLGlCQUFpQjtnQ0FDeEI7Z0NBQ0EsTUFBTXlCOzRCQUNSOzRCQUNBO3dCQUNGOzRCQUNFbkssUUFBUWdDLEtBQUssQ0FDWDtvQkFFTjtvQkFDQWdjLGdDQUFnQ3EvQjtvQkFDaENHLDRCQUE0QjtvQkFDNUJzQix1QkFDRS85QyxNQUNBNkssT0FDQWdELGtCQUNBd3dDO29CQUVGO2dCQUNGLEtBQUtwQjtvQkFDSGhnQyxnQ0FBZ0NxL0I7b0JBQ2hDRyw0QkFBNEI7b0JBQzVCc0IsdUJBQ0UvOUMsTUFDQTZLLE9BQ0FnRCxrQkFDQW92QztvQkFFRjtnQkFDRixLQUFLRDtvQkFDSFg7b0JBQ0FyZ0IsK0JBQStCb2U7b0JBQy9CLE1BQU1qeEM7Z0JBQ1I7b0JBQ0UsTUFBTWxFLE1BQ0o7WUFFTjtZQUNGLFNBQVNlLHFCQUFxQjZWLFFBQVEsR0FDbENtaUMsaUJBQ0FRO1lBQ0o7UUFDRixFQUFFLE9BQU9DLGVBQWU7WUFDdEI3QixZQUFZNThDLE1BQU15K0M7UUFDcEI7ZUFDSyxHQUFHO1FBQ1ZsWTtRQUNBdmdDLHFCQUFxQkMsQ0FBQyxHQUFHOHlCO1FBQ3pCL3lCLHFCQUFxQjAzQyxDQUFDLEdBQUdEO1FBQ3pCci9CLG1CQUFtQnkvQjtRQUNuQixJQUFJLFNBQVNsMkMsZ0JBQ1gsT0FDRSxTQUFTa0ksMEJBQ1AsZUFBZSxPQUFPQSx1QkFBdUI2dUMsaUJBQWlCLElBQzlEN3VDLHVCQUF1QjZ1QyxpQkFBaUIsSUFDMUN6aUI7UUFFSi9yQjtRQUNBdU0scUJBQXFCO1FBQ3JCRCxnQ0FBZ0M7UUFDaEN2RDtRQUNBLE9BQU8raUI7SUFDVDtJQUNBLFNBQVN3aUI7UUFDUCxNQUFPLFNBQVM3MkMsa0JBQWtCLENBQUNnM0MsZUFDakNULGtCQUFrQnYyQztJQUN0QjtJQUNBLFNBQVN1MkMsa0JBQWtCSixVQUFVO1FBQ25DLElBQUlqOUMsVUFBVWk5QyxXQUFXLzBDLFNBQVM7UUFDakMrMEMsQ0FBQUEsV0FBV2orQyxJQUFJLEdBQUcsT0FBT3dzQixTQUNyQnZSLENBQUFBLG1CQUFtQmdqQyxhQUNuQmo5QyxVQUFVcUgsa0JBQ1Q0MUMsWUFDQTVZLFdBQ0Fya0MsU0FDQWk5QyxZQUNBMzBCLHVCQUVGak8sNENBQTRDNGlDLFdBQVUsSUFDckRqOUMsVUFBVXFILGtCQUNUNDFDLFlBQ0E1WSxXQUNBcmtDLFNBQ0FpOUMsWUFDQTMwQjtRQUVOMjBCLFdBQVcvbEMsYUFBYSxHQUFHK2xDLFdBQVdsK0MsWUFBWTtRQUNsRCxTQUFTaUIsVUFDTDA5QyxtQkFBbUJULGNBQ2xCbjJDLGlCQUFpQjlHO0lBQ3hCO0lBQ0EsU0FBU3U5QywwQkFBMEJOLFVBQVU7UUFDM0MsSUFBSTUvQyxPQUFPZ0ssa0JBQWtCNDFDLFlBQVljLGlCQUFpQmQ7UUFDMURBLFdBQVcvbEMsYUFBYSxHQUFHK2xDLFdBQVdsK0MsWUFBWTtRQUNsRCxTQUFTMUIsT0FBT3FnRCxtQkFBbUJULGNBQWVuMkMsaUJBQWlCeko7SUFDckU7SUFDQSxTQUFTMGdELGdCQUFnQmQsVUFBVTtRQUNqQyxJQUFJajlDLFVBQVVpOUMsV0FBVy8wQyxTQUFTLEVBQ2hDODFDLGtCQUFrQixDQUFDZixXQUFXaitDLElBQUksR0FBRyxPQUFPd3NCO1FBQzlDd3lCLG1CQUFtQi9qQyxtQkFBbUJnakM7UUFDdEMsT0FBUUEsV0FBV24rQyxHQUFHO1lBQ3BCLEtBQUs7WUFDTCxLQUFLO2dCQUNIa0IsVUFBVWkrQix3QkFDUmorQixTQUNBaTlDLFlBQ0FBLFdBQVdsK0MsWUFBWSxFQUN2QmsrQyxXQUFXOTdDLElBQUksRUFDZixLQUFLLEdBQ0x3YTtnQkFFRjtZQUNGLEtBQUs7Z0JBQ0gzYixVQUFVaStCLHdCQUNSaitCLFNBQ0FpOUMsWUFDQUEsV0FBV2wrQyxZQUFZLEVBQ3ZCaytDLFdBQVc5N0MsSUFBSSxDQUFDZ0IsTUFBTSxFQUN0Qjg2QyxXQUFXajVCLEdBQUcsRUFDZHJJO2dCQUVGO1lBQ0YsS0FBSztnQkFDSDhSLG1CQUFtQnd2QjtZQUNyQjtnQkFDRXRSLHNCQUFzQjNyQyxTQUFTaTlDLGFBQzVCQSxhQUFhbjJDLGlCQUNaMGtDLG9CQUFvQnlSLFlBQVkzMEIsdUJBQ2pDdG9CLFVBQVVxa0MsVUFBVXJrQyxTQUFTaTlDLFlBQVkzMEI7UUFDaEQ7UUFDQTAxQixtQkFDRTNqQyw0Q0FBNEM0aUM7UUFDOUMsT0FBT2o5QztJQUNUO0lBQ0EsU0FBU2s5Qyx1QkFDUC85QyxJQUFJLEVBQ0o4OUMsVUFBVSxFQUNWakIsV0FBVyxFQUNYaUMsZUFBZTtRQUVmdlk7UUFDQWpZLG1CQUFtQnd2QjtRQUNuQm41QixrQkFBa0I7UUFDbEJELHlCQUF5QjtRQUN6QixJQUFJSixjQUFjdzVCLFdBQVd0NkMsTUFBTTtRQUNuQyxJQUFJO1lBQ0YsSUFDRW00QixlQUNFMzdCLE1BQ0Fza0IsYUFDQXc1QixZQUNBakIsYUFDQXJnQyxnQ0FFRjtnQkFDQXdmLCtCQUErQjRlO2dCQUMvQnJnQixpQkFDRXY2QixNQUNBc1EsMkJBQTJCdXNDLGFBQWE3OEMsS0FBS2EsT0FBTztnQkFFdEQ4RyxpQkFBaUI7Z0JBQ2pCO1lBQ0Y7UUFDRixFQUFFLE9BQU8xRyxPQUFPO1lBQ2QsSUFBSSxTQUFTcWpCLGFBQWEsTUFBTyxpQkFBa0JBLGFBQWNyakI7WUFDakUrNkIsK0JBQStCNGU7WUFDL0JyZ0IsaUJBQ0V2NkIsTUFDQXNRLDJCQUEyQnVzQyxhQUFhNzhDLEtBQUthLE9BQU87WUFFdEQ4RyxpQkFBaUI7WUFDakI7UUFDRjtRQUNBLElBQUltMkMsV0FBVzkwQyxLQUFLLEdBQUcsT0FBTztZQUM1QixJQUFJNkksZUFBZWl0QyxvQkFBb0I1QixrQkFBa0JsOUMsT0FBTyxDQUFDO2lCQUM1RCxJQUNIbTZDLG9DQUNBLE1BQU8zOUIsQ0FBQUEsZ0NBQWdDLFNBQVEsR0FFL0N4YyxPQUFPLENBQUM7aUJBQ0wsSUFDRiw2Q0FBOENBLE9BQU8sQ0FBQyxHQUN2RDgrQyxvQkFBb0I1aEMsbUJBQ2xCNGhDLG9CQUFvQmhDLHdCQUNwQmdDLG9CQUFvQjdCLG1DQUV0QixrQkFBbUJyekIsMkJBQTJCL29CLE9BQU8sRUFDbkQsU0FBU2krQyxtQkFDUCxPQUFPQSxnQkFBZ0JuL0MsR0FBRyxJQUN6Qm0vQyxDQUFBQSxnQkFBZ0I5MUMsS0FBSyxJQUFJLEtBQUk7WUFDcEMrMUMsaUJBQWlCakIsWUFBWTk5QztRQUMvQixPQUFPdStDLG1CQUFtQlQ7SUFDNUI7SUFDQSxTQUFTUyxtQkFBbUJULFVBQVU7UUFDcEMsSUFBSWhWLGdCQUFnQmdWO1FBQ3BCLEdBQUc7WUFDRCxJQUFJLE1BQU9oVixDQUFBQSxjQUFjOS9CLEtBQUssR0FBRyxLQUFJLEdBQUk7Z0JBQ3ZDKzFDLGlCQUNFalcsZUFDQXVSO2dCQUVGO1lBQ0Y7WUFDQSxJQUFJeDVDLFVBQVVpb0MsY0FBYy8vQixTQUFTO1lBQ3JDKzBDLGFBQWFoVixjQUFjdGxDLE1BQU07WUFDakNzWCxtQkFBbUJndUI7WUFDbkJqb0MsVUFBVXFILGtCQUNSNGdDLGVBQ0E2QyxjQUNBOXFDLFNBQ0Fpb0MsZUFDQTNmO1lBRUQyZixDQUFBQSxjQUFjanBDLElBQUksR0FBRyxPQUFPd3NCLFVBQzNCaFIsc0RBQXNEeXRCO1lBQ3hELElBQUksU0FBU2pvQyxTQUFTO2dCQUNwQjhHLGlCQUFpQjlHO2dCQUNqQjtZQUNGO1lBQ0Fpb0MsZ0JBQWdCQSxjQUFjdC9CLE9BQU87WUFDckMsSUFBSSxTQUFTcy9CLGVBQWU7Z0JBQzFCbmhDLGlCQUFpQm1oQztnQkFDakI7WUFDRjtZQUNBbmhDLGlCQUFpQm1oQyxnQkFBZ0JnVjtRQUNuQyxRQUFTLFNBQVNoVixlQUFlO1FBQ2pDOU0saUNBQWlDQyxrQkFDOUJELENBQUFBLCtCQUErQjZlLGFBQVk7SUFDaEQ7SUFDQSxTQUFTa0UsaUJBQWlCakIsVUFBVSxFQUFFa0IsWUFBWTtRQUNoRCxHQUFHO1lBQ0QsSUFBSTlnRCxPQUFPcXVDLFdBQVd1UixXQUFXLzBDLFNBQVMsRUFBRSswQztZQUM1QyxJQUFJLFNBQVM1L0MsTUFBTTtnQkFDakJBLEtBQUs4SyxLQUFLLElBQUk7Z0JBQ2RyQixpQkFBaUJ6SjtnQkFDakI7WUFDRjtZQUNBLElBQUksQ0FBQzQvQyxXQUFXaitDLElBQUksR0FBRyxPQUFPd3NCLFFBQVE7Z0JBQ3BDaFIsc0RBQXNEeWlDO2dCQUN0RDUvQyxPQUFPNC9DLFdBQVczaUMsY0FBYztnQkFDaEMsSUFBSyxJQUFJNVIsUUFBUXUwQyxXQUFXdjBDLEtBQUssRUFBRSxTQUFTQSxPQUMxQyxRQUFTQSxNQUFNNFIsY0FBYyxFQUFJNVIsUUFBUUEsTUFBTUMsT0FBTztnQkFDeERzMEMsV0FBVzNpQyxjQUFjLEdBQUdqZDtZQUM5QjtZQUNBQSxPQUFPNC9DLFdBQVd0NkMsTUFBTTtZQUN4QixTQUFTdEYsUUFDTixNQUFNOEssS0FBSyxJQUFJLE9BQ2Y5SyxLQUFLcWxDLFlBQVksR0FBRyxHQUNwQnJsQyxLQUFLeW5CLFNBQVMsR0FBRyxJQUFJO1lBQ3hCLElBQ0UsQ0FBQ3E1QixnQkFDQSxjQUFjbEIsV0FBV3QwQyxPQUFPLEVBQUcsU0FBU3MwQyxVQUFTLEdBQ3REO2dCQUNBbjJDLGlCQUFpQm0yQztnQkFDakI7WUFDRjtZQUNBbjJDLGlCQUFpQm0yQyxhQUFhNS9DO1FBQ2hDLFFBQVMsU0FBUzQvQyxZQUFZO1FBQzlCOWhCLCtCQUErQm9lO1FBQy9CenlDLGlCQUFpQjtJQUNuQjtJQUNBLFNBQVNtekMsV0FDUDk2QyxJQUFJLEVBQ0p5N0MsaUJBQWlCLEVBQ2pCcGYsV0FBVyxFQUNYcWYsMkJBQTJCLEVBQzNCbnZDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxtQkFBbUIsRUFDbkJtdkMscUJBQXFCLEVBQ3JCQyx3QkFBd0IsRUFDeEJDLHNCQUFzQjtRQUV0QixJQUFJcm9CLGlCQUFpQnp0QixxQkFBcUJzdEIsQ0FBQyxFQUN6QzJyQiw2QkFBNkJob0I7UUFDL0IsSUFBSTtZQUNGQyx5QkFBeUIsSUFDdEJseEIscUJBQXFCc3RCLENBQUMsR0FBRyxNQUMxQjRyQixlQUNFbC9DLE1BQ0F5N0MsbUJBQ0FwZixhQUNBcWYsNkJBQ0F1RCw0QkFDQTF5QyxhQUNBQyxjQUNBQyxxQkFDQW12Qyx1QkFDQUMsMEJBQ0FDO1FBRU4sU0FBVTtZQUNQOTFDLHFCQUFxQnN0QixDQUFDLEdBQUdHLGdCQUN4QnlELHlCQUF5QituQjtRQUM3QjtJQUNGO0lBQ0EsU0FBU0MsZUFDUGwvQyxJQUFJLEVBQ0p5N0MsaUJBQWlCLEVBQ2pCcGYsV0FBVyxFQUNYcWYsMkJBQTJCLEVBQzNCeUQsbUJBQW1CLEVBQ25CNXlDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxtQkFBbUI7UUFFbkIsR0FBRzlMO2VBQ0ksU0FBU3krQywrQkFBK0I7UUFDL0MxZ0Isd0JBQXdCMmdCLHlCQUF5QjtRQUNqRDNnQix3QkFBd0I0Z0IsbUNBQW1DO1FBQzNELElBQUksQ0FBQ2xoQyxtQkFBb0JDLENBQUFBLGdCQUFnQkMsYUFBWSxDQUFDLE1BQU9DLFdBQzNELE1BQU10WixNQUFNO1FBQ2QsSUFBSTJuQyxlQUFlNXNDLEtBQUs0c0MsWUFBWTtRQUNwQzhPLDhCQUE4QjE3QyxLQUFLc0wsYUFBYTtRQUNoRCxTQUFTdUUsMEJBQ1AsZUFBZSxPQUFPQSx1QkFBdUIwdkMsaUJBQWlCLElBQzlEMXZDLHVCQUF1QjB2QyxpQkFBaUIsQ0FBQzdEO1FBQzNDLElBQUksU0FBUzlPLGNBQWMsT0FBTzk4QixxQkFBcUI7UUFDdkQsTUFBTTRyQywrQkFDSno4QyxRQUFRZ0MsS0FBSyxDQUNYO1FBRUpqQixLQUFLNHNDLFlBQVksR0FBRztRQUNwQjVzQyxLQUFLc0wsYUFBYSxHQUFHO1FBQ3JCLElBQUlzaEMsaUJBQWlCNXNDLEtBQUthLE9BQU8sRUFDL0IsTUFBTW9FLE1BQ0o7UUFFSmpGLEtBQUtnZCxZQUFZLEdBQUc7UUFDcEJoZCxLQUFLcWQsZ0JBQWdCLEdBQUc7UUFDeEJyZCxLQUFLbWQsbUJBQW1CLEdBQUc7UUFDM0IsSUFBSTdRLGlCQUFpQnNnQyxhQUFhL2hDLEtBQUssR0FBRytoQyxhQUFhN3lCLFVBQVU7UUFDakV6TixrQkFBa0I4TTtRQUNsQi9NLGlCQUNFck0sTUFDQTA3Qyw2QkFDQXB2QyxnQkFDQUMsYUFDQUMsY0FDQUM7UUFFRnpNLFNBQVN5YyxzQkFDTixrQkFBa0JBLHFCQUFxQixNQUN2Q0QsZ0NBQWdDLENBQUM7UUFDbkMsTUFBT293QixDQUFBQSxhQUFhckosWUFBWSxHQUFHLEtBQUksS0FDdEMsTUFBT3FKLENBQUFBLGFBQWE1akMsS0FBSyxHQUFHLEtBQUksS0FDaEN3MkMsOEJBQ0MsOEJBQThCLENBQUMsR0FDL0JDLHNDQUFzQ256QyxnQkFDdENvekMsNEJBQTRCcmpCLGFBQzdCc2pCLGlCQUFpQnZ3QyxrQkFBa0I7WUFDakN6TyxvQkFBb0IsQ0FBQztZQUNyQixPQUFPO1FBQ1QsRUFBQztRQUNId3VDLGtCQUFrQm4wQjtRQUNsQnFoQixjQUFjLE1BQU91USxDQUFBQSxhQUFhNWpDLEtBQUssR0FBRyxLQUFJO1FBQzlDLE1BQU80akMsQ0FBQUEsYUFBYXJKLFlBQVksR0FBRyxLQUFJLEtBQU1sSCxjQUN4QyxlQUFlcjJCLHFCQUFxQnN0QixDQUFDLEVBQ3JDdHRCLHFCQUFxQnN0QixDQUFDLEdBQUcsTUFDekIvbUIsY0FBYzBxQiw0QkFDZkMseUJBQXlCLElBQ3hCMXFCLGVBQWU0UixrQkFDZkEsb0JBQW9CRSxlQUNyQnN5Qiw0QkFBNEI1d0MsTUFBTTRzQyxlQUNsQytHLHNCQUNFM3pDLE1BQ0E0c0MsY0FDQThPLDhCQUVGa0UsaUJBQWlCNS9DLEtBQUttbkIsYUFBYSxHQUNsQ25uQixLQUFLYSxPQUFPLEdBQUcrckMsY0FDaEIsU0FBUy84QiwwQkFDUCxlQUNFLE9BQU9BLHVCQUF1Qmd3Qyx3QkFBd0IsSUFDeERod0MsdUJBQXVCZ3dDLHdCQUF3QixDQUM3Q25FLDhCQUVKbkcsb0JBQW9CM0ksY0FBYzVzQyxNQUFNMDdDLDhCQUN4QyxTQUFTN3JDLDBCQUNQLGVBQ0UsT0FBT0EsdUJBQXVCaXdDLHdCQUF3QixJQUN4RGp3Qyx1QkFBdUJpd0Msd0JBQXdCLElBQ2pEQyxnQkFDQzNoQyxtQkFBbUI1UixjQUNwQjBxQix5QkFBeUIzcUIsY0FDeEJ2RyxxQkFBcUJzdEIsQ0FBQyxHQUFHK0ksV0FBVyxJQUNwQ3I4QixLQUFLYSxPQUFPLEdBQUcrckM7UUFDbkJ2USxDQUFBQSxjQUFjbWpCLDBCQUF5QixJQUNuQyw4QkFBOEIsQ0FBQyxHQUMvQkosZ0NBQWdDcC9DLE1BQ2hDZ2dELDZCQUE2QnRFLDJCQUEyQixJQUN4RHVFLENBQUFBLHVCQUF1QmpnRCxNQUFNc00saUJBQzdCNk4sMkJBQTJCLEdBQzNCQywrQkFBK0IsSUFBSTtRQUN4QzlOLGlCQUFpQnRNLEtBQUtpTCxZQUFZO1FBQ2xDLE1BQU1xQixrQkFBbUJtdkIsQ0FBQUEseUNBQXlDLElBQUc7UUFDckVZLGVBQWU2akIsK0JBQStCbGdEO1FBQzlDNk8sZUFBZSs5QixhQUFhampDLFNBQVMsRUFBRXcxQztRQUN2QzF4QyxxQkFBcUJ6TixLQUFLNk4sZ0JBQWdCLENBQUNHLEtBQUs7UUFDaEQ2cUM7UUFDQXA5QixzQkFBc0J6YjtRQUN0QixJQUFJLFNBQVN5N0MsbUJBQ1gsSUFDRTBELHNCQUFzQm4vQyxLQUFLbWdELGtCQUFrQixFQUFFdlQsZUFBZSxHQUM5REEsZUFBZTZPLGtCQUFrQmo5QyxNQUFNLEVBQ3ZDb3VDLGVBRUEsaUJBQWtCNk8saUJBQWlCLENBQUM3TyxhQUFhLEVBQzlDdlEsY0FBYytqQixjQUFjOXpDLGVBQWVuSCxLQUFLLEdBQ2pEK0Msa0JBQ0VvRSxlQUFlaUUsTUFBTSxFQUNyQjR1QyxxQkFDQTd5QyxlQUFlL04sS0FBSyxFQUNwQjg5QjtRQUVSLE1BQU8yakIsQ0FBQUEsNkJBQTZCLE1BQU1yL0M7UUFDMUMyTCxpQkFBaUJ0TSxLQUFLaUwsWUFBWTtRQUNsQyxNQUFPeXdDLENBQUFBLDhCQUE4QixPQUFNLEtBQzNDLE1BQU9wdkMsQ0FBQUEsaUJBQWlCLEVBQUMsSUFDcEIseUJBQXlCLENBQUMsR0FDM0J0TSxTQUFTcWEsd0JBQ0xKLHNCQUNDLHFCQUFxQixHQUFLSSx3QkFBd0JyYSxJQUFJLENBQUMsSUFDM0RpYSxvQkFBb0I7UUFDekJpQyw4QkFBOEIsR0FBRyxDQUFDO1FBQ2xDcE07UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTc3dDLGNBQWN4bEIsY0FBYztRQUNuQ0EsaUJBQWlCO1lBQUVBLGdCQUFnQkE7UUFBZTtRQUNsRGgyQixPQUFPeUIsY0FBYyxDQUFDdTBCLGdCQUFnQixVQUFVO1lBQzlDLzBCLEtBQUs7Z0JBQ0g1RyxRQUFRZ0MsS0FBSyxDQUNYO1lBRUo7UUFDRjtRQUNBLE9BQU8yNUI7SUFDVDtJQUNBLFNBQVNxbEIsdUJBQXVCamdELElBQUksRUFBRXNNLGNBQWM7UUFDbEQsTUFBT3RNLENBQUFBLEtBQUtzbUMsZ0JBQWdCLElBQUloNkIsY0FBYSxLQUMxQyxrQkFBa0J0TSxLQUFLb21DLFdBQVcsRUFDbkMsUUFBUTk1QixrQkFDTCxNQUFNODVCLFdBQVcsR0FBRyxNQUFPK0IsYUFBYTc3QixlQUFjLENBQUM7SUFDOUQ7SUFDQSxTQUFTM0w7UUFDUCxJQUFJLFNBQVN5K0MsK0JBQStCO1lBQzFDLElBQUlwL0MsT0FBT28vQywrQkFDVDl5QyxpQkFBaUJtekM7WUFDbkJBLHNDQUFzQztZQUN0QyxJQUFJWSxpQkFBaUJweUMscUJBQXFCK3hDLDZCQUN4Q00sV0FBVyxLQUFLRCxpQkFBaUIsS0FBS0E7WUFDeENBLGlCQUFpQnI2QyxxQkFBcUJzdEIsQ0FBQztZQUN2QyxJQUFJMEQsbUJBQW1CQztZQUN2QixJQUFJO2dCQUNGQyx5QkFBeUJvcEI7Z0JBQ3pCdDZDLHFCQUFxQnN0QixDQUFDLEdBQUc7Z0JBQ3pCLElBQUksU0FBUzhyQiwrQkFDWCxJQUFJcjNDLDJCQUEyQixDQUFDO3FCQUM3QjtvQkFDSHU0QyxXQUFXWjtvQkFDWEEsNEJBQTRCO29CQUM1QixJQUFJM0wsZ0JBQWdCcUwsK0JBQ2xCdjBDLFFBQVFtMUM7b0JBQ1ZaLGdDQUFnQztvQkFDaENZLDZCQUE2QjtvQkFDN0IsSUFDRSxDQUFDNWhDLG1CQUFvQkMsQ0FBQUEsZ0JBQWdCQyxhQUFZLENBQUMsTUFDbERDLFdBRUEsTUFBTXRaLE1BQ0o7b0JBRUpvMEMsMkJBQTJCLENBQUM7b0JBQzVCQyx3Q0FBd0MsQ0FBQztvQkFDekMsU0FBU3pwQywwQkFDUCxlQUNFLE9BQU9BLHVCQUF1QjB3Qyx5QkFBeUIsSUFDekQxd0MsdUJBQXVCMHdDLHlCQUF5QixDQUFDMTFDO29CQUNuRCxJQUFJZ3pDLHVCQUF1QnovQjtvQkFDM0JBLG9CQUFvQkU7b0JBQ3BCeTRCLDRCQUE0QmhELGNBQWNsekMsT0FBTztvQkFDakRtMUMsMEJBQ0VqQyxlQUNBQSxjQUFjbHpDLE9BQU8sRUFDckJnSyxPQUNBeTFDO29CQUVGLFNBQVN6d0MsMEJBQ1AsZUFDRSxPQUFPQSx1QkFBdUIyd0MseUJBQXlCLElBQ3pEM3dDLHVCQUF1QjJ3Qyx5QkFBeUI7b0JBQ2xETiwrQkFBK0JuTTtvQkFDL0IzMUIsbUJBQW1CeS9CO29CQUNuQjNoQyw4QkFBOEIsR0FBRyxDQUFDO29CQUNsQ285Qix3Q0FDSXZGLGtCQUFrQjM1QiwrQkFDaEJELDZCQUNDLDRCQUE0QixHQUM1QkMsK0JBQStCMjVCLGFBQWEsSUFDOUM1NUIsMkJBQTJCO29CQUNoQ20vQix3Q0FBd0NELDJCQUN0QyxDQUFDO29CQUNILElBQ0UzcUMsZ0JBQ0EsZUFBZSxPQUFPQSxhQUFhK3hDLHFCQUFxQixFQUV4RCxJQUFJO3dCQUNGL3hDLGFBQWEreEMscUJBQXFCLENBQUNqeUMsWUFBWXVsQztvQkFDakQsRUFBRSxPQUFPcGxDLEtBQUs7d0JBQ1pXLGtCQUNHLGtCQUFrQixDQUFDLEdBQ3BCclEsUUFBUWdDLEtBQUssQ0FDWCxrREFDQTBOLElBQ0Y7b0JBQ0o7b0JBQ0YsSUFBSWhGLFlBQVlvcUMsY0FBY2x6QyxPQUFPLENBQUM4SSxTQUFTO29CQUMvQ0EsVUFBVW83QixjQUFjLEdBQUc7b0JBQzNCcDdCLFVBQVVxN0IscUJBQXFCLEdBQUc7b0JBQ2xDajlCLDJCQUEyQixDQUFDO2dCQUM5QjtnQkFDQSxPQUFPQTtZQUNULFNBQVU7Z0JBQ1JtdkIseUJBQXlCRixtQkFDdEJoeEIscUJBQXFCc3RCLENBQUMsR0FBRytzQixnQkFDMUJKLHVCQUF1QmpnRCxNQUFNc007WUFDakM7UUFDRjtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBQ0EsU0FBU28wQyw4QkFBOEJDLFNBQVMsRUFBRTltQyxXQUFXLEVBQUU1WSxLQUFLO1FBQ2xFNFksY0FBY3ZKLDJCQUEyQnJQLE9BQU80WTtRQUNoREEsY0FBY3NoQixzQkFBc0J3bEIsVUFBVWgzQyxTQUFTLEVBQUVrUSxhQUFhO1FBQ3RFOG1DLFlBQVlyZ0MsY0FBY3FnQyxXQUFXOW1DLGFBQWE7UUFDbEQsU0FBUzhtQyxhQUNOeDBDLENBQUFBLGtCQUFrQncwQyxXQUFXLElBQUlsbEMsc0JBQXNCa2xDLFVBQVM7SUFDckU7SUFDQSxTQUFTL1Msd0JBQ1AvekIsV0FBVyxFQUNYa3pCLHNCQUFzQixFQUN0QjlyQyxLQUFLO1FBRUxxc0MsMkJBQTJCLENBQUM7UUFDNUIsSUFBSSxNQUFNenpCLFlBQVlsYSxHQUFHLEVBQ3ZCK2dELDhCQUE4QjdtQyxhQUFhQSxhQUFhNVk7YUFDckQ7WUFDSCxNQUFPLFNBQVM4ckMsd0JBQTBCO2dCQUN4QyxJQUFJLE1BQU1BLHVCQUF1QnB0QyxHQUFHLEVBQUU7b0JBQ3BDK2dELDhCQUNFM1Qsd0JBQ0FsekIsYUFDQTVZO29CQUVGO2dCQUNGO2dCQUNBLElBQUksTUFBTThyQyx1QkFBdUJwdEMsR0FBRyxFQUFFO29CQUNwQyxJQUFJbWlCLFdBQVdpckIsdUJBQXVCcGpDLFNBQVM7b0JBQy9DLElBQ0UsZUFDRSxPQUFPb2pDLHVCQUF1Qi9xQyxJQUFJLENBQUNzNUIsd0JBQXdCLElBQzVELGVBQWUsT0FBT3haLFNBQVMwWixpQkFBaUIsSUFDOUMsVUFBU0MsMENBQ1IsQ0FBQ0EsdUNBQXVDMXRCLEdBQUcsQ0FBQytULFNBQVEsR0FDeEQ7d0JBQ0FqSSxjQUFjdkosMkJBQTJCclAsT0FBTzRZO3dCQUNoRDVZLFFBQVFtNkIsdUJBQXVCO3dCQUMvQnRaLFdBQVd4QixjQUFjeXNCLHdCQUF3QjlyQyxPQUFPO3dCQUN4RCxTQUFTNmdCLFlBQ051WixDQUFBQSwyQkFDQ3A2QixPQUNBNmdCLFVBQ0FpckIsd0JBQ0FsekIsY0FFRjFOLGtCQUFrQjJWLFVBQVUsSUFDNUJyRyxzQkFBc0JxRyxTQUFRO3dCQUNoQztvQkFDRjtnQkFDRjtnQkFDQWlyQix5QkFBeUJBLHVCQUF1QnZwQyxNQUFNO1lBQ3hEO1lBQ0F2RSxRQUFRZ0MsS0FBSyxDQUNYLDJSQUNBQTtRQUVKO0lBQ0Y7SUFDQSxTQUFTbTdCLG1CQUFtQnA4QixJQUFJLEVBQUVzekMsUUFBUSxFQUFFem9DLEtBQUs7UUFDL0MsSUFBSSsxQyxZQUFZNWdELEtBQUs0Z0QsU0FBUztRQUM5QixJQUFJLFNBQVNBLFdBQVc7WUFDdEJBLFlBQVk1Z0QsS0FBSzRnRCxTQUFTLEdBQUcsSUFBSUM7WUFDakMsSUFBSUMsWUFBWSxJQUFJNTRCO1lBQ3BCMDRCLFVBQVV0L0MsR0FBRyxDQUFDZ3lDLFVBQVV3TjtRQUMxQixPQUNFLFlBQWFGLFVBQVUvNkMsR0FBRyxDQUFDeXRDLFdBQ3pCLEtBQUssTUFBTXdOLGFBQ1IsYUFBYSxJQUFJNTRCLE9BQVEwNEIsVUFBVXQvQyxHQUFHLENBQUNneUMsVUFBVXdOLFVBQVM7UUFDakVBLFVBQVUveUMsR0FBRyxDQUFDbEQsVUFDWCwyQ0FBMkMsQ0FBQyxHQUM3Q2kyQyxVQUFVbnpDLEdBQUcsQ0FBQzlDLFFBQ2IrMUMsWUFBWUcsa0JBQWtCdmpDLElBQUksQ0FBQyxNQUFNeGQsTUFBTXN6QyxVQUFVem9DLFFBQzFENEMscUJBQXFCb3VCLHVCQUF1Qjc3QixNQUFNNkssUUFDbER5b0MsU0FBU3AwQixJQUFJLENBQUMwaEMsV0FBV0EsVUFBUztJQUN0QztJQUNBLFNBQVNHLGtCQUFrQi9nRCxJQUFJLEVBQUVzekMsUUFBUSxFQUFFbG9DLFdBQVc7UUFDcEQsSUFBSXcxQyxZQUFZNWdELEtBQUs0Z0QsU0FBUztRQUM5QixTQUFTQSxhQUFhQSxVQUFVcnFDLE1BQU0sQ0FBQys4QjtRQUN2Q3R6QyxLQUFLb0wsV0FBVyxJQUFJcEwsS0FBS21MLGNBQWMsR0FBR0M7UUFDMUNwTCxLQUFLcUwsU0FBUyxJQUFJLENBQUNEO1FBQ25CNHRDLGdDQUNFLFNBQVNoekMscUJBQXFCNlYsUUFBUSxJQUN0QzVjLFFBQVFnQyxLQUFLLENBQ1g7UUFFSndiLHVCQUF1QnpjLFFBQ3JCLENBQUN3YyxnQ0FBZ0NwUixXQUFVLE1BQU9BLGVBQ2pENHdCLENBQUFBLGlDQUFpQ1MsMEJBQ2pDVCxpQ0FBaUNFLGlCQUNoQyxDQUFDMWYsZ0NBQWdDLFFBQU8sTUFDdENBLGlDQUNGSSxVQUFVazRCLCtCQUErQm9HLHVCQUN2QyxDQUFDOThCLG1CQUFtQkMsYUFBWSxNQUFPRSxhQUN2Q2c3QixrQkFBa0J2NUMsTUFBTSxLQUN2Qm84QyxpQ0FBaUNoeEMsYUFDdEM0L0Isc0NBQXNDeHVCLGlDQUNuQ3d1QixDQUFBQSxvQ0FBb0MsRUFBQztRQUMxQ3Z2QixzQkFBc0J6YjtJQUN4QjtJQUNBLFNBQVNnaEQsc0JBQXNCQyxhQUFhLEVBQUV0ZSxTQUFTO1FBQ3JELE1BQU1BLGFBQWNBLENBQUFBLFlBQVk3MkIsb0JBQW1CO1FBQ25EbTFDLGdCQUFnQnJuQywrQkFBK0JxbkMsZUFBZXRlO1FBQzlELFNBQVNzZSxpQkFDTjkwQyxDQUFBQSxrQkFBa0I4MEMsZUFBZXRlLFlBQ2xDbG5CLHNCQUFzQndsQyxjQUFhO0lBQ3ZDO0lBQ0EsU0FBUzdkLGdDQUFnQzZkLGFBQWE7UUFDcEQsSUFBSUMsZ0JBQWdCRCxjQUFjaGpELGFBQWEsRUFDN0Mwa0MsWUFBWTtRQUNkLFNBQVN1ZSxpQkFBa0J2ZSxDQUFBQSxZQUFZdWUsY0FBY3ZlLFNBQVM7UUFDOURxZSxzQkFBc0JDLGVBQWV0ZTtJQUN2QztJQUNBLFNBQVM2USxxQkFBcUJ5TixhQUFhLEVBQUUzTixRQUFRO1FBQ25ELElBQUkzUSxZQUFZO1FBQ2hCLE9BQVFzZSxjQUFjdGhELEdBQUc7WUFDdkIsS0FBSztnQkFDSCxJQUFJc3pDLGFBQWFnTyxjQUFjdDNDLFNBQVM7Z0JBQ3hDLElBQUl1M0MsZ0JBQWdCRCxjQUFjaGpELGFBQWE7Z0JBQy9DLFNBQVNpakQsaUJBQWtCdmUsQ0FBQUEsWUFBWXVlLGNBQWN2ZSxTQUFTO2dCQUM5RDtZQUNGLEtBQUs7Z0JBQ0hzUSxhQUFhZ08sY0FBY3QzQyxTQUFTO2dCQUNwQztZQUNGLEtBQUs7Z0JBQ0hzcEMsYUFBYWdPLGNBQWN0M0MsU0FBUyxDQUFDd3BDLFdBQVc7Z0JBQ2hEO1lBQ0Y7Z0JBQ0UsTUFBTWx1QyxNQUNKO1FBRU47UUFDQSxTQUFTZ3VDLGNBQWNBLFdBQVcxOEIsTUFBTSxDQUFDKzhCO1FBQ3pDME4sc0JBQXNCQyxlQUFldGU7SUFDdkM7SUFDQSxTQUFTd2UsK0NBQ1BwTixhQUFhLEVBQ2J2RCxXQUFXLEVBQ1g0USxjQUFjO1FBRWQsSUFBSSxNQUFPNVEsQ0FBQUEsWUFBWWpOLFlBQVksR0FBRyxRQUFPLEdBQzNDLElBQUtpTixjQUFjQSxZQUFZam5DLEtBQUssRUFBRSxTQUFTaW5DLGFBQWU7WUFDNUQsSUFBSXh3QyxPQUFPK3pDLGVBQ1RoMkMsUUFBUXl5QyxhQUNSNlEsb0JBQW9CdGpELE1BQU1pRSxJQUFJLEtBQUtRO1lBQ3JDNitDLG9CQUFvQkQsa0JBQWtCQztZQUN0QyxPQUFPdGpELE1BQU00QixHQUFHLEdBQ1o1QixNQUFNaUwsS0FBSyxHQUFHLFdBQ1pxNEMscUJBQ0FuNUMsa0JBQ0VuSyxPQUNBdWpELDRCQUNBdGhELE1BQ0FqQyxPQUNBLENBQUNBLE1BQU04QixJQUFJLEdBQUcsRUFBQyxNQUFPd3NCLFVBRXhCODBCLCtDQUNFbmhELE1BQ0FqQyxPQUNBc2pELHFCQUVKLFNBQVN0akQsTUFBTUUsYUFBYSxJQUMzQm9qRCxDQUFBQSxxQkFBcUJ0akQsTUFBTWlMLEtBQUssR0FBRyxPQUNoQ2Qsa0JBQ0VuSyxPQUNBdWpELDRCQUNBdGhELE1BQ0FqQyxTQUVGQSxNQUFNd2xDLFlBQVksR0FBRyxZQUNyQnI3QixrQkFDRW5LLE9BQ0FvakQsZ0RBQ0FuaEQsTUFDQWpDLE9BQ0FzakQsa0JBQ0Y7WUFDUjdRLGNBQWNBLFlBQVlobkMsT0FBTztRQUNuQztJQUNKO0lBQ0EsU0FBUzgzQywyQkFBMkJ0aEQsSUFBSSxFQUFFakMsS0FBSztRQUM3QyxJQUFJd2pELG1DQUNGLElBQUlDLFVBQVVoakQsTUFBTSxJQUFJLEtBQUssTUFBTWdqRCxTQUFTLENBQUMsRUFBRSxHQUFHQSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDcEVqeUMsMkJBQTJCLENBQUM7UUFDNUIsSUFBSTtZQUNGaW1DLHVCQUF1QnozQyxRQUNyQndqRCxvQ0FBb0N0Syx3QkFBd0JsNUMsUUFDNUQwM0Msc0JBQXNCejFDLE1BQU1qQyxNQUFNZ0wsU0FBUyxFQUFFaEwsT0FBTyxDQUFDLElBQ3JEd2pELG9DQUNFcEwsd0JBQXdCbjJDLE1BQU1qQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3JELFNBQVU7WUFDUndSLDJCQUEyQixDQUFDO1FBQzlCO0lBQ0Y7SUFDQSxTQUFTMndDLCtCQUErQmxnRCxJQUFJO1FBQzFDLElBQUl5aEQsc0JBQXNCLENBQUM7UUFDM0J6aEQsS0FBS2EsT0FBTyxDQUFDaEIsSUFBSSxHQUFHLE1BQU80aEQsQ0FBQUEsc0JBQXNCLENBQUM7UUFDbEROLCtDQUNFbmhELE1BQ0FBLEtBQUthLE9BQU8sRUFDWjRnRDtJQUVKO0lBQ0EsU0FBU2xuQyx5Q0FBeUN4YyxLQUFLO1FBQ3JELElBQUksQ0FBQ3FnQixtQkFBbUJDLGFBQVksTUFBT0UsV0FBVztZQUNwRCxJQUFJNWUsTUFBTTVCLE1BQU00QixHQUFHO1lBQ25CLElBQ0UsTUFBTUEsT0FDTixNQUFNQSxPQUNOLE1BQU1BLE9BQ04sT0FBT0EsT0FDUCxPQUFPQSxPQUNQLE9BQU9BLEtBQ1A7Z0JBQ0FBLE1BQU0yRCwwQkFBMEJ2RixVQUFVO2dCQUMxQyxJQUFJLFNBQVMyakQsNkNBQTZDO29CQUN4RCxJQUFJQSw0Q0FBNEMzekMsR0FBRyxDQUFDcE8sTUFBTTtvQkFDMUQraEQsNENBQTRDL3pDLEdBQUcsQ0FBQ2hPO2dCQUNsRCxPQUFPK2hELDhDQUE4QyxJQUFJeDVCLElBQUk7b0JBQUN2b0I7aUJBQUk7Z0JBQ2xFdUksa0JBQWtCbkssT0FBTztvQkFDdkJrQixRQUFRZ0MsS0FBSyxDQUNYO2dCQUVKO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsU0FBUzQ2Qix1QkFBdUI3N0IsSUFBSSxFQUFFNkssS0FBSztRQUN6QzRDLHFCQUNFek4sS0FBSzZOLGdCQUFnQixDQUFDck0sT0FBTyxDQUFDLFNBQVVtZ0QsZUFBZTtZQUNyRG4wQyxtQkFBbUJ4TixNQUFNMmhELGlCQUFpQjkyQztRQUM1QztJQUNKO0lBQ0EsU0FBUzgwQyxpQkFBaUJpQyxhQUFhLEVBQUV6NUMsUUFBUTtRQUMvQyxJQUFJMFQsV0FBVzdWLHFCQUFxQjZWLFFBQVE7UUFDNUMsT0FBTyxTQUFTQSxXQUNYQSxDQUFBQSxTQUFTcGEsSUFBSSxDQUFDMEcsV0FBVzA1QyxtQkFBa0IsSUFDNUNwa0MsbUJBQW1CbWtDLGVBQWV6NUM7SUFDeEM7SUFDQSxTQUFTd3hDLGtDQUFrQzU3QyxLQUFLO1FBQzlDaTdDLGdDQUNFLFNBQVNoekMscUJBQXFCNlYsUUFBUSxJQUN0QzNULGtCQUFrQm5LLE9BQU87WUFDdkJrQixRQUFRZ0MsS0FBSyxDQUNYLHlYQUNBcUMsMEJBQTBCdkY7UUFFOUI7SUFDSjtJQUNBLFNBQVN3L0IsK0JBQStCdjdCLElBQUk7UUFDMUMsSUFBSSxTQUFTeEIsZUFBZSxPQUFPd0I7UUFDbkMsSUFBSTgvQyxTQUFTdGhELGNBQWN3QjtRQUMzQixPQUFPLEtBQUssTUFBTTgvQyxTQUFTOS9DLE9BQU84L0MsT0FBT2poRCxPQUFPO0lBQ2xEO0lBQ0EsU0FBU3drQyxpQ0FBaUNyakMsSUFBSTtRQUM1QyxJQUFJLFNBQVN4QixlQUFlLE9BQU93QjtRQUNuQyxJQUFJOC9DLFNBQVN0aEQsY0FBY3dCO1FBQzNCLE9BQU8sS0FBSyxNQUFNOC9DLFNBQ2QsU0FBUzkvQyxRQUNULEtBQUssTUFBTUEsUUFDWCxlQUFlLE9BQU9BLEtBQUtnQixNQUFNLElBQ2hDLFVBQVV1NkIsK0JBQStCdjdCLEtBQUtnQixNQUFNLEdBQ3JEaEIsS0FBS2dCLE1BQU0sS0FBSzgrQyxNQUFLLElBQ2xCLFVBQVU7WUFBRTcvQyxVQUFVYTtZQUF3QkUsUUFBUTgrQztRQUFPLEdBQzlELEtBQUssTUFBTTkvQyxLQUFLRyxXQUFXLElBQ3hCMi9DLENBQUFBLE9BQU8zL0MsV0FBVyxHQUFHSCxLQUFLRyxXQUFXLEdBQ3hDMi9DLE1BQUssSUFDTDkvQyxPQUNGOC9DLE9BQU9qaEQsT0FBTztJQUNwQjtJQUNBLFNBQVNpbUIsa0NBQWtDL29CLEtBQUssRUFBRWtDLE9BQU87UUFDdkQsSUFBSSxTQUFTTyxlQUFlLE9BQU8sQ0FBQztRQUNwQyxJQUFJdWhELFdBQVdoa0QsTUFBTTZvQixXQUFXO1FBQ2hDM21CLFVBQVVBLFFBQVErQixJQUFJO1FBQ3RCLElBQUlnZ0QsdUJBQXVCLENBQUMsR0FDMUJDLG1CQUNFLGFBQWEsT0FBT2hpRCxXQUFXLFNBQVNBLFVBQ3BDQSxRQUFRZ0MsUUFBUSxHQUNoQjtRQUNSLE9BQVFsRSxNQUFNNEIsR0FBRztZQUNmLEtBQUs7Z0JBQ0gsZUFBZSxPQUFPTSxXQUFZK2hELENBQUFBLHVCQUF1QixDQUFDO2dCQUMxRDtZQUNGLEtBQUs7Z0JBQ0gsZUFBZSxPQUFPL2hELFVBQ2pCK2hELHVCQUF1QixDQUFDLElBQ3pCQyxxQkFBcUIvK0MsbUJBQ3BCOCtDLENBQUFBLHVCQUF1QixDQUFDO2dCQUM3QjtZQUNGLEtBQUs7Z0JBQ0hDLHFCQUFxQm4vQyx5QkFDaEJrL0MsdUJBQXVCLENBQUMsSUFDekJDLHFCQUFxQi8rQyxtQkFDcEI4K0MsQ0FBQUEsdUJBQXVCLENBQUM7Z0JBQzdCO1lBQ0YsS0FBSztZQUNMLEtBQUs7Z0JBQ0hDLHFCQUFxQmgvQyxrQkFDaEIrK0MsdUJBQXVCLENBQUMsSUFDekJDLHFCQUFxQi8rQyxtQkFDcEI4K0MsQ0FBQUEsdUJBQXVCLENBQUM7Z0JBQzdCO1lBQ0Y7Z0JBQ0UsT0FBTyxDQUFDO1FBQ1o7UUFDQSxPQUFPQSx3QkFDSixTQUFTeGhELGNBQWN1aEQsV0FDeEIsS0FBSyxNQUFNaGtELFNBQVNBLFVBQVV5QyxjQUFjUCxRQUFPLElBQ2pELENBQUMsSUFDRCxDQUFDO0lBQ1A7SUFDQSxTQUFTczdCLHVDQUF1Q3g5QixLQUFLO1FBQ25ELFNBQVN5QyxpQkFDUCxlQUFlLE9BQU8waEQsV0FDckIsVUFBU0Msb0JBQXFCQSxDQUFBQSxtQkFBbUIsSUFBSUQsU0FBUSxHQUM5REMsaUJBQWlCeDBDLEdBQUcsQ0FBQzVQLE1BQUs7SUFDOUI7SUFDQSxTQUFTNkMsc0NBQ1A3QyxLQUFLLEVBQ0wyQyxlQUFlLEVBQ2ZELGFBQWE7UUFFYixJQUFJc0ksWUFBWWhMLE1BQU1nTCxTQUFTLEVBQzdCUSxRQUFReEwsTUFBTXdMLEtBQUssRUFDbkJDLFVBQVV6TCxNQUFNeUwsT0FBTyxFQUN2QjdKLE1BQU01QixNQUFNNEIsR0FBRyxFQUNmcUMsT0FBT2pFLE1BQU1pRSxJQUFJLEVBQ2pCb2dELGdCQUFnQjtRQUNsQixPQUFRemlEO1lBQ04sS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIeWlELGdCQUFnQnBnRDtnQkFDaEI7WUFDRixLQUFLO2dCQUNIb2dELGdCQUFnQnBnRCxLQUFLZ0IsTUFBTTtRQUMvQjtRQUNBLElBQUksU0FBU3hDLGVBQ1gsTUFBTXlFLE1BQU07UUFDZCxJQUFJbzlDLGNBQWMsQ0FBQztRQUNuQnJnRCxPQUFPLENBQUM7UUFDUixTQUFTb2dELGlCQUNOLGlCQUFpQjVoRCxjQUFjNGhELGdCQUNoQyxLQUFLLE1BQU1BLGlCQUNSM2hELENBQUFBLGNBQWNzTixHQUFHLENBQUNxMEMsaUJBQ2RwZ0QsT0FBTyxDQUFDLElBQ1R0QixnQkFBZ0JxTixHQUFHLENBQUNxMEMsa0JBQ25CLE9BQU16aUQsTUFBT3FDLE9BQU8sQ0FBQyxJQUFNcWdELGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0RCxTQUFTRixvQkFDTkEsQ0FBQUEsaUJBQWlCcDBDLEdBQUcsQ0FBQ2hRLFVBQ25CLFNBQVNnTCxhQUFhbzVDLGlCQUFpQnAwQyxHQUFHLENBQUNoRixVQUFVLEtBQ3ZEL0csQ0FBQUEsT0FBTyxDQUFDO1FBQ1hBLFFBQVNqRSxDQUFBQSxNQUFNb25DLGtCQUFrQixHQUFHLENBQUM7UUFDckMsSUFBSW5qQyxRQUFRcWdELGFBQ1YsWUFBYXpvQywrQkFBK0I3YixPQUFPLElBQ2pELFNBQVNnTCxhQUFhb3BCLHNCQUFzQnBwQixXQUFXaEwsT0FBTztRQUNsRSxTQUFTd0wsU0FDUHZILFFBQ0FwQixzQ0FDRTJJLE9BQ0E3SSxpQkFDQUQ7UUFFSixTQUFTK0ksV0FDUDVJLHNDQUNFNEksU0FDQTlJLGlCQUNBRDtJQUVOO0lBQ0EsU0FBU1gsVUFBVUgsR0FBRyxFQUFFQyxZQUFZLEVBQUVuQixHQUFHLEVBQUVvQixJQUFJO1FBQzdDLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ2xCLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUMrSyxPQUFPLEdBQ1YsSUFBSSxDQUFDRCxLQUFLLEdBQ1YsSUFBSSxDQUFDL0YsTUFBTSxHQUNYLElBQUksQ0FBQ21HLFNBQVMsR0FDZCxJQUFJLENBQUMzSCxJQUFJLEdBQ1QsSUFBSSxDQUFDNGtCLFdBQVcsR0FDZDtRQUNKLElBQUksQ0FBQ3RvQixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUN3M0IsVUFBVSxHQUFHLElBQUksQ0FBQ2pSLEdBQUcsR0FBRztRQUM3QixJQUFJLENBQUNqbEIsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUM4c0IsWUFBWSxHQUNmLElBQUksQ0FBQ3p1QixhQUFhLEdBQ2xCLElBQUksQ0FBQzBoQixXQUFXLEdBQ2hCLElBQUksQ0FBQzVILGFBQWEsR0FDaEI7UUFDSixJQUFJLENBQUNsWSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDMGpDLFlBQVksR0FBRyxJQUFJLENBQUN2NkIsS0FBSyxHQUFHO1FBQ2pDLElBQUksQ0FBQzJjLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUM1TCxVQUFVLEdBQUcsSUFBSSxDQUFDbFAsS0FBSyxHQUFHO1FBQy9CLElBQUksQ0FBQzlCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNvUyxjQUFjLEdBQUcsQ0FBQztRQUN2QixJQUFJLENBQUNGLGVBQWUsR0FBRyxDQUFDO1FBQ3hCLElBQUksQ0FBQ3l3QixnQkFBZ0IsR0FBRyxJQUFJLENBQUN0d0IsZ0JBQWdCLEdBQUcsQ0FBQztRQUNqRCxJQUFJLENBQUNzTCxXQUFXLEdBQUcsSUFBSSxDQUFDbmpCLFVBQVUsR0FBRztRQUNyQyxJQUFJLENBQUM0aEMsa0JBQWtCLEdBQUcsQ0FBQztRQUMzQixJQUFJLENBQUNwWixlQUFlLEdBQUc7UUFDdkJ1MkIscUJBQ0UsZUFBZSxPQUFPMTlDLE9BQU8yOUMsaUJBQWlCLElBQzlDMzlDLE9BQU8yOUMsaUJBQWlCLENBQUMsSUFBSTtJQUNqQztJQUNBLFNBQVNsbEIsZ0JBQWdCelIsU0FBUztRQUNoQ0EsWUFBWUEsVUFBVXRsQixTQUFTO1FBQy9CLE9BQU8sQ0FBRSxFQUFDc2xCLGFBQWEsQ0FBQ0EsVUFBVTQyQixnQkFBZ0I7SUFDcEQ7SUFDQSxTQUFTdjhCLHFCQUFxQnBsQixPQUFPLEVBQUVqQixZQUFZO1FBQ2pELElBQUkrSCxpQkFBaUI5RyxRQUFRa0ksU0FBUztRQUN0QyxTQUFTcEIsaUJBQ0osa0JBQWtCakksWUFDakJtQixRQUFRbEIsR0FBRyxFQUNYQyxjQUNBaUIsUUFBUXBDLEdBQUcsRUFDWG9DLFFBQVFoQixJQUFJLEdBRWI4SCxlQUFlaWYsV0FBVyxHQUFHL2xCLFFBQVErbEIsV0FBVyxFQUNoRGpmLGVBQWUzRixJQUFJLEdBQUduQixRQUFRbUIsSUFBSSxFQUNsQzJGLGVBQWVnQyxTQUFTLEdBQUc5SSxRQUFROEksU0FBUyxFQUM1Q2hDLGVBQWUrZSxXQUFXLEdBQUc3bEIsUUFBUTZsQixXQUFXLEVBQ2hEL2UsZUFBZW9rQixlQUFlLEdBQUdsckIsUUFBUWtyQixlQUFlLEVBQ3hEcGtCLGVBQWVvQixTQUFTLEdBQUdsSSxTQUMzQkEsUUFBUWtJLFNBQVMsR0FBR3BCLGNBQWMsSUFDbEMsZ0JBQWdCL0gsWUFBWSxHQUFHQSxjQUMvQitILGVBQWUzRixJQUFJLEdBQUduQixRQUFRbUIsSUFBSSxFQUNsQzJGLGVBQWVxQixLQUFLLEdBQUcsR0FDdkJyQixlQUFlNDdCLFlBQVksR0FBRyxHQUM5QjU3QixlQUFlZ2UsU0FBUyxHQUFHLE1BQzNCaGUsZUFBZXdULGNBQWMsR0FBRyxDQUFDLEdBQ2pDeFQsZUFBZXNULGVBQWUsR0FBRyxDQUFDLEdBQUc7UUFDMUN0VCxlQUFlcUIsS0FBSyxHQUFHbkksUUFBUW1JLEtBQUssR0FBRztRQUN2Q3JCLGVBQWVvUyxVQUFVLEdBQUdsWixRQUFRa1osVUFBVTtRQUM5Q3BTLGVBQWVrRCxLQUFLLEdBQUdoSyxRQUFRZ0ssS0FBSztRQUNwQ2xELGVBQWU0QixLQUFLLEdBQUcxSSxRQUFRMEksS0FBSztRQUNwQzVCLGVBQWVvUSxhQUFhLEdBQUdsWCxRQUFRa1gsYUFBYTtRQUNwRHBRLGVBQWUxSixhQUFhLEdBQUc0QyxRQUFRNUMsYUFBYTtRQUNwRDBKLGVBQWVnWSxXQUFXLEdBQUc5ZSxRQUFROGUsV0FBVztRQUNoRC9mLGVBQWVpQixRQUFRNnJCLFlBQVk7UUFDbkMva0IsZUFBZStrQixZQUFZLEdBQ3pCLFNBQVM5c0IsZUFDTCxPQUNBO1lBQ0VpTCxPQUFPakwsYUFBYWlMLEtBQUs7WUFDekI4aEIsY0FBYy9zQixhQUFhK3NCLFlBQVk7WUFDdkNDLHFCQUFxQmh0QixhQUFhZ3RCLG1CQUFtQjtRQUN2RDtRQUNOamxCLGVBQWU2QixPQUFPLEdBQUczSSxRQUFRMkksT0FBTztRQUN4QzdCLGVBQWVySixLQUFLLEdBQUd1QyxRQUFRdkMsS0FBSztRQUNwQ3FKLGVBQWVrZCxHQUFHLEdBQUdoa0IsUUFBUWdrQixHQUFHO1FBQ2hDbGQsZUFBZW11QixVQUFVLEdBQUdqMUIsUUFBUWkxQixVQUFVO1FBQzlDbnVCLGVBQWV5VCxnQkFBZ0IsR0FBR3ZhLFFBQVF1YSxnQkFBZ0I7UUFDMUR6VCxlQUFlK2pDLGdCQUFnQixHQUFHN3FDLFFBQVE2cUMsZ0JBQWdCO1FBQzFEL2pDLGVBQWVwRSxVQUFVLEdBQUcxQyxRQUFRMEMsVUFBVTtRQUM5Q29FLGVBQWV3OUIsa0JBQWtCLEdBQUd0a0MsUUFBUXNrQyxrQkFBa0I7UUFDOUQsT0FBUXg5QixlQUFlaEksR0FBRztZQUN4QixLQUFLO1lBQ0wsS0FBSztnQkFDSGdJLGVBQWUzRixJQUFJLEdBQUd1N0IsK0JBQStCMThCLFFBQVFtQixJQUFJO2dCQUNqRTtZQUNGLEtBQUs7Z0JBQ0gyRixlQUFlM0YsSUFBSSxHQUFHdTdCLCtCQUErQjE4QixRQUFRbUIsSUFBSTtnQkFDakU7WUFDRixLQUFLO2dCQUNIMkYsZUFBZTNGLElBQUksR0FBR3FqQyxpQ0FBaUN4a0MsUUFBUW1CLElBQUk7UUFDdkU7UUFDQSxPQUFPMkY7SUFDVDtJQUNBLFNBQVMwa0Msb0JBQW9CMWtDLGNBQWMsRUFBRThELFdBQVc7UUFDdEQ5RCxlQUFlcUIsS0FBSyxJQUFJO1FBQ3hCLElBQUluSSxVQUFVOEcsZUFBZW9CLFNBQVM7UUFDdEMsU0FBU2xJLFVBQ0osZ0JBQWdCa1osVUFBVSxHQUFHLEdBQzdCcFMsZUFBZWtELEtBQUssR0FBR1ksYUFDdkI5RCxlQUFlNEIsS0FBSyxHQUFHLE1BQ3ZCNUIsZUFBZTQ3QixZQUFZLEdBQUcsR0FDOUI1N0IsZUFBZW9RLGFBQWEsR0FBRyxNQUMvQnBRLGVBQWUxSixhQUFhLEdBQUcsTUFDL0IwSixlQUFlZ1ksV0FBVyxHQUFHLE1BQzdCaFksZUFBZStrQixZQUFZLEdBQUcsTUFDOUIva0IsZUFBZWdDLFNBQVMsR0FBRyxNQUMzQmhDLGVBQWV5VCxnQkFBZ0IsR0FBRyxHQUNsQ3pULGVBQWUrakMsZ0JBQWdCLEdBQUcsQ0FBQyxJQUNuQyxnQkFBZ0IzeEIsVUFBVSxHQUFHbFosUUFBUWtaLFVBQVUsRUFDL0NwUyxlQUFla0QsS0FBSyxHQUFHaEssUUFBUWdLLEtBQUssRUFDcENsRCxlQUFlNEIsS0FBSyxHQUFHMUksUUFBUTBJLEtBQUssRUFDcEM1QixlQUFlNDdCLFlBQVksR0FBRyxHQUM5QjU3QixlQUFlZ2UsU0FBUyxHQUFHLE1BQzNCaGUsZUFBZW9RLGFBQWEsR0FBR2xYLFFBQVFrWCxhQUFhLEVBQ3BEcFEsZUFBZTFKLGFBQWEsR0FBRzRDLFFBQVE1QyxhQUFhLEVBQ3BEMEosZUFBZWdZLFdBQVcsR0FBRzllLFFBQVE4ZSxXQUFXLEVBQ2hEaFksZUFBZTNGLElBQUksR0FBR25CLFFBQVFtQixJQUFJLEVBQ2xDeUosY0FBYzVLLFFBQVE2ckIsWUFBWSxFQUNsQy9rQixlQUFlK2tCLFlBQVksR0FDMUIsU0FBU2poQixjQUNMLE9BQ0E7WUFDRVosT0FBT1ksWUFBWVosS0FBSztZQUN4QjhoQixjQUFjbGhCLFlBQVlraEIsWUFBWTtZQUN0Q0MscUJBQXFCbmhCLFlBQVltaEIsbUJBQW1CO1FBQ3RELEdBQ0xqbEIsZUFBZXlULGdCQUFnQixHQUFHdmEsUUFBUXVhLGdCQUFnQixFQUMxRHpULGVBQWUrakMsZ0JBQWdCLEdBQUc3cUMsUUFBUTZxQyxnQkFBZ0I7UUFDL0QsT0FBTy9qQztJQUNUO0lBQ0EsU0FBUysxQiw0QkFDUDE3QixJQUFJLEVBQ0p2RCxHQUFHLEVBQ0htQixZQUFZLEVBQ1o2aUQsS0FBSyxFQUNMNWlELElBQUksRUFDSmdMLEtBQUs7UUFFTCxJQUFJNjNDLFdBQVcsR0FDYkMsZUFBZTNnRDtRQUNqQixJQUFJLGVBQWUsT0FBT0EsTUFDeEJxN0IsZ0JBQWdCcjdCLFNBQVUwZ0QsQ0FBQUEsV0FBVyxJQUNsQ0MsZUFBZXBsQiwrQkFBK0JvbEI7YUFDOUMsSUFBSSxhQUFhLE9BQU8zZ0QsTUFDM0J5akMscUJBQXFCcHRCLHFCQUNoQixZQUFZOUYsa0JBQ1ptd0MsV0FBV0Usb0JBQW9CNWdELE1BQU1wQyxjQUFjOGlELFlBQ2hELEtBQ0FHLG9CQUFvQjdnRCxRQUNsQixLQUNBLENBQUMsSUFDUHlqQyxvQkFDRyxZQUFZbHpCLGtCQUNabXdDLFdBQVdFLG9CQUFvQjVnRCxNQUFNcEMsY0FBYzhpRCxZQUNoRCxLQUNBLENBQUMsSUFDSkEsV0FBV3JxQyxxQkFDUndxQyxvQkFBb0I3Z0QsUUFDbEIsS0FDQSxJQUNGO2FBRVZtSCxHQUFHLE9BQVFuSDtZQUNULEtBQUtLO2dCQUNILE9BQU9rbEIsd0JBQ0wzbkIsYUFBYTBULFFBQVEsRUFDckJ6VCxNQUNBZ0wsT0FDQXBNO1lBRUosS0FBSytEO2dCQUNIa2dELFdBQVc7Z0JBQ1g3aUQsUUFBUTtnQkFDUjtZQUNGLEtBQUswQztnQkFDSCxPQUNFLE9BQVEzQyxjQUNQNmlELFFBQVE1aUQsTUFDVCxhQUFhLE9BQU9tQyxLQUFLaEUsRUFBRSxJQUN6QmlCLFFBQVFnQyxLQUFLLENBQ1gsNkZBQ0EsT0FBT2UsS0FBS2hFLEVBQUUsR0FFakJTLE1BQU1pQixZQUFZLElBQUlzQyxNQUFNdkQsS0FBS2drRCxRQUFRLElBQ3pDaGtELElBQUltb0IsV0FBVyxHQUFHcmtCLHFCQUNsQjlELElBQUlvTSxLQUFLLEdBQUdBLE9BQ1pwTSxJQUFJa0wsU0FBUyxHQUFHO29CQUFFbzdCLGdCQUFnQjtvQkFBR0MsdUJBQXVCO2dCQUFFLEdBQy9Edm1DO1lBRUosS0FBS2dFO2dCQUNILE9BQ0UsTUFBTy9DLFlBQVksSUFBSUUsY0FBY25CLEtBQUtvQixPQUN6Q3BCLElBQUltb0IsV0FBVyxHQUFHbmtCLHFCQUNsQmhFLElBQUlvTSxLQUFLLEdBQUdBLE9BQ2JwTTtZQUVKLEtBQUtpRTtnQkFDSCxPQUNFLE1BQU9oRCxZQUFZLElBQUlFLGNBQWNuQixLQUFLb0IsT0FDekNwQixJQUFJbW9CLFdBQVcsR0FBR2xrQiwwQkFDbEJqRSxJQUFJb00sS0FBSyxHQUFHQSxPQUNicE07WUFFSixLQUFLcWtEO2dCQUNILE9BQU9wZix5QkFBeUI5akMsY0FBY0MsTUFBTWdMLE9BQU9wTTtZQUM3RDtnQkFDRSxJQUFJLGFBQWEsT0FBT3VELFFBQVEsU0FBU0EsTUFDdkMsT0FBUUEsS0FBS0MsUUFBUTtvQkFDbkIsS0FBSzhnRDtvQkFDTCxLQUFLcGdEO3dCQUNIKy9DLFdBQVc7d0JBQ1gsTUFBTXY1QztvQkFDUixLQUFLdkc7d0JBQ0g4L0MsV0FBVzt3QkFDWCxNQUFNdjVDO29CQUNSLEtBQUtyRzt3QkFDSDQvQyxXQUFXO3dCQUNYQyxlQUFldGQsaUNBQWlDc2Q7d0JBQ2hELE1BQU14NUM7b0JBQ1IsS0FBS2xHO3dCQUNIeS9DLFdBQVc7d0JBQ1gsTUFBTXY1QztvQkFDUixLQUFLakc7d0JBQ0h3L0MsV0FBVzt3QkFDWEMsZUFBZTt3QkFDZixNQUFNeDVDO2dCQUNWO2dCQUNGdzVDLGVBQWU7Z0JBQ2YsSUFDRSxLQUFLLE1BQU0zZ0QsUUFDVixhQUFhLE9BQU9BLFFBQ25CLFNBQVNBLFFBQ1QsTUFBTTRDLE9BQU80UixJQUFJLENBQUN4VSxNQUFNeEQsTUFBTSxFQUVoQ21rRCxnQkFDRTtnQkFDSixTQUFTM2dELE9BQ0pwQyxlQUFlLFNBQ2hCakIsWUFBWXFELFFBQ1RwQyxlQUFlLFVBQ2hCLEtBQUssTUFBTW9DLFFBQVFBLEtBQUtDLFFBQVEsS0FBSzRTLHFCQUNsQyxnQkFDQyxNQUNDOVMsQ0FBQUEseUJBQXlCQyxLQUFLQSxJQUFJLEtBQUssU0FBUSxJQUNoRCxPQUNEMmdELGVBQ0Msb0VBQW9FLElBQ3JFL2lELGVBQWUsT0FBT29DO2dCQUMvQjBnRCxXQUFXRCxRQUNQLGFBQWEsT0FBT0EsTUFBTTlpRCxHQUFHLEdBQzNCMkQsMEJBQTBCbS9DLFNBQzFCLGFBQWEsT0FBT0EsTUFBTXJnRCxJQUFJLEdBQzVCcWdELE1BQU1yZ0QsSUFBSSxHQUNWLE9BQ0o7Z0JBQ0pzZ0QsWUFDR0MsQ0FBQUEsZ0JBQ0MscUNBQXFDRCxXQUFXLElBQUc7Z0JBQ3ZEQSxXQUFXO2dCQUNYOWlELGVBQWVxRixNQUNiLGtJQUNHckYsQ0FBQUEsZUFBZSxNQUFNK2lELFlBQVc7Z0JBRXJDQSxlQUFlO1FBQ25CO1FBQ0Zsa0QsTUFBTWlCLFlBQVlnakQsVUFBVTlpRCxjQUFjbkIsS0FBS29CO1FBQy9DcEIsSUFBSW1vQixXQUFXLEdBQUc1a0I7UUFDbEJ2RCxJQUFJdUQsSUFBSSxHQUFHMmdEO1FBQ1hsa0QsSUFBSW9NLEtBQUssR0FBR0E7UUFDWnBNLElBQUlpb0IsV0FBVyxHQUFHKzdCO1FBQ2xCLE9BQU9oa0Q7SUFDVDtJQUNBLFNBQVM4bEIsdUJBQXVCdGtCLE9BQU8sRUFBRUosSUFBSSxFQUFFZ0wsS0FBSztRQUNsRGhMLE9BQU82OUIsNEJBQ0x6OUIsUUFBUStCLElBQUksRUFDWi9CLFFBQVF4QixHQUFHLEVBQ1h3QixRQUFRdUUsS0FBSyxFQUNidkUsUUFBUSttQixNQUFNLEVBQ2RubkIsTUFDQWdMO1FBRUZoTCxLQUFLNm1CLFdBQVcsR0FBR3ptQixRQUFRK21CLE1BQU07UUFDakMsT0FBT25uQjtJQUNUO0lBQ0EsU0FBUzBuQix3QkFBd0J5N0IsUUFBUSxFQUFFbmpELElBQUksRUFBRWdMLEtBQUssRUFBRXBNLEdBQUc7UUFDekR1a0QsV0FBV3RqRCxZQUFZLEdBQUdzakQsVUFBVXZrRCxLQUFLb0I7UUFDekNtakQsU0FBU240QyxLQUFLLEdBQUdBO1FBQ2pCLE9BQU9tNEM7SUFDVDtJQUNBLFNBQVN0Zix5QkFBeUI5akMsWUFBWSxFQUFFQyxJQUFJLEVBQUVnTCxLQUFLLEVBQUVwTSxHQUFHO1FBQzlEbUIsZUFBZUYsWUFBWSxJQUFJRSxjQUFjbkIsS0FBS29CO1FBQ2xERCxhQUFhZ25CLFdBQVcsR0FBR2s4QjtRQUMzQmxqRCxhQUFhaUwsS0FBSyxHQUFHQTtRQUNyQixJQUFJbzRDLHVCQUF1QjtZQUN6QmpwQyxhQUFhO1lBQ2Jna0Isb0JBQW9CO1lBQ3BCa2xCLGlCQUFpQjtZQUNqQi9QLGFBQWE7WUFDYmdRLGNBQWM7WUFDZG5PLFVBQVU7WUFDVm9PLFFBQVE7Z0JBQ04sSUFBSXRoQyxXQUFXbWhDLHNCQUNibGxELFFBQVErakIsU0FBU2t6QixRQUFRO2dCQUMzQixJQUFJLFNBQVNqM0MsT0FDWCxNQUFNa0gsTUFDSjtnQkFFSixJQUFJLE1BQU82YyxDQUFBQSxTQUFTa2Msa0JBQWtCLEdBQUcsSUFBSTtvQkFDM0MsSUFBSWgrQixPQUFPNFosK0JBQStCN2IsT0FBTztvQkFDakQsU0FBU2lDLFFBQ04sVUFBVWcrQixrQkFBa0IsSUFBSSxHQUNqQzdMLHNCQUFzQm55QixNQUFNakMsT0FBTyxFQUFDO2dCQUN4QztZQUNGO1lBQ0FzbEQsUUFBUTtnQkFDTixJQUFJdmhDLFdBQVdtaEMsc0JBQ2JsbEQsUUFBUStqQixTQUFTa3pCLFFBQVE7Z0JBQzNCLElBQUksU0FBU2ozQyxPQUNYLE1BQU1rSCxNQUNKO2dCQUVKLElBQUksTUFBTzZjLENBQUFBLFNBQVNrYyxrQkFBa0IsR0FBRyxJQUFJO29CQUMzQyxJQUFJaCtCLE9BQU80WiwrQkFBK0I3YixPQUFPO29CQUNqRCxTQUFTaUMsUUFDTixVQUFVZytCLGtCQUFrQixJQUFJLENBQUMsR0FDbEM3TCxzQkFBc0JueUIsTUFBTWpDLE9BQU8sRUFBQztnQkFDeEM7WUFDRjtRQUNGO1FBQ0E2QixhQUFhK0osU0FBUyxHQUFHczVDO1FBQ3pCLE9BQU9yakQ7SUFDVDtJQUNBLFNBQVM2bUIsb0JBQW9CM1MsT0FBTyxFQUFFalUsSUFBSSxFQUFFZ0wsS0FBSztRQUMvQ2lKLFVBQVVwVSxZQUFZLEdBQUdvVSxTQUFTLE1BQU1qVTtRQUN4Q2lVLFFBQVFqSixLQUFLLEdBQUdBO1FBQ2hCLE9BQU9pSjtJQUNUO0lBQ0EsU0FBU3VULHNCQUFzQkgsTUFBTSxFQUFFcm5CLElBQUksRUFBRWdMLEtBQUs7UUFDaERoTCxPQUFPSCxZQUNMLEdBQ0EsU0FBU3duQixPQUFPNVQsUUFBUSxHQUFHNFQsT0FBTzVULFFBQVEsR0FBRyxFQUFFLEVBQy9DNFQsT0FBT3pvQixHQUFHLEVBQ1ZvQjtRQUVGQSxLQUFLZ0wsS0FBSyxHQUFHQTtRQUNiaEwsS0FBSzhKLFNBQVMsR0FBRztZQUNmd2QsZUFBZUQsT0FBT0MsYUFBYTtZQUNuQzJpQixpQkFBaUI7WUFDakIxaUIsZ0JBQWdCRixPQUFPRSxjQUFjO1FBQ3ZDO1FBQ0EsT0FBT3ZuQjtJQUNUO0lBQ0EsU0FBU3lqRCxjQUNQbjhCLGFBQWEsRUFDYnhuQixHQUFHLEVBQ0g0akQsT0FBTyxFQUNQdHJCLGdCQUFnQixFQUNoQjBDLGVBQWUsRUFDZk0sYUFBYSxFQUNia2xCLGtCQUFrQixFQUNsQnpyQixTQUFTO1FBRVQsSUFBSSxDQUFDLzBCLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ3duQixhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ3lsQixZQUFZLEdBQ2YsSUFBSSxDQUFDZ1UsU0FBUyxHQUNkLElBQUksQ0FBQy8vQyxPQUFPLEdBQ1osSUFBSSxDQUFDaXBDLGVBQWUsR0FDbEI7UUFDSixJQUFJLENBQUNxUixhQUFhLEdBQUdvQjtRQUNyQixJQUFJLENBQUN2L0IsWUFBWSxHQUNmLElBQUksQ0FBQzllLElBQUksR0FDVCxJQUFJLENBQUMwdEMsY0FBYyxHQUNuQixJQUFJLENBQUMxckMsT0FBTyxHQUNaLElBQUksQ0FBQ2lkLG1CQUFtQixHQUN0QjtRQUNKLElBQUksQ0FBQ0UsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDclEsZUFBZSxHQUFHaEIsY0FBYyxDQUFDO1FBQ3RDLElBQUksQ0FBQ1ksY0FBYyxHQUNqQixJQUFJLENBQUNFLG1CQUFtQixHQUN4QixJQUFJLENBQUNELDBCQUEwQixHQUMvQixJQUFJLENBQUN2QixhQUFhLEdBQ2xCLElBQUksQ0FBQ3FCLFlBQVksR0FDakIsSUFBSSxDQUFDdEIsU0FBUyxHQUNkLElBQUksQ0FBQ0QsV0FBVyxHQUNoQixJQUFJLENBQUNELGNBQWMsR0FDbkIsSUFBSSxDQUFDRixZQUFZLEdBQ2Y7UUFDSixJQUFJLENBQUM4QixhQUFhLEdBQUdmLGNBQWM7UUFDbkMsSUFBSSxDQUFDaUIsYUFBYSxHQUFHakIsY0FBYztRQUNuQyxJQUFJLENBQUNpc0IsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQzBDLGVBQWUsR0FBR0E7UUFDdkIsSUFBSSxDQUFDTSxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ2tsQixrQkFBa0IsR0FBR0E7UUFDMUIsSUFBSSxDQUFDL1osV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0UsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDNVIsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUM4dUIscUJBQXFCLEdBQUcsSUFBSXZ0QztRQUNqQyxJQUFJLENBQUMrdUIscUJBQXFCLEdBQUcsSUFBSSxDQUFDRCxjQUFjLEdBQUcsQ0FBQztRQUNwRCxJQUFJLENBQUNsM0IsZ0JBQWdCLEdBQUcsSUFBSXFhO1FBQzVCZixnQkFBZ0IsSUFBSSxDQUFDelosc0JBQXNCLEdBQUcsRUFBRTtRQUNoRCxJQUFLL04sTUFBTSxHQUFHLEtBQUtBLEtBQUtBLE1BQU93bkIsY0FBYzFsQixJQUFJLENBQUMsSUFBSXltQjtRQUN0RCxJQUFJLENBQUN1N0IsY0FBYyxHQUFHRixVQUFVLGtCQUFrQjtJQUNwRDtJQUNBLFNBQVNHLGdCQUNQdjhCLGFBQWEsRUFDYnhuQixHQUFHLEVBQ0g0akQsT0FBTyxFQUNQSSxlQUFlLEVBQ2ZDLGtCQUFrQixFQUNsQkMsWUFBWSxFQUNaNXJCLGdCQUFnQixFQUNoQjBDLGVBQWUsRUFDZk0sYUFBYSxFQUNia2xCLGtCQUFrQixFQUNsQjJELG1CQUFtQixFQUNuQnB2QixTQUFTO1FBRVR2TixnQkFBZ0IsSUFBSW04QixjQUNsQm44QixlQUNBeG5CLEtBQ0E0akQsU0FDQXRyQixrQkFDQTBDLGlCQUNBTSxlQUNBa2xCLG9CQUNBenJCO1FBRUYvMEIsTUFBTTtRQUNOLENBQUMsTUFBTWtrRCxnQkFBaUJsa0QsQ0FBQUEsT0FBTyxFQUFDO1FBQ2hDOE4scUJBQXNCOU4sQ0FBQUEsT0FBTztRQUM3QmtrRCxlQUFlbmtELFlBQVksR0FBRyxNQUFNLE1BQU1DO1FBQzFDd25CLGNBQWN0bUIsT0FBTyxHQUFHZ2pEO1FBQ3hCQSxhQUFhbDZDLFNBQVMsR0FBR3dkO1FBQ3pCeG5CLE1BQU04NEI7UUFDTjROLFlBQVkxbUM7UUFDWnduQixjQUFjaWYsV0FBVyxHQUFHem1DO1FBQzVCMG1DLFlBQVkxbUM7UUFDWmtrRCxhQUFhNWxELGFBQWEsR0FBRztZQUMzQmdDLFNBQVMwakQ7WUFDVHBlLGNBQWNnZTtZQUNkN3FCLE9BQU8vNEI7UUFDVDtRQUNBK2Ysc0JBQXNCbWtDO1FBQ3RCLE9BQU8xOEI7SUFDVDtJQUNBLFNBQVM0OEIsbUJBQW1CeGxELEtBQUs7UUFDL0IsT0FBTyxLQUFLQTtJQUNkO0lBQ0EsU0FBU3lsRCxxQkFBcUJDLGVBQWU7UUFDM0MsSUFBSSxDQUFDQSxpQkFBaUIsT0FBTzlqRDtRQUM3QjhqRCxrQkFBa0I5akQ7UUFDbEIsT0FBTzhqRDtJQUNUO0lBQ0EsU0FBUzdqRCxvQkFDUEgsT0FBTyxFQUNQMHBDLFNBQVMsRUFDVHNhLGVBQWUsRUFDZjk3QyxRQUFRO1FBRVIsTUFBTXdoQyxVQUFVaHFDLEdBQUcsSUFBSWdCO1FBQ3ZCdWpELG9CQUNFdmEsVUFBVTlvQyxPQUFPLEVBQ2pCLEdBQ0FaLFNBQ0EwcEMsV0FDQXNhLGlCQUNBOTdDO1FBRUYsT0FBTztJQUNUO0lBQ0EsU0FBUys3QyxvQkFDUHZELFNBQVMsRUFDVGgyQyxJQUFJLEVBQ0oxSyxPQUFPLEVBQ1AwcEMsU0FBUyxFQUNUc2EsZUFBZSxFQUNmOTdDLFFBQVE7UUFFUixJQUNFdUcsZ0JBQ0EsZUFBZSxPQUFPQSxhQUFheTFDLG1CQUFtQixFQUV0RCxJQUFJO1lBQ0Z6MUMsYUFBYXkxQyxtQkFBbUIsQ0FBQzMxQyxZQUFZbTdCLFdBQVcxcEM7UUFDMUQsRUFBRSxPQUFPME8sS0FBSztZQUNaVyxrQkFDRyxrQkFBa0IsQ0FBQyxHQUNwQnJRLFFBQVFnQyxLQUFLLENBQ1gsa0RBQ0EwTixJQUNGO1FBQ0o7UUFDRixTQUFTa0IsMEJBQ1AsZUFBZSxPQUFPQSx1QkFBdUJ1MEMsbUJBQW1CLElBQ2hFdjBDLHVCQUF1QnUwQyxtQkFBbUIsQ0FBQ3o1QztRQUM3Q3M1QyxrQkFBa0JELHFCQUFxQkM7UUFDdkMsU0FBU3RhLFVBQVV6cEMsT0FBTyxHQUNyQnlwQyxVQUFVenBDLE9BQU8sR0FBRytqRCxrQkFDcEJ0YSxVQUFVaUMsY0FBYyxHQUFHcVk7UUFDaEN0N0MsZUFDRSxTQUFTOUgsV0FDVCxDQUFDd2pELDZCQUNBLDZCQUE2QixDQUFDLEdBQy9CcGxELFFBQVFnQyxLQUFLLENBQ1gsOE5BQ0FxQywwQkFBMEJ6QyxZQUFZLFVBQ3hDO1FBQ0Y4b0MsWUFBWXhwQixhQUFheFY7UUFDekJnL0IsVUFBVXRwQixPQUFPLEdBQUc7WUFBRXBnQixTQUFTQTtRQUFRO1FBQ3ZDa0ksV0FBVyxLQUFLLE1BQU1BLFdBQVcsT0FBT0E7UUFDeEMsU0FBU0EsWUFDTixnQkFBZSxPQUFPQSxZQUNyQmxKLFFBQVFnQyxLQUFLLENBQ1gsMEZBQ0FrSCxXQUVId2hDLFVBQVV4aEMsUUFBUSxHQUFHQSxRQUFRO1FBQ2hDbEksVUFBVXFnQixjQUFjcWdDLFdBQVdoWCxXQUFXaC9CO1FBQzlDLFNBQVMxSyxXQUNOa3lCLENBQUFBLHNCQUFzQmx5QixTQUFTMGdELFdBQVdoMkMsT0FDM0MrVixvQkFBb0J6Z0IsU0FBUzBnRCxXQUFXaDJDLEtBQUk7SUFDaEQ7SUFDQSxTQUFTMjVDLGtCQUFrQnZtRCxLQUFLLEVBQUU0a0MsU0FBUztRQUN6QzVrQyxRQUFRQSxNQUFNRSxhQUFhO1FBQzNCLElBQUksU0FBU0YsU0FBUyxTQUFTQSxNQUFNOGEsVUFBVSxFQUFFO1lBQy9DLElBQUkxUCxJQUFJcEwsTUFBTTRrQyxTQUFTO1lBQ3ZCNWtDLE1BQU00a0MsU0FBUyxHQUFHLE1BQU14NUIsS0FBS0EsSUFBSXc1QixZQUFZeDVCLElBQUl3NUI7UUFDbkQ7SUFDRjtJQUNBLFNBQVM0aEIsMkJBQTJCeG1ELEtBQUssRUFBRTRrQyxTQUFTO1FBQ2xEMmhCLGtCQUFrQnZtRCxPQUFPNGtDO1FBQ3hCNWtDLENBQUFBLFFBQVFBLE1BQU1nTCxTQUFTLEtBQUt1N0Msa0JBQWtCdm1ELE9BQU80a0M7SUFDeEQ7SUFDQSxTQUFTNmhCO1FBQ1AsT0FBTzNqRDtJQUNUO0lBQ0EsU0FBUzRqRDtRQUNQLElBQUssSUFBSXgxQixNQUFNLElBQUloWixPQUFPdEwsT0FBTyxHQUFHck0sUUFBUSxHQUFHLEtBQUtBLE9BQU9BLFFBQVM7WUFDbEUsSUFBSW9tRCxRQUFRaDZDLGdCQUFnQkM7WUFDNUJza0IsSUFBSTN0QixHQUFHLENBQUNxSixNQUFNKzVDO1lBQ2QvNUMsUUFBUTtRQUNWO1FBQ0EsT0FBT3NrQjtJQUNUO0lBQ0EsSUFBSXJ4QixVQUFVLENBQUM7SUFDZDtJQUNELElBQUkrbUQsUUFBUUMsbUJBQU9BLENBQUMsaUdBQU8sR0FDekJDLFlBQVlELG1CQUFPQSxDQUFDLDBEQUFXLEdBQy9CL2xELFNBQVMrRixPQUFPL0YsTUFBTSxFQUN0Qm1tQiw0QkFBNEI4L0IsT0FBT0MsR0FBRyxDQUFDLGtCQUN2Q2x3QyxxQkFBcUJpd0MsT0FBT0MsR0FBRyxDQUFDLCtCQUNoQ3ppRCxvQkFBb0J3aUQsT0FBT0MsR0FBRyxDQUFDLGlCQUMvQjFpRCxzQkFBc0J5aUQsT0FBT0MsR0FBRyxDQUFDLG1CQUNqQ3ZpRCx5QkFBeUJzaUQsT0FBT0MsR0FBRyxDQUFDLHNCQUNwQ3hpRCxzQkFBc0J1aUQsT0FBT0MsR0FBRyxDQUFDLG1CQUNqQ2hDLHNCQUFzQitCLE9BQU9DLEdBQUcsQ0FBQyxtQkFDakNuaUQsc0JBQXNCa2lELE9BQU9DLEdBQUcsQ0FBQyxtQkFDakNwaUQscUJBQXFCbWlELE9BQU9DLEdBQUcsQ0FBQyxrQkFDaENqaUQseUJBQXlCZ2lELE9BQU9DLEdBQUcsQ0FBQyxzQkFDcEN0aUQsc0JBQXNCcWlELE9BQU9DLEdBQUcsQ0FBQyxtQkFDakNyaUQsMkJBQTJCb2lELE9BQU9DLEdBQUcsQ0FBQyx3QkFDdEM5aEQsa0JBQWtCNmhELE9BQU9DLEdBQUcsQ0FBQyxlQUM3QjdoRCxrQkFBa0I0aEQsT0FBT0MsR0FBRyxDQUFDO0lBQy9CRCxPQUFPQyxHQUFHLENBQUM7SUFDWEQsT0FBT0MsR0FBRyxDQUFDO0lBQ1gsSUFBSWpDLHVCQUF1QmdDLE9BQU9DLEdBQUcsQ0FBQztJQUN0Q0QsT0FBT0MsR0FBRyxDQUFDO0lBQ1hELE9BQU9DLEdBQUcsQ0FBQztJQUNYLElBQUkzMUIsNEJBQTRCMDFCLE9BQU9DLEdBQUcsQ0FBQyw4QkFDekNqakQsd0JBQXdCZ2pELE9BQU9FLFFBQVEsRUFDdkM5aUQseUJBQXlCNGlELE9BQU9DLEdBQUcsQ0FBQywyQkFDcEMvK0MsdUJBQ0UyK0MsTUFBTU0sK0RBQStELEVBQ3ZFdGhELGdCQUFnQixHQUNoQkMsU0FDQUUsVUFDQUUsVUFDQUMsV0FDQUMsV0FDQUUsb0JBQ0FFO0lBQ0ZiLFlBQVl5aEQsa0JBQWtCLEdBQUcsQ0FBQztJQUNsQyxJQUFJbGdELFFBQ0ZLLFFBQ0FLLFVBQVUsQ0FBQztJQUNiLElBQUlFLHNCQUFzQixJQUN4QixnQkFBZSxPQUFPdS9DLFVBQVVBLFVBQVVsdkMsR0FBRTtJQUU5QyxJQUFJcFYsVUFBVSxNQUNaOEgsY0FBYyxDQUFDLEdBQ2ZoSyxjQUFjd3dCLE1BQU1pMkIsT0FBTyxFQUMzQkMsa0JBQWtCeG5ELFVBQVV3bkQsZUFBZSxFQUMzQ0Msc0JBQXNCem5ELFVBQVV5bkQsbUJBQW1CLEVBQ25EQyxzQkFBc0IxbkQsVUFBVTBuRCxtQkFBbUIsRUFDbkR6VyxvQkFBb0JqeEMsVUFBVWl4QyxpQkFBaUIsRUFDL0N6OEIscUJBQXFCeFUsVUFBVXdVLGtCQUFrQixFQUNqRE0sc0JBQXNCOVUsVUFBVThVLG1CQUFtQixFQUNuRG0rQixtQkFBbUJqekMsVUFBVWl6QyxnQkFBZ0IsRUFDN0M4TyxtQkFBbUIvaEQsVUFBVStoRCxnQkFBZ0IsRUFDN0M3VCxpQkFBaUJsdUMsVUFBVWt1QyxjQUFjLEVBQ3pDN0MscUJBQXFCcnJDLFVBQVVxckMsa0JBQWtCLEVBQ2pEbUIsMEJBQTBCeHNDLFVBQVV3c0MsdUJBQXVCLEVBQzNEOXhCLHVCQUF1QjFhLFVBQVUwYSxvQkFBb0IsRUFDckR5ekIscUJBQXFCbnVDLFVBQVVtdUMsa0JBQWtCLEVBQ2pEb1Asa0JBQWtCdjlDLFVBQVV1OUMsZUFBZSxFQUMzQ29CLGdCQUFnQjMrQyxVQUFVMitDLGFBQWEsRUFDdkNELFlBQVkxK0MsVUFBVTArQyxTQUFTLEVBQy9CMXBDLG9CQUFvQmhWLFVBQVVnVixpQkFBaUI7SUFDakRoVixVQUFVMm5ELGdCQUFnQjtJQUMxQixJQUFJdmMsbUJBQW1CcHJDLFVBQVVvckMsZ0JBQWdCLEVBQy9DRSxzQkFBc0J0ckMsVUFBVXNyQyxtQkFBbUIsRUFDbkR0eEIsb0JBQW9CaGEsVUFBVWdhLGlCQUFpQixFQUMvQ3kvQixzQkFBc0J6NUMsVUFBVXk1QyxtQkFBbUI7SUFDckR6NUMsVUFBVTRuRCx3QkFBd0I7SUFDbEM1bkQsVUFBVTZuRCx1QkFBdUI7SUFDakMsSUFBSXRaLHFCQUFxQnZ1QyxVQUFVdXVDLGtCQUFrQjtJQUNyRHZ1QyxVQUFVOG5ELGtCQUFrQjtJQUM1QjluRCxVQUFVK25ELG9CQUFvQjtJQUM5QixJQUFJMXVCLDJCQUEyQnI1QixVQUFVcTVCLHdCQUF3QixFQUMvREQsMkJBQTJCcDVCLFVBQVVvNUIsd0JBQXdCLEVBQzdEa2lCLHdCQUF3QnQ3QyxVQUFVczdDLHFCQUFxQjtJQUN6RHQ3QyxVQUFVZ29ELGdCQUFnQjtJQUMxQmhvRCxVQUFVaW9ELHFCQUFxQjtJQUMvQixJQUFJbnBDLCtCQUErQjllLFVBQVU4ZSw0QkFBNEIsRUFDdkVtMUIsd0JBQXdCajBDLFVBQVVpMEMscUJBQXFCO0lBQ3pEajBDLFVBQVVrb0Qsd0JBQXdCO0lBQ2xDLElBQUl4YixtQkFBbUIxc0MsVUFBVTBzQyxnQkFBZ0IsRUFDL0NDLGtCQUFrQjNzQyxVQUFVMnNDLGVBQWUsRUFDM0N1Uix3QkFBd0JsK0MsVUFBVWsrQyxxQkFBcUIsRUFDdkRyRixrQkFBa0I3NEMsVUFBVTY0QyxlQUFlLEVBQzNDc0YseUJBQXlCbitDLFVBQVVtK0Msc0JBQXNCLEVBQ3pEaHBDLHVCQUF1Qm5WLFVBQVVtVixvQkFBb0IsRUFDckRGLHdCQUF3QmpWLFVBQVVpVixxQkFBcUIsRUFDdkR3aUMsb0JBQW9CejNDLFVBQVV5M0MsaUJBQWlCLEVBQy9DMFEsZ0JBQWdCbm9ELFVBQVVtb0QsYUFBYSxFQUN2QzluQyxxQkFBcUJyZ0IsVUFBVXFnQixrQkFBa0IsRUFDakRDLG9CQUFvQnRnQixVQUFVc2dCLGlCQUFpQixFQUMvQ3c2Qix3QkFBd0I5NkMsVUFBVTg2QyxxQkFBcUIsRUFDdkRwQixnQkFBZ0IxNUMsVUFBVTA1QyxhQUFhLEVBQ3ZDME8sa0JBQWtCcG9ELFVBQVVvb0QsZUFBZSxFQUMzQzdOLGlCQUFpQnY2QyxVQUFVdTZDLGNBQWMsRUFDekNKLGtCQUFrQm42QyxVQUFVbTZDLGVBQWUsRUFDM0NFLHlCQUF5QnI2QyxVQUFVcTZDLHNCQUFzQixFQUN6RGdPLHNCQUFzQnJvRCxVQUFVcW9ELG1CQUFtQixFQUNuREMsNEJBQTRCdG9ELFVBQVVzb0QseUJBQXlCLEVBQy9EN1YsY0FBY3p5QyxVQUFVeXlDLFdBQVcsRUFDbkNILHlCQUF5QnR5QyxVQUFVc3lDLHNCQUFzQixFQUN6RHNFLG1CQUFtQjUyQyxVQUFVNDJDLGdCQUFnQixFQUM3QzlFLGNBQWM5eEMsVUFBVTh4QyxXQUFXLEVBQ25DRSxlQUFlaHlDLFVBQVVneUMsWUFBWSxFQUNyQ1EsZUFBZXh5QyxVQUFVd3lDLFlBQVksRUFDckNILDBCQUEwQnJ5QyxVQUFVcXlDLHVCQUF1QixFQUMzRHlDLGNBQWM5MEMsVUFBVTgwQyxXQUFXLEVBQ25DRCwyQkFBMkI3MEMsVUFBVTYwQyx3QkFBd0IsRUFDN0RqQyxtQkFBbUI1eUMsVUFBVTR5QyxnQkFBZ0IsRUFDN0N5RSxlQUFlcjNDLFVBQVVxM0MsWUFBWSxFQUNyQ0UsbUJBQW1CdjNDLFVBQVV1M0MsZ0JBQWdCLEVBQzdDRCxpQkFBaUJ0M0MsVUFBVXMzQyxjQUFjLEVBQ3pDRSxxQkFBcUJ4M0MsVUFBVXczQyxrQkFBa0IsRUFDakRyRSxpQkFBaUJuekMsVUFBVW16QyxjQUFjLEVBQ3pDNUcsZ0JBQWdCdnNDLFVBQVV1c0MsYUFBYSxFQUN2Q1AsMEJBQTBCaHNDLFVBQVVnc0MsdUJBQXVCLEVBQzNESixpQ0FBaUM1ckMsVUFBVTRyQyw4QkFBOEIsRUFDekVNLDRCQUE0QmxzQyxVQUFVa3NDLHlCQUF5QixFQUMvRDRHLDJCQUEyQjl5QyxVQUFVOHlDLHdCQUF3QixFQUM3RHRILHNCQUFzQnhyQyxVQUFVd3JDLG1CQUFtQixFQUNuREMsMEJBQTBCenJDLFVBQVV5ckMsdUJBQXVCLEVBQzNEbGYsNEJBQTRCdnNCLFVBQVV1c0IseUJBQXlCLEVBQy9EQyw2QkFBNkJ4c0IsVUFBVXdzQiwwQkFBMEIsRUFDakU0WSwwQ0FDRXBsQyxVQUFVb2xDLHVDQUF1QyxFQUNuREksZ0NBQWdDeGxDLFVBQVV3bEMsNkJBQTZCLEVBQ3ZFeE8sNEJBQTRCaDNCLFVBQVVnM0IseUJBQXlCLEVBQy9EQyw0QkFBNEJqM0IsVUFBVWkzQix5QkFBeUIsRUFDL0RsYywyQkFBMkIvYSxVQUFVK2Esd0JBQXdCLEVBQzdEa3RCLDBCQUEwQmpvQyxVQUFVaW9DLHVCQUF1QixFQUMzRE4seUNBQ0UzbkMsVUFBVTJuQyxzQ0FBc0MsRUFDbERsQyxnREFDRXpsQyxVQUFVeWxDLDZDQUE2QyxFQUN6RDBDLHFCQUFxQm5vQyxVQUFVbW9DLGtCQUFrQixFQUNqREUseUJBQXlCcm9DLFVBQVVxb0Msc0JBQXNCLEVBQ3pEMUQsNkJBQTZCM2tDLFVBQVUya0MsMEJBQTBCLEVBQ2pFMXFCLGtCQUFrQmphLFVBQVVpYSxlQUFlLEVBQzNDbzBCLHNCQUFzQnJ1QyxVQUFVcXVDLG1CQUFtQixFQUNuREMsMEJBQTBCdHVDLFVBQVVzdUMsdUJBQXVCLEVBQzNEeHpCLGlEQUNFOWEsVUFBVThhLDhDQUE4QyxFQUMxRGk4QiwwQkFBMEIvMkMsVUFBVSsyQyx1QkFBdUIsRUFDM0Q3QixpQ0FBaUNsMUMsVUFBVWsxQyw4QkFBOEIsRUFDekVGLHdCQUF3QmgxQyxVQUFVZzFDLHFCQUFxQixFQUN2REQscUNBQ0UvMEMsVUFBVSswQyxrQ0FBa0MsRUFDOUN0NkIsc0NBQ0V6YSxVQUFVeWEsbUNBQW1DLEVBQy9DdXRCLGtDQUNFaG9DLFVBQVVnb0MsK0JBQStCLEVBQzNDb0csaUNBQWlDcHVDLFVBQVVvdUMsOEJBQThCLEVBQ3pFNTBCLDJDQUNFeFosVUFBVXdaLHdDQUF3QyxFQUNwRDB1Qiw2QkFBNkJsb0MsVUFBVWtvQywwQkFBMEIsRUFDakVFLGlDQUFpQ3BvQyxVQUFVb29DLDhCQUE4QixFQUN6RVIsb0JBQW9CNW5DLFVBQVU0bkMsaUJBQWlCLEVBQy9DbWQsc0JBQXNCL2tELFVBQVUra0QsbUJBQW1CLEVBQ25Eak8sbUJBQW1COTJDLFVBQVU4MkMsZ0JBQWdCLEVBQzdDalAsY0FBYzduQyxVQUFVNm5DLFdBQVcsRUFDbkMyTyxrQkFBa0J4MkMsVUFBVXcyQyxlQUFlLEVBQzNDbEMsa0JBQWtCdDBDLFVBQVVzMEMsZUFBZSxFQUMzQ2dDLG1CQUFtQnQyQyxVQUFVczJDLGdCQUFnQixFQUM3Q0MsaUJBQWlCdjJDLFVBQVV1MkMsY0FBYyxFQUN6Q2hDLG1CQUFtQnYwQyxVQUFVdTBDLGdCQUFnQixFQUM3Q3pNLDBCQUEwQjluQyxVQUFVOG5DLHVCQUF1QixFQUMzRCtPLDRCQUE0QjcyQyxVQUFVNjJDLHlCQUF5QixFQUMvRDdKLDJCQUEyQmh0QyxVQUFVZ3RDLHdCQUF3QixFQUM3REMsa0JBQWtCanRDLFVBQVVpdEMsZUFBZSxFQUMzQzJMLGtCQUFrQjU0QyxVQUFVNDRDLGVBQWUsRUFDM0NwK0IscUJBQXFCeGEsVUFBVXdhLGtCQUFrQixFQUNqRHV0QiwyQkFBMkIvbkMsVUFBVStuQyx3QkFBd0IsRUFDN0QwTyxpQkFBaUJ6MkMsVUFBVXkyQyxjQUFjLEVBQ3pDQywyQkFBMkIxMkMsVUFBVTAyQyx3QkFBd0IsRUFDN0Q5QiwyQkFBMkI1MEMsVUFBVTQwQyx3QkFBd0IsRUFDN0RvUSxzQkFBc0JobEQsVUFBVWdsRCxtQkFBbUIsRUFDbkR2NEMsYUFBYSxFQUFFO0lBQ2pCLElBQUlELGFBQWEsRUFBRTtJQUNuQixJQUFJRCxpQkFBaUIsQ0FBQyxHQUNwQmpLLHFCQUFxQixDQUFDO0lBQ3hCeUUsT0FBT3doRCxNQUFNLENBQUNqbUQ7SUFDZCxJQUFJK00sUUFBUW01QyxLQUFLbjVDLEtBQUssR0FBR201QyxLQUFLbjVDLEtBQUssR0FBRzNDLGVBQ3BDQyxRQUFRNjdDLEtBQUt4aUQsR0FBRyxFQUNoQjRHLE1BQU00N0MsS0FBSzU3QyxHQUFHLEVBQ2RvQixxQkFBcUIsS0FDckJFLGdCQUFnQixTQUNoQjBSLHFCQUFxQm9uQyxVQUFVeUIseUJBQXlCLEVBQ3hEdG9DLG1CQUFtQjZtQyxVQUFVMEIsdUJBQXVCLEVBQ3BENUgsY0FBY2tHLFVBQVUyQixvQkFBb0IsRUFDNUN6RyxlQUFlOEUsVUFBVTRCLHFCQUFxQixFQUM5QzdwQyxRQUFRaW9DLFVBQVU2QixZQUFZLEVBQzlCeDNDLG9CQUFvQjIxQyxVQUFVOEIsMEJBQTBCLEVBQ3hEeDNDLHVCQUF1QjAxQyxVQUFVK0IsNkJBQTZCLEVBQzlEeDNDLG1CQUFtQnkxQyxVQUFVZ0MsdUJBQXVCLEVBQ3BEeDNDLGVBQWV3MUMsVUFBVWlDLHFCQUFxQixFQUM5Q2pqRCxNQUFNZ2hELFVBQVVoaEQsR0FBRyxFQUNuQjRMLGdDQUFnQ28xQyxVQUFVcDFDLDZCQUE2QixFQUN2RWpCLGFBQWEsTUFDYkUsZUFBZSxNQUNmbUIseUJBQXlCLE1BQ3pCUCxpQkFBaUIsQ0FBQyxHQUNsQjdCLG9CQUFvQixnQkFBZ0IsT0FBT1csZ0NBQzNDdVUsV0FBVyxlQUFlLE9BQU8vZCxPQUFPd0wsRUFBRSxHQUFHeEwsT0FBT3dMLEVBQUUsR0FBR0EsSUFDekRLLGlCQUFpQixJQUFJMDBDLFdBQ3JCdDBDLFlBQVksRUFBRSxFQUNkQyxpQkFBaUIsR0FDakJFLG1CQUFtQixNQUNuQkQsZ0JBQWdCLEdBQ2hCRyxVQUFVLEVBQUUsRUFDWkMsZUFBZSxHQUNmRyxzQkFBc0IsTUFDdEJGLGdCQUFnQixHQUNoQkMsc0JBQXNCLElBQ3RCZSxxQkFBcUJwSSxhQUFhLE9BQ2xDbUksMEJBQTBCbkksYUFBYSxPQUN2Q2tJLDBCQUEwQmxJLGFBQWEsT0FDdkN5SSwrQkFBK0J6SSxhQUFhLE9BQzVDZ0ssZ0JBQWdCLHVCQUNoQmlFLHVCQUF1QixNQUN2Qk8seUJBQXlCLE1BQ3pCM0csY0FBYyxDQUFDLEdBQ2Z1Rix1QkFBdUIsQ0FBQyxHQUN4QkosdUJBQXVCLE1BQ3ZCK0Isa0JBQWtCLE1BQ2xCYix5QkFBeUIsQ0FBQyxHQUMxQlIsNkJBQTZCelMsTUFDM0IsbUpBRUZvbkIsU0FBUyxHQUNUaFQsbUJBQW1CLEVBQUUsRUFDckJGLHdCQUF3QixHQUN4QkMsMkJBQTJCLEdBQzNCNEIsTUFBTTZwQyxVQUFVNkIsWUFBWSxFQUM1QnZYLGtCQUFrQixDQUFDLEdBQ25CcDBCLG9CQUFvQixDQUFDLEtBQ3JCTCx5QkFBeUIsQ0FBQyxHQUMxQmtELHdCQUF3QixDQUFDLEdBQ3pCRCx3QkFBd0IsQ0FBQyxHQUN6QmhDLHFCQUFxQixNQUNyQkQsb0JBQW9CLE1BQ3BCTyx1QkFBdUIsQ0FBQyxHQUN4QkgsMkJBQTJCLENBQUMsR0FDNUJGLDJCQUEyQixDQUFDLEdBQzVCUyxpQkFBaUIsQ0FBQyxHQUNsQkssNkJBQTZCLEdBQzdCWSx3QkFBd0IsQ0FBQyxHQUN6QnNCLDRCQUE0QixNQUM1QkUsK0JBQStCLEdBQy9CQyx1QkFBdUIsR0FDdkJDLGlDQUFpQyxNQUNqQ29CLGNBQWMsR0FDZDJCLGVBQWUsR0FDZkksY0FBYyxHQUNkRCxnQkFBZ0IsR0FDaEJaLGlCQUFpQixDQUFDO0lBQ3BCLElBQUlkLDRCQUE0QixDQUFDO0lBQ2pDLElBQUlELDJCQUEyQjtJQUMvQixJQUFJVyxrQ0FBa0MsQ0FBQyxHQUNyQ25NLGlCQUFpQm5RLE9BQU8wQixTQUFTLENBQUN5TyxjQUFjLEVBQ2hEMnBCLDBCQUEwQjtRQUN4QnlDLCtCQUErQixZQUFhO1FBQzVDbWUscUNBQXFDLFlBQWE7UUFDbEQzZ0IsNEJBQTRCLFlBQWE7UUFDekMwZ0IsMkJBQTJCLFlBQWE7UUFDeEMxQyx3QkFBd0IsWUFBYTtJQUN2QyxHQUNBb0ssb0NBQW9DLEVBQUUsRUFDdENDLDJDQUEyQyxFQUFFLEVBQzdDQywyQ0FBMkMsRUFBRSxFQUM3Q0Msa0RBQWtELEVBQUUsRUFDcERDLHFDQUFxQyxFQUFFLEVBQ3ZDQyw0Q0FBNEMsRUFBRSxFQUM5Q0MsK0JBQStCLElBQUluL0I7SUFDckN3Vyx3QkFBd0J5Qyw2QkFBNkIsR0FBRyxTQUN0RHBqQyxLQUFLLEVBQ0wrakIsUUFBUTtRQUVSdWxDLDZCQUE2QnQ1QyxHQUFHLENBQUNoUSxNQUFNaUUsSUFBSSxLQUN4QyxnQkFBZSxPQUFPOGYsU0FBUzhkLGtCQUFrQixJQUNoRCxDQUFDLE1BQU05ZCxTQUFTOGQsa0JBQWtCLENBQUNDLDRCQUE0QixJQUMvRGtuQixrQ0FBa0N0bEQsSUFBSSxDQUFDMUQsUUFDekNBLE1BQU04QixJQUFJLEdBQUcsS0FDWCxlQUFlLE9BQU9paUIsU0FBU2dlLHlCQUF5QixJQUN4RGtuQix5Q0FBeUN2bEQsSUFBSSxDQUFDMUQsUUFDaEQsZUFBZSxPQUFPK2pCLFNBQVNpWSx5QkFBeUIsSUFDdEQsQ0FBQyxNQUNDalksU0FBU2lZLHlCQUF5QixDQUFDOEYsNEJBQTRCLElBQ2pFb25CLHlDQUF5Q3hsRCxJQUFJLENBQUMxRCxRQUNoREEsTUFBTThCLElBQUksR0FBRyxLQUNYLGVBQWUsT0FBT2lpQixTQUFTa1ksZ0NBQWdDLElBQy9Ea3RCLGdEQUFnRHpsRCxJQUFJLENBQUMxRCxRQUN2RCxlQUFlLE9BQU8rakIsU0FBU2llLG1CQUFtQixJQUNoRCxDQUFDLE1BQU1qZSxTQUFTaWUsbUJBQW1CLENBQUNGLDRCQUE0QixJQUNoRXNuQixtQ0FBbUMxbEQsSUFBSSxDQUFDMUQsUUFDMUNBLE1BQU04QixJQUFJLEdBQUcsS0FDWCxlQUFlLE9BQU9paUIsU0FBU2tlLDBCQUEwQixJQUN6RG9uQiwwQ0FBMEMzbEQsSUFBSSxDQUFDMUQsTUFBSztJQUMxRDtJQUNBMmdDLHdCQUF3QjRnQixtQ0FBbUMsR0FBRztRQUM1RCxJQUFJZ0ksZ0NBQWdDLElBQUlwL0I7UUFDeEMsSUFBSTYrQixrQ0FBa0N2b0QsTUFBTSxJQUN6Q3VvRCxDQUFBQSxrQ0FBa0N2bEQsT0FBTyxDQUFDLFNBQVV6RCxLQUFLO1lBQ3hEdXBELDhCQUE4QjM1QyxHQUFHLENBQy9CckssMEJBQTBCdkYsVUFBVTtZQUV0Q3NwRCw2QkFBNkIxNUMsR0FBRyxDQUFDNVAsTUFBTWlFLElBQUk7UUFDN0MsSUFDQytrRCxvQ0FBb0MsRUFBRTtRQUN6QyxJQUFJUSx1Q0FBdUMsSUFBSXIvQjtRQUMvQyxJQUFJOCtCLHlDQUF5Q3hvRCxNQUFNLElBQ2hEd29ELENBQUFBLHlDQUF5Q3hsRCxPQUFPLENBQUMsU0FBVXpELEtBQUs7WUFDL0R3cEQscUNBQXFDNTVDLEdBQUcsQ0FDdENySywwQkFBMEJ2RixVQUFVO1lBRXRDc3BELDZCQUE2QjE1QyxHQUFHLENBQUM1UCxNQUFNaUUsSUFBSTtRQUM3QyxJQUNDZ2xELDJDQUEyQyxFQUFFO1FBQ2hELElBQUlRLHVDQUF1QyxJQUFJdC9CO1FBQy9DLElBQUkrK0IseUNBQXlDem9ELE1BQU0sSUFDaER5b0QsQ0FBQUEseUNBQXlDemxELE9BQU8sQ0FBQyxTQUFVekQsS0FBSztZQUMvRHlwRCxxQ0FBcUM3NUMsR0FBRyxDQUN0Q3JLLDBCQUEwQnZGLFVBQVU7WUFFdENzcEQsNkJBQTZCMTVDLEdBQUcsQ0FBQzVQLE1BQU1pRSxJQUFJO1FBQzdDLElBQ0NpbEQsMkNBQTJDLEVBQUU7UUFDaEQsSUFBSVEsOENBQThDLElBQUl2L0I7UUFDdEQsSUFBSWcvQixnREFBZ0Qxb0QsTUFBTSxJQUN2RDBvRCxDQUFBQSxnREFBZ0QxbEQsT0FBTyxDQUN0RCxTQUFVekQsS0FBSztZQUNiMHBELDRDQUE0Qzk1QyxHQUFHLENBQzdDckssMEJBQTBCdkYsVUFBVTtZQUV0Q3NwRCw2QkFBNkIxNUMsR0FBRyxDQUFDNVAsTUFBTWlFLElBQUk7UUFDN0MsSUFFRGtsRCxrREFBa0QsRUFBRTtRQUN2RCxJQUFJUSxpQ0FBaUMsSUFBSXgvQjtRQUN6QyxJQUFJaS9CLG1DQUFtQzNvRCxNQUFNLElBQzFDMm9ELENBQUFBLG1DQUFtQzNsRCxPQUFPLENBQUMsU0FBVXpELEtBQUs7WUFDekQycEQsK0JBQStCLzVDLEdBQUcsQ0FDaENySywwQkFBMEJ2RixVQUFVO1lBRXRDc3BELDZCQUE2QjE1QyxHQUFHLENBQUM1UCxNQUFNaUUsSUFBSTtRQUM3QyxJQUNDbWxELHFDQUFxQyxFQUFFO1FBQzFDLElBQUlRLHdDQUF3QyxJQUFJei9CO1FBQ2hELElBQUlrL0IsMENBQTBDNW9ELE1BQU0sSUFDakQ0b0QsQ0FBQUEsMENBQTBDNWxELE9BQU8sQ0FBQyxTQUFVekQsS0FBSztZQUNoRTRwRCxzQ0FBc0NoNkMsR0FBRyxDQUN2Q3JLLDBCQUEwQnZGLFVBQVU7WUFFdENzcEQsNkJBQTZCMTVDLEdBQUcsQ0FBQzVQLE1BQU1pRSxJQUFJO1FBQzdDLElBQ0NvbEQsNENBQTRDLEVBQUU7UUFDakQsSUFBSSxJQUFJRyxxQ0FBcUN6NUMsSUFBSSxFQUFFO1lBQ2pELElBQUk4NUMsY0FBY3ZtRCxrQkFDaEJrbUQ7WUFFRnRvRCxRQUFRZ0MsS0FBSyxDQUNYLDRUQUNBMm1EO1FBRUo7UUFDQSxJQUFJSCw0Q0FBNEMzNUMsSUFBSSxJQUNqRCxlQUFlek0sa0JBQ2RvbUQsOENBRUZ4b0QsUUFBUWdDLEtBQUssQ0FDWCw2ZUFDQTJtRCxZQUNGO1FBQ0YsSUFBSUQsc0NBQXNDNzVDLElBQUksSUFDM0MsZUFBZXpNLGtCQUNkc21ELHdDQUVGMW9ELFFBQVFnQyxLQUFLLENBQ1gsZ1NBQ0EybUQsWUFDRjtRQUNGLElBQUlOLDhCQUE4Qng1QyxJQUFJLElBQ25DLGVBQWV6TSxrQkFBa0JpbUQsZ0NBQ2xDcm9ELFFBQVFDLElBQUksQ0FDVixra0JBQ0Ewb0QsWUFDRjtRQUNGLElBQUlKLHFDQUFxQzE1QyxJQUFJLElBQzFDLGVBQWV6TSxrQkFDZG1tRCx1Q0FFRnZvRCxRQUFRQyxJQUFJLENBQ1YsaXdCQUNBMG9ELFlBQ0Y7UUFDRixJQUFJRiwrQkFBK0I1NUMsSUFBSSxJQUNwQyxlQUFlek0sa0JBQWtCcW1ELGlDQUNsQ3pvRCxRQUFRQyxJQUFJLENBQ1Ysd2lCQUNBMG9ELFlBQ0Y7SUFDSjtJQUNBLElBQUlDLDhCQUE4QixJQUFJNXhDLE9BQ3BDNnhDLDRCQUE0QixJQUFJNS9CO0lBQ2xDd1csd0JBQXdCQywwQkFBMEIsR0FBRyxTQUNuRDVnQyxLQUFLLEVBQ0wrakIsUUFBUTtRQUVSLElBQUlpbUMsYUFBYTtRQUNqQixJQUFLLElBQUlsL0MsT0FBTzlLLE9BQU8sU0FBUzhLLE1BQzlCQSxLQUFLaEosSUFBSSxHQUFHLEtBQU1rb0QsQ0FBQUEsYUFBYWwvQyxJQUFHLEdBQUtBLE9BQU9BLEtBQUtyRixNQUFNO1FBQzNELFNBQVN1a0QsYUFDTDlvRCxRQUFRZ0MsS0FBSyxDQUNYLHlJQUVGLENBQUM2bUQsMEJBQTBCLzVDLEdBQUcsQ0FBQ2hRLE1BQU1pRSxJQUFJLEtBQ3hDLFFBQVE2bEQsNEJBQTRCaGlELEdBQUcsQ0FBQ2tpRCxhQUN6QyxRQUFRaHFELE1BQU1pRSxJQUFJLENBQUM0OEIsWUFBWSxJQUM3QixRQUFRN2dDLE1BQU1pRSxJQUFJLENBQUNzK0IsaUJBQWlCLElBQ25DLFNBQVN4ZSxZQUNSLGVBQWUsT0FBT0EsU0FBU2tmLGVBQWUsS0FDakQsTUFBSyxNQUFNbjRCLFFBQ1QsUUFBUSxFQUFFLEVBQUdnL0MsNEJBQTRCdm1ELEdBQUcsQ0FBQ3ltRCxZQUFZbC9DLEtBQUksR0FDaEVBLEtBQUtwSCxJQUFJLENBQUMxRCxNQUFLO0lBQ3JCO0lBQ0EyZ0Msd0JBQXdCMmdCLHlCQUF5QixHQUFHO1FBQ2xEd0ksNEJBQTRCcm1ELE9BQU8sQ0FBQyxTQUFVd21ELFVBQVU7WUFDdEQsSUFBSSxNQUFNQSxXQUFXeHBELE1BQU0sRUFBRTtnQkFDM0IsSUFBSXlwRCxhQUFhRCxVQUFVLENBQUMsRUFBRSxFQUM1QkUsY0FBYyxJQUFJaGdDO2dCQUNwQjgvQixXQUFXeG1ELE9BQU8sQ0FBQyxTQUFVekQsS0FBSztvQkFDaENtcUQsWUFBWXY2QyxHQUFHLENBQUNySywwQkFBMEJ2RixVQUFVO29CQUNwRCtwRCwwQkFBMEJuNkMsR0FBRyxDQUFDNVAsTUFBTWlFLElBQUk7Z0JBQzFDO2dCQUNBLElBQUk0bEQsY0FBY3ZtRCxrQkFBa0I2bUQ7Z0JBQ3BDaGdELGtCQUFrQisvQyxZQUFZO29CQUM1QmhwRCxRQUFRZ0MsS0FBSyxDQUNYLGtUQUNBMm1EO2dCQUVKO1lBQ0Y7UUFDRjtJQUNGO0lBQ0FscEIsd0JBQXdCaWUsc0JBQXNCLEdBQUc7UUFDL0NvSyxvQ0FBb0MsRUFBRTtRQUN0Q0MsMkNBQTJDLEVBQUU7UUFDN0NDLDJDQUEyQyxFQUFFO1FBQzdDQyxrREFBa0QsRUFBRTtRQUNwREMscUNBQXFDLEVBQUU7UUFDdkNDLDRDQUE0QyxFQUFFO1FBQzlDUyw4QkFBOEIsSUFBSTV4QztJQUNwQztJQUNBLElBQUk2TixvQkFBb0I3ZSxNQUNwQixrYUFFRnlsQywyQkFBMkJ6bEMsTUFDekIseUlBRUZrM0IsOEJBQThCO1FBQzVCamQsTUFBTTtZQUNKamdCLFFBQVFnQyxLQUFLLENBQ1g7UUFFSjtJQUNGLEdBQ0EyaUIsb0JBQW9CLE1BQ3BCQyxtQ0FBbUMsQ0FBQyxHQUNwQ3NrQyxnQkFBZ0I7UUFDZCw0QkFBNEIsU0FBVXY4QixTQUFTLEVBQUVwbkIsS0FBSyxFQUFFcW5CLFNBQVM7WUFDL0QsSUFBSXU4QixlQUFlei9DO1lBQ25CQSxjQUFjLENBQUM7WUFDZixJQUFJO2dCQUNGLE9BQU9pakIsVUFBVXBuQixPQUFPcW5CO1lBQzFCLFNBQVU7Z0JBQ1JsakIsY0FBY3kvQztZQUNoQjtRQUNGO0lBQ0YsR0FDQTk3QixxQkFDRTY3QixhQUFhLENBQUMsMkJBQTJCLENBQUMzcUMsSUFBSSxDQUFDMnFDLGdCQUNqREUsYUFBYTtRQUNYLDRCQUE0QixTQUFVdm1DLFFBQVE7WUFDNUMsSUFBSXNtQyxlQUFlei9DO1lBQ25CQSxjQUFjLENBQUM7WUFDZixJQUFJO2dCQUNGLE9BQU9tWixTQUFTOWUsTUFBTTtZQUN4QixTQUFVO2dCQUNSMkYsY0FBY3kvQztZQUNoQjtRQUNGO0lBQ0YsR0FDQTdtQixrQkFBa0I4bUIsVUFBVSxDQUFDLDJCQUEyQixDQUFDN3FDLElBQUksQ0FBQzZxQyxhQUM5REMsd0JBQXdCO1FBQ3RCLDRCQUE0QixTQUFVMWIsWUFBWSxFQUFFOXFCLFFBQVE7WUFDMUQsSUFBSTtnQkFDRkEsU0FBU3NmLGlCQUFpQjtZQUM1QixFQUFFLE9BQU9uZ0MsT0FBTztnQkFDZDJzQyx3QkFBd0JoQixjQUFjQSxhQUFhcHBDLE1BQU0sRUFBRXZDO1lBQzdEO1FBQ0Y7SUFDRixHQUNBb3dDLDZCQUE2QmlYLHFCQUFxQixDQUNoRCwyQkFDRCxDQUFDOXFDLElBQUksQ0FBQzhxQyx3QkFDUEMseUJBQXlCO1FBQ3ZCLDRCQUE0QixTQUMxQjNiLFlBQVksRUFDWjlxQixRQUFRLEVBQ1I4YixTQUFTLEVBQ1RwSyxTQUFTLEVBQ1RnYixRQUFRO1lBRVIsSUFBSTtnQkFDRjFzQixTQUFTZ2Ysa0JBQWtCLENBQUNsRCxXQUFXcEssV0FBV2diO1lBQ3BELEVBQUUsT0FBT3Z0QyxPQUFPO2dCQUNkMnNDLHdCQUF3QmhCLGNBQWNBLGFBQWFwcEMsTUFBTSxFQUFFdkM7WUFDN0Q7UUFDRjtJQUNGLEdBQ0Fxd0MsOEJBQThCaVgsc0JBQXNCLENBQ2xELDJCQUNELENBQUMvcUMsSUFBSSxDQUFDK3FDLHlCQUNQQyx3QkFBd0I7UUFDdEIsNEJBQTRCLFNBQVUxbUMsUUFBUSxFQUFFMFksU0FBUztZQUN2RCxJQUFJcjFCLFFBQVFxMUIsVUFBVXIxQixLQUFLO1lBQzNCMmMsU0FBUzBaLGlCQUFpQixDQUFDaEIsVUFBVWo4QixLQUFLLEVBQUU7Z0JBQzFDcThCLGdCQUFnQixTQUFTejFCLFFBQVFBLFFBQVE7WUFDM0M7UUFDRjtJQUNGLEdBQ0F1MkIsNkJBQTZCOHNCLHFCQUFxQixDQUNoRCwyQkFDRCxDQUFDaHJDLElBQUksQ0FBQ2dyQyx3QkFDUEMsMkJBQTJCO1FBQ3pCLDRCQUE0QixTQUMxQjVuRCxPQUFPLEVBQ1Brc0Msc0JBQXNCLEVBQ3RCanJCLFFBQVE7WUFFUixJQUFJO2dCQUNGQSxTQUFTZ3hCLG9CQUFvQjtZQUMvQixFQUFFLE9BQU83eEMsT0FBTztnQkFDZDJzQyx3QkFBd0Ivc0MsU0FBU2tzQyx3QkFBd0I5ckM7WUFDM0Q7UUFDRjtJQUNGLEdBQ0EydEMsZ0NBQWdDNlosd0JBQXdCLENBQ3RELDJCQUNELENBQUNqckMsSUFBSSxDQUFDaXJDLDJCQUNQQyxhQUFhO1FBQ1gsNEJBQTRCLFNBQVVDLE1BQU07WUFDMUMsSUFBSWgzQixTQUFTZzNCLE9BQU9oM0IsTUFBTTtZQUMxQmczQixTQUFTQSxPQUFPNzJCLElBQUk7WUFDcEJILFNBQVNBO1lBQ1QsT0FBUWczQixPQUFPcDNCLE9BQU8sR0FBR0k7UUFDM0I7SUFDRixHQUNBNGIsa0JBQWtCbWIsVUFBVSxDQUFDLDJCQUEyQixDQUFDbHJDLElBQUksQ0FBQ2tyQyxhQUM5REUsY0FBYztRQUNaLDRCQUE0QixTQUMxQi9uRCxPQUFPLEVBQ1Brc0Msc0JBQXNCLEVBQ3RCeGIsT0FBTztZQUVQLElBQUk7Z0JBQ0ZBO1lBQ0YsRUFBRSxPQUFPdHdCLE9BQU87Z0JBQ2Qyc0Msd0JBQXdCL3NDLFNBQVNrc0Msd0JBQXdCOXJDO1lBQzNEO1FBQ0Y7SUFDRixHQUNBOHNDLG1CQUNFNmEsV0FBVyxDQUFDLDJCQUEyQixDQUFDcHJDLElBQUksQ0FBQ29yQyxjQUMvQ0MsZUFBZTtRQUNiLDRCQUE0QixTQUFVQyxJQUFJO1lBQ3hDLElBQUlwNUIsT0FBT281QixLQUFLMWxELEtBQUs7WUFDckIsT0FBT3NzQixLQUFLbzVCLEtBQUszbEQsUUFBUTtRQUMzQjtJQUNGLEdBQ0E0akIsb0JBQ0U4aEMsWUFBWSxDQUFDLDJCQUEyQixDQUFDcnJDLElBQUksQ0FBQ3FyQyxlQUNoRGxrQyxrQkFBa0IsTUFDbEJELHlCQUF5QixHQUN6QlAsbUJBQW1CLE1BQ25CNEU7SUFDRixJQUFJRix5QkFBMEJFLG1CQUFtQixDQUFDO0lBQ2xELElBQUlnZ0Msd0JBQXdCLENBQUM7SUFDN0IsSUFBSTNqQyw4QkFBOEIsQ0FBQztJQUNuQyxJQUFJRSw0QkFBNEIsQ0FBQztJQUNqQ2xrQixvQkFBb0IsU0FBVWtqQixXQUFXLEVBQUUzYyxjQUFjLEVBQUU0QixLQUFLO1FBQzlELElBQ0UsU0FBU0EsU0FDVCxhQUFhLE9BQU9BLFNBQ3BCQSxNQUFNeS9DLE1BQU0sSUFDWCxFQUFFei9DLE1BQU15L0MsTUFBTSxDQUFDQyxTQUFTLElBQUksUUFBUTEvQyxNQUFNOUssR0FBRyxJQUM1QyxNQUFNOEssTUFBTXkvQyxNQUFNLENBQUNDLFNBQVMsR0FDOUI7WUFDQSxJQUFJLGFBQWEsT0FBTzEvQyxNQUFNeS9DLE1BQU0sRUFDbEMsTUFBTS9qRCxNQUNKO1lBRUpzRSxNQUFNeS9DLE1BQU0sQ0FBQ0MsU0FBUyxHQUFHO1lBQ3pCLElBQUl4b0MsZ0JBQWdCbmQsMEJBQTBCZ2hCLGNBQzVDNGtDLGVBQWV6b0MsaUJBQWlCO1lBQ2xDLElBQUksQ0FBQ3NvQyxxQkFBcUIsQ0FBQ0csYUFBYSxFQUFFO2dCQUN4Q0gscUJBQXFCLENBQUNHLGFBQWEsR0FBRyxDQUFDO2dCQUN2QzMvQyxRQUFRQSxNQUFNeWQsTUFBTTtnQkFDcEIxQyxjQUFjQSxZQUFZb0MsV0FBVztnQkFDckMsSUFBSXlpQyw0QkFBNEI7Z0JBQ2hDN2tDLGVBQ0UsYUFBYSxPQUFPQSxZQUFZM2tCLEdBQUcsSUFDbEN1cEQsQ0FBQUEsZUFBZTVsRCwwQkFBMEJnaEIsWUFBVyxLQUNwRDZrQyxDQUFBQSw0QkFDQyxxQ0FBcUNELGVBQWUsSUFBRztnQkFDM0RDLDZCQUNHMW9DLGlCQUNFMG9DLENBQUFBLDRCQUNDLGdEQUNBMW9DLGdCQUNBLElBQUc7Z0JBQ1QsSUFBSTJvQyxxQkFBcUI7Z0JBQ3pCLFFBQVE3L0MsU0FDTithLGdCQUFnQi9hLFNBQ2YsaUJBQWlCLE1BQ2xCLGFBQWEsT0FBT0EsTUFBTTVKLEdBQUcsR0FDeEI4Z0IsZ0JBQWdCbmQsMEJBQTBCaUcsU0FDM0MsYUFBYSxPQUFPQSxNQUFNbkgsSUFBSSxJQUFLcWUsQ0FBQUEsZ0JBQWdCbFgsTUFBTW5ILElBQUksR0FDakVxZSxpQkFDRzJvQyxDQUFBQSxxQkFDQyxpQ0FBaUMzb0MsZ0JBQWdCLEdBQUUsQ0FBQztnQkFDMUR2WSxrQkFBa0JQLGdCQUFnQjtvQkFDaEMxSSxRQUFRZ0MsS0FBSyxDQUNYLDJIQUNBa29ELDJCQUNBQztnQkFFSjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUlyc0IsdUJBQXVCeFgsc0JBQXNCLENBQUMsSUFDaER1WCxtQkFBbUJ2WCxzQkFBc0IsQ0FBQyxJQUMxQzhELCtCQUErQnJmLGFBQWEsT0FDNUNvZixpQ0FBaUNwZixhQUFhLElBQzlDNGYsNkJBQTZCNWYsYUFBYSxPQUMxQzZmLGdCQUFnQixNQUNoQkYsNkJBQTZCLEdBQzdCMFksd0JBQXdCLEdBQ3hCM1ksc0JBQXNCMWYsYUFBYSxJQUNuQ2tqQyxVQUFVLEdBQ1Y5YixZQUFZLEdBQ1ppYyxZQUFZLEdBQ1p6WCxTQUFTLEdBQ1R2RSxVQUFVLEdBQ1ZOO0lBQ0YsSUFBSWpHLDBDQUEwQyxJQUFJNUM7SUFDbEQsSUFBSW1GLG1DQUFtQyxJQUFJbkY7SUFDM0MsSUFBSThELG1DQUFtQyxJQUFJOUQ7SUFDM0MsSUFBSW1ELDJCQUEyQixJQUFJbkQ7SUFDbkMsSUFBSXpjLGNBQWMsR0FDaEJvZiw0QkFBNEIsTUFDNUJrQyxjQUFjLE1BQ2RDLHFCQUFxQixNQUNyQkMsK0JBQStCLENBQUMsR0FDaENWLDZDQUE2QyxDQUFDLEdBQzlDSCxzQ0FBc0MsQ0FBQyxHQUN2Q2dDLGlCQUFpQixHQUNqQmxCLHVCQUF1QixHQUN2QjdKLGdCQUFnQixNQUNoQitVLHdCQUF3QixHQUN4QjdLLGtCQUFrQixJQUNsQjlDLHVCQUF1QixNQUN2QkMsZUFBZSxNQUNmRSwwQkFBMEIsQ0FBQyxHQUMzQmMsNkJBQTZCLENBQUM7SUFDaEMsSUFBSXdELHFDQUFxQztRQUN2QyxPQUFPO1lBQUUxQixZQUFZO1lBQU1DLFFBQVE7WUFBTUMsUUFBUTtZQUFNQyxXQUFXO1FBQUs7SUFDekU7SUFDQSxJQUFJZCx3QkFBd0I7UUFDMUJpQyxhQUFhQTtRQUNiRixLQUFLQTtRQUNMeTZCLGFBQWEvOUI7UUFDYmcrQixZQUFZaCtCO1FBQ1ppK0IsV0FBV2orQjtRQUNYaytCLHFCQUFxQmwrQjtRQUNyQm0rQixpQkFBaUJuK0I7UUFDakJvK0Isb0JBQW9CcCtCO1FBQ3BCcStCLFNBQVNyK0I7UUFDVHMrQixZQUFZdCtCO1FBQ1p1K0IsUUFBUXYrQjtRQUNSMEMsVUFBVTFDO1FBQ1Z3K0IsZUFBZXgrQjtRQUNmeStCLGtCQUFrQnorQjtRQUNsQjArQixlQUFlMStCO1FBQ2YyK0Isc0JBQXNCMytCO1FBQ3RCNCtCLE9BQU81K0I7SUFDVDtJQUNBdUIsc0JBQXNCczlCLGVBQWUsR0FBRzcrQjtJQUN4Q3VCLHNCQUFzQmtDLFlBQVksR0FBR3pEO0lBQ3JDdUIsc0JBQXNCa0wsdUJBQXVCLEdBQUd6TTtJQUNoRHVCLHNCQUFzQnU5QixZQUFZLEdBQUc5K0I7SUFDckN1QixzQkFBc0J3OUIsY0FBYyxHQUFHLytCO0lBQ3ZDdUIsc0JBQXNCeTlCLGFBQWEsR0FBR2gvQjtJQUN0QyxJQUFJYSw4QkFBOEIsTUFDaENELDJDQUEyQyxNQUMzQ0QsK0JBQStCLE1BQy9CMkIsaUNBQWlDLE1BQ2pDMjhCLDJDQUEyQyxNQUMzQ3Z4Qiw0Q0FBNEMsTUFDNUN3eEIsOENBQThDO0lBQ2hEcitCLDhCQUE4QjtRQUM1QjJDLGFBQWEsU0FBVTV1QixPQUFPO1lBQzVCLE9BQU80dUIsWUFBWTV1QjtRQUNyQjtRQUNBMHVCLEtBQUtBO1FBQ0x5NkIsYUFBYSxTQUFVbGhELFFBQVEsRUFBRWdqQixJQUFJO1lBQ25DVix1QkFBdUI7WUFDdkJGO1lBQ0FXLHFCQUFxQkM7WUFDckIsT0FBTzhLLGNBQWM5dEIsVUFBVWdqQjtRQUNqQztRQUNBbStCLFlBQVksU0FBVXBwRCxPQUFPO1lBQzNCdXFCLHVCQUF1QjtZQUN2QkY7WUFDQSxPQUFPdUUsWUFBWTV1QjtRQUNyQjtRQUNBcXBELFdBQVcsU0FBVTUzQixNQUFNLEVBQUV4RyxJQUFJO1lBQy9CVix1QkFBdUI7WUFDdkJGO1lBQ0FXLHFCQUFxQkM7WUFDckIsT0FBTzhGLFlBQVlVLFFBQVF4RztRQUM3QjtRQUNBcStCLHFCQUFxQixTQUFVM2tDLEdBQUcsRUFBRThNLE1BQU0sRUFBRXhHLElBQUk7WUFDOUNWLHVCQUF1QjtZQUN2QkY7WUFDQVcscUJBQXFCQztZQUNyQixPQUFPNEssc0JBQXNCbFIsS0FBSzhNLFFBQVF4RztRQUM1QztRQUNBdStCLG9CQUFvQixTQUFVLzNCLE1BQU0sRUFBRXhHLElBQUk7WUFDeENWLHVCQUF1QjtZQUN2QkY7WUFDQVcscUJBQXFCQztZQUNyQnFLLGdCQUFnQixHQUFHNlgsV0FBVzFiLFFBQVF4RztRQUN4QztRQUNBcytCLGlCQUFpQixTQUFVOTNCLE1BQU0sRUFBRXhHLElBQUk7WUFDckNWLHVCQUF1QjtZQUN2QkY7WUFDQVcscUJBQXFCQztZQUNyQixPQUFPd0ssa0JBQWtCaEUsUUFBUXhHO1FBQ25DO1FBQ0F3K0IsU0FBUyxTQUFVaDRCLE1BQU0sRUFBRXhHLElBQUk7WUFDN0JWLHVCQUF1QjtZQUN2QkY7WUFDQVcscUJBQXFCQztZQUNyQixJQUFJNE4saUJBQWlCL3lCLHFCQUFxQkMsQ0FBQztZQUMzQ0QscUJBQXFCQyxDQUFDLEdBQUdza0Q7WUFDekIsSUFBSTtnQkFDRixPQUFPcDBCLFVBQVV4RSxRQUFReEc7WUFDM0IsU0FBVTtnQkFDUm5sQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E2d0IsWUFBWSxTQUFVcDZCLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxJQUFJO1lBQzdDakYsdUJBQXVCO1lBQ3ZCRjtZQUNBLElBQUl3TyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBR3NrRDtZQUN6QixJQUFJO2dCQUNGLE9BQU9oN0IsYUFBYUMsU0FBU0MsWUFBWUM7WUFDM0MsU0FBVTtnQkFDUjFwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E4d0IsUUFBUSxTQUFVdDBCLFlBQVk7WUFDNUI5Syx1QkFBdUI7WUFDdkJGO1lBQ0EsT0FBTytLLFNBQVNDO1FBQ2xCO1FBQ0F2SCxVQUFVLFNBQVUyQixZQUFZO1lBQzlCbEYsdUJBQXVCO1lBQ3ZCRjtZQUNBLElBQUl3TyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBR3NrRDtZQUN6QixJQUFJO2dCQUNGLE9BQU9qNEIsV0FBVzNDO1lBQ3BCLFNBQVU7Z0JBQ1IzcEIscUJBQXFCQyxDQUFDLEdBQUc4eUI7WUFDM0I7UUFDRjtRQUNBK3dCLGVBQWU7WUFDYnIvQix1QkFBdUI7WUFDdkJGO1FBQ0Y7UUFDQXcvQixrQkFBa0IsU0FBVXhyRCxLQUFLLEVBQUVnM0IsWUFBWTtZQUM3QzlLLHVCQUF1QjtZQUN2QkY7WUFDQSxPQUFPK0wsbUJBQW1CLzNCLE9BQU9nM0I7UUFDbkM7UUFDQXkwQixlQUFlO1lBQ2J2L0IsdUJBQXVCO1lBQ3ZCRjtZQUNBLE9BQU9tTjtRQUNUO1FBQ0F1eUIsc0JBQXNCLFNBQ3BCdDVCLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyxpQkFBaUI7WUFFakJwRyx1QkFBdUI7WUFDdkJGO1lBQ0EsT0FBT21HLHVCQUNMQyxXQUNBQyxhQUNBQztRQUVKO1FBQ0FxNUIsT0FBTztZQUNMei9CLHVCQUF1QjtZQUN2QkY7WUFDQSxPQUFPeU47UUFDVDtRQUNBbXlCLGlCQUFpQjtZQUNmMS9CLHVCQUF1QjtZQUN2QkY7WUFDQSxPQUFPOE47UUFDVDtJQUNGO0lBQ0FsTSw0QkFBNEI0QyxZQUFZLEdBQUdBO0lBQzNDNUMsNEJBQTRCNEwsdUJBQXVCLEdBQ2pEQTtJQUNGNUwsNEJBQTRCaStCLFlBQVksR0FBRyxTQUFVOTZCLE1BQU0sRUFBRUssWUFBWTtRQUN2RWxGLHVCQUF1QjtRQUN2QkY7UUFDQWE7UUFDQSxPQUFPbUosaUJBQWlCakYsUUFBUUs7SUFDbEM7SUFDQXhELDRCQUE0QmsrQixjQUFjLEdBQUcsU0FDM0MvNkIsTUFBTSxFQUNOSyxZQUFZO1FBRVpsRix1QkFBdUI7UUFDdkJGO1FBQ0EsT0FBT2dLLGlCQUFpQmpGLFFBQVFLO0lBQ2xDO0lBQ0F4RCw0QkFBNEJtK0IsYUFBYSxHQUFHLFNBQVU3M0IsV0FBVztRQUMvRGhJLHVCQUF1QjtRQUN2QkY7UUFDQSxPQUFPaUksZ0JBQWdCQztJQUN6QjtJQUNBdkcsMkNBQTJDO1FBQ3pDNEMsYUFBYSxTQUFVNXVCLE9BQU87WUFDNUIsT0FBTzR1QixZQUFZNXVCO1FBQ3JCO1FBQ0EwdUIsS0FBS0E7UUFDTHk2QixhQUFhLFNBQVVsaEQsUUFBUSxFQUFFZ2pCLElBQUk7WUFDbkNWLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPc0wsY0FBYzl0QixVQUFVZ2pCO1FBQ2pDO1FBQ0FtK0IsWUFBWSxTQUFVcHBELE9BQU87WUFDM0J1cUIsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU9tRSxZQUFZNXVCO1FBQ3JCO1FBQ0FxcEQsV0FBVyxTQUFVNTNCLE1BQU0sRUFBRXhHLElBQUk7WUFDL0JWLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPc0csWUFBWVUsUUFBUXhHO1FBQzdCO1FBQ0FxK0IscUJBQXFCLFNBQVUza0MsR0FBRyxFQUFFOE0sTUFBTSxFQUFFeEcsSUFBSTtZQUM5Q1YsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU9vTCxzQkFBc0JsUixLQUFLOE0sUUFBUXhHO1FBQzVDO1FBQ0F1K0Isb0JBQW9CLFNBQVUvM0IsTUFBTSxFQUFFeEcsSUFBSTtZQUN4Q1YsdUJBQXVCO1lBQ3ZCRTtZQUNBNkssZ0JBQWdCLEdBQUc2WCxXQUFXMWIsUUFBUXhHO1FBQ3hDO1FBQ0FzK0IsaUJBQWlCLFNBQVU5M0IsTUFBTSxFQUFFeEcsSUFBSTtZQUNyQ1YsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU9nTCxrQkFBa0JoRSxRQUFReEc7UUFDbkM7UUFDQXcrQixTQUFTLFNBQVVoNEIsTUFBTSxFQUFFeEcsSUFBSTtZQUM3QlYsdUJBQXVCO1lBQ3ZCRTtZQUNBLElBQUlvTyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBR3NrRDtZQUN6QixJQUFJO2dCQUNGLE9BQU9wMEIsVUFBVXhFLFFBQVF4RztZQUMzQixTQUFVO2dCQUNSbmxCLHFCQUFxQkMsQ0FBQyxHQUFHOHlCO1lBQzNCO1FBQ0Y7UUFDQTZ3QixZQUFZLFNBQVVwNkIsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLElBQUk7WUFDN0NqRix1QkFBdUI7WUFDdkJFO1lBQ0EsSUFBSW9PLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHc2tEO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBT2g3QixhQUFhQyxTQUFTQyxZQUFZQztZQUMzQyxTQUFVO2dCQUNSMXBCLHFCQUFxQkMsQ0FBQyxHQUFHOHlCO1lBQzNCO1FBQ0Y7UUFDQTh3QixRQUFRLFNBQVV0MEIsWUFBWTtZQUM1QjlLLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPMkssU0FBU0M7UUFDbEI7UUFDQXZILFVBQVUsU0FBVTJCLFlBQVk7WUFDOUJsRix1QkFBdUI7WUFDdkJFO1lBQ0EsSUFBSW9PLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHc2tEO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBT2o0QixXQUFXM0M7WUFDcEIsU0FBVTtnQkFDUjNwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0Erd0IsZUFBZTtZQUNici9CLHVCQUF1QjtZQUN2QkU7UUFDRjtRQUNBby9CLGtCQUFrQixTQUFVeHJELEtBQUssRUFBRWczQixZQUFZO1lBQzdDOUssdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU8yTCxtQkFBbUIvM0IsT0FBT2czQjtRQUNuQztRQUNBeTBCLGVBQWU7WUFDYnYvQix1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBTytNO1FBQ1Q7UUFDQXV5QixzQkFBc0IsU0FDcEJ0NUIsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLGlCQUFpQjtZQUVqQnBHLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPK0YsdUJBQ0xDLFdBQ0FDLGFBQ0FDO1FBRUo7UUFDQXE1QixPQUFPO1lBQ0x6L0IsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU9xTjtRQUNUO1FBQ0FteUIsaUJBQWlCO1lBQ2YxL0IsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU8wTjtRQUNUO0lBQ0Y7SUFDQW5NLHlDQUF5QzZDLFlBQVksR0FBR0E7SUFDeEQ3Qyx5Q0FBeUM2TCx1QkFBdUIsR0FDOURBO0lBQ0Y3TCx5Q0FBeUNrK0IsWUFBWSxHQUFHLFNBQ3REOTZCLE1BQU0sRUFDTkssWUFBWTtRQUVabEYsdUJBQXVCO1FBQ3ZCRTtRQUNBUztRQUNBLE9BQU9tSixpQkFBaUJqRixRQUFRSztJQUNsQztJQUNBekQseUNBQXlDbStCLGNBQWMsR0FBRyxTQUN4RC82QixNQUFNLEVBQ05LLFlBQVk7UUFFWmxGLHVCQUF1QjtRQUN2QkU7UUFDQSxPQUFPNEosaUJBQWlCakYsUUFBUUs7SUFDbEM7SUFDQXpELHlDQUF5Q28rQixhQUFhLEdBQUcsU0FDdkQ3M0IsV0FBVztRQUVYaEksdUJBQXVCO1FBQ3ZCRTtRQUNBLE9BQU82SCxnQkFBZ0JDO0lBQ3pCO0lBQ0F4RywrQkFBK0I7UUFDN0I2QyxhQUFhLFNBQVU1dUIsT0FBTztZQUM1QixPQUFPNHVCLFlBQVk1dUI7UUFDckI7UUFDQTB1QixLQUFLQTtRQUNMeTZCLGFBQWEsU0FBVWxoRCxRQUFRLEVBQUVnakIsSUFBSTtZQUNuQ1YsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU91TCxlQUFlL3RCLFVBQVVnakI7UUFDbEM7UUFDQW0rQixZQUFZLFNBQVVwcEQsT0FBTztZQUMzQnVxQix1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBT21FLFlBQVk1dUI7UUFDckI7UUFDQXFwRCxXQUFXLFNBQVU1M0IsTUFBTSxFQUFFeEcsSUFBSTtZQUMvQlYsdUJBQXVCO1lBQ3ZCRTtZQUNBaUgsaUJBQWlCLE1BQU1QLFNBQVNNLFFBQVF4RztRQUMxQztRQUNBcStCLHFCQUFxQixTQUFVM2tDLEdBQUcsRUFBRThNLE1BQU0sRUFBRXhHLElBQUk7WUFDOUNWLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPcUwsdUJBQXVCblIsS0FBSzhNLFFBQVF4RztRQUM3QztRQUNBdStCLG9CQUFvQixTQUFVLzNCLE1BQU0sRUFBRXhHLElBQUk7WUFDeENWLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPaUgsaUJBQWlCLEdBQUd5YixXQUFXMWIsUUFBUXhHO1FBQ2hEO1FBQ0FzK0IsaUJBQWlCLFNBQVU5M0IsTUFBTSxFQUFFeEcsSUFBSTtZQUNyQ1YsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU9pSCxpQkFBaUIsR0FBR2dFLFFBQVFqRSxRQUFReEc7UUFDN0M7UUFDQXcrQixTQUFTLFNBQVVoNEIsTUFBTSxFQUFFeEcsSUFBSTtZQUM3QlYsdUJBQXVCO1lBQ3ZCRTtZQUNBLElBQUlvTyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBRyt5QjtZQUN6QixJQUFJO2dCQUNGLE9BQU8zQyxXQUFXMUUsUUFBUXhHO1lBQzVCLFNBQVU7Z0JBQ1JubEIscUJBQXFCQyxDQUFDLEdBQUc4eUI7WUFDM0I7UUFDRjtRQUNBNndCLFlBQVksU0FBVXA2QixPQUFPLEVBQUVDLFVBQVUsRUFBRUMsSUFBSTtZQUM3Q2pGLHVCQUF1QjtZQUN2QkU7WUFDQSxJQUFJb08saUJBQWlCL3lCLHFCQUFxQkMsQ0FBQztZQUMzQ0QscUJBQXFCQyxDQUFDLEdBQUcreUI7WUFDekIsSUFBSTtnQkFDRixPQUFPaEosY0FBY1IsU0FBU0MsWUFBWUM7WUFDNUMsU0FBVTtnQkFDUjFwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E4d0IsUUFBUTtZQUNOcC9CLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPOEQsMkJBQTJCeHdCLGFBQWE7UUFDakQ7UUFDQSt2QixVQUFVO1lBQ1J2RCx1QkFBdUI7WUFDdkJFO1lBQ0EsSUFBSW9PLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHK3lCO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBT2hKLGNBQWNYO1lBQ3ZCLFNBQVU7Z0JBQ1JycEIscUJBQXFCQyxDQUFDLEdBQUc4eUI7WUFDM0I7UUFDRjtRQUNBK3dCLGVBQWU7WUFDYnIvQix1QkFBdUI7WUFDdkJFO1FBQ0Y7UUFDQW8vQixrQkFBa0IsU0FBVXhyRCxLQUFLLEVBQUVnM0IsWUFBWTtZQUM3QzlLLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPNkwsb0JBQW9CajRCLE9BQU9nM0I7UUFDcEM7UUFDQXkwQixlQUFlO1lBQ2J2L0IsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU9nTjtRQUNUO1FBQ0FzeUIsc0JBQXNCLFNBQ3BCdDVCLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyxpQkFBaUI7WUFFakJwRyx1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBTzZHLHdCQUNMYixXQUNBQyxhQUNBQztRQUVKO1FBQ0FxNUIsT0FBTztZQUNMei9CLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPOEQsMkJBQTJCeHdCLGFBQWE7UUFDakQ7UUFDQWtzRCxpQkFBaUI7WUFDZjEvQix1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBTzhELDJCQUEyQnh3QixhQUFhO1FBQ2pEO0lBQ0Y7SUFDQWd1Qiw2QkFBNkI4QyxZQUFZLEdBQUdBO0lBQzVDOUMsNkJBQTZCOEwsdUJBQXVCLEdBQ2xEQTtJQUNGOUwsNkJBQTZCbStCLFlBQVksR0FBRyxTQUFVOTZCLE1BQU07UUFDMUQ3RSx1QkFBdUI7UUFDdkJFO1FBQ0FTO1FBQ0EsT0FBTzJKLGtCQUFrQnpGO0lBQzNCO0lBQ0FyRCw2QkFBNkJvK0IsY0FBYyxHQUFHLFNBQVUvNkIsTUFBTTtRQUM1RDdFLHVCQUF1QjtRQUN2QkU7UUFDQSxPQUFPb0ssa0JBQWtCekY7SUFDM0I7SUFDQXJELDZCQUE2QnErQixhQUFhLEdBQUcsU0FDM0M3M0IsV0FBVyxFQUNYakQsT0FBTztRQUVQL0UsdUJBQXVCO1FBQ3ZCRTtRQUNBLE9BQU9nSSxpQkFBaUJGLGFBQWFqRDtJQUN2QztJQUNBNUIsaUNBQWlDO1FBQy9Ca0IsYUFBYSxTQUFVNXVCLE9BQU87WUFDNUIsT0FBTzR1QixZQUFZNXVCO1FBQ3JCO1FBQ0EwdUIsS0FBS0E7UUFDTHk2QixhQUFhLFNBQVVsaEQsUUFBUSxFQUFFZ2pCLElBQUk7WUFDbkNWLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPdUwsZUFBZS90QixVQUFVZ2pCO1FBQ2xDO1FBQ0FtK0IsWUFBWSxTQUFVcHBELE9BQU87WUFDM0J1cUIsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU9tRSxZQUFZNXVCO1FBQ3JCO1FBQ0FxcEQsV0FBVyxTQUFVNTNCLE1BQU0sRUFBRXhHLElBQUk7WUFDL0JWLHVCQUF1QjtZQUN2QkU7WUFDQWlILGlCQUFpQixNQUFNUCxTQUFTTSxRQUFReEc7UUFDMUM7UUFDQXErQixxQkFBcUIsU0FBVTNrQyxHQUFHLEVBQUU4TSxNQUFNLEVBQUV4RyxJQUFJO1lBQzlDVix1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBT3FMLHVCQUF1Qm5SLEtBQUs4TSxRQUFReEc7UUFDN0M7UUFDQXUrQixvQkFBb0IsU0FBVS8zQixNQUFNLEVBQUV4RyxJQUFJO1lBQ3hDVix1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBT2lILGlCQUFpQixHQUFHeWIsV0FBVzFiLFFBQVF4RztRQUNoRDtRQUNBcytCLGlCQUFpQixTQUFVOTNCLE1BQU0sRUFBRXhHLElBQUk7WUFDckNWLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPaUgsaUJBQWlCLEdBQUdnRSxRQUFRakUsUUFBUXhHO1FBQzdDO1FBQ0F3K0IsU0FBUyxTQUFVaDRCLE1BQU0sRUFBRXhHLElBQUk7WUFDN0JWLHVCQUF1QjtZQUN2QkU7WUFDQSxJQUFJb08saUJBQWlCL3lCLHFCQUFxQkMsQ0FBQztZQUMzQ0QscUJBQXFCQyxDQUFDLEdBQUd1a0Q7WUFDekIsSUFBSTtnQkFDRixPQUFPbjBCLFdBQVcxRSxRQUFReEc7WUFDNUIsU0FBVTtnQkFDUm5sQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E2d0IsWUFBWSxTQUFVcDZCLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxJQUFJO1lBQzdDakYsdUJBQXVCO1lBQ3ZCRTtZQUNBLElBQUlvTyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBR3VrRDtZQUN6QixJQUFJO2dCQUNGLE9BQU9oNkIsZ0JBQWdCaEIsU0FBU0MsWUFBWUM7WUFDOUMsU0FBVTtnQkFDUjFwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E4d0IsUUFBUTtZQUNOcC9CLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPOEQsMkJBQTJCeHdCLGFBQWE7UUFDakQ7UUFDQSt2QixVQUFVO1lBQ1J2RCx1QkFBdUI7WUFDdkJFO1lBQ0EsSUFBSW9PLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHdWtEO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBT2g2QixnQkFBZ0JuQjtZQUN6QixTQUFVO2dCQUNScnBCLHFCQUFxQkMsQ0FBQyxHQUFHOHlCO1lBQzNCO1FBQ0Y7UUFDQSt3QixlQUFlO1lBQ2JyL0IsdUJBQXVCO1lBQ3ZCRTtRQUNGO1FBQ0FvL0Isa0JBQWtCLFNBQVV4ckQsS0FBSyxFQUFFZzNCLFlBQVk7WUFDN0M5Syx1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBTytMLHNCQUFzQm40QixPQUFPZzNCO1FBQ3RDO1FBQ0F5MEIsZUFBZTtZQUNidi9CLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPbU47UUFDVDtRQUNBbXlCLHNCQUFzQixTQUNwQnQ1QixTQUFTLEVBQ1RDLFdBQVcsRUFDWEMsaUJBQWlCO1lBRWpCcEcsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU82Ryx3QkFDTGIsV0FDQUMsYUFDQUM7UUFFSjtRQUNBcTVCLE9BQU87WUFDTHovQix1QkFBdUI7WUFDdkJFO1lBQ0EsT0FBTzhELDJCQUEyQnh3QixhQUFhO1FBQ2pEO1FBQ0Frc0QsaUJBQWlCO1lBQ2YxL0IsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU84RCwyQkFBMkJ4d0IsYUFBYTtRQUNqRDtJQUNGO0lBQ0EydkIsK0JBQStCbUIsWUFBWSxHQUFHQTtJQUM5Q25CLCtCQUErQm1LLHVCQUF1QixHQUNwREE7SUFDRm5LLCtCQUErQnc4QixZQUFZLEdBQUcsU0FBVTk2QixNQUFNO1FBQzVEN0UsdUJBQXVCO1FBQ3ZCRTtRQUNBUztRQUNBLE9BQU9pSyxvQkFBb0IvRjtJQUM3QjtJQUNBMUIsK0JBQStCeThCLGNBQWMsR0FBRyxTQUFVLzZCLE1BQU07UUFDOUQ3RSx1QkFBdUI7UUFDdkJFO1FBQ0EsT0FBTzBLLG9CQUFvQi9GO0lBQzdCO0lBQ0ExQiwrQkFBK0IwOEIsYUFBYSxHQUFHLFNBQzdDNzNCLFdBQVcsRUFDWGpELE9BQU87UUFFUC9FLHVCQUF1QjtRQUN2QkU7UUFDQSxPQUFPa0ksbUJBQW1CSixhQUFhakQ7SUFDekM7SUFDQSs2QiwyQ0FBMkM7UUFDekN6N0IsYUFBYSxTQUFVNXVCLE9BQU87WUFDNUJnQjtZQUNBLE9BQU80dEIsWUFBWTV1QjtRQUNyQjtRQUNBMHVCLEtBQUssU0FBVUMsTUFBTTtZQUNuQjd0QjtZQUNBLE9BQU80dEIsSUFBSUM7UUFDYjtRQUNBdzZCLGFBQWEsU0FBVWxoRCxRQUFRLEVBQUVnakIsSUFBSTtZQUNuQ1YsdUJBQXVCO1lBQ3ZCenBCO1lBQ0F1cEI7WUFDQSxPQUFPMEwsY0FBYzl0QixVQUFVZ2pCO1FBQ2pDO1FBQ0FtK0IsWUFBWSxTQUFVcHBELE9BQU87WUFDM0J1cUIsdUJBQXVCO1lBQ3ZCenBCO1lBQ0F1cEI7WUFDQSxPQUFPdUUsWUFBWTV1QjtRQUNyQjtRQUNBcXBELFdBQVcsU0FBVTUzQixNQUFNLEVBQUV4RyxJQUFJO1lBQy9CVix1QkFBdUI7WUFDdkJ6cEI7WUFDQXVwQjtZQUNBLE9BQU8wRyxZQUFZVSxRQUFReEc7UUFDN0I7UUFDQXErQixxQkFBcUIsU0FBVTNrQyxHQUFHLEVBQUU4TSxNQUFNLEVBQUV4RyxJQUFJO1lBQzlDVix1QkFBdUI7WUFDdkJ6cEI7WUFDQXVwQjtZQUNBLE9BQU93TCxzQkFBc0JsUixLQUFLOE0sUUFBUXhHO1FBQzVDO1FBQ0F1K0Isb0JBQW9CLFNBQVUvM0IsTUFBTSxFQUFFeEcsSUFBSTtZQUN4Q1YsdUJBQXVCO1lBQ3ZCenBCO1lBQ0F1cEI7WUFDQWlMLGdCQUFnQixHQUFHNlgsV0FBVzFiLFFBQVF4RztRQUN4QztRQUNBcytCLGlCQUFpQixTQUFVOTNCLE1BQU0sRUFBRXhHLElBQUk7WUFDckNWLHVCQUF1QjtZQUN2QnpwQjtZQUNBdXBCO1lBQ0EsT0FBT29MLGtCQUFrQmhFLFFBQVF4RztRQUNuQztRQUNBdytCLFNBQVMsU0FBVWg0QixNQUFNLEVBQUV4RyxJQUFJO1lBQzdCVix1QkFBdUI7WUFDdkJ6cEI7WUFDQXVwQjtZQUNBLElBQUl3TyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBR3NrRDtZQUN6QixJQUFJO2dCQUNGLE9BQU9wMEIsVUFBVXhFLFFBQVF4RztZQUMzQixTQUFVO2dCQUNSbmxCLHFCQUFxQkMsQ0FBQyxHQUFHOHlCO1lBQzNCO1FBQ0Y7UUFDQTZ3QixZQUFZLFNBQVVwNkIsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLElBQUk7WUFDN0NqRix1QkFBdUI7WUFDdkJ6cEI7WUFDQXVwQjtZQUNBLElBQUl3TyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBR3NrRDtZQUN6QixJQUFJO2dCQUNGLE9BQU9oN0IsYUFBYUMsU0FBU0MsWUFBWUM7WUFDM0MsU0FBVTtnQkFDUjFwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E4d0IsUUFBUSxTQUFVdDBCLFlBQVk7WUFDNUI5Syx1QkFBdUI7WUFDdkJ6cEI7WUFDQXVwQjtZQUNBLE9BQU8rSyxTQUFTQztRQUNsQjtRQUNBdkgsVUFBVSxTQUFVMkIsWUFBWTtZQUM5QmxGLHVCQUF1QjtZQUN2QnpwQjtZQUNBdXBCO1lBQ0EsSUFBSXdPLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHc2tEO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBT2o0QixXQUFXM0M7WUFDcEIsU0FBVTtnQkFDUjNwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0Erd0IsZUFBZTtZQUNici9CLHVCQUF1QjtZQUN2QnpwQjtZQUNBdXBCO1FBQ0Y7UUFDQXcvQixrQkFBa0IsU0FBVXhyRCxLQUFLLEVBQUVnM0IsWUFBWTtZQUM3QzlLLHVCQUF1QjtZQUN2QnpwQjtZQUNBdXBCO1lBQ0EsT0FBTytMLG1CQUFtQi8zQixPQUFPZzNCO1FBQ25DO1FBQ0F5MEIsZUFBZTtZQUNidi9CLHVCQUF1QjtZQUN2QnpwQjtZQUNBdXBCO1lBQ0EsT0FBT21OO1FBQ1Q7UUFDQXV5QixzQkFBc0IsU0FDcEJ0NUIsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLGlCQUFpQjtZQUVqQnBHLHVCQUF1QjtZQUN2QnpwQjtZQUNBdXBCO1lBQ0EsT0FBT21HLHVCQUNMQyxXQUNBQyxhQUNBQztRQUVKO1FBQ0FxNUIsT0FBTztZQUNMei9CLHVCQUF1QjtZQUN2QnpwQjtZQUNBdXBCO1lBQ0EsT0FBT3lOO1FBQ1Q7UUFDQW15QixpQkFBaUI7WUFDZjEvQix1QkFBdUI7WUFDdkJGO1lBQ0EsT0FBTzhOO1FBQ1Q7UUFDQXRKLGNBQWMsU0FBVWpoQixJQUFJO1lBQzFCOU07WUFDQSxPQUFPK3RCLGFBQWFqaEI7UUFDdEI7SUFDRjtJQUNBeThDLHlDQUF5Q3h5Qix1QkFBdUIsR0FDOURBO0lBQ0Z3eUIseUNBQXlDSCxZQUFZLEdBQUcsU0FDdEQ5NkIsTUFBTSxFQUNOSyxZQUFZO1FBRVpsRix1QkFBdUI7UUFDdkJ6cEI7UUFDQXVwQjtRQUNBLE9BQU9nSyxpQkFBaUJqRixRQUFRSztJQUNsQztJQUNBNDZCLHlDQUF5Q0YsY0FBYyxHQUFHLFNBQ3hELzZCLE1BQU0sRUFDTkssWUFBWTtRQUVabEYsdUJBQXVCO1FBQ3ZCenBCO1FBQ0F1cEI7UUFDQSxPQUFPZ0ssaUJBQWlCakYsUUFBUUs7SUFDbEM7SUFDQTQ2Qix5Q0FBeUNELGFBQWEsR0FBRyxTQUN2RDczQixXQUFXO1FBRVhoSSx1QkFBdUI7UUFDdkJ6cEI7UUFDQXVwQjtRQUNBLE9BQU9pSSxnQkFBZ0JDO0lBQ3pCO0lBQ0F1Ryw0Q0FBNEM7UUFDMUNsSyxhQUFhLFNBQVU1dUIsT0FBTztZQUM1QmdCO1lBQ0EsT0FBTzR0QixZQUFZNXVCO1FBQ3JCO1FBQ0EwdUIsS0FBSyxTQUFVQyxNQUFNO1lBQ25CN3RCO1lBQ0EsT0FBTzR0QixJQUFJQztRQUNiO1FBQ0F3NkIsYUFBYSxTQUFVbGhELFFBQVEsRUFBRWdqQixJQUFJO1lBQ25DVix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU91TCxlQUFlL3RCLFVBQVVnakI7UUFDbEM7UUFDQW0rQixZQUFZLFNBQVVwcEQsT0FBTztZQUMzQnVxQix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU9tRSxZQUFZNXVCO1FBQ3JCO1FBQ0FxcEQsV0FBVyxTQUFVNTNCLE1BQU0sRUFBRXhHLElBQUk7WUFDL0JWLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0FpSCxpQkFBaUIsTUFBTVAsU0FBU00sUUFBUXhHO1FBQzFDO1FBQ0FxK0IscUJBQXFCLFNBQVUza0MsR0FBRyxFQUFFOE0sTUFBTSxFQUFFeEcsSUFBSTtZQUM5Q1YsdUJBQXVCO1lBQ3ZCenBCO1lBQ0EycEI7WUFDQSxPQUFPcUwsdUJBQXVCblIsS0FBSzhNLFFBQVF4RztRQUM3QztRQUNBdStCLG9CQUFvQixTQUFVLzNCLE1BQU0sRUFBRXhHLElBQUk7WUFDeENWLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBT2lILGlCQUFpQixHQUFHeWIsV0FBVzFiLFFBQVF4RztRQUNoRDtRQUNBcytCLGlCQUFpQixTQUFVOTNCLE1BQU0sRUFBRXhHLElBQUk7WUFDckNWLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBT2lILGlCQUFpQixHQUFHZ0UsUUFBUWpFLFFBQVF4RztRQUM3QztRQUNBdytCLFNBQVMsU0FBVWg0QixNQUFNLEVBQUV4RyxJQUFJO1lBQzdCVix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLElBQUlvTyxpQkFBaUIveUIscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBRyt5QjtZQUN6QixJQUFJO2dCQUNGLE9BQU8zQyxXQUFXMUUsUUFBUXhHO1lBQzVCLFNBQVU7Z0JBQ1JubEIscUJBQXFCQyxDQUFDLEdBQUc4eUI7WUFDM0I7UUFDRjtRQUNBNndCLFlBQVksU0FBVXA2QixPQUFPLEVBQUVDLFVBQVUsRUFBRUMsSUFBSTtZQUM3Q2pGLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsSUFBSW9PLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHK3lCO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBT2hKLGNBQWNSLFNBQVNDLFlBQVlDO1lBQzVDLFNBQVU7Z0JBQ1IxcEIscUJBQXFCQyxDQUFDLEdBQUc4eUI7WUFDM0I7UUFDRjtRQUNBOHdCLFFBQVE7WUFDTnAvQix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU84RCwyQkFBMkJ4d0IsYUFBYTtRQUNqRDtRQUNBK3ZCLFVBQVU7WUFDUnZELHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsSUFBSW9PLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHK3lCO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBT2hKLGNBQWNYO1lBQ3ZCLFNBQVU7Z0JBQ1JycEIscUJBQXFCQyxDQUFDLEdBQUc4eUI7WUFDM0I7UUFDRjtRQUNBK3dCLGVBQWU7WUFDYnIvQix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtRQUNGO1FBQ0FvL0Isa0JBQWtCLFNBQVV4ckQsS0FBSyxFQUFFZzNCLFlBQVk7WUFDN0M5Syx1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU82TCxvQkFBb0JqNEIsT0FBT2czQjtRQUNwQztRQUNBeTBCLGVBQWU7WUFDYnYvQix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU9nTjtRQUNUO1FBQ0FzeUIsc0JBQXNCLFNBQ3BCdDVCLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyxpQkFBaUI7WUFFakJwRyx1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU82Ryx3QkFDTGIsV0FDQUMsYUFDQUM7UUFFSjtRQUNBcTVCLE9BQU87WUFDTHovQix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU84RCwyQkFBMkJ4d0IsYUFBYTtRQUNqRDtRQUNBa3NELGlCQUFpQjtZQUNmMS9CLHVCQUF1QjtZQUN2QkU7WUFDQSxPQUFPOEQsMkJBQTJCeHdCLGFBQWE7UUFDakQ7UUFDQTh3QixjQUFjLFNBQVVqaEIsSUFBSTtZQUMxQjlNO1lBQ0EsT0FBTyt0QixhQUFhamhCO1FBQ3RCO0lBQ0Y7SUFDQWtyQiwwQ0FBMENqQix1QkFBdUIsR0FDL0RBO0lBQ0ZpQiwwQ0FBMENveEIsWUFBWSxHQUFHLFNBQVU5NkIsTUFBTTtRQUN2RTdFLHVCQUF1QjtRQUN2QnpwQjtRQUNBMnBCO1FBQ0EsT0FBT29LLGtCQUFrQnpGO0lBQzNCO0lBQ0EwSiwwQ0FBMENxeEIsY0FBYyxHQUFHLFNBQ3pELzZCLE1BQU07UUFFTjdFLHVCQUF1QjtRQUN2QnpwQjtRQUNBMnBCO1FBQ0EsT0FBT29LLGtCQUFrQnpGO0lBQzNCO0lBQ0EwSiwwQ0FBMENzeEIsYUFBYSxHQUFHLFNBQ3hENzNCLFdBQVcsRUFDWGpELE9BQU87UUFFUC9FLHVCQUF1QjtRQUN2QnpwQjtRQUNBMnBCO1FBQ0EsT0FBT2dJLGlCQUFpQkYsYUFBYWpEO0lBQ3ZDO0lBQ0FnN0IsOENBQThDO1FBQzVDMTdCLGFBQWEsU0FBVTV1QixPQUFPO1lBQzVCZ0I7WUFDQSxPQUFPNHRCLFlBQVk1dUI7UUFDckI7UUFDQTB1QixLQUFLLFNBQVVDLE1BQU07WUFDbkI3dEI7WUFDQSxPQUFPNHRCLElBQUlDO1FBQ2I7UUFDQXc2QixhQUFhLFNBQVVsaEQsUUFBUSxFQUFFZ2pCLElBQUk7WUFDbkNWLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBT3VMLGVBQWUvdEIsVUFBVWdqQjtRQUNsQztRQUNBbStCLFlBQVksU0FBVXBwRCxPQUFPO1lBQzNCdXFCLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBT21FLFlBQVk1dUI7UUFDckI7UUFDQXFwRCxXQUFXLFNBQVU1M0IsTUFBTSxFQUFFeEcsSUFBSTtZQUMvQlYsdUJBQXVCO1lBQ3ZCenBCO1lBQ0EycEI7WUFDQWlILGlCQUFpQixNQUFNUCxTQUFTTSxRQUFReEc7UUFDMUM7UUFDQXErQixxQkFBcUIsU0FBVTNrQyxHQUFHLEVBQUU4TSxNQUFNLEVBQUV4RyxJQUFJO1lBQzlDVix1QkFBdUI7WUFDdkJ6cEI7WUFDQTJwQjtZQUNBLE9BQU9xTCx1QkFBdUJuUixLQUFLOE0sUUFBUXhHO1FBQzdDO1FBQ0F1K0Isb0JBQW9CLFNBQVUvM0IsTUFBTSxFQUFFeEcsSUFBSTtZQUN4Q1YsdUJBQXVCO1lBQ3ZCenBCO1lBQ0EycEI7WUFDQSxPQUFPaUgsaUJBQWlCLEdBQUd5YixXQUFXMWIsUUFBUXhHO1FBQ2hEO1FBQ0FzK0IsaUJBQWlCLFNBQVU5M0IsTUFBTSxFQUFFeEcsSUFBSTtZQUNyQ1YsdUJBQXVCO1lBQ3ZCenBCO1lBQ0EycEI7WUFDQSxPQUFPaUgsaUJBQWlCLEdBQUdnRSxRQUFRakUsUUFBUXhHO1FBQzdDO1FBQ0F3K0IsU0FBUyxTQUFVaDRCLE1BQU0sRUFBRXhHLElBQUk7WUFDN0JWLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsSUFBSW9PLGlCQUFpQi95QixxQkFBcUJDLENBQUM7WUFDM0NELHFCQUFxQkMsQ0FBQyxHQUFHK3lCO1lBQ3pCLElBQUk7Z0JBQ0YsT0FBTzNDLFdBQVcxRSxRQUFReEc7WUFDNUIsU0FBVTtnQkFDUm5sQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E2d0IsWUFBWSxTQUFVcDZCLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxJQUFJO1lBQzdDakYsdUJBQXVCO1lBQ3ZCenBCO1lBQ0EycEI7WUFDQSxJQUFJb08saUJBQWlCL3lCLHFCQUFxQkMsQ0FBQztZQUMzQ0QscUJBQXFCQyxDQUFDLEdBQUcreUI7WUFDekIsSUFBSTtnQkFDRixPQUFPeEksZ0JBQWdCaEIsU0FBU0MsWUFBWUM7WUFDOUMsU0FBVTtnQkFDUjFwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0E4d0IsUUFBUTtZQUNOcC9CLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBTzhELDJCQUEyQnh3QixhQUFhO1FBQ2pEO1FBQ0ErdkIsVUFBVTtZQUNSdkQsdUJBQXVCO1lBQ3ZCenBCO1lBQ0EycEI7WUFDQSxJQUFJb08saUJBQWlCL3lCLHFCQUFxQkMsQ0FBQztZQUMzQ0QscUJBQXFCQyxDQUFDLEdBQUcreUI7WUFDekIsSUFBSTtnQkFDRixPQUFPeEksZ0JBQWdCbkI7WUFDekIsU0FBVTtnQkFDUnJwQixxQkFBcUJDLENBQUMsR0FBRzh5QjtZQUMzQjtRQUNGO1FBQ0Erd0IsZUFBZTtZQUNici9CLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1FBQ0Y7UUFDQW8vQixrQkFBa0IsU0FBVXhyRCxLQUFLLEVBQUVnM0IsWUFBWTtZQUM3QzlLLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBTytMLHNCQUFzQm40QixPQUFPZzNCO1FBQ3RDO1FBQ0F5MEIsZUFBZTtZQUNidi9CLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBT21OO1FBQ1Q7UUFDQW15QixzQkFBc0IsU0FDcEJ0NUIsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLGlCQUFpQjtZQUVqQnBHLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBTzZHLHdCQUNMYixXQUNBQyxhQUNBQztRQUVKO1FBQ0FxNUIsT0FBTztZQUNMei9CLHVCQUF1QjtZQUN2QnpwQjtZQUNBMnBCO1lBQ0EsT0FBTzhELDJCQUEyQnh3QixhQUFhO1FBQ2pEO1FBQ0Frc0QsaUJBQWlCO1lBQ2YxL0IsdUJBQXVCO1lBQ3ZCRTtZQUNBLE9BQU84RCwyQkFBMkJ4d0IsYUFBYTtRQUNqRDtRQUNBOHdCLGNBQWMsU0FBVWpoQixJQUFJO1lBQzFCOU07WUFDQSxPQUFPK3RCLGFBQWFqaEI7UUFDdEI7SUFDRjtJQUNBMDhDLDRDQUE0Q3p5Qix1QkFBdUIsR0FDakVBO0lBQ0Z5eUIsNENBQTRDSixZQUFZLEdBQUcsU0FDekQ5NkIsTUFBTTtRQUVON0UsdUJBQXVCO1FBQ3ZCenBCO1FBQ0EycEI7UUFDQSxPQUFPMEssb0JBQW9CL0Y7SUFDN0I7SUFDQWs3Qiw0Q0FBNENILGNBQWMsR0FBRyxTQUMzRC82QixNQUFNO1FBRU43RSx1QkFBdUI7UUFDdkJ6cEI7UUFDQTJwQjtRQUNBLE9BQU8wSyxvQkFBb0IvRjtJQUM3QjtJQUNBazdCLDRDQUE0Q0YsYUFBYSxHQUFHLFNBQzFENzNCLFdBQVcsRUFDWGpELE9BQU87UUFFUC9FLHVCQUF1QjtRQUN2QnpwQjtRQUNBMnBCO1FBQ0EsT0FBT2tJLG1CQUFtQkosYUFBYWpEO0lBQ3pDO0lBQ0EsSUFBSWdRLHVCQUF1QixDQUFDO0lBQzVCLElBQUl2RiwwQ0FBMEMsSUFBSS9SO0lBQ2xELElBQUl1WCxpQ0FBaUMsSUFBSXZYO0lBQ3pDLElBQUk2WSxzREFBc0QsSUFBSTdZO0lBQzlELElBQUlnWSw4Q0FBOEMsSUFBSWhZO0lBQ3RELElBQUlnWiw0Q0FBNEMsSUFBSWhaO0lBQ3BELElBQUlzUixvQ0FBb0MsSUFBSXRSO0lBQzVDLElBQUlzWSw2QkFBNkIsSUFBSXRZO0lBQ3JDLElBQUlxWSxnQ0FBZ0MsSUFBSXJZO0lBQ3hDLElBQUltWCxvQ0FBb0MsSUFBSW5YO0lBQzVDLElBQUlrUiwyQkFBMkIsSUFBSWxSO0lBQ25DdGpCLE9BQU93aEQsTUFBTSxDQUFDNW1CO0lBQ2QsSUFBSXRGLHdCQUF3QjtRQUN4QnV3QixXQUFXLFNBQVVDLFNBQVM7WUFDNUIsSUFBSWpJLFFBQVE1aEQ7WUFDWixJQUFJLFNBQVM0aEQsU0FBUzk1QyxlQUFlLE1BQU04NUMsTUFBTTlpRCxHQUFHLEVBQUU7Z0JBQ3BELElBQUltaUIsV0FBVzJnQyxNQUFNOTRDLFNBQVM7Z0JBQzlCbVksU0FBUzZvQyx3QkFBd0IsSUFDL0IxckQsUUFBUWdDLEtBQUssQ0FDWCx5UkFDQXFDLDBCQUEwQm0vQyxVQUFVO2dCQUV4QzNnQyxTQUFTNm9DLHdCQUF3QixHQUFHLENBQUM7WUFDdkM7WUFDQSxPQUFPLENBQUNELFlBQVlBLFVBQVVwckIsZUFBZSxJQUN6QzEyQix1QkFBdUI4aEQsZUFBZUEsWUFDdEMsQ0FBQztRQUNQO1FBQ0F2ckIsaUJBQWlCLFNBQVVyTixJQUFJLEVBQUV6UixPQUFPLEVBQUVsWSxRQUFRO1lBQ2hEMnBCLE9BQU9BLEtBQUt3TixlQUFlO1lBQzNCLElBQUkzMEIsT0FBTzBzQixrQkFBa0J2RixPQUMzQnZ4QixTQUFTNGYsYUFBYXhWO1lBQ3hCcEssT0FBTzhmLE9BQU8sR0FBR0E7WUFDakIsS0FBSyxNQUFNbFksWUFDVCxTQUFTQSxZQUNSZ3hCLENBQUFBLHNCQUFzQmh4QixXQUFZNUgsT0FBTzRILFFBQVEsR0FBR0EsUUFBUTtZQUMvRGtZLFVBQVVDLGNBQWN3UixNQUFNdnhCLFFBQVFvSztZQUN0QyxTQUFTMFYsV0FDTjhSLENBQUFBLHNCQUFzQjlSLFNBQVN5UixNQUFNbm5CLE9BQ3RDK1Ysb0JBQW9CTCxTQUFTeVIsTUFBTW5uQixLQUFJO1lBQ3pDd0YseUJBQXlCMmhCLE1BQU1ubkI7UUFDakM7UUFDQXd2QixxQkFBcUIsU0FBVXJJLElBQUksRUFBRXpSLE9BQU8sRUFBRWxZLFFBQVE7WUFDcEQycEIsT0FBT0EsS0FBS3dOLGVBQWU7WUFDM0IsSUFBSTMwQixPQUFPMHNCLGtCQUFrQnZGLE9BQzNCdnhCLFNBQVM0ZixhQUFheFY7WUFDeEJwSyxPQUFPWixHQUFHLEdBQUdvaUI7WUFDYnhoQixPQUFPOGYsT0FBTyxHQUFHQTtZQUNqQixLQUFLLE1BQU1sWSxZQUNULFNBQVNBLFlBQ1JneEIsQ0FBQUEsc0JBQXNCaHhCLFdBQVk1SCxPQUFPNEgsUUFBUSxHQUFHQSxRQUFRO1lBQy9Ea1ksVUFBVUMsY0FBY3dSLE1BQU12eEIsUUFBUW9LO1lBQ3RDLFNBQVMwVixXQUNOOFIsQ0FBQUEsc0JBQXNCOVIsU0FBU3lSLE1BQU1ubkIsT0FDdEMrVixvQkFBb0JMLFNBQVN5UixNQUFNbm5CLEtBQUk7WUFDekN3Rix5QkFBeUIyaEIsTUFBTW5uQjtRQUNqQztRQUNBaWdELG9CQUFvQixTQUFVOTRCLElBQUksRUFBRTNwQixRQUFRO1lBQzFDMnBCLE9BQU9BLEtBQUt3TixlQUFlO1lBQzNCLElBQUkzMEIsT0FBTzBzQixrQkFBa0J2RixPQUMzQnZ4QixTQUFTNGYsYUFBYXhWO1lBQ3hCcEssT0FBT1osR0FBRyxHQUFHd2lCO1lBQ2IsS0FBSyxNQUFNaGEsWUFDVCxTQUFTQSxZQUNSZ3hCLENBQUFBLHNCQUFzQmh4QixXQUFZNUgsT0FBTzRILFFBQVEsR0FBR0EsUUFBUTtZQUMvREEsV0FBV21ZLGNBQWN3UixNQUFNdnhCLFFBQVFvSztZQUN2QyxTQUFTeEMsWUFDTmdxQixDQUFBQSxzQkFBc0JocUIsVUFBVTJwQixNQUFNbm5CLE9BQ3ZDK1Ysb0JBQW9CdlksVUFBVTJwQixNQUFNbm5CLEtBQUk7WUFDMUMsU0FBU2tGLDBCQUNQLGVBQ0UsT0FBT0EsdUJBQXVCZzdDLHdCQUF3QixJQUN4RGg3Qyx1QkFBdUJnN0Msd0JBQXdCLENBQUMvNEIsTUFBTW5uQjtRQUMxRDtJQUNGLEdBQ0FtZ0Qsb0JBQ0UsZUFBZSxPQUFPQyxjQUNsQkEsY0FDQSxTQUFVOXBELEtBQUs7UUFDYixJQUNFLEtBQ3VDLEVBQ3ZDLGNBYUQsTUFBTSxJQUNMLGFBQWEsT0FBT3pELFdBQ3BCLGVBQWUsT0FBT0EsUUFBUTh0RCxJQUFJLEVBQ2xDO1lBQ0E5dEQsUUFBUTh0RCxJQUFJLENBQUMscUJBQXFCcnFEO1lBQ2xDO1FBQ0Y7UUFDQWhDLFFBQVFnQyxLQUFLLENBQUNBO0lBQ2hCLEdBQ053ZixnQkFBZ0IsTUFDaEJnYSxvQkFBb0IsTUFDcEIwSSw4QkFBOEJsK0IsTUFDNUIsNktBRUZrb0IsbUJBQW1CLENBQUM7SUFDdEIsSUFBSXNSLHVCQUF1QixDQUFDO0lBQzVCLElBQUlrRCw2Q0FBNkMsQ0FBQztJQUNsRCxJQUFJOUMsMkJBQTJCLENBQUM7SUFDaEMsSUFBSTZDLGlEQUFpRCxDQUFDO0lBQ3RELElBQUlGLCtCQUErQixDQUFDO0lBQ3BDLElBQUlrRCwwQkFBMEIsQ0FBQztJQUMvQixJQUFJQywwQkFBMEIsQ0FBQztJQUMvQixJQUFJN0IsbUJBQW1CO1FBQ25CanFCLFlBQVk7UUFDWjRwQixhQUFhO1FBQ2JFLFdBQVc7SUFDYixHQUNBd0Qsa0RBQWtELENBQUMsR0FDbkRRLGNBQWMzOEIsYUFBYTtJQUM3QixJQUFJNDhCLG9CQUFvQjU4QixhQUFhO0lBQ3JDLElBQUkrOEIscUJBQXFCLzhCLGFBQWE7SUFDdEMsSUFBSTg4QixnQkFBZ0IsQ0FBQztJQUNyQixJQUFJTCwwQkFBMEIsTUFDNUJELHdCQUF3QixNQUN4QnhrQiwrQkFBK0IsQ0FBQyxHQUNoQytsQix1QkFDRSxnQkFBZ0IsT0FBT3dqQixrQkFDbkJBLGtCQUNBO1FBQ0UsSUFBSWxzQyxZQUFZLEVBQUUsRUFDaEI0b0IsU0FBVSxJQUFJLENBQUNBLE1BQU0sR0FBRztZQUN0QkMsU0FBUyxDQUFDO1lBQ1ZzakIsa0JBQWtCLFNBQVV4cEQsSUFBSSxFQUFFcXhCLFFBQVE7Z0JBQ3hDaFUsVUFBVTVkLElBQUksQ0FBQzR4QjtZQUNqQjtRQUNGO1FBQ0YsSUFBSSxDQUFDaVYsS0FBSyxHQUFHO1lBQ1hMLE9BQU9DLE9BQU8sR0FBRyxDQUFDO1lBQ2xCN29CLFVBQVU3ZCxPQUFPLENBQUMsU0FBVTZ4QixRQUFRO2dCQUNsQyxPQUFPQTtZQUNUO1FBQ0Y7SUFDRixHQUNOK1UscUJBQXFCeWMsVUFBVXlCLHlCQUF5QixFQUN4RGplLGlCQUFpQndjLFVBQVVnQyx1QkFBdUIsRUFDbER0b0IsZUFBZTtRQUNidDhCLFVBQVVVO1FBQ1Y4b0QsVUFBVTtRQUNWQyxVQUFVO1FBQ1YzNEMsZUFBZTtRQUNmRSxnQkFBZ0I7UUFDaEIwNEMsY0FBYztRQUNkOWtCLGtCQUFrQjtRQUNsQkcsbUJBQW1CO0lBQ3JCLEdBQ0E0a0IsOEJBQThCNWxELHFCQUFxQjh0QixDQUFDO0lBQ3REOXRCLHFCQUFxQjh0QixDQUFDLEdBQUcsU0FBVXBWLFVBQVUsRUFBRWtWLFdBQVc7UUFDeEQsYUFBYSxPQUFPQSxlQUNsQixTQUFTQSxlQUNULGVBQWUsT0FBT0EsWUFBWTFVLElBQUksSUFDdENULG9CQUFvQkMsWUFBWWtWO1FBQ2xDLFNBQVNnNEIsK0JBQ1BBLDRCQUE0Qmx0QyxZQUFZa1Y7SUFDNUM7SUFDQSxJQUFJNFUsZUFBZXgrQixhQUFhLE9BQzlCeWtDLDRDQUE0QztJQUM5Q0EsNENBQTRDLElBQUl2bUI7SUFDaEQsSUFBSXNwQiwyQkFBMkIsQ0FBQyxHQUM5QkMsNEJBQTRCLENBQUMsR0FDN0IrQyxpQkFBaUIsQ0FBQyxHQUNsQnRCLGtCQUFrQixlQUFlLE9BQU9nUCxVQUFVQSxVQUFVaDZCLEtBQzVENm9CLGFBQWEsTUFDYjBDLGtCQUFrQixNQUNsQkMsaUJBQWlCLE1BQ2pCekMsb0NBQW9DLENBQUMsR0FDckNxQixhQUFhLE1BQ2JFLHdCQUF3QixDQUFDLEdBQ3pCMEIsdUJBQXVCLE1BQ3ZCcUMsc0JBQXNCLE1BQ3RCb0gseUJBQXlCO1FBQ3ZCa08saUJBQWlCLFNBQVVDLFlBQVk7WUFDckMsSUFBSXB6QixRQUFRNUosWUFBWXlQLGVBQ3RCd3RCLGVBQWVyekIsTUFBTTFKLElBQUksQ0FBQ25wQixHQUFHLENBQUNpbUQ7WUFDaEMsS0FBSyxNQUFNQyxnQkFDUixnQkFBZ0JELGdCQUNqQnB6QixNQUFNMUosSUFBSSxDQUFDMXRCLEdBQUcsQ0FBQ3dxRCxjQUFjQyxhQUFZO1lBQzNDLE9BQU9BO1FBQ1Q7UUFDQUMsVUFBVTtZQUNSLE9BQU9uckQ7UUFDVDtJQUNGLEdBQ0E4MkMsaUJBQWlCLEdBQ2pCQyx3QkFBd0IsR0FDeEJLLFlBQVksR0FDWkksaUJBQWlCLEdBQ2pCRixZQUFZO0lBQ2QsSUFBSSxlQUFlLE9BQU8yTSxVQUFVQSxPQUFPQyxHQUFHLEVBQUU7UUFDOUMsSUFBSWtILFlBQVluSCxPQUFPQyxHQUFHO1FBQzFCcE4saUJBQWlCc1UsVUFBVTtRQUMzQnJVLHdCQUF3QnFVLFVBQVU7UUFDbENoVSxZQUFZZ1UsVUFBVTtRQUN0QjVULGlCQUFpQjRULFVBQVU7UUFDM0I5VCxZQUFZOFQsVUFBVTtJQUN4QjtJQUNBLElBQUluVCxjQUFjLEVBQUUsRUFDbEIrSCxrQkFBa0IsZUFBZSxPQUFPc0UsVUFBVUEsVUFBVWx2QyxLQUM1RHNJLFlBQVksR0FDWkYsZ0JBQWdCLEdBQ2hCQyxnQkFBZ0IsR0FDaEIyZCxpQkFBaUIsR0FDakIyZSxtQkFBbUIsR0FDbkJsZSxjQUFjLEdBQ2RSLGdCQUFnQixHQUNoQk8seUJBQXlCLEdBQ3pCb2UsZ0JBQWdCLEdBQ2hCVCxxQkFBcUIsR0FDckJoOEIsbUJBQW1CRyxXQUNuQjlCLHFCQUFxQixNQUNyQjlVLGlCQUFpQixNQUNqQjZVLGdDQUFnQyxHQUNoQzgvQixlQUFlLEdBQ2ZZLG1CQUFtQixHQUNuQmhnQyxrQkFBa0IsR0FDbEI0L0IsdUJBQXVCLEdBQ3ZCQyxzQkFBc0IsR0FDdEJzQix3Q0FBd0MsR0FDeENwQixvQ0FBb0MsR0FDcENJLDhCQUE4QixHQUM5QkwsdUJBQXVCLEdBQ3ZCLy9CLGdDQUFnQ3EvQixjQUNoQ0csNEJBQTRCLE1BQzVCcEMsNkNBQTZDLENBQUMsR0FDOUNGLG1DQUFtQyxDQUFDLEdBQ3BDTywwQ0FBMEMsQ0FBQyxHQUMzQ3Z4Qix1QkFBdUIsR0FDdkI2UywrQkFBK0JDLGdCQUMvQjdaLGlDQUFpQyxHQUNqQ3czQiw0Q0FBNEMsR0FDNUN3QyxnQ0FBZ0MsR0FDaENwYSw2QkFBNkIsR0FDN0JnSixvQ0FBb0MsR0FDcENyTyxxQ0FBcUMsTUFDckNnZSxzQ0FBc0MsTUFDdENLLG9EQUFvRCxDQUFDLEdBQ3JEbEcsK0JBQStCLEdBQy9Cb0csdUJBQXVCLEtBQ3ZCNU8scUNBQXFDNGYsVUFDckMvTixvQkFBb0IsS0FDcEJwRCw0QkFBNEIsTUFDNUJ0Zix5Q0FBeUMsTUFDekMrakIsNkJBQTZCLENBQUMsR0FDOUJKLGdDQUFnQyxNQUNoQ1ksNkJBQTZCLEdBQzdCUCxzQ0FBc0MsR0FDdENDLDRCQUE0QixNQUM1QnhsQyxzQkFBc0IsSUFDdEJELG9CQUFvQixHQUNwQkksd0JBQXdCLE1BQ3hCZy9CLDJCQUEyQixDQUFDLEdBQzVCQyx3Q0FBd0MsQ0FBQyxHQUN6Q2gvQiw4QkFBOEIsSUFDOUJILDJCQUEyQixHQUMzQkMsK0JBQStCLE1BQy9Ca3pCLDJCQUEyQixDQUFDLEdBQzVCMk4sbUJBQW1CLEdBQ25CZ0IsbUJBQW1CLEdBQ25CWCxtQkFBbUIsR0FDbkJvRyw4Q0FBOEMsTUFDOUNoSSw2QkFBNkIsQ0FBQztJQUNoQyxJQUFJRCxnREFBZ0QsSUFBSXZ4QjtJQUN4RCxJQUFJMjVCLHNCQUFzQixDQUFDLEdBQ3pCcmhELGdCQUFnQixNQUNoQjJoRCxtQkFBbUI7SUFDckIsSUFBSUcsb0JBQW9CLENBQUM7SUFDekIsSUFBSTtRQUNGLElBQUk2SixzQkFBc0J2bkQsT0FBTzI5QyxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3BELElBQUl0c0MsSUFBSTtZQUFDO2dCQUFDazJDO2dCQUFxQjthQUFLO1NBQUM7UUFDckMsSUFBSWprQyxJQUFJO1lBQUNpa0M7U0FBb0I7SUFDL0IsRUFBRSxPQUFPdHhCLEdBQUc7UUFDVnluQixvQkFBb0IsQ0FBQztJQUN2QjtJQUNBLElBQUkrQiw0QkFBNEIsQ0FBQztJQUNqQyxJQUFJK0gsbUNBQW1DLENBQUM7SUFDeEMsSUFBSUMsb0JBQW9CLE1BQ3RCQyw4QkFBOEIsTUFDOUJDLDhCQUE4QixNQUM5QkMsZ0JBQWdCLE1BQ2hCQywwQkFBMEIsTUFDMUJDLDBCQUEwQixNQUMxQkMsaUJBQWlCLE1BQ2pCQyxrQkFBa0IsTUFDbEJDLHFCQUFxQjtJQUN2QlIsb0JBQW9CLFNBQVV0dUQsS0FBSyxFQUFFQyxFQUFFLEVBQUVLLElBQUksRUFBRUUsS0FBSztRQUNsRFAsS0FBS0YsU0FBU0MsT0FBT0M7UUFDckIsU0FBU0EsTUFDTixRQUFRRyxnQkFBZ0JILEdBQUdDLGFBQWEsRUFBRUksTUFBTSxHQUFHRSxRQUNuRFAsR0FBR0MsYUFBYSxHQUFHSSxNQUNuQkwsR0FBRzRoQixTQUFTLEdBQUd2aEIsTUFDZk4sTUFBTWdhLGFBQWEsR0FBR2xaLE9BQU8sQ0FBQyxHQUFHZCxNQUFNZ2EsYUFBYSxHQUNwRDFaLE9BQU91YiwrQkFBK0I3YixPQUFPLElBQzlDLFNBQVNNLFFBQVE4ekIsc0JBQXNCOXpCLE1BQU1OLE9BQU8sRUFBQztJQUN6RDtJQUNBdXVELDhCQUE4QixTQUFVdnVELEtBQUssRUFBRUMsRUFBRSxFQUFFSyxJQUFJO1FBQ3JETCxLQUFLRixTQUFTQyxPQUFPQztRQUNyQixTQUFTQSxNQUNOLFFBQVF1QixtQkFBbUJ2QixHQUFHQyxhQUFhLEVBQUVJLE1BQU0sSUFDbkRMLEdBQUdDLGFBQWEsR0FBR0ksTUFDbkJMLEdBQUc0aEIsU0FBUyxHQUFHdmhCLE1BQ2ZOLE1BQU1nYSxhQUFhLEdBQUdsWixPQUFPLENBQUMsR0FBR2QsTUFBTWdhLGFBQWEsR0FDcEQxWixPQUFPdWIsK0JBQStCN2IsT0FBTyxJQUM5QyxTQUFTTSxRQUFROHpCLHNCQUFzQjl6QixNQUFNTixPQUFPLEVBQUM7SUFDekQ7SUFDQXd1RCw4QkFBOEIsU0FBVXh1RCxLQUFLLEVBQUVDLEVBQUUsRUFBRWUsT0FBTyxFQUFFQyxPQUFPO1FBQ2pFaEIsS0FBS0YsU0FBU0MsT0FBT0M7UUFDckIsU0FBU0EsTUFDTixXQUFXYyxlQUFlZCxHQUFHQyxhQUFhLEVBQUVjLFNBQVNDLFVBQ3JEaEIsR0FBR0MsYUFBYSxHQUFHYyxTQUNuQmYsR0FBRzRoQixTQUFTLEdBQUc3Z0IsU0FDZmhCLE1BQU1nYSxhQUFhLEdBQUdsWixPQUFPLENBQUMsR0FBR2QsTUFBTWdhLGFBQWEsR0FDcERoWixVQUFVNmEsK0JBQStCN2IsT0FBTyxJQUNqRCxTQUFTZ0IsV0FBV296QixzQkFBc0JwekIsU0FBU2hCLE9BQU8sRUFBQztJQUMvRDtJQUNBeXVELGdCQUFnQixTQUFVenVELEtBQUssRUFBRU0sSUFBSSxFQUFFRSxLQUFLO1FBQzFDUixNQUFNNkIsWUFBWSxHQUFHekIsZ0JBQWdCSixNQUFNZ2EsYUFBYSxFQUFFMVosTUFBTSxHQUFHRTtRQUNuRVIsTUFBTWdMLFNBQVMsSUFBS2hMLENBQUFBLE1BQU1nTCxTQUFTLENBQUNuSixZQUFZLEdBQUc3QixNQUFNNkIsWUFBWTtRQUNyRXZCLE9BQU91YiwrQkFBK0I3YixPQUFPO1FBQzdDLFNBQVNNLFFBQVE4ekIsc0JBQXNCOXpCLE1BQU1OLE9BQU87SUFDdEQ7SUFDQTB1RCwwQkFBMEIsU0FBVTF1RCxLQUFLLEVBQUVNLElBQUk7UUFDN0NOLE1BQU02QixZQUFZLEdBQUdMLG1CQUFtQnhCLE1BQU1nYSxhQUFhLEVBQUUxWixNQUFNO1FBQ25FTixNQUFNZ0wsU0FBUyxJQUFLaEwsQ0FBQUEsTUFBTWdMLFNBQVMsQ0FBQ25KLFlBQVksR0FBRzdCLE1BQU02QixZQUFZO1FBQ3JFdkIsT0FBT3ViLCtCQUErQjdiLE9BQU87UUFDN0MsU0FBU00sUUFBUTh6QixzQkFBc0I5ekIsTUFBTU4sT0FBTztJQUN0RDtJQUNBMnVELDBCQUEwQixTQUFVM3VELEtBQUssRUFBRWdCLE9BQU8sRUFBRUMsT0FBTztRQUN6RGpCLE1BQU02QixZQUFZLEdBQUdkLGVBQ25CZixNQUFNZ2EsYUFBYSxFQUNuQmhaLFNBQ0FDO1FBRUZqQixNQUFNZ0wsU0FBUyxJQUFLaEwsQ0FBQUEsTUFBTWdMLFNBQVMsQ0FBQ25KLFlBQVksR0FBRzdCLE1BQU02QixZQUFZO1FBQ3JFYixVQUFVNmEsK0JBQStCN2IsT0FBTztRQUNoRCxTQUFTZ0IsV0FBV296QixzQkFBc0JwekIsU0FBU2hCLE9BQU87SUFDNUQ7SUFDQTR1RCxpQkFBaUIsU0FBVTV1RCxLQUFLO1FBQzlCLElBQUlpQyxPQUFPNFosK0JBQStCN2IsT0FBTztRQUNqRCxTQUFTaUMsUUFBUW15QixzQkFBc0JueUIsTUFBTWpDLE9BQU87SUFDdEQ7SUFDQTZ1RCxrQkFBa0IsU0FBVUUsa0JBQWtCO1FBQzVDcnRELGtCQUFrQnF0RDtJQUNwQjtJQUNBRCxxQkFBcUIsU0FBVUUsb0JBQW9CO1FBQ2pEdnRELG9CQUFvQnV0RDtJQUN0QjtJQUNBbnZELFFBQVFvdkQsMEJBQTBCLEdBQUcsU0FBVWp2RCxLQUFLO1FBQ2xELElBQUksT0FBT0EsTUFBTTRCLEdBQUcsRUFBRTtZQUNwQixJQUFJSyxPQUFPNFosK0JBQStCN2IsT0FBTztZQUNqRCxTQUFTaUMsUUFBUW15QixzQkFBc0JueUIsTUFBTWpDLE9BQU87WUFDcER3bUQsMkJBQTJCeG1ELE9BQU87UUFDcEM7SUFDRjtJQUNBSCxRQUFRcXZELGlDQUFpQyxHQUFHLFNBQVVsdkQsS0FBSztRQUN6RCxJQUFJLE9BQU9BLE1BQU00QixHQUFHLEVBQUU7WUFDcEIsSUFBSWdMLE9BQU8wc0Isa0JBQWtCdDVCLFFBQzNCaUMsT0FBTzRaLCtCQUErQjdiLE9BQU80TTtZQUMvQyxTQUFTM0ssUUFBUW15QixzQkFBc0JueUIsTUFBTWpDLE9BQU80TTtZQUNwRDQ1QywyQkFBMkJ4bUQsT0FBTzRNO1FBQ3BDO0lBQ0Y7SUFDQS9NLFFBQVFzdkQsMkJBQTJCLEdBQUcsU0FBVW52RCxLQUFLO1FBQ25ELE9BQVFBLE1BQU00QixHQUFHO1lBQ2YsS0FBSztnQkFDSDVCLFFBQVFBLE1BQU00TCxTQUFTO2dCQUN2QixJQUFJNUwsTUFBTThDLE9BQU8sQ0FBQzVDLGFBQWEsQ0FBQ3NuQyxZQUFZLEVBQUU7b0JBQzVDLElBQUkxNkIsUUFBUUQsd0JBQXdCN00sTUFBTWtOLFlBQVk7b0JBQ3RELElBQUksTUFBTUosT0FBTzt3QkFDZjlNLE1BQU1rTixZQUFZLElBQUk7d0JBQ3RCLElBQUtsTixNQUFNNk8sY0FBYyxJQUFJLEdBQUcvQixPQUFTOzRCQUN2QyxJQUFJRixPQUFPLEtBQU0sS0FBS3VDLE1BQU1yQzs0QkFDNUI5TSxNQUFNZ1AsYUFBYSxDQUFDLEVBQUUsSUFBSXBDOzRCQUMxQkUsU0FBUyxDQUFDRjt3QkFDWjt3QkFDQThRLHNCQUFzQjFkO3dCQUNyQnFnQixDQUFBQSxtQkFBb0JDLENBQUFBLGdCQUFnQkMsYUFBWSxDQUFDLE1BQ2hEQyxhQUNDLHNDQUNDM0IsVUFBVXVoQyxtQkFDWmppQyw4QkFBOEIsR0FBRyxDQUFDLEVBQUM7b0JBQ3ZDO2dCQUNGO2dCQUNBO1lBQ0YsS0FBSztnQkFDRnJSLFFBQVErTywrQkFBK0I3YixPQUFPLElBQzdDLFNBQVM4TSxTQUFTc25CLHNCQUFzQnRuQixPQUFPOU0sT0FBTyxJQUN0RHNDLGlCQUNBa2tELDJCQUEyQnhtRCxPQUFPO1FBQ3hDO0lBQ0Y7SUFDQUgsUUFBUXV2RCxjQUFjLEdBQUcsU0FBVTNuRCxFQUFFLEVBQUUyRCxDQUFDO1FBQ3RDLE9BQU8zRCxHQUFHMkQ7SUFDWjtJQUNBdkwsUUFBUXd2RCx1QkFBdUIsR0FBRyxTQUFVMUMsU0FBUztRQUNuRCxPQUFPO1lBQUV6b0QsVUFBVTAxQztZQUFnQnA1QyxPQUFPbXNEO1FBQVU7SUFDdEQ7SUFDQTlzRCxRQUFReXZELGVBQWUsR0FBRyxTQUN4QmxtQyxhQUFhLEVBQ2J4bkIsR0FBRyxFQUNIaWtELGtCQUFrQixFQUNsQkMsWUFBWSxFQUNaeUosa0NBQWtDLEVBQ2xDcjFCLGdCQUFnQixFQUNoQjBDLGVBQWUsRUFDZk0sYUFBYSxFQUNia2xCLGtCQUFrQixFQUNsQjJELG1CQUFtQjtRQUVuQixPQUFPSixnQkFDTHY4QixlQUNBeG5CLEtBQ0EsQ0FBQyxHQUNELE1BQ0Fpa0Qsb0JBQ0FDLGNBQ0E1ckIsa0JBQ0EwQyxpQkFDQU0sZUFDQWtsQixvQkFDQTJELHFCQUNBO0lBRUo7SUFDQWxtRCxRQUFRMnZELDRCQUE0QixHQUFHLFNBQVUvVSxTQUFTO1FBQ3hELE9BQU87WUFBRXYyQyxVQUFVMjFDO1lBQXVCcjVDLE9BQU9pNkM7UUFBVTtJQUM3RDtJQUNBNTZDLFFBQVE0dkQsd0JBQXdCLEdBQUcsU0FDakM3SixlQUFlLEVBQ2Z4N0MsUUFBUSxFQUNSZ2YsYUFBYSxFQUNieG5CLEdBQUcsRUFDSGlrRCxrQkFBa0IsRUFDbEJDLFlBQVksRUFDWnlKLGtDQUFrQyxFQUNsQ3IxQixnQkFBZ0IsRUFDaEIwQyxlQUFlLEVBQ2ZNLGFBQWEsRUFDYmtsQixrQkFBa0IsRUFDbEIyRCxtQkFBbUIsRUFDbkJwdkIsU0FBUztRQUVUaXZCLGtCQUFrQkQsZ0JBQ2hCdjhCLGVBQ0F4bkIsS0FDQSxDQUFDLEdBQ0Rna0QsaUJBQ0FDLG9CQUNBQyxjQUNBNXJCLGtCQUNBMEMsaUJBQ0FNLGVBQ0FrbEIsb0JBQ0EyRCxxQkFDQXB2QjtRQUVGaXZCLGdCQUFnQnpqRCxPQUFPLEdBQUc4akQscUJBQXFCO1FBQy9DNzhCLGdCQUFnQnc4QixnQkFBZ0I5aUQsT0FBTztRQUN2Q2xCLE1BQU0wM0Isa0JBQWtCbFE7UUFDeEJ5OEIscUJBQXFCempDLGFBQWF4Z0I7UUFDbENpa0QsbUJBQW1CejdDLFFBQVEsR0FDekIsS0FBSyxNQUFNQSxZQUFZLFNBQVNBLFdBQVdBLFdBQVc7UUFDeERtWSxjQUFjNkcsZUFBZXk4QixvQkFBb0Jqa0Q7UUFDakRna0QsZ0JBQWdCOWlELE9BQU8sQ0FBQ2dLLEtBQUssR0FBR2xMO1FBQ2hDd00sa0JBQWtCdzNDLGlCQUFpQmhrRDtRQUNuQzhiLHNCQUFzQmtvQztRQUN0QixPQUFPQTtJQUNUO0lBQ0EvbEQsUUFBUTZ2RCxZQUFZLEdBQUcsU0FBVW42QyxRQUFRLEVBQUU2VCxhQUFhLEVBQUVDLGNBQWM7UUFDdEUsSUFBSTNvQixNQUNGLElBQUkraUQsVUFBVWhqRCxNQUFNLElBQUksS0FBSyxNQUFNZ2pELFNBQVMsQ0FBQyxFQUFFLEdBQUdBLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDbkUsSUFBSTtZQUNGdUMsbUJBQW1CdGxEO1lBQ25CLElBQUlzSiwyQkFBMkIsQ0FBQztRQUNsQyxFQUFFLE9BQU8ybEQsS0FBSztZQUNaM2xELDJCQUEyQixDQUFDO1FBQzlCO1FBQ0FBLDRCQUNHOUksQ0FBQUEsUUFBUWdDLEtBQUssQ0FDWiw0R0FDQSxlQUFnQixPQUFPNmpELFVBQ3JCQSxPQUFPNkksV0FBVyxJQUNsQmx2RCxHQUFHLENBQUNxbUQsT0FBTzZJLFdBQVcsQ0FBQyxJQUN2Qmx2RCxJQUFJLFdBQVcsQ0FBQzJELElBQUksSUFDcEIsV0FFSjJoRCxtQkFBbUJ0bEQsSUFBRztRQUN4QixPQUFPO1lBQ0x3RCxVQUFVSztZQUNWN0QsS0FBSyxRQUFRQSxNQUFNLE9BQU8sS0FBS0E7WUFDL0I2VSxVQUFVQTtZQUNWNlQsZUFBZUE7WUFDZkMsZ0JBQWdCQTtRQUNsQjtJQUNGO0lBQ0F4cEIsUUFBUWd3RCxrQkFBa0IsR0FBRyxTQUFVQyxJQUFJO1FBQ3pDLE9BQU87WUFBRTVyRCxVQUFVZzJDO1lBQVcxNUMsT0FBT3N2RDtRQUFLO0lBQzVDO0lBQ0Fqd0QsUUFBUWt3RCxzQkFBc0IsR0FBRyxTQUFVOXZELEVBQUU7UUFDM0MsT0FBTztZQUFFaUUsVUFBVW8yQztZQUFnQjk1QyxPQUFPUDtRQUFHO0lBQy9DO0lBQ0FKLFFBQVFtd0Qsa0JBQWtCLEdBQUcsU0FBVUMsSUFBSTtRQUN6QyxPQUFPO1lBQUUvckQsVUFBVWsyQztZQUFXNTVDLE9BQU95dkQ7UUFBSztJQUM1QztJQUNBcHdELFFBQVFxd0Qsb0JBQW9CLEdBQUcsU0FBVWh0RCxLQUFLLEVBQUV1NUIsU0FBUztRQUN2RCxJQUFJMHpCLHVCQUF1Qnp0QyxnQkFDckIsc0NBQXNDQSxnQkFBZ0IsaUJBQ3RELDZEQUNKMHRDLGtCQUNFLHdHQUNDLEVBQUMxekIscUJBQXFCLFdBQVUsSUFBSyxHQUFFLEdBQzFDMnpCLHNCQUFzQnBvRCxxQkFBcUIwQyxlQUFlLEVBQzFEa3lCLGlCQUNFLFFBQVFKLFVBQVVJLGNBQWMsR0FBR0osVUFBVUksY0FBYyxHQUFHO1FBQ2xFNTBCLHFCQUFxQjBDLGVBQWUsR0FBRztZQUNyQyxPQUFPa3lCO1FBQ1Q7UUFDQSxJQUFJO1lBQ0YsYUFBYSxPQUFPMzVCLFNBQ3BCLFNBQVNBLFNBQ1QsYUFBYSxPQUFPQSxNQUFNb3RELGVBQWUsR0FDckNySSxjQUNFLFNBQ0E7Z0JBQ0U7Z0JBQ0Eva0Q7Z0JBQ0FpdEQ7Z0JBQ0FDO2FBQ0QsRUFDRGx0RCxNQUFNb3RELGVBQWUsTUFFdkJwdkQsUUFBUWdDLEtBQUssQ0FDWCxvQkFDQUEsT0FDQWl0RCxzQkFDQUM7UUFFUixTQUFVO1lBQ1Jub0QscUJBQXFCMEMsZUFBZSxHQUFHMGxEO1FBQ3pDO0lBQ0Y7SUFDQXh3RCxRQUFRMHdELHlCQUF5QixHQUFHLFNBQVVydEQsS0FBSztRQUNqRDZwRCxrQkFBa0I3cEQ7SUFDcEI7SUFDQXJELFFBQVEyd0Qsc0JBQXNCLEdBQUcsU0FBVXR0RCxLQUFLLEVBQUV1NUIsU0FBUztRQUN6RHN3QixrQkFBa0I3cEQ7UUFDbEJBLFFBQVF3ZixnQkFDSiwrQkFBK0JBLGdCQUFnQixpQkFDL0M7UUFDSixJQUFJMnRDLHNCQUFzQnBvRCxxQkFBcUIwQyxlQUFlLEVBQzVEa3lCLGlCQUNFLFFBQVFKLFVBQVVJLGNBQWMsR0FBR0osVUFBVUksY0FBYyxHQUFHO1FBQ2xFNTBCLHFCQUFxQjBDLGVBQWUsR0FBRztZQUNyQyxPQUFPa3lCO1FBQ1Q7UUFDQSxJQUFJO1lBQ0YzN0IsUUFBUUMsSUFBSSxDQUNWLGNBQ0ErQixPQUNBO1FBRUosU0FBVTtZQUNSK0UscUJBQXFCMEMsZUFBZSxHQUFHMGxEO1FBQ3pDO0lBQ0Y7SUFDQXh3RCxRQUFRNHdELGVBQWUsR0FBRyxTQUFVaHBELEVBQUU7UUFDcEMsSUFBSWl1QixpQkFBaUJ6dEIscUJBQXFCc3RCLENBQUMsRUFDekMwRCxtQkFBbUJDO1FBQ3JCLElBQUk7WUFDRixPQUNFQyx5QkFBeUIsS0FBTWx4QixxQkFBcUJzdEIsQ0FBQyxHQUFHLE1BQU85dEI7UUFFbkUsU0FBVTtZQUNSMHhCLHlCQUF5QkYsbUJBQ3RCaHhCLHFCQUFxQnN0QixDQUFDLEdBQUdHO1FBQzlCO0lBQ0Y7SUFDQTcxQixRQUFRNndELGVBQWUsR0FBRyxTQUFVanBELEVBQUUsRUFBRTJELENBQUMsRUFBRUMsQ0FBQyxFQUFFMkksQ0FBQyxFQUFFMjhDLENBQUM7UUFDaEQsSUFBSWo3QixpQkFBaUJ6dEIscUJBQXFCc3RCLENBQUMsRUFDekMwRCxtQkFBbUJDO1FBQ3JCLElBQUk7WUFDRixPQUNFQyx5QkFBeUIsSUFDeEJseEIscUJBQXFCc3RCLENBQUMsR0FBRyxNQUMxQjl0QixHQUFHMkQsR0FBR0MsR0FBRzJJLEdBQUcyOEM7UUFFaEIsU0FBVTtZQUNSeDNCLHlCQUF5QkYsbUJBQ3RCaHhCLHFCQUFxQnN0QixDQUFDLEdBQUdHLGdCQUMxQnJWLHFCQUFxQkcsYUFDbEIrdEIsQ0FBQUEscUNBQXFDMXZCLFVBQVV1aEMsaUJBQWdCO1FBQ3RFO0lBQ0Y7SUFDQXZnRCxRQUFRODZDLFlBQVksR0FBR0E7SUFDdkI5NkMsUUFBUSt3RCxpQkFBaUIsR0FBRyxTQUFVdlgsUUFBUSxFQUFFb0IsU0FBUztRQUN2RCxJQUFJLENBQUNHLHVCQUNILE1BQU0xekMsTUFBTTtRQUNkdXpDLFlBQVlFLGFBQWF0QixVQUFVb0I7UUFDbkNwQixXQUFXLEVBQUU7UUFDYixJQUFLLElBQUlqNEMsSUFBSSxHQUFHQSxJQUFJcTVDLFVBQVVoNkMsTUFBTSxFQUFFVyxJQUNwQ2k0QyxTQUFTMzFDLElBQUksQ0FBQ3drRCxnQkFBZ0J6TixTQUFTLENBQUNyNUMsRUFBRTtRQUM1QyxJQUFLcTVDLFlBQVlwQixTQUFTNTRDLE1BQU0sR0FBRyxHQUFHLElBQUlnNkMsV0FBV0EsWUFBYTtZQUNoRXI1QyxJQUFJaTRDLFFBQVEsQ0FBQ29CLFVBQVU7WUFDdkIsSUFDRSxJQUFJb1csYUFBYXp2RCxFQUFFa0UsQ0FBQyxFQUNsQndyRCxjQUFjRCxhQUFhenZELEVBQUUydkQsS0FBSyxFQUNsQ0MsWUFBWTV2RCxFQUFFa1IsQ0FBQyxFQUNmMitDLGVBQWVELFlBQVk1dkQsRUFBRTh2RCxNQUFNLEVBQ25DQyxJQUFJMVcsWUFBWSxHQUNsQixLQUFLMFcsR0FDTEEsSUFFQSxJQUFJMVcsY0FBYzBXLEdBQUc7Z0JBQ25CLElBQUlDLFlBQVkvWCxRQUFRLENBQUM4WCxFQUFFLEVBQ3pCRSxZQUFZRCxVQUFVOXJELENBQUMsRUFDdkJnc0QsYUFBYUQsWUFBWUQsVUFBVUwsS0FBSyxFQUN4Q1EsV0FBV0gsVUFBVTkrQyxDQUFDLEVBQ3RCay9DLGNBQWNELFdBQVdILFVBQVVGLE1BQU07Z0JBQzNDLElBQ0VMLGNBQWNRLGFBQ2RMLGFBQWFPLFlBQ2JULGVBQWVRLGNBQ2ZMLGdCQUFnQk8sYUFDaEI7b0JBQ0FuWSxTQUFTOTNDLE1BQU0sQ0FBQ2s1QyxXQUFXO29CQUMzQjtnQkFDRixPQUFPLElBQ0wsQ0FDRW9XLENBQUFBLGVBQWVRLGFBQ2Zqd0QsRUFBRTJ2RCxLQUFLLEtBQUtLLFVBQVVMLEtBQUssSUFDM0JTLGNBQWNSLGFBQ2RPLFdBQVdOLFlBQVcsR0FFeEI7b0JBQ0FNLFdBQVdQLGFBQ1IsV0FBV0UsTUFBTSxJQUFJSyxXQUFXUCxXQUNoQ0ksVUFBVTkrQyxDQUFDLEdBQUcwK0MsU0FBUztvQkFDMUJRLGNBQWNQLGdCQUNYRyxDQUFBQSxVQUFVRixNQUFNLEdBQUdELGVBQWVNLFFBQU87b0JBQzVDbFksU0FBUzkzQyxNQUFNLENBQUNrNUMsV0FBVztvQkFDM0I7Z0JBQ0YsT0FBTyxJQUNMLENBQ0V1VyxDQUFBQSxjQUFjTyxZQUNkbndELEVBQUU4dkQsTUFBTSxLQUFLRSxVQUFVRixNQUFNLElBQzdCSSxhQUFhVCxjQUNiUSxZQUFZUCxXQUFVLEdBRXhCO29CQUNBTyxZQUFZUixjQUNULFdBQVdFLEtBQUssSUFBSU0sWUFBWVIsWUFDaENPLFVBQVU5ckQsQ0FBQyxHQUFHdXJELFVBQVU7b0JBQzNCUyxhQUFhUixlQUNWTSxDQUFBQSxVQUFVTCxLQUFLLEdBQUdELGNBQWNPLFNBQVE7b0JBQzNDaFksU0FBUzkzQyxNQUFNLENBQUNrNUMsV0FBVztvQkFDM0I7Z0JBQ0Y7WUFDRjtRQUNKO1FBQ0EsT0FBT3BCO0lBQ1Q7SUFDQXg1QyxRQUFRNHhELGdCQUFnQixHQUFHLFNBQVU5RSxTQUFTO1FBQzVDLElBQUkzc0QsUUFBUTJzRCxVQUFVcHJCLGVBQWU7UUFDckMsSUFBSSxLQUFLLE1BQU12aEMsT0FBTztZQUNwQixJQUFJLGVBQWUsT0FBTzJzRCxVQUFVMW5ELE1BQU0sRUFDeEMsTUFBTWlDLE1BQU07WUFDZHlsRCxZQUFZOWxELE9BQU80UixJQUFJLENBQUNrMEMsV0FBVy9vRCxJQUFJLENBQUM7WUFDeEMsTUFBTXNELE1BQ0osd0RBQXdEeWxEO1FBRTVEO1FBQ0FBLFlBQVk5Z0QscUJBQXFCN0w7UUFDakMsT0FBTyxTQUFTMnNELFlBQVksT0FBTzViLGtCQUFrQjRiLFVBQVUvZ0QsU0FBUztJQUMxRTtJQUNBL0wsUUFBUTZ4RCw2QkFBNkIsR0FBRyxTQUFVMXhELEtBQUs7UUFDckRBLFFBQVFtTCw4QkFBOEJuTDtRQUN0Q0EsUUFDRSxTQUFTQSxRQUFRZ00sc0NBQXNDaE0sU0FBUztRQUNsRSxPQUFPLFNBQVNBLFFBQVEsT0FBTyt3QyxrQkFBa0Ivd0MsTUFBTTRMLFNBQVM7SUFDbEU7SUFDQS9MLFFBQVE4eEQsMkJBQTJCLEdBQUcsU0FBVWhGLFNBQVMsRUFBRWlGLFVBQVU7UUFDbkUsSUFBSTV4RCxRQUFRMnNELFVBQVVwckIsZUFBZTtRQUNyQyxJQUFJLEtBQUssTUFBTXZoQyxPQUFPO1lBQ3BCLElBQUksZUFBZSxPQUFPMnNELFVBQVUxbkQsTUFBTSxFQUN4QyxNQUFNaUMsTUFBTTtZQUNkeWxELFlBQVk5bEQsT0FBTzRSLElBQUksQ0FBQ2swQyxXQUFXL29ELElBQUksQ0FBQztZQUN4QyxNQUFNc0QsTUFDSix3REFBd0R5bEQ7UUFFNUQ7UUFDQUEsWUFBWTlnRCxxQkFBcUI3TDtRQUNqQyxJQUFJLFNBQVMyc0QsV0FBVyxPQUFPO1FBQy9CLElBQUlBLFVBQVU3cUQsSUFBSSxHQUFHLEdBQUc7WUFDdEIsSUFBSTRnQixnQkFBZ0JuZCwwQkFBMEJ2RixVQUFVO1lBQ3hEcXVELGdDQUFnQyxDQUFDM3JDLGNBQWMsSUFDNUMsaUNBQWlDLENBQUNBLGNBQWMsR0FBRyxDQUFDLEdBQ3JEdlksa0JBQWtCd2lELFdBQVc7Z0JBQzNCM3NELE1BQU04QixJQUFJLEdBQUcsSUFDVFosUUFBUWdDLEtBQUssQ0FDWCx1UEFDQTB1RCxZQUNBQSxZQUNBbHZDLGlCQUVGeGhCLFFBQVFnQyxLQUFLLENBQ1gsOFBBQ0EwdUQsWUFDQUEsWUFDQWx2QztZQUVSLEVBQUM7UUFDTDtRQUNBLE9BQU9xdUIsa0JBQWtCNGIsVUFBVS9nRCxTQUFTO0lBQzlDO0lBQ0EvTCxRQUFRK0MsbUJBQW1CLEdBQUdBO0lBQzlCL0MsUUFBUWd5RCx1QkFBdUIsR0FBRyxTQUFVcHFELEVBQUU7UUFDNUMsSUFBSXE0Qyx1QkFBdUJ6L0I7UUFDM0JBLG9CQUFvQjtRQUNwQixJQUFJcVYsaUJBQWlCenRCLHFCQUFxQnN0QixDQUFDLEVBQ3pDMEQsbUJBQW1CQztRQUNyQixJQUFJO1lBQ0YsSUFBS0MseUJBQXlCLElBQUtseEIscUJBQXFCc3RCLENBQUMsR0FBRyxNQUFPOXRCLElBQ2pFLE9BQU9BO1FBQ1gsU0FBVTtZQUNSMHhCLHlCQUF5QkYsbUJBQ3RCaHhCLHFCQUFxQnN0QixDQUFDLEdBQUdHLGdCQUN6QnJWLG1CQUFtQnkvQixzQkFDcEIsQ0FBQ3ovQixtQkFBb0JDLENBQUFBLGdCQUFnQkMsYUFBWSxDQUFDLE1BQU9DLGFBQ3ZEckMsOEJBQThCLEdBQUcsQ0FBQztRQUN4QztJQUNGO0lBQ0F0ZSxRQUFReUMsYUFBYSxHQUFHQTtJQUN4QnpDLFFBQVFpeUQsV0FBVyxHQUFHLFNBQVV6WSxRQUFRLEVBQUVvQixTQUFTO1FBQ2pELElBQUksQ0FBQ0csdUJBQ0gsTUFBTTF6QyxNQUFNO1FBQ2RteUMsV0FBV0QseUJBQXlCQztRQUNwQ29CLFlBQVlELFVBQVVuQixVQUFVb0I7UUFDaENBLFlBQVlycEIsTUFBTXlwQixJQUFJLENBQUNKO1FBQ3ZCLElBQUtwQixXQUFXLEdBQUdBLFdBQVdvQixVQUFVaDZDLE1BQU0sRUFBSTtZQUNoRCxJQUFJVCxRQUFReTZDLFNBQVMsQ0FBQ3BCLFdBQVcsRUFDL0J6M0MsTUFBTTVCLE1BQU00QixHQUFHO1lBQ2pCLElBQUksQ0FBQ3E0QyxnQkFBZ0JqNkMsUUFBUTtnQkFDM0IsSUFDRSxDQUFDLE1BQU00QixPQUFPLE9BQU9BLE9BQU8sT0FBT0EsR0FBRSxLQUNyQ3VtRCxvQkFBb0Jub0QsTUFBTTRMLFNBQVMsR0FFbkMsT0FBTyxDQUFDO2dCQUNWLElBQUs1TCxRQUFRQSxNQUFNd0wsS0FBSyxFQUFFLFNBQVN4TCxPQUNqQ3k2QyxVQUFVLzJDLElBQUksQ0FBQzFELFFBQVNBLFFBQVFBLE1BQU15TCxPQUFPO1lBQ2pEO1FBQ0Y7UUFDQSxPQUFPLENBQUM7SUFDVjtJQUNBNUwsUUFBUWt5RCxpQ0FBaUMsR0FBRyxTQUFVMVksUUFBUSxFQUFFb0IsU0FBUztRQUN2RSxJQUFJLENBQUNHLHVCQUNILE1BQU0xekMsTUFBTTtRQUNkLElBQUk4cUQsbUJBQW1CLEdBQ3JCQyxlQUFlLEVBQUU7UUFDbkI1WSxXQUFXO1lBQUNELHlCQUF5QkM7WUFBVztTQUFFO1FBQ2xELElBQUssSUFBSTk0QyxRQUFRLEdBQUdBLFFBQVE4NEMsU0FBUzU0QyxNQUFNLEVBQUk7WUFDN0MsSUFBSVQsUUFBUXE1QyxRQUFRLENBQUM5NEMsUUFBUSxFQUMzQnFCLE1BQU01QixNQUFNNEIsR0FBRyxFQUNmbTRDLGdCQUFnQlYsUUFBUSxDQUFDOTRDLFFBQVEsRUFDakNvNUMsV0FBV2MsU0FBUyxDQUFDVixjQUFjO1lBQ3JDLElBQUksTUFBT240QyxPQUFPLE9BQU9BLE9BQU8sT0FBT0EsT0FBUSxDQUFDcTRDLGdCQUFnQmo2QyxRQUM5RDtnQkFBQSxJQUNHeTVDLGNBQWN6NUMsT0FBTzI1QyxhQUNuQnNZLENBQUFBLGFBQWF2dUQsSUFBSSxDQUFDNjJDLGlCQUFpQlosWUFDcENJLGlCQUNBQSxnQkFBZ0JpWSxvQkFDYkEsQ0FBQUEsbUJBQW1CalksYUFBWSxDQUFDLEdBQ3JDQSxnQkFBZ0JVLFVBQVVoNkMsTUFBTSxFQUVoQyxJQUFLVCxRQUFRQSxNQUFNd0wsS0FBSyxFQUFFLFNBQVN4TCxPQUNqQ3E1QyxTQUFTMzFDLElBQUksQ0FBQzFELE9BQU8rNUMsZ0JBQWlCLzVDLFFBQVFBLE1BQU15TCxPQUFPO1lBQUM7UUFDcEU7UUFDQSxJQUFJdW1ELG1CQUFtQnZYLFVBQVVoNkMsTUFBTSxFQUFFO1lBQ3ZDLElBQ0U0NEMsV0FBVyxFQUFFLEVBQ2IyWSxtQkFBbUJ2WCxVQUFVaDZDLE1BQU0sRUFDbkN1eEQsbUJBRUEzWSxTQUFTMzFDLElBQUksQ0FBQzYyQyxpQkFBaUJFLFNBQVMsQ0FBQ3VYLGlCQUFpQjtZQUM1RCxPQUNFLDZEQUNDQyxDQUFBQSxhQUFhcnVELElBQUksQ0FBQyxTQUNqQiw4Q0FBNkMsSUFDL0N5MUMsU0FBU3oxQyxJQUFJLENBQUM7UUFFbEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQS9ELFFBQVFxeUQscUJBQXFCLEdBQUcsU0FBVXRtQixTQUFTO1FBQ2pEQSxZQUFZQSxVQUFVOW9DLE9BQU87UUFDN0IsSUFBSSxDQUFDOG9DLFVBQVVwZ0MsS0FBSyxFQUFFLE9BQU87UUFDN0IsT0FBUW9nQyxVQUFVcGdDLEtBQUssQ0FBQzVKLEdBQUc7WUFDekIsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBT212QyxrQkFBa0JuRixVQUFVcGdDLEtBQUssQ0FBQ0ksU0FBUztZQUNwRDtnQkFDRSxPQUFPZ2dDLFVBQVVwZ0MsS0FBSyxDQUFDSSxTQUFTO1FBQ3BDO0lBQ0Y7SUFDQS9MLFFBQVFzeUQsa0JBQWtCLEdBQUc7UUFDM0IsSUFBSS9oRCxZQUFZO1lBQ2RnaUQsWUFBWTtZQUNaQyxTQUFTL0s7WUFDVEMscUJBQXFCQTtZQUNyQitLLHNCQUFzQnJxRDtZQUN0QnNxRCx5QkFBeUJoWjtZQUN6QmlaLG1CQUFtQjtRQUNyQjtRQUNBLFNBQVNoTCx1QkFDTnAzQyxDQUFBQSxVQUFVcWlELGNBQWMsR0FBR2pMLG1CQUFrQjtRQUNoRHAzQyxVQUFVaytDLGlCQUFpQixHQUFHQTtRQUM5QmwrQyxVQUFVbStDLDJCQUEyQixHQUFHQTtRQUN4Q24rQyxVQUFVbytDLDJCQUEyQixHQUFHQTtRQUN4Q3ArQyxVQUFVcStDLGFBQWEsR0FBR0E7UUFDMUJyK0MsVUFBVXMrQyx1QkFBdUIsR0FBR0E7UUFDcEN0K0MsVUFBVXUrQyx1QkFBdUIsR0FBR0E7UUFDcEN2K0MsVUFBVXcrQyxjQUFjLEdBQUdBO1FBQzNCeCtDLFVBQVV5K0MsZUFBZSxHQUFHQTtRQUM1QnorQyxVQUFVMCtDLGtCQUFrQixHQUFHQTtRQUMvQjErQyxVQUFVN04sZUFBZSxHQUFHQTtRQUM1QjZOLFVBQVVwTyxZQUFZLEdBQUdBO1FBQ3pCb08sVUFBVXJOLGlCQUFpQixHQUFHQTtRQUM5QnFOLFVBQVVzaUQsZUFBZSxHQUFHak07UUFDNUJyMkMsVUFBVXMyQyxlQUFlLEdBQUdBO1FBQzVCdDJDLFVBQVV3QixvQkFBb0IsR0FBR0E7UUFDakMsT0FBT3pCLGdCQUFnQkM7SUFDekI7SUFDQXZRLFFBQVE4eUQsa0JBQWtCLEdBQUc7UUFDM0IsT0FBTyxDQUFDdHlDLG1CQUFvQkMsQ0FBQUEsZ0JBQWdCQyxhQUFZLENBQUMsTUFBT0M7SUFDbEU7SUFDQTNnQixRQUFRK3lELG1CQUFtQixHQUFHLFNBQzVCdlosUUFBUSxFQUNSb0IsU0FBUyxFQUNUcndDLFFBQVEsRUFDUnlvRCxPQUFPO1FBRVAsU0FBUzdYO1lBQ1AsSUFBSThYLG9CQUFvQm5ZLGFBQWF0QixVQUFVb0I7WUFDL0NzWSxjQUFjdHZELE9BQU8sQ0FBQyxTQUFVdXZELE1BQU07Z0JBQ3BDLElBQUlGLGtCQUFrQnZyRCxPQUFPLENBQUN5ckQsV0FBV0MsVUFBVUQ7WUFDckQ7WUFDQUYsa0JBQWtCcnZELE9BQU8sQ0FBQyxTQUFVdXZELE1BQU07Z0JBQ3hDLElBQUlELGNBQWN4ckQsT0FBTyxDQUFDeXJELFdBQVdFLFFBQVFGO1lBQy9DO1FBQ0Y7UUFDQSxJQUFJLENBQUNwWSx1QkFDSCxNQUFNMXpDLE1BQU07UUFDZCxJQUFJNnJELGdCQUFnQnBZLGFBQWF0QixVQUFVb0I7UUFDM0Nyd0MsV0FBV2crQywwQkFBMEIySyxlQUFlM29ELFVBQVV5b0Q7UUFDOUQsSUFBSU0sYUFBYS9vRCxTQUFTK29ELFVBQVUsRUFDbENELFVBQVU5b0QsU0FBUzhvRCxPQUFPLEVBQzFCRCxZQUFZN29ELFNBQVM2b0QsU0FBUztRQUNoQ2xZLFlBQVlyM0MsSUFBSSxDQUFDczNDO1FBQ2pCLE9BQU87WUFDTG1ZLFlBQVk7Z0JBQ1YsSUFBSTV5RCxRQUFRdzZDLFlBQVl4ekMsT0FBTyxDQUFDeXpDO2dCQUNoQyxLQUFLejZDLFNBQVN3NkMsWUFBWXg1QyxNQUFNLENBQUNoQixPQUFPO2dCQUN4QzR5RDtZQUNGO1FBQ0Y7SUFDRjtJQUNBdHpELFFBQVF1ekQsV0FBVyxHQUFHLFNBQVVwekQsS0FBSztRQUNuQyxPQUFPMEIsZ0JBQWdCMUI7SUFDekI7SUFDQUgsUUFBUXd6RCxhQUFhLEdBQUcsU0FBVXJ6RCxLQUFLO1FBQ3JDLE9BQU95QixrQkFBa0J6QjtJQUMzQjtJQUNBSCxRQUFReXpELG1CQUFtQixHQUFHLFNBQzVCOTVCLFNBQVMsRUFDVFQsWUFBWSxFQUNaeEgsTUFBTSxFQUNOZ2lDLFFBQVE7UUFFUixJQUFJLE1BQU0vNUIsVUFBVTUzQixHQUFHLEVBQ3JCLE1BQU1zRixNQUNKO1FBRUosSUFBSXFVLFFBQVFnZSw4QkFBOEJDLFdBQVdqZSxLQUFLO1FBQzFEdWQsZ0JBQ0VVLFdBQ0FqZSxPQUNBd2QsY0FDQTlqQixzQkFDQSxTQUFTc2MsU0FDTG51QixPQUNBO1lBQ0UsU0FBUzZFLHFCQUFxQnN0QixDQUFDLElBQzdCcjBCLFFBQVFnQyxLQUFLLENBQ1g7WUFFSixJQUFJc3dELGtCQUNGajZCLDhCQUE4QkMsV0FBV3I1QixJQUFJLENBQUNvYixLQUFLO1lBQ3JEOGQseUJBQ0VHLFdBQ0FnNkIsaUJBQ0EsQ0FBQyxHQUNEbDZCLGtCQUFrQkU7WUFFcEIsT0FBT2pJLE9BQU9naUM7UUFDaEI7SUFFUjtJQUNBMXpELFFBQVE0ekQsZUFBZSxHQUFHLFNBQ3hCdnhELE9BQU8sRUFDUDBwQyxTQUFTLEVBQ1RzYSxlQUFlLEVBQ2Y5N0MsUUFBUTtRQUVSLElBQUl0SCxVQUFVOG9DLFVBQVU5b0MsT0FBTyxFQUM3QjhKLE9BQU8wc0Isa0JBQWtCeDJCO1FBQzNCcWpELG9CQUNFcmpELFNBQ0E4SixNQUNBMUssU0FDQTBwQyxXQUNBc2EsaUJBQ0E5N0M7UUFFRixPQUFPd0M7SUFDVDtJQUNBL00sUUFBUXdDLG1CQUFtQixHQUFHQTtJQUM5QixPQUFPeEM7QUFDVCxHQUNDRCx5QkFBc0IsR0FBR0EsT0FBT0MsT0FBTyxFQUN4Q2dILE9BQU95QixjQUFjLENBQUMxSSxPQUFPQyxPQUFPLEVBQUUsY0FBYztJQUFFVyxPQUFPLENBQUM7QUFBRSxFQUFDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gICgobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJCQkY29uZmlnKSB7XG4gICAgZnVuY3Rpb24gZmluZEhvb2soZmliZXIsIGlkKSB7XG4gICAgICBmb3IgKGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTsgbnVsbCAhPT0gZmliZXIgJiYgMCA8IGlkOyApXG4gICAgICAgIChmaWJlciA9IGZpYmVyLm5leHQpLCBpZC0tO1xuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZShvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpXG4gICAgICAgIGNvbnNvbGUud2FybihcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICBpZiAob2xkUGF0aFtpXSAhPT0gbmV3UGF0aFtpXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcImNvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aFxuICAgICAgICA/ICgodXBkYXRlZFtuZXdQYXRoW2luZGV4XV0gPSB1cGRhdGVkW29sZEtleV0pLFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpXG4gICAgICAgICAgICA/IHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSlcbiAgICAgICAgICAgIDogZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XSlcbiAgICAgICAgOiAodXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKFxuICAgICAgICAgICAgb2JqW29sZEtleV0sXG4gICAgICAgICAgICBvbGRQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgIGluZGV4ICsgMVxuICAgICAgICAgICkpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIGluZGV4KSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpc0FycmF5SW1wbCh1cGRhdGVkKSA/IHVwZGF0ZWQuc3BsaWNlKGtleSwgMSkgOiBkZWxldGUgdXBkYXRlZFtrZXldLFxuICAgICAgICAgIHVwZGF0ZWRcbiAgICAgICAgKTtcbiAgICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kSW1wbCgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkRXJyb3JJbXBsKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJvb3Qocm9vdCwgZWxlbWVudCkge1xuICAgICAgcm9vdC5jb250ZXh0ID09PSBlbXB0eUNvbnRleHRPYmplY3QgJiZcbiAgICAgICAgKHVwZGF0ZUNvbnRhaW5lclN5bmMoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCksIGZsdXNoU3luY1dvcmsoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaChyb290LCB1cGRhdGUpIHtcbiAgICAgIGlmIChudWxsICE9PSByZXNvbHZlRmFtaWx5KSB7XG4gICAgICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXM7XG4gICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICAgICAgZmx1c2hTeW5jV29yaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRSZWZyZXNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkludmFsaWRIb29rQWNjZXNzKCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuIFlvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JNaXNzaW5nS2V5KCkge31cbiAgICBmdW5jdGlvbiBzZXRUb1NvcnRlZFN0cmluZyhzZXQpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oXCIsIFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBtYXliZUl0ZXJhYmxlID1cbiAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlSXRlcmFibGUgPyBtYXliZUl0ZXJhYmxlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIFwiQ2FjaGVcIjtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHJldHVybiBcIkRlaHlkcmF0ZWRGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSB0eXBlLnJlbmRlciksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSB8fFxuICAgICAgICAgICAgICAoXCJcIiAhPT0gZmliZXIgPyBcIkZvcndhcmRSZWYoXCIgKyBmaWJlciArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIFwiUm9vdFwiO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIFwiVGV4dFwiO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA/IFwiU3RyaWN0TW9kZVwiIDogXCJNb2RlXCI7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICByZXR1cm4gXCJTY29wZVwiO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIFwiVHJhY2luZ01hcmtlclwiO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdHlwZSA9IGZpYmVyLl9kZWJ1Z0luZm87XG4gICAgICAgICAgaWYgKG51bGwgIT0gdHlwZSlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0eXBlLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGVbaV0ubmFtZSkgcmV0dXJuIHR5cGVbaV0ubmFtZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIucmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIucmV0dXJuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMSkpLCBmaWJlcjtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlciwgITEpKSwgZmliZXJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSwgITApKSwgZmliZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAoZGVidWdJbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZW50cnkubmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvLFxuICAgICAgICAgICAgICAgICAgZW52ID0gZW50cnkuZW52O1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcbiAgICAgICAgICAgICAgICAgIGVudHJ5Lm5hbWUgKyAoZW52ID8gXCIgW1wiICsgZW52ICsgXCJdXCIgOiBcIlwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaW5mbyA9IEpTQ29tcGlsZXJfdGVtcF9jb25zdCArIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnQgPyBcIlwiIDogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgY2FsbGJhY2ssIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9XG4gICAgICAgIG51bGwgPT09IGZpYmVyID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudCA9IHByZXZpb3VzRmliZXI7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJydW5XaXRoRmliZXJJbkRFViBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGluIHByb2R1Y3Rpb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgICAgIHZhciBub2RlID0gZmliZXIsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG4gICAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSBmb3IgKDsgbm9kZS5yZXR1cm47ICkgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZpYmVyID0gbm9kZTtcbiAgICAgICAgZG9cbiAgICAgICAgICAobm9kZSA9IGZpYmVyKSxcbiAgICAgICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiYgKG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm4pLFxuICAgICAgICAgICAgKGZpYmVyID0gbm9kZS5yZXR1cm4pO1xuICAgICAgICB3aGlsZSAoZmliZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDMgPT09IG5vZGUudGFnID8gbmVhcmVzdE1vdW50ZWQgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgICAgIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpXG4gICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoIWFsdGVybmF0ZSkge1xuICAgICAgICBhbHRlcm5hdGUgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcbiAgICAgICAgaWYgKG51bGwgPT09IGFsdGVybmF0ZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIHJldHVybiBhbHRlcm5hdGUgIT09IGZpYmVyID8gbnVsbCA6IGZpYmVyO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgYSA9IGZpYmVyLCBiID0gYWx0ZXJuYXRlOyA7ICkge1xuICAgICAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcGFyZW50QSkgYnJlYWs7XG4gICAgICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChudWxsID09PSBwYXJlbnRCKSB7XG4gICAgICAgICAgYiA9IHBhcmVudEEucmV0dXJuO1xuICAgICAgICAgIGlmIChudWxsICE9PSBiKSB7XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgICAgIGZvciAocGFyZW50QiA9IHBhcmVudEEuY2hpbGQ7IHBhcmVudEI7ICkge1xuICAgICAgICAgICAgaWYgKHBhcmVudEIgPT09IGEpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGZpYmVyO1xuICAgICAgICAgICAgaWYgKHBhcmVudEIgPT09IGIpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGFsdGVybmF0ZTtcbiAgICAgICAgICAgIHBhcmVudEIgPSBwYXJlbnRCLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSAoYSA9IHBhcmVudEEpLCAoYiA9IHBhcmVudEIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBkaWRGaW5kQ2hpbGQgPSAhMSwgX2NoaWxkID0gcGFyZW50QS5jaGlsZDsgX2NoaWxkOyApIHtcbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgICBmb3IgKF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7IF9jaGlsZDsgKSB7XG4gICAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKDMgIT09IGEudGFnKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICByZXR1cm4gYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSA/IGZpYmVyIDogYWx0ZXJuYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gcGFyZW50ID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKHBhcmVudCkgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcgfHwgNiA9PT0gdGFnKSByZXR1cm4gbm9kZTtcbiAgICAgIGZvciAobm9kZSA9IG5vZGUuY2hpbGQ7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICB0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSk7XG4gICAgICAgIGlmIChudWxsICE9PSB0YWcpIHJldHVybiB0YWc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChub2RlKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICA0ICE9PSBub2RlLnRhZyAmJlxuICAgICAgICAgICgodGFnID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChub2RlKSksIG51bGwgIT09IHRhZylcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHsgY3VycmVudDogZGVmYXVsdFZhbHVlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gICAgICAwID4gaW5kZXgkanNjb21wJDBcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBwb3AuXCIpXG4gICAgICAgIDogKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLlwiKSxcbiAgICAgICAgICAoY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSksXG4gICAgICAgICAgKHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdID0gbnVsbCksXG4gICAgICAgICAgKGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdID0gbnVsbCksXG4gICAgICAgICAgaW5kZXgkanNjb21wJDAtLSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgICAgIGluZGV4JGpzY29tcCQwKys7XG4gICAgICB2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSA9IGN1cnNvci5jdXJyZW50O1xuICAgICAgZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBmaWJlcjtcbiAgICAgIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICAgICAgeCA+Pj49IDA7XG4gICAgICByZXR1cm4gMCA9PT0geCA/IDMyIDogKDMxIC0gKChsb2ckMSh4KSAvIExOMikgfCAwKSkgfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMYWJlbEZvckxhbmUobGFuZSkge1xuICAgICAgaWYgKGxhbmUgJiAxKSByZXR1cm4gXCJTeW5jSHlkcmF0aW9uTGFuZVwiO1xuICAgICAgaWYgKGxhbmUgJiAyKSByZXR1cm4gXCJTeW5jXCI7XG4gICAgICBpZiAobGFuZSAmIDQpIHJldHVybiBcIklucHV0Q29udGludW91c0h5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA4KSByZXR1cm4gXCJJbnB1dENvbnRpbnVvdXNcIjtcbiAgICAgIGlmIChsYW5lICYgMTYpIHJldHVybiBcIkRlZmF1bHRIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMzIpIHJldHVybiBcIkRlZmF1bHRcIjtcbiAgICAgIGlmIChsYW5lICYgNjQpIHJldHVybiBcIlRyYW5zaXRpb25IeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgNDE5NDE3NikgcmV0dXJuIFwiVHJhbnNpdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA2MjkxNDU2MCkgcmV0dXJuIFwiUmV0cnlcIjtcbiAgICAgIGlmIChsYW5lICYgNjcxMDg4NjQpIHJldHVybiBcIlNlbGVjdGl2ZUh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAxMzQyMTc3MjgpIHJldHVybiBcIklkbGVIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMjY4NDM1NDU2KSByZXR1cm4gXCJJZGxlXCI7XG4gICAgICBpZiAobGFuZSAmIDUzNjg3MDkxMikgcmV0dXJuIFwiT2Zmc2NyZWVuXCI7XG4gICAgICBpZiAobGFuZSAmIDEwNzM3NDE4MjQpIHJldHVybiBcIkRlZmVycmVkXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gICAgICBpZiAoMCAhPT0gcGVuZGluZ1N5bmNMYW5lcykgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgICBzd2l0Y2ggKGxhbmVzICYgLWxhbmVzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIHJldHVybiA2NDtcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA0MTk0MTc2O1xuICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICByZXR1cm4gbGFuZXMgJiA2MjkxNDU2MDtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgICByZXR1cm4gNjcxMDg4NjQ7XG4gICAgICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgICAgIHJldHVybiAxMzQyMTc3Mjg7XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICAgIHJldHVybiA1MzY4NzA5MTI7XG4gICAgICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzKSB7XG4gICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICBpZiAoMCA9PT0gcGVuZGluZ0xhbmVzKSByZXR1cm4gMDtcbiAgICAgIHZhciBuZXh0TGFuZXMgPSAwLFxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgICAgd2FybUxhbmVzID0gcm9vdC53YXJtTGFuZXM7XG4gICAgICByb290ID0gMCAhPT0gcm9vdC5maW5pc2hlZExhbmVzO1xuICAgICAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiAxMzQyMTc3Mjc7XG4gICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgID8gKChwZW5kaW5nTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBwZW5kaW5nTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBlbmRpbmdMYW5lcykpXG4gICAgICAgICAgICA6ICgocGluZ2VkTGFuZXMgJj0gbm9uSWRsZVBlbmRpbmdMYW5lcyksXG4gICAgICAgICAgICAgIDAgIT09IHBpbmdlZExhbmVzXG4gICAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgICAgICAgKCh3YXJtTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfndhcm1MYW5lcyksXG4gICAgICAgICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSkpXG4gICAgICAgIDogKChub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzKSxcbiAgICAgICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgICA6IHJvb3QgfHxcbiAgICAgICAgICAgICAgICAoKHdhcm1MYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH53YXJtTGFuZXMpLFxuICAgICAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHdhcm1MYW5lcykpKSk7XG4gICAgICByZXR1cm4gMCA9PT0gbmV4dExhbmVzXG4gICAgICAgID8gMFxuICAgICAgICA6IDAgIT09IHdpcExhbmVzICYmXG4gICAgICAgICAgICB3aXBMYW5lcyAhPT0gbmV4dExhbmVzICYmXG4gICAgICAgICAgICAwID09PSAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgJiZcbiAgICAgICAgICAgICgoc3VzcGVuZGVkTGFuZXMgPSBuZXh0TGFuZXMgJiAtbmV4dExhbmVzKSxcbiAgICAgICAgICAgICh3YXJtTGFuZXMgPSB3aXBMYW5lcyAmIC13aXBMYW5lcyksXG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA+PSB3YXJtTGFuZXMgfHxcbiAgICAgICAgICAgICAgKDMyID09PSBzdXNwZW5kZWRMYW5lcyAmJiAwICE9PSAod2FybUxhbmVzICYgNDE5NDE3NikpKVxuICAgICAgICAgID8gd2lwTGFuZXNcbiAgICAgICAgICA6IG5leHRMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCByZW5kZXJMYW5lcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgMCA9PT1cbiAgICAgICAgKHJvb3QucGVuZGluZ0xhbmVzICZcbiAgICAgICAgICB+KHJvb3Quc3VzcGVuZGVkTGFuZXMgJiB+cm9vdC5waW5nZWRMYW5lcykgJlxuICAgICAgICAgIHJlbmRlckxhbmVzKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBzd2l0Y2ggKGxhbmUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1ZTM7XG4gICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgY2FzZSA2NzEwODg2NDpcbiAgICAgICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICBjYXNlIDUzNjg3MDkxMjpcbiAgICAgICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC0xXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgICAgIG5leHRUcmFuc2l0aW9uTGFuZSA8PD0gMTtcbiAgICAgIDAgPT09IChuZXh0VHJhbnNpdGlvbkxhbmUgJiA0MTk0MTc2KSAmJiAobmV4dFRyYW5zaXRpb25MYW5lID0gMTI4KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gICAgICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gICAgICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuICAgICAgMCA9PT0gKG5leHRSZXRyeUxhbmUgJiA2MjkxNDU2MCkgJiYgKG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0KTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgICAgIGZvciAodmFyIGxhbmVNYXAgPSBbXSwgaSA9IDA7IDMxID4gaTsgaSsrKSBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gICAgICByZXR1cm4gbGFuZU1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTtcbiAgICAgIDI2ODQzNTQ1NiAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAoKHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3QucGluZ2VkTGFuZXMgPSAwKSxcbiAgICAgICAgKHJvb3Qud2FybUxhbmVzID0gMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkTGFuZXMsXG4gICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzID0gMDtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICAgICAgcm9vdC53YXJtTGFuZXMgPSAwO1xuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gICAgICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICAgIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gICAgICBmb3IgKFxuICAgICAgICByZW1haW5pbmdMYW5lcyA9IHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gICAgICAgIDAgPCByZW1haW5pbmdMYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocmVtYWluaW5nTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IDA7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSAtMTtcbiAgICAgICAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleF07XG4gICAgICAgIGlmIChudWxsICE9PSBoaWRkZW5VcGRhdGVzRm9yTGFuZSlcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBudWxsLCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBoaWRkZW5VcGRhdGVzRm9yTGFuZVtpbmRleF07XG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGUgJiYgKHVwZGF0ZS5sYW5lICY9IC01MzY4NzA5MTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgMCk7XG4gICAgICAwICE9PSBzdXNwZW5kZWRSZXRyeUxhbmVzICYmXG4gICAgICAgIDAgPT09IHVwZGF0ZWRMYW5lcyAmJlxuICAgICAgICAwICE9PSByb290LnRhZyAmJlxuICAgICAgICAocm9vdC5zdXNwZW5kZWRMYW5lcyB8PVxuICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMgJiB+KHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+ZmluaXNoZWRMYW5lcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyAmPSB+c3Bhd25lZExhbmU7XG4gICAgICB2YXIgc3Bhd25lZExhbmVJbmRleCA9IDMxIC0gY2x6MzIoc3Bhd25lZExhbmUpO1xuICAgICAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSA9XG4gICAgICAgIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSB8XG4gICAgICAgIDEwNzM3NDE4MjQgfFxuICAgICAgICAoZW50YW5nbGVkTGFuZXMgJiA0MTk0MjE4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIHZhciByb290RW50YW5nbGVkTGFuZXMgPSAocm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgICBmb3IgKHJvb3QgPSByb290LmVudGFuZ2xlbWVudHM7IHJvb3RFbnRhbmdsZWRMYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIocm9vdEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgKGxhbmUgJiBlbnRhbmdsZWRMYW5lcykgfCAocm9vdFtpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykgJiZcbiAgICAgICAgICAocm9vdFtpbmRleF0gfD0gZW50YW5nbGVkTGFuZXMpO1xuICAgICAgICByb290RW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChyb290ID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwOyAwIDwgbGFuZXM7ICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgcm9vdFtpbmRleF0uYWRkKGZpYmVyKTtcbiAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCxcbiAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IGxhbmVzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpO1xuICAgICAgICAgIHJvb3QgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIGluZGV4ID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG4gICAgICAgICAgMCA8IGluZGV4LnNpemUgJiZcbiAgICAgICAgICAgIChpbmRleC5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIG1lbW9pemVkVXBkYXRlcnMuaGFzKGFsdGVybmF0ZSkpIHx8XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmRleC5jbGVhcigpKTtcbiAgICAgICAgICBsYW5lcyAmPSB+cm9vdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICAgICAgbGFuZXMgJj0gLWxhbmVzO1xuICAgICAgcmV0dXJuIDIgPCBsYW5lc1xuICAgICAgICA/IDggPCBsYW5lc1xuICAgICAgICAgID8gMCAhPT0gKGxhbmVzICYgMTM0MjE3NzI3KVxuICAgICAgICAgICAgPyAzMlxuICAgICAgICAgICAgOiAyNjg0MzU0NTZcbiAgICAgICAgICA6IDhcbiAgICAgICAgOiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykgcmV0dXJuICExO1xuICAgICAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gICAgICBpZiAoaG9vay5pc0Rpc2FibGVkKSByZXR1cm4gITA7XG4gICAgICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcmVhY3QtZGV2dG9vbHNcIlxuICAgICAgICAgICksXG4gICAgICAgICAgITBcbiAgICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIChyZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKSksIChpbmplY3RlZEhvb2sgPSBob29rKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy5cIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob29rLmNoZWNrRENFID8gITAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Db21taXRSb290JDEocm9vdCwgZXZlbnRQcmlvcml0eSkge1xuICAgICAgaWYgKGluamVjdGVkSG9vayAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGRpZEVycm9yID0gMTI4ID09PSAocm9vdC5jdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QoXG4gICAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5LFxuICAgICAgICAgICAgZGlkRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKG5ld0lzU3RyaWN0TW9kZSkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9nICYmXG4gICAgICAgIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBwcm9maWxpbmdIb29rcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbW1pdFN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcykge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZSkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBDYXB0dXJlZFN0YWNrcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgICAgICB9O1xuICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya0NvdW50O1xuICAgICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHRyZWVGb3JrQ291bnQgPSB0b3RhbENoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gICAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgdmFyIGJhc2VMZW5ndGggPSAzMiAtIGNsejMyKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmPSB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoO1xuICAgICAgaWYgKDMwIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgICAgICBsZW5ndGggPSAoXG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJlxuICAgICAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICAgICApLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgPj49IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgICAgICB0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCAoMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGgpKSB8XG4gICAgICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdDtcbiAgICAgICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IGxlbmd0aCArIHdvcmtJblByb2dyZXNzO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlQ29udGV4dElkID1cbiAgICAgICAgICAoMSA8PCBsZW5ndGgpIHwgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHwgYmFzZUlkV2l0aExlYWRpbmdCaXQpLFxuICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLnJldHVybiAmJlxuICAgICAgICAocHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCAxKSwgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgMSwgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyOyApXG4gICAgICAgICh0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGwpO1xuICAgICAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlQ29udGV4dFByb3ZpZGVyOyApXG4gICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0SWQgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gICAgICBpc0h5ZHJhdGluZyB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gYmUgaHlkcmF0aW5nLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICAgbnVsbCA9PT0gYyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCwgZmliZXIpO1xuICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBwdXNoKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTtcbiAgICAgIGNvbnRleHQgIT09IG5leHRDb250ZXh0ICYmXG4gICAgICAgIChwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpLFxuICAgICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dENvbnRleHQsIGZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgICBjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgICAgICAocG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpLCBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKSk7XG4gICAgICBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgICAgIChwb3AoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIpLFxuICAgICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgID8gKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gTm90UGVuZGluZ1RyYW5zaXRpb24pXG4gICAgICAgICAgOiAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gTm90UGVuZGluZ1RyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcyAmJlxuICAgICAgICAwID09PSBub2RlLnNlcnZlclRhaWwubGVuZ3RoICYmXG4gICAgICAgIDEgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIDMgPCBub2RlLmRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgbm9kZS5kaXN0YW5jZUZyb21MZWFmID4gMTUgLSBpbmRlbnRcbiAgICAgICAgPyBmaW5kTm90YWJsZU5vZGUobm9kZS5jaGlsZHJlblswXSwgaW5kZW50KVxuICAgICAgICA6IG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGVudGF0aW9uKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiICBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIrIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVkKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiLSBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZmliZXIudHlwZTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gXCJMYXp5XCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBmaWJlci50eXBlKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci50eXBlLnJlbmRlciksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZmliZXIudHlwZSksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVUZXh0Tm9kZShjb250ZW50LCBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZWVkc0VzY2FwaW5nLnRlc3QoY29udGVudClcbiAgICAgICAgPyAoKGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjb250ZW50KSksXG4gICAgICAgICAgY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGggLSAyXG4gICAgICAgICAgICA/IDggPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgPyAne1wiLi4uXCJ9J1xuICAgICAgICAgICAgICA6IFwie1wiICsgY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSA3KSArICcuLi5cIn0nXG4gICAgICAgICAgICA6IFwie1wiICsgY29udGVudCArIFwifVwiKVxuICAgICAgICA6IGNvbnRlbnQubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICA/ICd7XCIuLi5cIn0nXG4gICAgICAgICAgICA6IGNvbnRlbnQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gMykgKyBcIi4uLlwiXG4gICAgICAgICAgOiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVRleHREaWZmKGNsaWVudFRleHQsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogaW5kZW50O1xuICAgICAgaWYgKG51bGwgPT09IHNlcnZlclByb3BzKVxuICAgICAgICByZXR1cm4gYWRkZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArIFwiXFxuXCI7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlclByb3BzKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGZpcnN0RGlmZiA9IDA7XG4gICAgICAgICAgZmlyc3REaWZmIDwgc2VydmVyUHJvcHMubGVuZ3RoICYmXG4gICAgICAgICAgZmlyc3REaWZmIDwgY2xpZW50VGV4dC5sZW5ndGggJiZcbiAgICAgICAgICBzZXJ2ZXJQcm9wcy5jaGFyQ29kZUF0KGZpcnN0RGlmZikgPT09XG4gICAgICAgICAgICBjbGllbnRUZXh0LmNoYXJDb2RlQXQoZmlyc3REaWZmKTtcbiAgICAgICAgICBmaXJzdERpZmYrK1xuICAgICAgICApO1xuICAgICAgICBmaXJzdERpZmYgPiBtYXhMZW5ndGggLSA4ICYmXG4gICAgICAgICAgMTAgPCBmaXJzdERpZmYgJiZcbiAgICAgICAgICAoKGNsaWVudFRleHQgPSBcIi4uLlwiICsgY2xpZW50VGV4dC5zbGljZShmaXJzdERpZmYgLSA4KSksXG4gICAgICAgICAgKHNlcnZlclByb3BzID0gXCIuLi5cIiArIHNlcnZlclByb3BzLnNsaWNlKGZpcnN0RGlmZiAtIDgpKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYWRkZWQoaW5kZW50KSArXG4gICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICtcbiAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICByZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyUHJvcHMsIG1heExlbmd0aCkgK1xuICAgICAgICAgIFwiXFxuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLmNhbGwob2JqZWN0KVxuICAgICAgICAucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgICAgICAgIHJldHVybiBwMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpLFxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgICAgID8gJ1wiLi4uXCInXG4gICAgICAgICAgICAgICAgOiB2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGggLSA0KSArICcuLi5cIidcbiAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAobnVsbCA9PT0gdmFsdWUpIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwodmFsdWUpKSByZXR1cm4gXCJbLi4uXVwiO1xuICAgICAgICAgIGlmICh2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSkpXG4gICAgICAgICAgICAgID8gXCI8XCIgKyBtYXhMZW5ndGggKyBcIj5cIlxuICAgICAgICAgICAgICA6IFwiPC4uLj5cIjtcbiAgICAgICAgICB2YXIgbmFtZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuICAgICAgICAgIGlmIChcIk9iamVjdFwiID09PSBuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG1heExlbmd0aCAtPSAyO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdmFsdWUpXG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvblByb3BOYW1lID0gSlNPTi5zdHJpbmdpZnkocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGpzb25Qcm9wTmFtZSAhPT0gJ1wiJyArIHByb3BOYW1lICsgJ1wiJyAmJlxuICAgICAgICAgICAgICAgICAgKHByb3BOYW1lID0ganNvblByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBqc29uUHJvcE5hbWUgPSBkZXNjcmliZVZhbHVlKFxuICAgICAgICAgICAgICAgICAgdmFsdWVbcHJvcE5hbWVdLFxuICAgICAgICAgICAgICAgICAgMTUgPiBtYXhMZW5ndGggPyBtYXhMZW5ndGggOiAxNVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IGpzb25Qcm9wTmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKDAgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgKz0gXCJcIiA9PT0gbmFtZSA/IFwiLi4uXCIgOiBcIiwgLi4uXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZSArPVxuICAgICAgICAgICAgICAgICAgKFwiXCIgPT09IG5hbWUgPyBcIlwiIDogXCIsXCIpICsgcHJvcE5hbWUgKyBcIjpcIiArIGpzb25Qcm9wTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwie1wiICsgbmFtZSArIFwifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIChtYXhMZW5ndGggPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lKVxuICAgICAgICAgICAgPyBcImZ1bmN0aW9uIFwiICsgbWF4TGVuZ3RoXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVQcm9wVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgIT09IHR5cGVvZiB2YWx1ZSB8fCBuZWVkc0VzY2FwaW5nLnRlc3QodmFsdWUpXG4gICAgICAgID8gXCJ7XCIgKyBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggLSAyKSArIFwifVwiXG4gICAgICAgIDogdmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMlxuICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgPyAnXCIuLi5cIidcbiAgICAgICAgICAgIDogJ1wiJyArIHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDUpICsgJy4uLlwiJ1xuICAgICAgICAgIDogJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodHlwZSwgcHJvcHMsIHJvd1ByZWZpeCkge1xuICAgICAgdmFyIHJlbWFpbmluZ1Jvd0xlbmd0aCA9IDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSB0eXBlLmxlbmd0aCxcbiAgICAgICAgcHJvcGVydGllcyA9IFtdLFxuICAgICAgICBwcm9wTmFtZTtcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gcHJvcHMpXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSxcbiAgICAgICAgICAgIDEyMCAtIHJvd1ByZWZpeC5sZW5ndGggLSBwcm9wTmFtZS5sZW5ndGggLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW1haW5pbmdSb3dMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BOYW1lICsgXCI9XCIgKyBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gMCA9PT0gcHJvcGVydGllcy5sZW5ndGhcbiAgICAgICAgPyByb3dQcmVmaXggKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIlxuICAgICAgICA6IDAgPCByZW1haW5pbmdSb3dMZW5ndGhcbiAgICAgICAgICA/IHJvd1ByZWZpeCArIFwiPFwiICsgdHlwZSArIFwiIFwiICsgcHJvcGVydGllcy5qb2luKFwiIFwiKSArIFwiPlxcblwiXG4gICAgICAgICAgOiByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIiAgXCIgK1xuICAgICAgICAgICAgcHJvcGVydGllcy5qb2luKFwiXFxuXCIgKyByb3dQcmVmaXggKyBcIiAgXCIpICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiPlxcblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVByb3BlcnRpZXNEaWZmKGNsaWVudE9iamVjdCwgc2VydmVyT2JqZWN0LCBpbmRlbnQpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gXCJcIixcbiAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllcyA9IGFzc2lnbih7fSwgc2VydmVyT2JqZWN0KSxcbiAgICAgICAgcHJvcE5hbWU7XG4gICAgICBmb3IgKHByb3BOYW1lIGluIGNsaWVudE9iamVjdClcbiAgICAgICAgaWYgKGNsaWVudE9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBpbmRlbnQgLSBwcm9wTmFtZS5sZW5ndGggLSAyLFxuICAgICAgICAgICAgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZShjbGllbnRPYmplY3RbcHJvcE5hbWVdLCBtYXhMZW5ndGgpO1xuICAgICAgICAgIHNlcnZlck9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSlcbiAgICAgICAgICAgID8gKChtYXhMZW5ndGggPSBkZXNjcmliZVZhbHVlKHNlcnZlck9iamVjdFtwcm9wTmFtZV0sIG1heExlbmd0aCkpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudFByb3BWYWx1ZSArIFwiXFxuXCIpLFxuICAgICAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgbWF4TGVuZ3RoICsgXCJcXG5cIikpXG4gICAgICAgICAgICA6IChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgY2xpZW50UHJvcFZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzKVxuICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZSkgJiZcbiAgICAgICAgICAoKGNsaWVudE9iamVjdCA9IGRlc2NyaWJlVmFsdWUoXG4gICAgICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW19wcm9wTmFtZV0sXG4gICAgICAgICAgICAxMjAgLSAyICogaW5kZW50IC0gX3Byb3BOYW1lLmxlbmd0aCAtIDJcbiAgICAgICAgICApKSxcbiAgICAgICAgICAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICsgX3Byb3BOYW1lICsgXCI6IFwiICsgY2xpZW50T2JqZWN0ICsgXCJcXG5cIikpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudERpZmYodHlwZSwgY2xpZW50UHJvcHMsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIixcbiAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChwcm9wTmFtZSRqc2NvbXAkMCBpbiBzZXJ2ZXJQcm9wcylcbiAgICAgICAgc2VydmVyUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUkanNjb21wJDApICYmXG4gICAgICAgICAgc2VydmVyUHJvcE5hbWVzLnNldChcbiAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMFxuICAgICAgICAgICk7XG4gICAgICBpZiAoMSA9PT0gc2VydmVyUHJvcE5hbWVzLnNpemUgJiYgc2VydmVyUHJvcE5hbWVzLmhhcyhcImNoaWxkcmVuXCIpKVxuICAgICAgICBjb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2xpZW50UHJvcHMsXG4gICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KVxuICAgICAgICApO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9wcm9wTmFtZTIgaW4gY2xpZW50UHJvcHMpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2xpZW50UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lMikgJiZcbiAgICAgICAgICAgIFwiY2hpbGRyZW5cIiAhPT0gX3Byb3BOYW1lMlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgMTIwIC0gMiAqIChpbmRlbnQgKyAxKSAtIF9wcm9wTmFtZTIubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wTmFtZXMuZ2V0KF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBzZXJ2ZXJQcm9wTmFtZSkge1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZGVsZXRlKF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgIHZhciBwcm9wTmFtZSRqc2NvbXAkMCA9IGNsaWVudFByb3BzW19wcm9wTmFtZTJdO1xuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BzW3NlcnZlclByb3BOYW1lXTtcbiAgICAgICAgICAgICAgdmFyIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHByb3BOYW1lJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBzZXJ2ZXJQcm9wTmFtZSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHByb3BOYW1lJGpzY29tcCQwKSAmJlxuICAgICAgICAgICAgICBcIk9iamVjdFwiID09PSBvYmplY3ROYW1lKHNlcnZlclByb3BOYW1lKSAmJlxuICAgICAgICAgICAgICAoMiA8IE9iamVjdC5rZXlzKHByb3BOYW1lJGpzY29tcCQwKS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAyIDwgT2JqZWN0LmtleXMoc2VydmVyUHJvcE5hbWUpLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIC0xIDwgY2xpZW50UHJvcFZhbHVlLmluZGV4T2YoXCIuLi5cIikgfHxcbiAgICAgICAgICAgICAgICAtMSA8IG1heExlbmd0aCRqc2NvbXAkMC5pbmRleE9mKFwiLi4uXCIpKVxuICAgICAgICAgICAgICAgID8gKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9e3tcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICsgMlxuICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIn19XFxuXCIpXG4gICAgICAgICAgICAgICAgOiAoKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRQcm9wVmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICAgIChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDAgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcblwiKSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICBfcHJvcE5hbWUyICtcbiAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wVmFsdWUoY2xpZW50UHJvcHNbX3Byb3BOYW1lMl0sIG1heExlbmd0aCRqc2NvbXAkMCkgK1xuICAgICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICBpZiAoXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiAoaW5kZW50ICsgMSkgLSBwcm9wTmFtZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29udGVudCArPVxuICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgK1xuICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgIGRlc2NyaWJlUHJvcFZhbHVlKHNlcnZlclByb3BzW3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudCA9XG4gICAgICAgICAgXCJcIiA9PT0gY29udGVudFxuICAgICAgICAgICAgPyBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCJcbiAgICAgICAgICAgIDogaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgdHlwZSArXG4gICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICBjb250ZW50ICtcbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArXG4gICAgICAgICAgICAgIFwiPlxcblwiO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHNlcnZlclByb3BzLmNoaWxkcmVuO1xuICAgICAgY2xpZW50UHJvcHMgPSBjbGllbnRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICkge1xuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICAgIClcbiAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBcIlwiICsgY2xpZW50UHJvcHM7XG4gICAgICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVUZXh0RGlmZihzZXJ2ZXJQcm9wTmFtZXMsIFwiXCIgKyB0eXBlLCBpbmRlbnQgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzXG4gICAgICApXG4gICAgICAgIGNvbnRlbnQgPVxuICAgICAgICAgIG51bGwgPT0gdHlwZVxuICAgICAgICAgICAgPyBjb250ZW50ICsgZGVzY3JpYmVUZXh0RGlmZihcIlwiICsgY2xpZW50UHJvcHMsIG51bGwsIGluZGVudCArIDEpXG4gICAgICAgICAgICA6IGNvbnRlbnQgKyBkZXNjcmliZVRleHREaWZmKFwiXCIgKyBjbGllbnRQcm9wcywgdm9pZCAwLCBpbmRlbnQgKyAxKTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IGRlc2NyaWJlRmliZXJUeXBlKGZpYmVyKTtcbiAgICAgIGlmIChudWxsID09PSB0eXBlKSB7XG4gICAgICAgIHR5cGUgPSBcIlwiO1xuICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IGZpYmVyOyApXG4gICAgICAgICAgKHR5cGUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoZmliZXIsIGluZGVudCkpLFxuICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOb2RlKG5vZGUsIGluZGVudCkge1xuICAgICAgdmFyIHNraXBUb05vZGUgPSBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KTtcbiAgICAgIGlmIChcbiAgICAgICAgc2tpcFRvTm9kZSAhPT0gbm9kZSAmJlxuICAgICAgICAoMSAhPT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggfHwgbm9kZS5jaGlsZHJlblswXSAhPT0gc2tpcFRvTm9kZSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCIuLi5cXG5cIiArIGRlc2NyaWJlTm9kZShza2lwVG9Ob2RlLCBpbmRlbnQgKyAxKVxuICAgICAgICApO1xuICAgICAgc2tpcFRvTm9kZSA9IFwiXCI7XG4gICAgICB2YXIgZGVidWdJbmZvID0gbm9kZS5maWJlci5fZGVidWdJbmZvO1xuICAgICAgaWYgKGRlYnVnSW5mbylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlYnVnSW5mb1tpXS5uYW1lO1xuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAoKHNraXBUb05vZGUgKz1cbiAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgc2VydmVyQ29tcG9uZW50TmFtZSArIFwiPlxcblwiKSxcbiAgICAgICAgICAgIGluZGVudCsrKTtcbiAgICAgICAgfVxuICAgICAgZGVidWdJbmZvID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgIGlmICg2ID09PSBub2RlLmZpYmVyLnRhZylcbiAgICAgICAgKGRlYnVnSW5mbyA9IGRlc2NyaWJlVGV4dERpZmYoaSwgbm9kZS5zZXJ2ZXJQcm9wcywgaW5kZW50KSksIGluZGVudCsrO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICgoc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlc2NyaWJlRmliZXJUeXBlKG5vZGUuZmliZXIpKSxcbiAgICAgICAgbnVsbCAhPT0gc2VydmVyQ29tcG9uZW50TmFtZSlcbiAgICAgIClcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcykge1xuICAgICAgICAgIGRlYnVnSW5mbyA9IGluZGVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGRlYnVnSW5mbyAtIHNlcnZlckNvbXBvbmVudE5hbWUubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIGZvciAocHJvcE5hbWUgaW4gaSlcbiAgICAgICAgICAgIGlmIChpLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiBcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShpW3Byb3BOYW1lXSwgMTUpO1xuICAgICAgICAgICAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG4gICAgICAgICAgICAgIGlmICgwID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBcIiAuLi5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIFwiICsgcHJvcE5hbWUgKyBcIj1cIiArIHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1Z0luZm8gPVxuICAgICAgICAgICAgaW5kZW50YXRpb24oZGVidWdJbmZvKSArXG4gICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lICtcbiAgICAgICAgICAgIGNvbnRlbnQgK1xuICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG51bGwgPT09IG5vZGUuc2VydmVyUHJvcHNcbiAgICAgICAgICAgID8gKChkZWJ1Z0luZm8gPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaW5kZW50KyspXG4gICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBub2RlLnNlcnZlclByb3BzXG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiU2hvdWxkIG5vdCBoYXZlIG1hdGNoZWQgYSBub24gSG9zdFRleHQgZmliZXIgdG8gYSBUZXh0IG5vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogKChkZWJ1Z0luZm8gPSBkZXNjcmliZUVsZW1lbnREaWZmKFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICBub2RlLnNlcnZlclByb3BzLFxuICAgICAgICAgICAgICAgICAgaW5kZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgaW5kZW50KyspO1xuICAgICAgdmFyIHByb3BOYW1lID0gXCJcIjtcbiAgICAgIGkgPSBub2RlLmZpYmVyLmNoaWxkO1xuICAgICAgZm9yIChcbiAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSA9IDA7XG4gICAgICAgIGkgJiYgc2VydmVyQ29tcG9uZW50TmFtZSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICApXG4gICAgICAgIChtYXhMZW5ndGggPSBub2RlLmNoaWxkcmVuW3NlcnZlckNvbXBvbmVudE5hbWVdKSxcbiAgICAgICAgICBtYXhMZW5ndGguZmliZXIgPT09IGlcbiAgICAgICAgICAgID8gKChwcm9wTmFtZSArPSBkZXNjcmliZU5vZGUobWF4TGVuZ3RoLCBpbmRlbnQpKSxcbiAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSsrKVxuICAgICAgICAgICAgOiAocHJvcE5hbWUgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoaSwgaW5kZW50KSksXG4gICAgICAgICAgKGkgPSBpLnNpYmxpbmcpO1xuICAgICAgaSAmJlxuICAgICAgICAwIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKHByb3BOYW1lICs9IGluZGVudGF0aW9uKGluZGVudCkgKyBcIi4uLlxcblwiKTtcbiAgICAgIGkgPSBub2RlLnNlcnZlclRhaWw7XG4gICAgICBudWxsID09PSBub2RlLnNlcnZlclByb3BzICYmIGluZGVudC0tO1xuICAgICAgZm9yIChub2RlID0gMDsgbm9kZSA8IGkubGVuZ3RoOyBub2RlKyspXG4gICAgICAgIChzZXJ2ZXJDb21wb25lbnROYW1lID0gaVtub2RlXSksXG4gICAgICAgICAgKHByb3BOYW1lID1cbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lXG4gICAgICAgICAgICAgID8gcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgIChyZW1vdmVkKGluZGVudCkgK1xuICAgICAgICAgICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJDb21wb25lbnROYW1lLCAxMjAgLSAyICogaW5kZW50KSArXG4gICAgICAgICAgICAgICAgICBcIlxcblwiKVxuICAgICAgICAgICAgICA6IHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUudHlwZSxcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUucHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudClcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgIHJldHVybiBza2lwVG9Ob2RlICsgZGVidWdJbmZvICsgcHJvcE5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRGlmZihyb290Tm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFwiXFxuXFxuXCIgKyBkZXNjcmliZU5vZGUocm9vdE5vZGUsIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybikge1xuICAgICAgICBpZiAobnVsbCA9PT0gaHlkcmF0aW9uRGlmZlJvb3RERVYpXG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICAgICAgfTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlNhdyBtdWx0aXBsZSBoeWRyYXRpb24gZGlmZiByb290cyBpbiBhIHBhc3MuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgfVxuICAgICAgdmFyIHNpYmxpbmdzID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmICsgMVxuICAgICAgKS5jaGlsZHJlbjtcbiAgICAgIGlmICgwIDwgc2libGluZ3MubGVuZ3RoICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2libGluZ3MgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXSksXG4gICAgICAgICAgc2libGluZ3MuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYgJiZcbiAgICAgICAgICAgIChzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZiksXG4gICAgICAgICAgc2libGluZ3NcbiAgICAgICAgKTtcbiAgICAgIGRpc3RhbmNlRnJvbUxlYWYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdm9pZCAwLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICAgIHNpYmxpbmdzLnB1c2goZGlzdGFuY2VGcm9tTGVhZik7XG4gICAgICByZXR1cm4gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIHJlamVjdGVkQ2FuZGlkYXRlKSB7XG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAoKGZpYmVyID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCkpLFxuICAgICAgICAoZmliZXIuc2VydmVyUHJvcHMgPSBudWxsKSxcbiAgICAgICAgbnVsbCAhPT0gcmVqZWN0ZWRDYW5kaWRhdGUgJiZcbiAgICAgICAgICAoKHJlamVjdGVkQ2FuZGlkYXRlID1cbiAgICAgICAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MocmVqZWN0ZWRDYW5kaWRhdGUpKSxcbiAgICAgICAgICBmaWJlci5zZXJ2ZXJUYWlsLnB1c2gocmVqZWN0ZWRDYW5kaWRhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICAgICAgdmFyIGRpZmYgPSBcIlwiLFxuICAgICAgICBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgbnVsbCAhPT0gZGlmZlJvb3QgJiZcbiAgICAgICAgKChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLCAoZGlmZiA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCkpKTtcbiAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgXCJIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50LiBBcyBhIHJlc3VsdCB0aGlzIHRyZWUgd2lsbCBiZSByZWdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG5odHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiICtcbiAgICAgICAgICAgICAgZGlmZlxuICAgICAgICAgICksXG4gICAgICAgICAgZmliZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRocm93IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCBob3N0Q29udGV4dCkge1xuICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICBoeWRyYXRlSW5zdGFuY2UoXG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgZmliZXIudHlwZSxcbiAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaG9zdENvbnRleHQsXG4gICAgICAgIGZpYmVyXG4gICAgICApIHx8IHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgICAgIGZvciAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47IGh5ZHJhdGlvblBhcmVudEZpYmVyOyApXG4gICAgICAgIHN3aXRjaCAoaHlkcmF0aW9uUGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uIHx8IGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikgcmV0dXJuICExO1xuICAgICAgaWYgKCFpc0h5ZHJhdGluZylcbiAgICAgICAgcmV0dXJuIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpLCAoaXNIeWRyYXRpbmcgPSAhMCksICExO1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gITE7XG4gICAgICBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgPyAzICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAyNyAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKDUgIT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgKHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpICYmXG4gICAgICAgICAgKHNob3VsZENsZWFyID0gITApXG4gICAgICAgIDogMyAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKDUgIT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgKHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpICYmXG4gICAgICAgICAgKHNob3VsZENsZWFyID0gITApO1xuICAgICAgaWYgKHNob3VsZENsZWFyICYmIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICAgICAgZm9yIChzaG91bGRDbGVhciA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7IHNob3VsZENsZWFyOyApIHtcbiAgICAgICAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhzaG91bGRDbGVhcik7XG4gICAgICAgICAgZGlmZk5vZGUuc2VydmVyVGFpbC5wdXNoKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBzaG91bGRDbGVhciA9XG4gICAgICAgICAgICBcIlN1c3BlbnNlXCIgPT09IGRlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHNob3VsZENsZWFyKVxuICAgICAgICAgICAgICA6IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhzaG91bGRDbGVhcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgICAgIH1cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgZmliZXIgPSBudWxsICE9PSBmaWJlciA/IGZpYmVyLmRlaHlkcmF0ZWQgOiBudWxsO1xuICAgICAgICBpZiAoIWZpYmVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXJcbiAgICAgICAgICA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsKSxcbiAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gaXNIeWRyYXRpbmcgPSAhMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICBudWxsID09PSBoeWRyYXRpb25FcnJvcnNcbiAgICAgICAgPyAoaHlkcmF0aW9uRXJyb3JzID0gW2Vycm9yXSlcbiAgICAgICAgOiBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSB7XG4gICAgICB2YXIgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgICAgIG51bGwgIT09IGRpZmZSb290ICYmXG4gICAgICAgICgoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgKGRpZmZSb290ID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIHRyZWUgaHlkcmF0ZWQgYnV0IHNvbWUgYXR0cmlidXRlcyBvZiB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQgcHJvcGVydGllcy4gVGhpcyB3b24ndCBiZSBwYXRjaGVkIHVwLiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblxcbi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuLSBEYXRlIGZvcm1hdHRpbmcgaW4gYSB1c2VyJ3MgbG9jYWxlIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggdGhlIHNlcnZlci5cXG4tIEV4dGVybmFsIGNoYW5naW5nIGRhdGEgd2l0aG91dCBzZW5kaW5nIGEgc25hcHNob3Qgb2YgaXQgYWxvbmcgd2l0aCB0aGUgSFRNTC5cXG4tIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG5cXG5JdCBjYW4gYWxzbyBoYXBwZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBicm93c2VyIGV4dGVuc2lvbiBpbnN0YWxsZWQgd2hpY2ggbWVzc2VzIHdpdGggdGhlIEhUTUwgYmVmb3JlIFJlYWN0IGxvYWRlZC5cXG5cXG4lcyVzXCIsXG4gICAgICAgICAgXCJodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaFwiLFxuICAgICAgICAgIGRpZmZSb290XG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gY29uY3VycmVudFF1ZXVlc0luZGV4LFxuICAgICAgICAgIGkgPSAoY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCk7XG4gICAgICAgIGkgPCBlbmRJbmRleDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBxdWV1ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgICAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgICAgICB2YXIgbGFuZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBxdWV1ZSAmJiBudWxsICE9PSB1cGRhdGUpIHtcbiAgICAgICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAwICE9PSBsYW5lICYmIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gZmliZXI7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHF1ZXVlO1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSB1cGRhdGU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGxhbmU7XG4gICAgICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gICAgICBmaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5sYW5lcyB8PSBsYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgbnVsbCwgbnVsbCwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIHNvdXJjZUZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gbGFuZSk7XG4gICAgICBmb3IgKHZhciBpc0hpZGRlbiA9ICExLCBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICAocGFyZW50LmNoaWxkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgKGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgMjIgPT09IHBhcmVudC50YWcgJiZcbiAgICAgICAgICAgICgoc291cmNlRmliZXIgPSBwYXJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyIHx8XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLl92aXNpYmlsaXR5ICYgMSB8fFxuICAgICAgICAgICAgICAoaXNIaWRkZW4gPSAhMCkpLFxuICAgICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudCksXG4gICAgICAgICAgKHBhcmVudCA9IHBhcmVudC5yZXR1cm4pO1xuICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgbnVsbCAhPT0gdXBkYXRlICYmXG4gICAgICAgIDMgPT09IHNvdXJjZUZpYmVyLnRhZyAmJlxuICAgICAgICAoKHBhcmVudCA9IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgIChpc0hpZGRlbiA9IDMxIC0gY2x6MzIobGFuZSkpLFxuICAgICAgICAocGFyZW50ID0gcGFyZW50LmhpZGRlblVwZGF0ZXMpLFxuICAgICAgICAoc291cmNlRmliZXIgPSBwYXJlbnRbaXNIaWRkZW5dKSxcbiAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICA/IChwYXJlbnRbaXNIaWRkZW5dID0gW3VwZGF0ZV0pXG4gICAgICAgICAgOiBzb3VyY2VGaWJlci5wdXNoKHVwZGF0ZSksXG4gICAgICAgICh1cGRhdGUubGFuZSA9IGxhbmUgfCA1MzY4NzA5MTIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihzb3VyY2VGaWJlcikge1xuICAgICAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gbmVzdGVkVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGwpLFxuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXCJcbiAgICAgICAgICApKVxuICAgICAgICApO1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUICYmXG4gICAgICAgICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiBldmVyeSByZW5kZXIuXCJcbiAgICAgICAgKSk7XG4gICAgICBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgMCAhPT0gKHNvdXJjZUZpYmVyLmZsYWdzICYgNDA5OCkgJiZcbiAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgICBmb3IgKHZhciBub2RlID0gc291cmNlRmliZXIsIHBhcmVudCA9IG5vZGUucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAgICAgbnVsbCA9PT0gbm9kZS5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAwICE9PSAobm9kZS5mbGFncyAmIDQwOTgpICYmXG4gICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlciksXG4gICAgICAgICAgKG5vZGUgPSBwYXJlbnQpLFxuICAgICAgICAgIChwYXJlbnQgPSBub2RlLnJldHVybik7XG4gICAgICByZXR1cm4gMyA9PT0gbm9kZS50YWcgPyBub2RlLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKSB7XG4gICAgICB2YXIgcHJldkVmZmVjdER1cmF0aW9uID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgcmV0dXJuIHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSBwcmV2RWZmZWN0RHVyYXRpb247XG4gICAgICByZXR1cm4gZWxhcHNlZFRpbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IHByb2ZpbGVyRWZmZWN0RHVyYXRpb247XG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgMCA+IGZpYmVyLmFjdHVhbFN0YXJ0VGltZSAmJiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gcHJvZmlsZXJTdGFydFRpbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbihmaWJlcikge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29yZEVmZmVjdER1cmF0aW9uKCkge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRFZmZlY3RUaW1lcigpIHtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGZvciAodmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IGNoaWxkOyApXG4gICAgICAgIChmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCkge1xuICAgICAgcm9vdCAhPT0gbGFzdFNjaGVkdWxlZFJvb3QgJiZcbiAgICAgICAgbnVsbCA9PT0gcm9vdC5uZXh0ICYmXG4gICAgICAgIChudWxsID09PSBsYXN0U2NoZWR1bGVkUm9vdFxuICAgICAgICAgID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdClcbiAgICAgICAgICA6IChsYXN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290Lm5leHQgPSByb290KSk7XG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgID8gZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0IHx8XG4gICAgICAgICAgKChkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSAhMCksXG4gICAgICAgICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaykpXG4gICAgICAgIDogZGlkU2NoZWR1bGVNaWNyb3Rhc2sgfHxcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrID0gITApLFxuICAgICAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgb25seUxlZ2FjeSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nV29yayAmJiBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmspIHtcbiAgICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBkaWRQZXJmb3JtU29tZVdvcmsgPSAhMTtcbiAgICAgICAgICBmb3IgKHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290OyBudWxsICE9PSByb290OyApIHtcbiAgICAgICAgICAgIGlmICghb25seUxlZ2FjeSlcbiAgICAgICAgICAgICAgaWYgKDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgdmFyIG5leHRMYW5lcyA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICAoMSA8PCAoMzEgLSBjbHozMig0MiB8IHN5bmNUcmFuc2l0aW9uTGFuZXMpICsgMSkpIC0gMTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmPSBwZW5kaW5nTGFuZXMgJiB+KHN1c3BlbmRlZExhbmVzICYgfnBpbmdlZExhbmVzKTtcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyAmIDIwMTMyNjY3N1xuICAgICAgICAgICAgICAgICAgICAgID8gKG5leHRMYW5lcyAmIDIwMTMyNjY3NykgfCAxXG4gICAgICAgICAgICAgICAgICAgICAgOiBuZXh0TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dExhbmVzIHwgMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAwICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICgoZGlkUGVyZm9ybVNvbWVXb3JrID0gITApLFxuICAgICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcykpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gbmV4dExhbmVzIDogMFxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAwID09PSAobmV4dExhbmVzICYgMykgfHxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBuZXh0TGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICgoZGlkUGVyZm9ybVNvbWVXb3JrID0gITApLFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbmV4dExhbmVzKSk7XG4gICAgICAgICAgICByb290ID0gcm9vdC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkUGVyZm9ybVNvbWVXb3JrKTtcbiAgICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCkge1xuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID1cbiAgICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPVxuICAgICAgICAgICExO1xuICAgICAgdmFyIHN5bmNUcmFuc2l0aW9uTGFuZXMgPSAwO1xuICAgICAgMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiZcbiAgICAgICAgKHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24oKSAmJlxuICAgICAgICAgIChzeW5jVHJhbnNpdGlvbkxhbmVzID0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpLFxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwKSk7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBub3ckMSgpLCBwcmV2ID0gbnVsbCwgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgbnVsbCAhPT0gcm9vdDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0LFxuICAgICAgICAgIG5leHRMYW5lcyA9IHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpO1xuICAgICAgICBpZiAoMCA9PT0gbmV4dExhbmVzKVxuICAgICAgICAgIChyb290Lm5leHQgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgPT09IHByZXYgPyAoZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dCkgOiAocHJldi5uZXh0ID0gbmV4dCksXG4gICAgICAgICAgICBudWxsID09PSBuZXh0ICYmIChsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXYpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoKHByZXYgPSByb290KSwgMCAhPT0gc3luY1RyYW5zaXRpb25MYW5lcyB8fCAwICE9PSAobmV4dExhbmVzICYgMykpXG4gICAgICAgIClcbiAgICAgICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMDtcbiAgICAgICAgcm9vdCA9IG5leHQ7XG4gICAgICB9XG4gICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChzeW5jVHJhbnNpdGlvbkxhbmVzLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgICAgICAgIGxhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiAtNjI5MTQ1NjE7XG4gICAgICAgIDAgPCBsYW5lcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4LFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcbiAgICAgICAgaWYgKC0xID09PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIGlmICgwID09PSAobGFuZSAmIHN1c3BlbmRlZExhbmVzKSB8fCAwICE9PSAobGFuZSAmIHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGVsc2UgZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUgJiYgKHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmUpO1xuICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRUaW1lID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgc3VzcGVuZGVkTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHN1c3BlbmRlZExhbmVzID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICByb290LFxuICAgICAgICByb290ID09PSBjdXJyZW50VGltZSA/IHN1c3BlbmRlZExhbmVzIDogMFxuICAgICAgKTtcbiAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IHN1c3BlbmRlZExhbmVzIHx8XG4gICAgICAgIChyb290ID09PSBjdXJyZW50VGltZSAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja05vZGUgPSBudWxsKSxcbiAgICAgICAgICAocm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMClcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gKHN1c3BlbmRlZExhbmVzICYgMykgfHxcbiAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBzdXNwZW5kZWRMYW5lcylcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50VGltZSA9IHN1c3BlbmRlZExhbmVzICYgLXN1c3BlbmRlZExhbmVzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudFRpbWUgIT09IHJvb3QuY2FsbGJhY2tQcmlvcml0eSB8fFxuICAgICAgICAgIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICAgICAgcGluZ2VkTGFuZXMgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSlcbiAgICAgICAgKVxuICAgICAgICAgIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgICAgZWxzZSByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkoc3VzcGVuZGVkTGFuZXMpKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgIH1cbiAgICAgICAgcGluZ2VkTGFuZXMgPSBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgICA/IChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKHBpbmdlZExhbmVzKSxcbiAgICAgICAgICAgIChzdXNwZW5kZWRMYW5lcyA9IGZha2VBY3RDYWxsYmFja05vZGUkMSkpXG4gICAgICAgICAgOiAoc3VzcGVuZGVkTGFuZXMgPSBzY2hlZHVsZUNhbGxiYWNrJDMoc3VzcGVuZGVkTGFuZXMsIHBpbmdlZExhbmVzKSk7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyk7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAyO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayhyb290LCBkaWRUaW1lb3V0KSB7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMTtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICAgICAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSAmJiByb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgOiAwXG4gICAgICApO1xuICAgICAgaWYgKDAgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwKSByZXR1cm4gbnVsbDtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KFxuICAgICAgICByb290LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgZGlkVGltZW91dFxuICAgICAgKTtcbiAgICAgIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgbm93JDEoKSk7XG4gICAgICByZXR1cm4gbnVsbCAhPSByb290LmNhbGxiYWNrTm9kZSAmJlxuICAgICAgICByb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGVcbiAgICAgICAgPyBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2suYmluZChudWxsLCByb290KVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBsYW5lcykge1xuICAgICAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7XG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMTtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSkge1xuICAgICAgY2FsbGJhY2tOb2RlICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgJiZcbiAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2tOb2RlICYmXG4gICAgICAgIGNhbmNlbENhbGxiYWNrJDEoY2FsbGJhY2tOb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJbW1lZGlhdGVUYXNrKGNiKSB7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIHN1cHBvcnRzTWljcm90YXNrc1xuICAgICAgICA/IHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dFxuICAgICAgICAgICAgICA/IHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpXG4gICAgICAgICAgICAgIDogY2IoKTtcbiAgICAgICAgICB9KVxuICAgICAgICA6IHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSB7XG4gICAgICAwID09PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgICAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpKTtcbiAgICAgIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW10pO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZW50YW5nbGVkTGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICAgICAgdGhlbmFibGUudGhlbihwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlLCBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgJiZcbiAgICAgICAgICAoY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycztcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlID0ge1xuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS52YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgKDAsIGxpc3RlbmVyc1tpXSkocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgIGZvciAoZXJyb3IgPSAwOyBlcnJvciA8IGxpc3RlbmVycy5sZW5ndGg7IGVycm9yKyspXG4gICAgICAgICAgICAoMCwgbGlzdGVuZXJzW2Vycm9yXSkodm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gICAgICBmaWJlci51cGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgICAgICBzaGFyZWQ6IHsgcGVuZGluZzogbnVsbCwgbGFuZXM6IDAsIGhpZGRlbkNhbGxiYWNrczogbnVsbCB9LFxuICAgICAgICBjYWxsYmFja3M6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudC5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGxhbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhbmU6IGxhbmUsXG4gICAgICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgICAgIHBheWxvYWQ6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHVwZGF0ZVF1ZXVlKSByZXR1cm4gbnVsbDtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHVwZGF0ZVF1ZXVlICYmXG4gICAgICAgICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCB3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSBjYWxsYmFjay5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50OiAlc1wiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoY29tcG9uZW50TmFtZSA9IHVwZGF0ZVF1ZXVlLnBlbmRpbmcpLFxuICAgICAgICAgIG51bGwgPT09IGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gY29tcG9uZW50TmFtZS5uZXh0KSxcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUubmV4dCA9IHVwZGF0ZSkpLFxuICAgICAgICAgICh1cGRhdGVRdWV1ZS5wZW5kaW5nID0gdXBkYXRlKSxcbiAgICAgICAgICAodXBkYXRlID0gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcikpLFxuICAgICAgICAgIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBudWxsLCBsYW5lKSxcbiAgICAgICAgICB1cGRhdGVcbiAgICAgICAgKTtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgdXBkYXRlUXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgICAgIGZpYmVyID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIgJiYgKChmaWJlciA9IGZpYmVyLnNoYXJlZCksIDAgIT09IChsYW5lICYgNDE5NDE3NikpKSB7XG4gICAgICAgIHZhciBxdWV1ZUxhbmVzID0gZmliZXIubGFuZXM7XG4gICAgICAgIHF1ZXVlTGFuZXMgJj0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICAgICAgZmliZXIubGFuZXMgPSBsYW5lO1xuICAgICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsXG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksIHF1ZXVlID09PSBjdXJyZW50KVxuICAgICAgKSB7XG4gICAgICAgIHZhciBuZXdGaXJzdCA9IG51bGwsXG4gICAgICAgICAgbmV3TGFzdCA9IG51bGw7XG4gICAgICAgIHF1ZXVlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gcXVldWUpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHF1ZXVlLmxhbmUsXG4gICAgICAgICAgICAgIHRhZzogcXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBxdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0xhc3RcbiAgICAgICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmUpXG4gICAgICAgICAgICAgIDogKG5ld0xhc3QgPSBuZXdMYXN0Lm5leHQgPSBjbG9uZSk7XG4gICAgICAgICAgICBxdWV1ZSA9IHF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gcXVldWUpO1xuICAgICAgICAgIG51bGwgPT09IG5ld0xhc3RcbiAgICAgICAgICAgID8gKG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlKVxuICAgICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICBxdWV1ZSA9IHtcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG4gICAgICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgICAgICBjYWxsYmFja3M6IGN1cnJlbnQuY2FsbGJhY2tzXG4gICAgICAgIH07XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICA/IChxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZSlcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSB7XG4gICAgICBpZiAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbikge1xuICAgICAgICB2YXIgZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICAgIGlmIChudWxsICE9PSBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSkgdGhyb3cgZW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcHJvcHMsXG4gICAgICBpbnN0YW5jZSRqc2NvbXAkMCxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgICAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcbiAgICAgIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWUsXG4gICAgICAgICAgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7XG4gICAgICAgIG51bGwgPT09IGxhc3RCYXNlVXBkYXRlXG4gICAgICAgICAgPyAoZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlKVxuICAgICAgICAgIDogKGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpO1xuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgIChwZW5kaW5nUXVldWUgPSBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlKSxcbiAgICAgICAgICBwZW5kaW5nUXVldWUgIT09IGxhc3RCYXNlVXBkYXRlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlKVxuICAgICAgICAgICAgICA6IChwZW5kaW5nUXVldWUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSksXG4gICAgICAgICAgICAoY3VycmVudC5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlKSkpO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IGZpcnN0QmFzZVVwZGF0ZSkge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gMDtcbiAgICAgICAgY3VycmVudCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gZmlyc3RCYXNlVXBkYXRlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUubGFuZSAmIC01MzY4NzA5MTMsXG4gICAgICAgICAgICBpc0hpZGRlblVwZGF0ZSA9IHVwZGF0ZUxhbmUgIT09IHBlbmRpbmdRdWV1ZS5sYW5lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlXG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgMCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgICAgICB1cGRhdGVMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50Lm5leHQgPVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICB1cGRhdGVMYW5lID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSBwcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlJGpzY29tcCQwO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnRpYWxTdGF0ZS50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXJ0aWFsU3RhdGUuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUxhbmUubW9kZSAmIDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZS5jYWxsKGluc3RhbmNlLCBuZXdTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITE7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBwYXJ0aWFsU3RhdGU7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUxhbmUuZmxhZ3MgPSAodXBkYXRlTGFuZS5mbGFncyAmIC02NTUzNykgfCAxMjg7XG4gICAgICAgICAgICAgICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IG5leHRTdGF0ZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlTGFuZS5tb2RlICYgOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBwYXJ0aWFsU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcGFydGlhbFN0YXRlIHx8IHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlKSBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBhc3NpZ24oe30sIG5ld1N0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHBlbmRpbmdRdWV1ZS5jYWxsYmFjaztcbiAgICAgICAgICAgIG51bGwgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NCksXG4gICAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSxcbiAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcXVldWUuY2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgICAgICA/IChxdWV1ZS5jYWxsYmFja3MgPSBbdXBkYXRlTGFuZV0pXG4gICAgICAgICAgICAgICAgOiBpc0hpZGRlblVwZGF0ZS5wdXNoKHVwZGF0ZUxhbmUpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IHBlbmRpbmdRdWV1ZS5jYWxsYmFjayxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/ICgoZmlyc3RQZW5kaW5nVXBkYXRlID0gY3VycmVudCA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgICAgIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKSlcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50ID0gY3VycmVudC5uZXh0ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAobGFzdEJhc2VVcGRhdGUgfD0gdXBkYXRlTGFuZSk7XG4gICAgICAgICAgcGVuZGluZ1F1ZXVlID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgICAgIGlmICgoKHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nKSwgbnVsbCA9PT0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHBlbmRpbmdRdWV1ZSksXG4gICAgICAgICAgICAgICAgKHBlbmRpbmdRdWV1ZSA9IGlzSGlkZGVuVXBkYXRlLm5leHQpLFxuICAgICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZS5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAgIChxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGwpO1xuICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJiAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSk7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY3VycmVudDtcbiAgICAgICAgbnVsbCA9PT0gZmlyc3RCYXNlVXBkYXRlICYmIChxdWV1ZS5zaGFyZWQubGFuZXMgPSAwKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGxhc3RCYXNlVXBkYXRlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhc3RCYXNlVXBkYXRlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogXCIgK1xuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGhpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3M7XG4gICAgICBpZiAobnVsbCAhPT0gaGlkZGVuQ2FsbGJhY2tzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBudWxsLCB1cGRhdGVRdWV1ZSA9IDA7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPCBoaWRkZW5DYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICAgICAgKVxuICAgICAgICAgIGNhbGxDYWxsYmFjayhoaWRkZW5DYWxsYmFja3NbdXBkYXRlUXVldWVdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gdXBkYXRlUXVldWUuY2FsbGJhY2tzO1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5jYWxsYmFja3MgPSBudWxsLCB1cGRhdGVRdWV1ZSA9IDA7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPCBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICAgICAgKVxuICAgICAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFja3NbdXBkYXRlUXVldWVdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgICAgIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkgcmV0dXJuICEwO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQSB8fFxuICAgICAgICBudWxsID09PSBvYmpBIHx8XG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpCIHx8XG4gICAgICAgIG51bGwgPT09IG9iakJcbiAgICAgIClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSksXG4gICAgICAgIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIGZvciAoa2V5c0IgPSAwOyBrZXlzQiA8IGtleXNBLmxlbmd0aDsga2V5c0IrKykge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2tleXNCXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8XG4gICAgICAgICAgIW9iamVjdElzKG9iakFbY3VycmVudEtleV0sIG9iakJbY3VycmVudEtleV0pXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSB7XG4gICAgICByZXR1cm4geyBkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2U6ICExLCB0aGVuYWJsZXM6IFtdIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVGhlbmFibGVSZXNvbHZlZCh0aGVuYWJsZSkge1xuICAgICAgdGhlbmFibGUgPSB0aGVuYWJsZS5zdGF0dXM7XG4gICAgICByZXR1cm4gXCJmdWxmaWxsZWRcIiA9PT0gdGhlbmFibGUgfHwgXCJyZWplY3RlZFwiID09PSB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCQxKCkge31cbiAgICBmdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITApO1xuICAgICAgdmFyIHRyYWNrZWRUaGVuYWJsZXMgPSB0aGVuYWJsZVN0YXRlLnRoZW5hYmxlcztcbiAgICAgIGluZGV4ID0gdHJhY2tlZFRoZW5hYmxlc1tpbmRleF07XG4gICAgICB2b2lkIDAgPT09IGluZGV4XG4gICAgICAgID8gdHJhY2tlZFRoZW5hYmxlcy5wdXNoKHRoZW5hYmxlKVxuICAgICAgICA6IGluZGV4ICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICh0aGVuYWJsZVN0YXRlLmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSB8fFxuICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlLmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQSBjb21wb25lbnQgd2FzIHN1c3BlbmRlZCBieSBhbiB1bmNhY2hlZCBwcm9taXNlLiBDcmVhdGluZyBwcm9taXNlcyBpbnNpZGUgYSBDbGllbnQgQ29tcG9uZW50IG9yIGhvb2sgaXMgbm90IHlldCBzdXBwb3J0ZWQsIGV4Y2VwdCB2aWEgYSBTdXNwZW5zZS1jb21wYXRpYmxlIGxpYnJhcnkgb3IgZnJhbWV3b3JrLlwiXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKSxcbiAgICAgICAgICAodGhlbmFibGUgPSBpbmRleCkpO1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uKSxcbiAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHRoZW5hYmxlU3RhdGUpLFxuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdGhlbmFibGUuc3RhdHVzKVxuICAgICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmXG4gICAgICAgICAgICAgIDEwMCA8IHRoZW5hYmxlU3RhdGUuc2hlbGxTdXNwZW5kQ291bnRlclxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImFzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5IFNlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUucmVhc29uKSxcbiAgICAgICAgICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCh0aGVuYWJsZVN0YXRlKSxcbiAgICAgICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITA7XG4gICAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFRoZW5hYmxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChyZWplY3RlZFJlYXNvbikge1xuICAgICAgaWYgKHJlamVjdGVkUmVhc29uID09PSBTdXNwZW5zZUV4Y2VwdGlvbilcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJIb29rcyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUgYW4gYXN5bmMgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRGVidWdJbmZvKGRlYnVnSW5mbykge1xuICAgICAgdmFyIHByZXZpb3VzRGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgIG51bGwgIT0gZGVidWdJbmZvICYmXG4gICAgICAgIChjdXJyZW50RGVidWdJbmZvID1cbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c0RlYnVnSW5mb1xuICAgICAgICAgICAgPyBkZWJ1Z0luZm9cbiAgICAgICAgICAgIDogcHJldmlvdXNEZWJ1Z0luZm8uY29uY2F0KGRlYnVnSW5mbykpO1xuICAgICAgcmV0dXJuIHByZXZpb3VzRGVidWdJbmZvO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgZmliZXIsIHJldHVybkZpYmVyKSB7XG4gICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5wcm9wcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKFwiY2hpbGRyZW5cIiAhPT0ga2V5ICYmIFwia2V5XCIgIT09IGtleSkge1xuICAgICAgICAgIG51bGwgPT09IGZpYmVyICYmXG4gICAgICAgICAgICAoKGZpYmVyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCAwKSksXG4gICAgICAgICAgICAoZmliZXIuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgKGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcmVkS2V5KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLFxuICAgICAgICAgICAgICAgIGVycm9yZWRLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlciQxO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSQxICYmICh0aGVuYWJsZVN0YXRlJDEgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCkpO1xuICAgICAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUkMSwgdGhlbmFibGUsIGluZGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlUmVmKHdvcmtJblByb2dyZXNzLCBlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wcm9wcy5yZWY7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSB2b2lkIDAgIT09IGVsZW1lbnQgPyBlbGVtZW50IDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnQSBSZWFjdCBFbGVtZW50IGZyb20gYW4gb2xkZXIgdmVyc2lvbiBvZiBSZWFjdCB3YXMgcmVuZGVyZWQuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSXQgY2FuIGhhcHBlbiBpZjpcXG4tIE11bHRpcGxlIGNvcGllcyBvZiB0aGUgXCJyZWFjdFwiIHBhY2thZ2UgaXMgdXNlZC5cXG4tIEEgbGlicmFyeSBwcmUtYnVuZGxlZCBhbiBvbGQgY29weSBvZiBcInJlYWN0XCIgb3IgXCJyZWFjdC9qc3gtcnVudGltZVwiLlxcbi0gQSBjb21waWxlciB0cmllcyB0byBcImlubGluZVwiIEpTWCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBydW50aW1lLidcbiAgICAgICAgKTtcbiAgICAgIHJldHVybkZpYmVyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgK1xuICAgICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICA6IHJldHVybkZpYmVyKSArXG4gICAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gfHxcbiAgICAgICAgKChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSAhMCksXG4gICAgICAgIChpbnZhbGlkQ2hpbGQgPVxuICAgICAgICAgIGludmFsaWRDaGlsZC5kaXNwbGF5TmFtZSB8fCBpbnZhbGlkQ2hpbGQubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgMyA9PT0gcmV0dXJuRmliZXIudGFnXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4gIHJvb3QucmVuZGVyKCVzKVwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4gIDwlcz57JXN9PC8lcz5cIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSB8fFxuICAgICAgICAoKG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSAhMCksXG4gICAgICAgIChpbnZhbGlkQ2hpbGQgPSBTdHJpbmcoaW52YWxpZENoaWxkKSksXG4gICAgICAgIDMgPT09IHJldHVybkZpYmVyLnRhZ1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gIHJvb3QucmVuZGVyKCVzKVwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuICA8JXM+JXM8LyVzPlwiLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuICAgICAgICAgIG51bGwgPT09IGRlbGV0aW9uc1xuICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgICA6IGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgICAgIGZvciAodmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQua2V5XG4gICAgICAgICAgICA/IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmtleSwgY3VycmVudEZpcnN0Q2hpbGQpXG4gICAgICAgICAgICA6IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmluZGV4LCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgICAgIGZpYmVyID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcyk7XG4gICAgICAgIGZpYmVyLmluZGV4ID0gMDtcbiAgICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICAgICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKVxuICAgICAgICAgIHJldHVybiAobmV3RmliZXIuZmxhZ3MgfD0gMTA0ODU3NiksIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgICAgbmV3SW5kZXggPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXdJbmRleClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5ld0luZGV4ID0gbmV3SW5kZXguaW5kZXgpLFxuICAgICAgICAgICAgbmV3SW5kZXggPCBsYXN0UGxhY2VkSW5kZXhcbiAgICAgICAgICAgICAgPyAoKG5ld0ZpYmVyLmZsYWdzIHw9IDMzNTU0NDM0KSwgbGFzdFBsYWNlZEluZGV4KVxuICAgICAgICAgICAgICA6IG5ld0luZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpO1xuICAgICAgICByZXR1cm4gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDYgIT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGVsZW1lbnQua2V5XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBjdXJyZW50LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoY3VycmVudC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHxcbiAgICAgICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSB8fFxuICAgICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgICAgICBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIGNhbGxMYXp5SW5pdEluREVWKGVsZW1lbnRUeXBlKSA9PT0gY3VycmVudC50eXBlKSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMpKSxcbiAgICAgICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgICAgY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBsYW5lcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgIDQgIT09IGN1cnJlbnQudGFnIHx8XG4gICAgICAgICAgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHxcbiAgICAgICAgICBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcykpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSkge1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA3ICE9PSBjdXJyZW50LnRhZylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgICAgIFwiXCIgKyBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgX3ByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBjcmVhdGVDaGlsZChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBrZXkgPSBudWxsICE9PSBvbGRGaWJlciA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIG51bGwgIT09IGtleVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgXCJcIiArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkLmtleSA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyAoKGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBrZXkpLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkLmtleSA9PT0ga2V5XG4gICAgICAgICAgICAgICAgPyB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBrZXkpLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBrZXkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAga2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IGtleTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBuZXdJZHgsXG4gICAgICAgIG5ld0NoaWxkLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsKSxcbiAgICAgICAgICAgIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3SWR4ID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBleGlzdGluZ0NoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmdldChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICApIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbzc7XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChuZXdJZHggPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBleGlzdGluZ0NoaWxkcmVuKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoX3ByZXZEZWJ1Z0luZm83ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cykge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNoaWxkIHx8IG51bGwgPT09IGNoaWxkKSByZXR1cm4ga25vd25LZXlzO1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2Yga2V5KSBicmVhaztcbiAgICAgICAgICAgIGlmIChudWxsID09PSBrbm93bktleXMpIHtcbiAgICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKHdvcmtJblByb2dyZXNzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuIEtleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCBcXHUyMDE0IHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uXCIsXG4gICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgKGNoaWxkID0gY2FsbExhenlJbml0SW5ERVYoY2hpbGQpKSxcbiAgICAgICAgICAgICAgd2Fybk9uSW52YWxpZEtleShyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGwsXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBudWxsLFxuICAgICAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICAgICAgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgbmV3SWR4KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICAgICAgOiAobmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZyk7XG4gICAgICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKSxcbiAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KSxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gb2xkRmliZXIpIHtcbiAgICAgICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKylcbiAgICAgICAgICAgIChvbGRGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcykpLFxuICAgICAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJlxuICAgICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gb2xkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBvbGRGaWJlciksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG9sZEZpYmVyID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpO1xuICAgICAgICAgIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKG51bGwgPT0gbmV3Q2hpbGRyZW4pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuXCIpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBudWxsLFxuICAgICAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeCA9IChjdXJyZW50Rmlyc3RDaGlsZCA9IDApLFxuICAgICAgICAgICAgbmV4dE9sZEZpYmVyID0gbnVsbCxcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG51bGwsXG4gICAgICAgICAgICBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmICFzdGVwLmRvbmU7XG4gICAgICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICAgICAgOiAobmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZyk7XG4gICAgICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV3RmliZXIpIHtcbiAgICAgICAgICAgIG51bGwgPT09IG9sZEZpYmVyICYmIChvbGRGaWJlciA9IG5leHRPbGRGaWJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3RmliZXIsXG4gICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBvbGRGaWJlciAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChuZXdGaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCk7XG4gICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyKVxuICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXIpO1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RlcC5kb25lKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSlcbiAgICAgICAgICAgIChvbGRGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcykpLFxuICAgICAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJlxuICAgICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gb2xkRmliZXIpXG4gICAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBvbGRGaWJlciksXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG9sZEZpYmVyID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpO1xuICAgICAgICAgICFzdGVwLmRvbmU7XG4gICAgICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICAgICAgKVxuICAgICAgICAgIChuZXh0T2xkRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgb2xkRmliZXIuZGVsZXRlKFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV4dE9sZEZpYmVyLmtleSA/IG5ld0lkeCA6IG5leHRPbGRGaWJlci5rZXlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV4dE9sZEZpYmVyKVxuICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5leHRPbGRGaWJlciksXG4gICAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gbmV4dE9sZEZpYmVyKSk7XG4gICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICBvbGRGaWJlci5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgbnVsbCAhPT0gbmV3Q2hpbGQgJiZcbiAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmXG4gICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ICYmXG4gICAgICAgICAgKHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbnVsbCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgIChuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5ID0gbmV3Q2hpbGQua2V5OyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV3Q2hpbGQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICg3ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMuX2RlYnVnT3duZXIgPSBuZXdDaGlsZC5fb3duZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbGFuZXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5lbGVtZW50VHlwZSA9PT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGtleSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0ga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbExhenlJbml0SW5ERVYoa2V5KSA9PT0gY3VycmVudEZpcnN0Q2hpbGQudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgICAgICA6ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybkZpYmVyID0gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IHByZXZEZWJ1Z0luZm8ua2V5O1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IG5ld0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgNCA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnICYmXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmNvbnRhaW5lckluZm8gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyA9IHVzZUZpYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLmNoaWxkcmVuIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCkpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGtleSA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGtleSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBrZXkuY2FsbChuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGRyZW4gPT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAwICE9PSByZXR1cm5GaWJlci50YWcgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmV0dXJuRmliZXIudHlwZSkgfHxcbiAgICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yXVwiICE9PVxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkcmVuKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyB8fFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJVc2luZyBJdGVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkIHVuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuIFlvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSBgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIFlvdSBjYW4gYWxzbyB1c2UgYW4gSXRlcmFibGUgdGhhdCBjYW4gaXRlcmF0ZSBtdWx0aXBsZSB0aW1lcyBvdmVyIHRoZSBzYW1lIGl0ZW1zLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAhMCk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbmV3Q2hpbGQuZW50cmllcyAhPT0ga2V5IHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0TWFwcyB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRNYXBzID0gITApKTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbztcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IFwiXCIgKyBuZXdDaGlsZCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZCAmJiA2ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWdcbiAgICAgICAgICAgICAgPyAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCBwcmV2RGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgIDogKGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSksXG4gICAgICAgICAgICBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuICAgICAgICAgIHZhciBmaXJzdENoaWxkRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZEZpYmVyO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgaWYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB0aHJvdyB4O1xuICAgICAgICAgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKDI5LCB4LCBudWxsLCByZXR1cm5GaWJlci5tb2RlKTtcbiAgICAgICAgICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICAgICAgICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSAoZmliZXIuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pO1xuICAgICAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgICAgaWYgKG51bGwgIT0gZGVidWdJbmZvKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSlcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkZWJ1Z0luZm9baV0uc3RhY2spIHtcbiAgICAgICAgICAgICAgICBmaWJlci5fZGVidWdPd25lciA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhpZGRlbkNvbnRleHQoZmliZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgPSBlbnRhbmdsZWRSZW5kZXJMYW5lcztcbiAgICAgIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgICAgIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgfCBjb250ZXh0LmJhc2VMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayhmaWJlcikge1xuICAgICAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGVudGFuZ2xlZFJlbmRlckxhbmVzLCBmaWJlcik7XG4gICAgICBwdXNoKFxuICAgICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLFxuICAgICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgIGZpYmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIaWRkZW5Db250ZXh0KGZpYmVyKSB7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvci5jdXJyZW50O1xuICAgICAgcG9wKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaGFuZGxlci5hbHRlcm5hdGU7XG4gICAgICBwdXNoKFxuICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLFxuICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayxcbiAgICAgICAgaGFuZGxlclxuICAgICAgKTtcbiAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGhhbmRsZXIsIGhhbmRsZXIpO1xuICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeSAmJlxuICAgICAgICAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsICE9PSBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICA/IChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcilcbiAgICAgICAgICA6IG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJiAoc2hlbGxCb3VuZGFyeSA9IGhhbmRsZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICAgICAgaWYgKDIyID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpLFxuICAgICAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlciksXG4gICAgICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoc2hlbGxCb3VuZGFyeSA9IGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcikge1xuICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKTtcbiAgICAgIHB1c2goXG4gICAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLFxuICAgICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50LFxuICAgICAgICBmaWJlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gICAgICBwb3Aoc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHNoZWxsQm91bmRhcnkgPT09IGZpYmVyICYmIChzaGVsbEJvdW5kYXJ5ID0gbnVsbCk7XG4gICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gcm93OyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgaWYgKDEzID09PSBub2RlLnRhZykge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBzdGF0ZSAmJlxuICAgICAgICAgICAgKChzdGF0ZSA9IHN0YXRlLmRlaHlkcmF0ZWQpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc3RhdGUgfHxcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhzdGF0ZSkgfHxcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3RhdGUpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIDE5ID09PSBub2RlLnRhZyAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICgwICE9PSAobm9kZS5mbGFncyAmIDEyOCkpIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKG51bGwgIT09IG5vZGUuY2hpbGQpIHtcbiAgICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHJvdykgYnJlYWs7XG4gICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gcm93KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9va1R5cGVzRGV2KCkge1xuICAgICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG4gICAgICBudWxsID09PSBob29rVHlwZXNEZXZcbiAgICAgICAgPyAoaG9va1R5cGVzRGV2ID0gW2hvb2tOYW1lXSlcbiAgICAgICAgOiBob29rVHlwZXNEZXYucHVzaChob29rTmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0RldigpIHtcbiAgICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBob29rVHlwZXNEZXYgJiZcbiAgICAgICAgKGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2KyssXG4gICAgICAgIGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0gIT09IGhvb2tOYW1lKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICAgIG51bGwgIT09IGhvb2tUeXBlc0RldilcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yICh2YXIgdGFibGUgPSBcIlwiLCBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2xkSG9va05hbWUgPSBob29rVHlwZXNEZXZbaV0sXG4gICAgICAgICAgICAgIG5ld0hvb2tOYW1lID1cbiAgICAgICAgICAgICAgICBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBvbGRIb29rTmFtZSA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7XG4gICAgICAgICAgICAgIDMwID4gb2xkSG9va05hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIG9sZEhvb2tOYW1lICs9IFwiIFwiO1xuICAgICAgICAgICAgb2xkSG9va05hbWUgKz0gbmV3SG9va05hbWUgKyBcIlxcblwiO1xuICAgICAgICAgICAgdGFibGUgKz0gb2xkSG9va05hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiBUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4gICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiVzICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuXCIsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcbiAgICAgIHZvaWQgMCA9PT0gZGVwcyB8fFxuICAgICAgICBudWxsID09PSBkZXBzIHx8XG4gICAgICAgIGlzQXJyYXlJbXBsKGRlcHMpIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCIlcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiBzcGVjaWZpZWQsIHRoZSBmaW5hbCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LlwiLFxuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICAgIHR5cGVvZiBkZXBzXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICAgICAgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmhhcyhjb21wb25lbnROYW1lKSB8fFxuICAgICAgICAoZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlLmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0RE9NLnVzZUZvcm1TdGF0ZSBoYXMgYmVlbiByZW5hbWVkIHRvIFJlYWN0LnVzZUFjdGlvblN0YXRlLiBQbGVhc2UgdXBkYXRlICVzIHRvIHVzZSBSZWFjdC51c2VBY3Rpb25TdGF0ZS5cIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykgcmV0dXJuICExO1xuICAgICAgaWYgKG51bGwgPT09IHByZXZEZXBzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGl0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLlwiLFxuICAgICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXZcbiAgICAgICAgICApLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICBuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG5QcmV2aW91czogJXNcXG5JbmNvbWluZzogJXNcIixcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICBcIltcIiArIHByZXZEZXBzLmpvaW4oXCIsIFwiKSArIFwiXVwiLFxuICAgICAgICAgIFwiW1wiICsgbmV4dERlcHMuam9pbihcIiwgXCIpICsgXCJdXCJcbiAgICAgICAgKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHByb3BzLFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgbmV4dFJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIGlmIChcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudCkgfHxcbiAgICAgICAgXCJbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dXCIgPT09XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudClcbiAgICAgIClcbiAgICAgICAgKG5leHRSZW5kZXJMYW5lcyA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgICApKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMobmV4dFJlbmRlckxhbmVzKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50LmFkZChuZXh0UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJhc3luYy9hd2FpdCBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50cywgb25seSBTZXJ2ZXIgQ29tcG9uZW50cy4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDA7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgICA6IG51bGwgIT09IGhvb2tUeXBlc0RldlxuICAgICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWXG4gICAgICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gbmV4dFJlbmRlckxhbmVzID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSAhPT0gTm9Nb2RlO1xuICAgICAgdmFyIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmXG4gICAgICAgIChjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzZWNvbmRBcmdcbiAgICAgICAgKSk7XG4gICAgICBpZiAobmV4dFJlbmRlckxhbmVzKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHNlY29uZEFyZ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXNcbiAgICAgICAgPyBudWxsICE9PSB0aGVuYWJsZVN0YXRlICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgICAgZmlyc3RDb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogdGhlbmFibGVTdGF0ZVxuICAgICAgICAgIH0pXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcy5fZGVidWdUaGVuYWJsZVN0YXRlID0gdGhlbmFibGVTdGF0ZSk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiYgbnVsbCAhPT0gY3VycmVudEhvb2submV4dDtcbiAgICAgIHJlbmRlckxhbmVzID0gMDtcbiAgICAgIGhvb2tUeXBlc0RldiA9XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgY3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID1cbiAgICAgICAgICBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MCkgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDMxNDU3MjgwKSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHN0YXRpYyBmbGFnIHdhcyBtaXNzaW5nLiBQbGVhc2Ugbm90aWZ5IHRoZSBSZWFjdCB0ZWFtLlwiXG4gICAgICAgICk7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICAgIGlmIChkaWRSZW5kZXJUb29GZXdIb29rcylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCBlYXJseSByZXR1cm4gc3RhdGVtZW50LlwiXG4gICAgICAgICk7XG4gICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHxcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQpICYmXG4gICAgICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCkpO1xuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVZcbiAgICAgICAgPyAoKG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITEpLCAoY3VycmVudCA9ICEwKSlcbiAgICAgICAgOiAoY3VycmVudCA9ICExKTtcbiAgICAgIGN1cnJlbnQgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKHdvcmtJblByb2dyZXNzKSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImB1c2VgIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSB0cnkvY2F0Y2ggYmxvY2suIFRoaXMgaXMgbm90IGFsbG93ZWQgYW5kIGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFRvIGhhbmRsZSBlcnJvcnMgdHJpZ2dlcmVkIGJ5IGB1c2VgLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGEgZXJyb3IgYm91bmRhcnkuXCJcbiAgICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJiAodGhlbmFibGVTdGF0ZSA9IG51bGwpO1xuICAgICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgICAgICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG4gICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gITE7XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBjaGlsZHJlbi5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICBjaGlsZHJlbi5ldmVudHMgPSBudWxsO1xuICAgICAgICAgIGNoaWxkcmVuLnN0b3JlcyA9IG51bGw7XG4gICAgICAgICAgbnVsbCAhPSBjaGlsZHJlbi5tZW1vQ2FjaGUgJiYgKGNoaWxkcmVuLm1lbW9DYWNoZS5pbmRleCA9IDApO1xuICAgICAgICB9XG4gICAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5ILFxuICAgICAgICBtYXliZVRoZW5hYmxlID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgbWF5YmVUaGVuYWJsZSA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG1heWJlVGhlbmFibGUudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUobWF5YmVUaGVuYWJsZSlcbiAgICAgICAgICA6IG1heWJlVGhlbmFibGU7XG4gICAgICBkaXNwYXRjaGVyID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpWzBdO1xuICAgICAgKG51bGwgIT09IGN1cnJlbnRIb29rID8gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSA6IG51bGwpICE9PVxuICAgICAgICBkaXNwYXRjaGVyICYmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IDEwMjQpO1xuICAgICAgcmV0dXJuIG1heWJlVGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAgICAgdmFyIGRpZFJlbmRlcklkSG9vayA9IDAgIT09IGxvY2FsSWRDb3VudGVyO1xuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPVxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlXG4gICAgICAgICAgPyB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC0yMDEzMjg2NDVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTIwNTM7XG4gICAgICBjdXJyZW50LmxhbmVzICY9IH5sYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRIb29rc09uVW53aW5kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy5xdWV1ZTtcbiAgICAgICAgICBudWxsICE9PSBxdWV1ZSAmJiAocXVldWUucGVuZGluZyA9IG51bGwpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITE7XG4gICAgICB9XG4gICAgICByZW5kZXJMYW5lcyA9IDA7XG4gICAgICBob29rVHlwZXNEZXYgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBjdXJyZW50SG9vayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPVxuICAgICAgICAgIG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIHZhciBob29rID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgICAgICBiYXNlU3RhdGU6IG51bGwsXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50SG9vaykge1xuICAgICAgICB2YXIgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG4gICAgICAgIG5leHRDdXJyZW50SG9vayA9XG4gICAgICAgICAgbnVsbCAhPT0gbmV4dEN1cnJlbnRIb29rID8gbmV4dEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgfSBlbHNlIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICAgIGlmIChudWxsICE9PSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKVxuICAgICAgICAod29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vayksXG4gICAgICAgICAgKGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAobnVsbCA9PT0gbmV4dEN1cnJlbnRIb29rKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVXBkYXRlIGhvb2sgY2FsbGVkIG9uIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgICAgICBuZXh0Q3VycmVudEhvb2sgPSB7XG4gICAgICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICAgICAgICBuZXh0Q3VycmVudEhvb2spXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXh0Q3VycmVudEhvb2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCkpO1xuICAgICAgdGhlbmFibGUgPSB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgICAgaW5kZXggPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgbnVsbCA9PT1cbiAgICAgICAgKG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQpICYmXG4gICAgICAgICgoaW5kZXggPSBpbmRleC5hbHRlcm5hdGUpLFxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICAgICAgbnVsbCAhPT0gaW5kZXggJiYgbnVsbCAhPT0gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWXG4gICAgICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVikpO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gICAgICBpZiAobnVsbCAhPT0gdXNhYmxlICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1c2FibGUpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKSByZXR1cm4gdXNlVGhlbmFibGUodXNhYmxlKTtcbiAgICAgICAgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSByZXR1cm4gcmVhZENvbnRleHQodXNhYmxlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiBcIiArIFN0cmluZyh1c2FibGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTWVtb0NhY2hlKHNpemUpIHtcbiAgICAgIHZhciBtZW1vQ2FjaGUgPSBudWxsLFxuICAgICAgICB1cGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsICE9PSB1cGRhdGVRdWV1ZSAmJiAobWVtb0NhY2hlID0gdXBkYXRlUXVldWUubWVtb0NhY2hlKTtcbiAgICAgIGlmIChudWxsID09IG1lbW9DYWNoZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5tZW1vQ2FjaGUpLFxuICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIChtZW1vQ2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogY3VycmVudC5kYXRhLm1hcChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICBudWxsID09IG1lbW9DYWNoZSAmJiAobWVtb0NhY2hlID0geyBkYXRhOiBbXSwgaW5kZXg6IDAgfSk7XG4gICAgICBudWxsID09PSB1cGRhdGVRdWV1ZSAmJlxuICAgICAgICAoKHVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZSkpO1xuICAgICAgdXBkYXRlUXVldWUubWVtb0NhY2hlID0gbWVtb0NhY2hlO1xuICAgICAgdXBkYXRlUXVldWUgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdXBkYXRlUXVldWUgfHwgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdID0gQXJyYXkoc2l6ZSksXG4gICAgICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgICAgICBjdXJyZW50IDwgc2l6ZTtcbiAgICAgICAgICBjdXJyZW50KytcbiAgICAgICAgKVxuICAgICAgICAgIHVwZGF0ZVF1ZXVlW2N1cnJlbnRdID0gUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTDtcbiAgICAgIGVsc2VcbiAgICAgICAgdXBkYXRlUXVldWUubGVuZ3RoICE9PSBzaXplICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSBjb25zdGFudCBzaXplIGFyZ3VtZW50IGZvciBlYWNoIGludm9jYXRpb24gb2YgdXNlTWVtb0NhY2hlLiBUaGUgcHJldmlvdXMgY2FjaGUgd2FzIGFsbG9jYXRlZCB3aXRoIHNpemUgJXMgYnV0IHNpemUgJXMgd2FzIHJlcXVlc3RlZC5cIixcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgIHNpemVcbiAgICAgICAgICApO1xuICAgICAgbWVtb0NhY2hlLmluZGV4Kys7XG4gICAgICByZXR1cm4gdXBkYXRlUXVldWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb24gPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gaW5pdCkge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaW5pdGlhbFN0YXRlID0gaW5pdGlhbEFyZztcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgcmVkdWNlciA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gICAgICB9O1xuICAgICAgaG9vay5xdWV1ZSA9IHJlZHVjZXI7XG4gICAgICByZWR1Y2VyID0gcmVkdWNlci5kaXNwYXRjaCA9IGRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICByZWR1Y2VyXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHJlZHVjZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlZHVjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50LCByZWR1Y2VyKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHF1ZXVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsKVwiXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHZhciBiYXNlUXVldWUgPSBob29rLmJhc2VRdWV1ZSxcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcbiAgICAgIGlmIChudWxsICE9PSBwZW5kaW5nUXVldWUpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgICAgIHBlbmRpbmdRdWV1ZS5uZXh0ID0gYmFzZUZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcGVuZGluZ1F1ZXVlID0gaG9vay5iYXNlU3RhdGU7XG4gICAgICBpZiAobnVsbCA9PT0gYmFzZVF1ZXVlKSBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSAoYmFzZUZpcnN0ID0gbnVsbCksXG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG51bGwsXG4gICAgICAgICAgdXBkYXRlID0gY3VycmVudCxcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lICYgLTUzNjg3MDkxMztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZVxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByZXZlcnRMYW5lID0gdXBkYXRlLnJldmVydExhbmU7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcmV2ZXJ0TGFuZSlcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3QmFzZVF1ZXVlTGFzdCAmJlxuICAgICAgICAgICAgICAgIChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID1cbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKChyZW5kZXJMYW5lcyAmIHJldmVydExhbmUpID09PSByZXZlcnRMYW5lKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICAgICAgICByZXZlcnRMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAodXBkYXRlTGFuZSA9IHtcbiAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSByZXZlcnRMYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgJiZcbiAgICAgICAgICAgICAgcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlID0gdXBkYXRlLmhhc0VhZ2VyU3RhdGVcbiAgICAgICAgICAgICAgPyB1cGRhdGUuZWFnZXJTdGF0ZVxuICAgICAgICAgICAgICA6IHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChyZXZlcnRMYW5lID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB1cGRhdGVMYW5lKTtcbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobnVsbCAhPT0gdXBkYXRlICYmIHVwZGF0ZSAhPT0gY3VycmVudCk7XG4gICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICA/IChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpXG4gICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gbmV3QmFzZVF1ZXVlRmlyc3QpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIW9iamVjdElzKHBlbmRpbmdRdWV1ZSwgaG9vay5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICgoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uICYmXG4gICAgICAgICAgICAoKHJlZHVjZXIgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUpLCBudWxsICE9PSByZWR1Y2VyKSlcbiAgICAgICAgKVxuICAgICAgICAgIHRocm93IHJlZHVjZXI7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgaG9vay5iYXNlU3RhdGUgPSBiYXNlRmlyc3Q7XG4gICAgICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICAgICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICB9XG4gICAgICBudWxsID09PSBiYXNlUXVldWUgJiYgKHF1ZXVlLmxhbmVzID0gMCk7XG4gICAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcXVldWUuZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgcXVldWUgPSBob29rLnF1ZXVlO1xuICAgICAgaWYgKG51bGwgPT09IHF1ZXVlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsKVwiXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoLFxuICAgICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nLFxuICAgICAgICBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHZhciB1cGRhdGUgPSAobGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQpO1xuICAgICAgICBkb1xuICAgICAgICAgIChuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIHVwZGF0ZS5hY3Rpb24pKSwgKHVwZGF0ZSA9IHVwZGF0ZS5uZXh0KTtcbiAgICAgICAgd2hpbGUgKHVwZGF0ZSAhPT0gbGFzdFJlbmRlclBoYXNlVXBkYXRlKTtcbiAgICAgICAgb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBudWxsID09PSBob29rLmJhc2VRdWV1ZSAmJiAoaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZSk7XG4gICAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICB2YXIgbmV4dFNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgfHxcbiAgICAgICAgICBuZXh0U25hcHNob3QgPT09IGdldFNlcnZlclNuYXBzaG90KCkgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IHx8XG4gICAgICAgICAgKChnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCkpLFxuICAgICAgICAgIG9iamVjdElzKG5leHRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHx8XG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKSk7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSB7IHZhbHVlOiBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9O1xuICAgICAgaG9vay5xdWV1ZSA9IGdldFNlcnZlclNuYXBzaG90O1xuICAgICAgbW91bnRFZmZlY3QoXG4gICAgICAgIHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgZ2V0U2VydmVyU25hcHNob3QsIHN1YnNjcmliZSksXG4gICAgICAgIFtzdWJzY3JpYmVdXG4gICAgICApO1xuICAgICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgIG5leHRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgICApLFxuICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgKSB7XG4gICAgICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwID0gaXNIeWRyYXRpbmc7XG4gICAgICBpZiAoaXNIeWRyYXRpbmckanNjb21wJDApIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk1pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICgoZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpKSwgIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG4gICAgICAgIG9iamVjdElzKGdldFNlcnZlclNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkgfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gITApKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKGNhY2hlZFNuYXBzaG90ID0gIW9iamVjdElzKFxuICAgICAgICAgIChjdXJyZW50SG9vayB8fCBob29rKS5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICkpXG4gICAgICApXG4gICAgICAgIChob29rLm1lbW9pemVkU3RhdGUgPSBnZXRTZXJ2ZXJTbmFwc2hvdCksIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgaG9vayA9IGhvb2sucXVldWU7XG4gICAgICB2YXIgY3JlYXRlID0gc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBob29rLCBzdWJzY3JpYmUpO1xuICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIFtzdWJzY3JpYmVdKTtcbiAgICAgIGlmIChcbiAgICAgICAgaG9vay5nZXRTbmFwc2hvdCAhPT0gZ2V0U25hcHNob3QgfHxcbiAgICAgICAgY2FjaGVkU25hcHNob3QgfHxcbiAgICAgICAgKG51bGwgIT09IHdvcmtJblByb2dyZXNzSG9vayAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyAmIEhhc0VmZmVjdClcbiAgICAgICkge1xuICAgICAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgICAgICBwdXNoRWZmZWN0KFxuICAgICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgaG9vayxcbiAgICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgICAgICAgZ2V0U25hcHNob3RcbiAgICAgICAgICApLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpc0h5ZHJhdGluZyRqc2NvbXAkMCB8fFxuICAgICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCByZW5kZXJlZFNuYXBzaG90KSB7XG4gICAgICBmaWJlci5mbGFncyB8PSAxNjM4NDtcbiAgICAgIGZpYmVyID0geyBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsIHZhbHVlOiByZW5kZXJlZFNuYXBzaG90IH07XG4gICAgICBnZXRTbmFwc2hvdCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBnZXRTbmFwc2hvdFxuICAgICAgICA/ICgoZ2V0U25hcHNob3QgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gZ2V0U25hcHNob3QpLFxuICAgICAgICAgIChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKSlcbiAgICAgICAgOiAoKHJlbmRlcmVkU25hcHNob3QgPSBnZXRTbmFwc2hvdC5zdG9yZXMpLFxuICAgICAgICAgIG51bGwgPT09IHJlbmRlcmVkU25hcHNob3RcbiAgICAgICAgICAgID8gKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pXG4gICAgICAgICAgICA6IHJlbmRlcmVkU25hcHNob3QucHVzaChmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gICAgICBpbnN0LnZhbHVlID0gbmV4dFNuYXBzaG90O1xuICAgICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90O1xuICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb1N0b3JlKGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gICAgICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICAgICAgaW5zdCA9IGluc3QudmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICAgICAgcmV0dXJuICFvYmplY3RJcyhpbnN0LCBuZXh0VmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGVJbml0aWFsaXplciA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIGhvb2sucXVldWUgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSk7XG4gICAgICB2YXIgcXVldWUgPSBpbml0aWFsU3RhdGUucXVldWUsXG4gICAgICAgIGRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgICBxdWV1ZVxuICAgICAgICApO1xuICAgICAgcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgdmFyIHF1ZXVlID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBudWxsXG4gICAgICB9O1xuICAgICAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgaG9vayA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgICEwLFxuICAgICAgICBxdWV1ZVxuICAgICAgKTtcbiAgICAgIHF1ZXVlLmRpc3BhdGNoID0gaG9vaztcbiAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2tdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnQsIHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vayxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVkdWNlciA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRIb29rKVxuICAgICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rLnF1ZXVlLmRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBzZXRQZW5kaW5nU3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHBheWxvYWRcbiAgICApIHtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIGZvcm0gc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgIGZpYmVyID0gYWN0aW9uUXVldWUuYWN0aW9uO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgIHZhciBhY3Rpb25Ob2RlID0ge1xuICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgYWN0aW9uOiBmaWJlcixcbiAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgIGlzVHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGFjdGlvbk5vZGUubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVFxuICAgICAgICAgID8gc2V0UGVuZGluZ1N0YXRlKCEwKVxuICAgICAgICAgIDogKGFjdGlvbk5vZGUuaXNUcmFuc2l0aW9uID0gITEpO1xuICAgICAgICBzZXRTdGF0ZShhY3Rpb25Ob2RlKTtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgICAgbnVsbCA9PT0gc2V0UGVuZGluZ1N0YXRlXG4gICAgICAgICAgPyAoKGFjdGlvbk5vZGUubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBhY3Rpb25Ob2RlKSxcbiAgICAgICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlKSlcbiAgICAgICAgICA6ICgoYWN0aW9uTm9kZS5uZXh0ID0gc2V0UGVuZGluZ1N0YXRlLm5leHQpLFxuICAgICAgICAgICAgKGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCA9IGFjdGlvbk5vZGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5vZGUpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBub2RlLmFjdGlvbixcbiAgICAgICAgcGF5bG9hZCA9IG5vZGUucGF5bG9hZCxcbiAgICAgICAgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGU7XG4gICAgICBpZiAobm9kZS5pc1RyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQuX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCksXG4gICAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2VHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgICAoKGFjdGlvblF1ZXVlID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCksXG4gICAgICAgICAgICAgIDEwIDwgYWN0aW9uUXVldWUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIChjdXJyZW50VHJhbnNpdGlvbiA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpKSxcbiAgICAgICAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCBjdXJyZW50VHJhbnNpdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yJDIpIHtcbiAgICAgICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvciQyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpIHtcbiAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICAgICAgPyAocmV0dXJuVmFsdWUudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG4gICAgICAgICAgbm9kZS5pc1RyYW5zaXRpb24gfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQW4gYXN5bmMgZnVuY3Rpb24gd2FzIHBhc3NlZCB0byB1c2VBY3Rpb25TdGF0ZSwgYnV0IGl0IHdhcyBkaXNwYXRjaGVkIG91dHNpZGUgb2YgYW4gYWN0aW9uIGNvbnRleHQuIFRoaXMgaXMgbGlrZWx5IG5vdCB3aGF0IHlvdSBpbnRlbmRlZC4gRWl0aGVyIHBhc3MgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIHRvIGFuIGBhY3Rpb25gIHByb3AsIG9yIGRpc3BhdGNoIG1hbnVhbGx5IGluc2lkZSBgc3RhcnRUcmFuc2l0aW9uYFwiXG4gICAgICAgICAgICApKVxuICAgICAgICA6IG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIG5leHRTdGF0ZSkge1xuICAgICAgYWN0aW9uTm9kZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgYWN0aW9uTm9kZS52YWx1ZSA9IG5leHRTdGF0ZTtcbiAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKTtcbiAgICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsICE9PSBhY3Rpb25Ob2RlICYmXG4gICAgICAgICgobmV4dFN0YXRlID0gYWN0aW9uTm9kZS5uZXh0KSxcbiAgICAgICAgbmV4dFN0YXRlID09PSBhY3Rpb25Ob2RlXG4gICAgICAgICAgPyAoYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGwpXG4gICAgICAgICAgOiAoKG5leHRTdGF0ZSA9IG5leHRTdGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlLm5leHQgPSBuZXh0U3RhdGUpLFxuICAgICAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5leHRTdGF0ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgZXJyb3IpIHtcbiAgICAgIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGxhc3QpIHtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgZG9cbiAgICAgICAgICAoYWN0aW9uTm9kZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUucmVhc29uID0gZXJyb3IpLFxuICAgICAgICAgICAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLm5leHQpO1xuICAgICAgICB3aGlsZSAoYWN0aW9uTm9kZSAhPT0gbGFzdCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSkge1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubGlzdGVuZXJzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25Ob2RlLmxlbmd0aDsgaSsrKSAoMCwgYWN0aW9uTm9kZVtpXSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aW9uU3RhdGVSZWR1Y2VyKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlUHJvcCkge1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciBzc3JGb3JtU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QuZm9ybVN0YXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gc3NyRm9ybVN0YXRlKSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIGlzTWF0Y2hpbmcgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlckluc3RhbmNlID0gY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlcihcbiAgICAgICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VySW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobWFya2VySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgaXNNYXRjaGluZyA9IGlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcobWFya2VySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGlzTWF0Y2hpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNNYXRjaGluZyA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01hdGNoaW5nICYmIChpbml0aWFsU3RhdGVQcm9wID0gc3NyRm9ybVN0YXRlWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3NyRm9ybVN0YXRlID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHNzckZvcm1TdGF0ZS5tZW1vaXplZFN0YXRlID0gc3NyRm9ybVN0YXRlLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZVByb3A7XG4gICAgICBpc01hdGNoaW5nID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGFjdGlvblN0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVByb3BcbiAgICAgIH07XG4gICAgICBzc3JGb3JtU3RhdGUucXVldWUgPSBpc01hdGNoaW5nO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBpc01hdGNoaW5nXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZy5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgICB2YXIgc2V0UGVuZGluZ1N0YXRlID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgITEsXG4gICAgICAgIGlzTWF0Y2hpbmcucXVldWVcbiAgICAgICk7XG4gICAgICBpc01hdGNoaW5nID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIG1hcmtlckluc3RhbmNlID0ge1xuICAgICAgICBzdGF0ZTogaW5pdGlhbFN0YXRlUHJvcCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBwZW5kaW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgaXNNYXRjaGluZy5xdWV1ZSA9IG1hcmtlckluc3RhbmNlO1xuICAgICAgc3NyRm9ybVN0YXRlID0gZGlzcGF0Y2hBY3Rpb25TdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBtYXJrZXJJbnN0YW5jZSxcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlLFxuICAgICAgICBzc3JGb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBtYXJrZXJJbnN0YW5jZS5kaXNwYXRjaCA9IHNzckZvcm1TdGF0ZTtcbiAgICAgIGlzTWF0Y2hpbmcubWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlUHJvcCwgc3NyRm9ybVN0YXRlLCAhMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRIb29rLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICAgICAgc3RhdGVIb29rLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rLFxuICAgICAgICBhY3Rpb25TdGF0ZVJlZHVjZXJcbiAgICAgIClbMF07XG4gICAgICBzdGF0ZUhvb2sgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPVxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vayAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sudGhlblxuICAgICAgICAgID8gdXNlVGhlbmFibGUoY3VycmVudFN0YXRlSG9vaylcbiAgICAgICAgICA6IGN1cnJlbnRTdGF0ZUhvb2s7XG4gICAgICB2YXIgYWN0aW9uUXVldWVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoO1xuICAgICAgYWN0aW9uICE9PSBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgICBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLFxuICAgICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgICAgbnVsbFxuICAgICAgICApKTtcbiAgICAgIHJldHVybiBbY3VycmVudFN0YXRlSG9vaywgZGlzcGF0Y2gsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgICAgIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBzdGF0ZUhvb2sgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGN1cnJlbnRTdGF0ZUhvb2sucXVldWUuZGlzcGF0Y2g7XG4gICAgICBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gICAgICByZXR1cm4gW3N0YXRlSG9vaywgZGlzcGF0Y2gsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICAgICAgdGFnID0geyB0YWc6IHRhZywgY3JlYXRlOiBjcmVhdGUsIGluc3Q6IGluc3QsIGRlcHM6IGRlcHMsIG5leHQ6IG51bGwgfTtcbiAgICAgIGNyZWF0ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG4gICAgICBudWxsID09PSBjcmVhdGUgJiZcbiAgICAgICAgKChjcmVhdGUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNyZWF0ZSkpO1xuICAgICAgaW5zdCA9IGNyZWF0ZS5sYXN0RWZmZWN0O1xuICAgICAgbnVsbCA9PT0gaW5zdFxuICAgICAgICA/IChjcmVhdGUubGFzdEVmZmVjdCA9IHRhZy5uZXh0ID0gdGFnKVxuICAgICAgICA6ICgoZGVwcyA9IGluc3QubmV4dCksXG4gICAgICAgICAgKGluc3QubmV4dCA9IHRhZyksXG4gICAgICAgICAgKHRhZy5uZXh0ID0gZGVwcyksXG4gICAgICAgICAgKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnKSk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH07XG4gICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChcbiAgICAgICAgSGFzRWZmZWN0IHwgaG9va0ZsYWdzLFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIGluc3QgPSBob29rLm1lbW9pemVkU3RhdGUuaW5zdDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmXG4gICAgICBudWxsICE9PSBkZXBzICYmXG4gICAgICBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZS5kZXBzKVxuICAgICAgICA/IChob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBkZXBzKSlcbiAgICAgICAgOiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncyksXG4gICAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoXG4gICAgICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgICAgICBjcmVhdGUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgZGVwc1xuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiA2NCkgPT09IE5vTW9kZVxuICAgICAgICA/IG1vdW50RWZmZWN0SW1wbCgxNDI2MDgzODQsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcylcbiAgICAgICAgOiBtb3VudEVmZmVjdEltcGwoODM5MDY1NiwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICAgIHZhciByZWZDbGVhbnVwID0gcmVmKGNyZWF0ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmQ2xlYW51cCA/IHJlZkNsZWFudXAoKSA6IHJlZihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSByZWYgJiYgdm9pZCAwICE9PSByZWYpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgcmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICAgIFwiYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhyZWYpLmpvaW4oXCIsIFwiKSArIFwifVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjcmVhdGUgPSBjcmVhdGUoKSksXG4gICAgICAgICAgKHJlZi5jdXJyZW50ID0gY3JlYXRlKSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgbnVsbCAhPT0gY3JlYXRlID8gdHlwZW9mIGNyZWF0ZSA6IFwibnVsbFwiXG4gICAgICAgICk7XG4gICAgICBkZXBzID0gbnVsbCAhPT0gZGVwcyAmJiB2b2lkIDAgIT09IGRlcHMgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICAgICAgdmFyIGZpYmVyRmxhZ3MgPSA0MTk0MzA4O1xuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIChmaWJlckZsYWdzIHw9IDY3MTA4ODY0KTtcbiAgICAgIG1vdW50RWZmZWN0SW1wbChcbiAgICAgICAgZmliZXJGbGFncyxcbiAgICAgICAgTGF5b3V0LFxuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgICBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIG51bGwgIT09IGNyZWF0ZSA/IHR5cGVvZiBjcmVhdGUgOiBcIm51bGxcIlxuICAgICAgICApO1xuICAgICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoXG4gICAgICAgIDQsXG4gICAgICAgIExheW91dCxcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSxcbiAgICAgICAgZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gW1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgIF07XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBkZXBzXTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHRDcmVhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIGRlcHNdO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBkZXBzICYmIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBwcmV2U3RhdGVbMV0pKVxuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgcHJldlN0YXRlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbcHJldlN0YXRlLCBkZXBzXTtcbiAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgICBob29rLFxuICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50SG9va1xuICAgICAgICA/IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSlcbiAgICAgICAgOiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsVmFsdWVcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGluaXRpYWxWYWx1ZSB8fCAwICE9PSAocmVuZGVyTGFuZXMgJiAxMDczNzQxODI0KSlcbiAgICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWU7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gICAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmIChvYmplY3RJcyh2YWx1ZSwgcHJldlZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoaG9vayA9IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkpLFxuICAgICAgICAgIG9iamVjdElzKGhvb2ssIHByZXZWYWx1ZSkgfHwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICAgICAgaG9va1xuICAgICAgICApO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIDQyKSlcbiAgICAgICAgcmV0dXJuIChkaWRSZWNlaXZlVXBkYXRlID0gITApLCAoaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWUpO1xuICAgICAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gaG9vaztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShcbiAgICAgICAgMCAhPT0gcHJldmlvdXNQcmlvcml0eSAmJiA4ID4gcHJldmlvdXNQcmlvcml0eSA/IHByZXZpb3VzUHJpb3JpdHkgOiA4XG4gICAgICApO1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCAhMSwgcXVldWUsIHBlbmRpbmdTdGF0ZSk7XG4gICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCksXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgICAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSA9IGNoYWluVGhlbmFibGVWYWx1ZShcbiAgICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICAgICAgZmluaXNoZWRTdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICBmaW5pc2hlZFN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICB7IHRoZW46IGZ1bmN0aW9uICgpIHt9LCBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiBlcnJvciB9LFxuICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAgIDEwIDwgZmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikge1xuICAgICAgdmFyIGV4aXN0aW5nU3RhdGVIb29rID0gZm9ybUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZXhpc3RpbmdTdGF0ZUhvb2spIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZToge1xuICAgICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICB2YXIgaW5pdGlhbFJlc2V0U3RhdGUgPSB7fTtcbiAgICAgIGV4aXN0aW5nU3RhdGVIb29rLm5leHQgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgICBmb3JtRmliZXIgPSBmb3JtRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZm9ybUZpYmVyICYmIChmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rKTtcbiAgICAgIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBzdGF0ZUhvb2sucXVldWUsXG4gICAgICAgICEwLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgICAgIHJldHVybiBbITEsIHN0YXRlSG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA6IHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKSxcbiAgICAgICAgc3RhcnRcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcilbMF0sXG4gICAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICAgIHN0YXJ0XG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChIb3N0VHJhbnNpdGlvbkNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudElkKCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4ID0gd29ya0luUHJvZ3Jlc3NSb290LmlkZW50aWZpZXJQcmVmaXg7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHRyZWVJZCA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICAgIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgICAgdHJlZUlkID1cbiAgICAgICAgICAoXG4gICAgICAgICAgICBpZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8ICgzMiAtIGNsejMyKGlkV2l0aExlYWRpbmdCaXQpIC0gMSkpXG4gICAgICAgICAgKS50b1N0cmluZygzMikgKyB0cmVlSWQ7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBcIjpcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcIlJcIiArIHRyZWVJZDtcbiAgICAgICAgdHJlZUlkID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgICAgMCA8IHRyZWVJZCAmJiAoaWRlbnRpZmllclByZWZpeCArPSBcIkhcIiArIHRyZWVJZC50b1N0cmluZygzMikpO1xuICAgICAgICBpZGVudGlmaWVyUHJlZml4ICs9IFwiOlwiO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0cmVlSWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKyksXG4gICAgICAgICAgKGlkZW50aWZpZXJQcmVmaXggPVxuICAgICAgICAgICAgXCI6XCIgKyBpZGVudGlmaWVyUHJlZml4ICsgXCJyXCIgKyB0cmVlSWQudG9TdHJpbmcoMzIpICsgXCI6XCIpO1xuICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpZGVudGlmaWVyUHJlZml4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWZyZXNoKCkge1xuICAgICAgcmV0dXJuIChtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlciwgc2VlZEtleSkge1xuICAgICAgZm9yICh2YXIgcHJvdmlkZXIgPSBmaWJlci5yZXR1cm47IG51bGwgIT09IHByb3ZpZGVyOyApIHtcbiAgICAgICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUocHJvdmlkZXIpO1xuICAgICAgICAgICAgZmliZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIGZpYmVyLCBsYW5lKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcHJvdmlkZXIsIGxhbmUpKTtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgICAgICAgIG51bGwgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBzZWVkS2V5ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBzZWVkIGFyZ3VtZW50IGlzIG5vdCBlbmFibGVkIG91dHNpZGUgZXhwZXJpbWVudGFsIGNoYW5uZWxzLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaWJlci5wYXlsb2FkID0geyBjYWNoZTogcHJvdmlkZXIgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgKTtcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgbGFuZTogSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwLFxuICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKVxuICAgICAgICA/IGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgYWN0aW9uKVxuICAgICAgICA6ICgoYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IGFjdGlvbiAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihcbiAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKFxuICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICAgICAgICAgICkpKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb24sXG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICApIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICk7XG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDEgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDFcbiAgICAgICk7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDAgPT09IGZpYmVyLmxhbmVzICYmXG4gICAgICAgICAgKG51bGwgPT09IGFsdGVybmF0ZSB8fCAwID09PSBhbHRlcm5hdGUubGFuZXMpICYmXG4gICAgICAgICAgKChhbHRlcm5hdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyKSwgbnVsbCAhPT0gYWx0ZXJuYXRlKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlID0gYWx0ZXJuYXRlKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gITA7XG4gICAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG4gICAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIDApLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gYWN0aW9uKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWN0aW9uLCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSksXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICB0aHJvd0lmRHVyaW5nUmVuZGVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgMCA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFuIG9wdGltaXN0aWMgc3RhdGUgdXBkYXRlIG9jY3VycmVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRoZSB1cGRhdGUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICk7XG4gICAgICBhY3Rpb24gPSB7XG4gICAgICAgIGxhbmU6IDIsXG4gICAgICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICAgICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgdXBkYXRlIG9wdGltaXN0aWMgc3RhdGUgd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBjYWxsIHN0YXJ0VHJhbnNpdGlvbiB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJvd0lmRHVyaW5nUmVuZGVyID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAyXG4gICAgICAgICkpLFxuICAgICAgICAgIG51bGwgIT09IHRocm93SWZEdXJpbmdSZW5kZXIgJiZcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcih0aHJvd0lmRHVyaW5nUmVuZGVyLCBmaWJlciwgMik7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHxcbiAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICEwO1xuICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCA9PT0gcGVuZGluZ1xuICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICAgICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gICAgICBpZiAoMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkge1xuICAgICAgICB2YXIgcXVldWVMYW5lcyA9IHF1ZXVlLmxhbmVzO1xuICAgICAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgICAgIHF1ZXVlLmxhbmVzID0gbGFuZTtcbiAgICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKG51bGwgIT09IGNhbGxiYWNrICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBrZXkgPSBTdHJpbmcoY2FsbGJhY2spO1xuICAgICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkgfHxcbiAgICAgICAgICAoZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICAgIG5leHRQcm9wc1xuICAgICkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICAoKGN0b3IgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY3RvcikgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjdG9yKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICApKSk7XG4gICAgICBwcmV2U3RhdGUgPVxuICAgICAgICBudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGVcbiAgICAgICAgICA/IHByZXZTdGF0ZVxuICAgICAgICAgIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBvbGRQcm9wcyA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICBuZXh0Q29udGV4dFxuICAgICAgICApO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZvaWQgMCA9PT0gb2xkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBvbGRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudFxuICAgICAgICA/ICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICkge1xuICAgICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICkpLFxuICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuICAgICAgaWYgKFwicmVmXCIgaW4gYmFzZVByb3BzKSB7XG4gICAgICAgIG5ld1Byb3BzID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBwcm9wTmFtZSAmJiAobmV3UHJvcHNbcHJvcE5hbWVdID0gYmFzZVByb3BzW3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoKENvbXBvbmVudCA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHMpKSB7XG4gICAgICAgIG5ld1Byb3BzID09PSBiYXNlUHJvcHMgJiYgKG5ld1Byb3BzID0gYXNzaWduKHt9LCBuZXdQcm9wcykpO1xuICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gQ29tcG9uZW50KVxuICAgICAgICAgIHZvaWQgMCA9PT0gbmV3UHJvcHNbX3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgKG5ld1Byb3BzW19wcm9wTmFtZV0gPSBDb21wb25lbnRbX3Byb3BOYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZVxuICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBvblVuY2F1Z2h0RXJyb3IgPSByb290Lm9uVW5jYXVnaHRFcnJvcjtcbiAgICAgICAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IsIHsgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgYm91bmRhcnksIGVycm9ySW5mbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2VcbiAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSk7XG4gICAgICAgIHZhciBvbkNhdWdodEVycm9yID0gcm9vdC5vbkNhdWdodEVycm9yO1xuICAgICAgICBvbkNhdWdodEVycm9yKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICAgICAgZXJyb3JCb3VuZGFyeTogMSA9PT0gYm91bmRhcnkudGFnID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290LCBlcnJvckluZm8sIGxhbmUpIHtcbiAgICAgIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBsYW5lLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gICAgICBsYW5lLnBheWxvYWQgPSB7IGVsZW1lbnQ6IG51bGwgfTtcbiAgICAgIGxhbmUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UsIGxvZ1VuY2F1Z2h0RXJyb3IsIHJvb3QsIGVycm9ySW5mbyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSkge1xuICAgICAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGxhbmUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgIT09IGluc3QgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAodXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGVycm9ySW5mby5zb3VyY2UsXG4gICAgICAgICAgICBsb2dDYXVnaHRFcnJvcixcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGVycm9ySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWRcbiAgICAgICAgICAgICAgPyAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFt0aGlzXSkpXG4gICAgICAgICAgICAgIDogbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKHRoaXMpKTtcbiAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFVih0aGlzLCBlcnJvckluZm8pO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgKDAgPT09IChmaWJlci5sYW5lcyAmIDIpICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiBJbiB0aGF0IG1ldGhvZCwgcmV0dXJuIGEgc3RhdGUgdXBkYXRlIHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvciBmYWxsYmFjayBVSS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKFxuICAgICAgcm9vdCxcbiAgICAgIHJldHVybkZpYmVyLFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJvb3RSZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgc291cmNlRmliZXIuZmxhZ3MgfD0gMzI3Njg7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHZhbHVlICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMCk7XG4gICAgICAgIHNvdXJjZUZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgICAgaWYgKG51bGwgIT09IHNvdXJjZUZpYmVyKSB7XG4gICAgICAgICAgc3dpdGNoIChzb3VyY2VGaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgICAgICAgPyByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKClcbiAgICAgICAgICAgICAgICAgIDogbnVsbCA9PT0gc291cmNlRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzICY9IC0yNTcpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgOiByZXR1cm5GaWJlci5hZGQodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VySW5zdGFuY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlOiBuZXcgU2V0KFt2YWx1ZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICA6ICgoc291cmNlRmliZXIgPSByZXR1cm5GaWJlci5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKHJldHVybkZpYmVyLnJldHJ5UXVldWUgPSBuZXcgU2V0KFt2YWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNvdXJjZUZpYmVyLmFkZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0h5ZHJhdGluZylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMCksXG4gICAgICAgICAgKHJldHVybkZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgID8gKDAgPT09IChyZXR1cm5GaWJlci5mbGFncyAmIDY1NTM2KSAmJiAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMjU2KSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgdmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uICYmXG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIGZyb20gdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnkuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6ICh2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAocm9vdCA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICAocm9vdC5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgJj0gLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChyb290LmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcikpLFxuICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgIHJvb3Quc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHJvb3QsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkKSksXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIHZhciBlcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICBFcnJvcihcbiAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgY29uY3VycmVudCByZW5kZXJpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBzeW5jaHJvbm91c2x5IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuXCIsXG4gICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICApLFxuICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgKTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnNcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFtlcnJvcl0pXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZCk7XG4gICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHJldHVybiAhMDtcbiAgICAgIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgIHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXI7XG4gICAgICBkbyB7XG4gICAgICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJvb3QgPSByb290UmVuZGVyTGFuZXMgJiAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3QpLFxuICAgICAgICAgICAgICAocm9vdCA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcm9vdFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290KSxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudHlwZSksXG4gICAgICAgICAgICAgIChlcnJvciA9IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIDAgPT09IChzb3VyY2VGaWJlci5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuRmliZXIuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAobnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZXJyb3IuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhlcnJvcikpKSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHJvb3RSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZUZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gc291cmNlRmliZXIpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9XG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnJlbmRlcjtcbiAgICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBpZiAoXCJyZWZcIiBpbiBuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV4dFByb3BzKVxuICAgICAgICAgIFwicmVmXCIgIT09IGtleSAmJiAocHJvcHNXaXRob3V0UmVmW2tleV0gPSBuZXh0UHJvcHNba2V5XSk7XG4gICAgICB9IGVsc2UgcHJvcHNXaXRob3V0UmVmID0gbmV4dFByb3BzO1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBwcm9wc1dpdGhvdXRSZWYsXG4gICAgICAgIHJlZixcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgICBrZXkgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYga2V5ICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiZcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgbnVsbCA9PT0gQ29tcG9uZW50LmNvbXBhcmVcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoQ29tcG9uZW50ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCksXG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHR5cGUpLFxuICAgICAgICAgICAgdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgQ29tcG9uZW50LnR5cGUsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBpZiAoIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSkge1xuICAgICAgICB2YXIgcHJldlByb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgICAgICBDb21wb25lbnQgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICAgICAgQ29tcG9uZW50ID0gbnVsbCAhPT0gQ29tcG9uZW50ID8gQ29tcG9uZW50IDogc2hhbGxvd0VxdWFsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgQ29tcG9uZW50KHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgICAgIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWZcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIGN1cnJlbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyh0eXBlLCBuZXh0UHJvcHMpO1xuICAgICAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmXG4gICAgICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZVxuICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcyksXG4gICAgICAgICAgICBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzEwNzIpICYmIChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgbmV4dElzRGV0YWNoZWQgPVxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMiksXG4gICAgICAgIHByZXZTdGF0ZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAoXCJoaWRkZW5cIiA9PT0gbmV4dFByb3BzLm1vZGUgfHwgbmV4dElzRGV0YWNoZWQpIHtcbiAgICAgICAgaWYgKDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkpIHtcbiAgICAgICAgICBuZXh0UHJvcHMgPVxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgID8gcHJldlN0YXRlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgIDogcmVuZGVyTGFuZXM7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICAgICAgICAgIGZvciAobmV4dElzRGV0YWNoZWQgPSAwOyBudWxsICE9PSBuZXh0Q2hpbGRyZW47IClcbiAgICAgICAgICAgICAgKG5leHRJc0RldGFjaGVkID1cbiAgICAgICAgICAgICAgICBuZXh0SXNEZXRhY2hlZCB8IG5leHRDaGlsZHJlbi5sYW5lcyB8IG5leHRDaGlsZHJlbi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgICAobmV4dENoaWxkcmVuID0gbmV4dENoaWxkcmVuLnNpYmxpbmcpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IG5leHRJc0RldGFjaGVkICYgfm5leHRQcm9wcztcbiAgICAgICAgICB9IGVsc2UgKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSwgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpKVxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0geyBiYXNlTGFuZXM6IDAsIGNhY2hlUG9vbDogbnVsbCB9KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgcHVzaFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmNhY2hlUG9vbCA6IG51bGxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICA/IHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpXG4gICAgICAgICAgICAgIDogcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gNTM2ODcwOTEyKSxcbiAgICAgICAgICAgIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgPyAocHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZS5jYWNoZVBvb2wpLFxuICAgICAgICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSksXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSlcbiAgICAgICAgICA6IChudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dEJhc2VMYW5lcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgIG51bGwgPT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyLFxuICAgICAgICAgICAgICBwb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsICEwKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKG51bGwgPT09IHJlZilcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQucmVmICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZWYgJiYgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgdW5kZWZpbmVkL251bGwuXCJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIDggJiZcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAodmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKSkpKTtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIENvbXBvbmVudCA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgbmV4dFByb3BzID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIG5leHRQcm9wcyAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgc2Vjb25kQXJnLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgc2Vjb25kQXJnXG4gICAgICApO1xuICAgICAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgQ29tcG9uZW50ID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIENvbXBvbmVudCAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAoc2hvdWxkRXJyb3JJbXBsKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICBjYXNlICExOlxuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyB3b3JrSW5Qcm9ncmVzcy50eXBlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UuY29udGV4dFxuICAgICAgICAgICAgKS5zdGF0ZTtcbiAgICAgICAgICBfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLCBzdGF0ZSwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgITA6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY1NTM2O1xuICAgICAgICAgIF9pbnN0YW5jZSA9IEVycm9yKFwiU2ltdWxhdGVkIGVycm9yIGNvbWluZyBmcm9tIERldlRvb2xzXCIpO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgfD0gbGFuZTtcbiAgICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbGFuZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSk7XG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICBsYW5lLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGxhbmUpO1xuICAgICAgfVxuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICBzdGF0ZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBcImNvbnRleHRUeXBlXCIgaW4gQ29tcG9uZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gX2luc3RhbmNlIHx8IF9pbnN0YW5jZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIChsYW5lID1cbiAgICAgICAgICAgIHZvaWQgMCA9PT0gX2luc3RhbmNlXG4gICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gdHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLlwiXG4gICAgICAgICAgICAgIDogXCJvYmplY3RcIiAhPT0gdHlwZW9mIF9pbnN0YW5jZVxuICAgICAgICAgICAgICAgID8gXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgXCIgKyB0eXBlb2YgX2luc3RhbmNlICsgXCIuXCJcbiAgICAgICAgICAgICAgICA6IF9pbnN0YW5jZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRVxuICAgICAgICAgICAgICAgICAgPyBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/XCJcbiAgICAgICAgICAgICAgICAgIDogXCIgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMge1wiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2luc3RhbmNlKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIn0uXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXNcIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIsXG4gICAgICAgICAgICBsYW5lXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfaW5zdGFuY2UgJiZcbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAoc3RhdGUgPSByZWFkQ29udGV4dChfaW5zdGFuY2UpKTtcbiAgICAgICAgX2luc3RhbmNlID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIHN0YXRlKTtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgc3RhdGUpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlLnN0YXRlICYmIHZvaWQgMCAhPT0gX2luc3RhbmNlLnN0YXRlXG4gICAgICAgICAgICA/IF9pbnN0YW5jZS5zdGF0ZVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBfaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICBfaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxzID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIF9pbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICBudWxsID09PSBzdGF0ZSAmJlxuICAgICAgICAgICgoc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoc3RhdGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5IGFzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiBUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuXCIsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBudWxsID09PSBfaW5zdGFuY2Uuc3RhdGUgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gKGxhbmUgPSBzdGF0ZSA9IG51bGwpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChzdGF0ZSA9IFwiY29tcG9uZW50V2lsbE1vdW50XCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgIChzdGF0ZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAobGFuZSA9IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgICAobGFuZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIik7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlXCIpO1xuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZSB8fCBudWxsICE9PSBsYW5lIHx8IG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUpIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgICAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcbiAgICAgICAgICAgICAgICA/IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKClcIlxuICAgICAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfaW5zdGFuY2UpIHx8XG4gICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfaW5zdGFuY2UpLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblRoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzXCIsXG4gICAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gc3RhdGUgPyBcIlxcbiAgXCIgKyBzdGF0ZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbGFuZSA/IFwiXFxuICBcIiArIGxhbmUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogXCJcIlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgIF9pbnN0YW5jZS5yZW5kZXIgfHxcbiAgICAgICAgICAoQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yP1wiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLlwiLFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAhX2luc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgICAgIF9pbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHxcbiAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgfHxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgICFfaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmNvbnRleHRUeXBlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICkpO1xuICAgICAgICBDb21wb25lbnQuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiBQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQSBwdXJlIGNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgdXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgcnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIGxhbmUgPSBfaW5zdGFuY2UucHJvcHMgIT09IG5leHRQcm9wcztcbiAgICAgICAgdm9pZCAwICE9PSBfaW5zdGFuY2UucHJvcHMgJiZcbiAgICAgICAgICBsYW5lICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgdXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuXCIsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoQ29tcG9uZW50KSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KVxuICAgICAgICAgICkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgKGxhbmUgPSBfaW5zdGFuY2Uuc3RhdGUpICYmXG4gICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBsYW5lIHx8IGlzQXJyYXlJbXBsKGxhbmUpKSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGxcIiwgc3RhdGUpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnJlZnMgPSB7fTtcbiAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgc3RhdGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIF9pbnN0YW5jZS5jb250ZXh0ID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygc3RhdGUgJiYgbnVsbCAhPT0gc3RhdGVcbiAgICAgICAgICAgID8gcmVhZENvbnRleHQoc3RhdGUpXG4gICAgICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID09PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAoKHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKHN0YXRlKSB8fFxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChzdGF0ZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIGJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuXCIsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKSk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiA4ICYmXG4gICAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIF9pbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBzdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN0YXRlICYmXG4gICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICksXG4gICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAoKHN0YXRlID0gX2luc3RhbmNlLnN0YXRlKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgc3RhdGUgIT09IF9pbnN0YW5jZS5zdGF0ZSAmJlxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLnN0YXRlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpLFxuICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KTtcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCk7XG4gICAgICAgIF9pbnN0YW5jZSA9ICEwO1xuICAgICAgfSBlbHNlIGlmIChudWxsID09PSBjdXJyZW50JGpzY29tcCQwKSB7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGxhbmUgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGxhbmU7XG4gICAgICAgIHZhciBvbGRDb250ZXh0ID0gX2luc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIHN0YXRlID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZm91bmRXaWxsVXBkYXRlTmFtZSAmJlxuICAgICAgICAgIG51bGwgIT09IGZvdW5kV2lsbFVwZGF0ZU5hbWUgJiZcbiAgICAgICAgICAoc3RhdGUgPSByZWFkQ29udGV4dChmb3VuZFdpbGxVcGRhdGVOYW1lKSk7XG4gICAgICAgIG5ld0FwaU5hbWUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID1cbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdBcGlOYW1lIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgIT09IHVucmVzb2x2ZWRPbGRQcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB8fFxuICAgICAgICAgICgodW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZENvbnRleHQgIT09IHN0YXRlKSAmJlxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgIG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgfHwgb2xkU3RhdGUgIT09IG9sZENvbnRleHQgfHwgaGFzRm9yY2VVcGRhdGVcbiAgICAgICAgICA/IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdBcGlOYW1lICYmXG4gICAgICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgICAgICAobGFuZSA9XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBsYW5lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZXh0LFxuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSlcbiAgICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvbGRDb250ZXh0KSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSBvbGRDb250ZXh0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UuY29udGV4dCA9IHN0YXRlKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSBsYW5lKSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9ICExKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCRqc2NvbXAkMCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHN0YXRlKTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gZm91bmRXaWxsVXBkYXRlTmFtZTtcbiAgICAgICAgbmV3QXBpTmFtZSA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgb2xkU3RhdGUgPSBfaW5zdGFuY2UuY29udGV4dDtcbiAgICAgICAgb2xkQ29udGV4dCA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgbGFuZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9sZENvbnRleHQgJiZcbiAgICAgICAgICBudWxsICE9PSBvbGRDb250ZXh0ICYmXG4gICAgICAgICAgKGxhbmUgPSByZWFkQ29udGV4dChvbGRDb250ZXh0KSk7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIChvbGRDb250ZXh0ID1cbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUpIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAgICAgKChzdGF0ZSAhPT0gbmV3QXBpTmFtZSB8fCBvbGRTdGF0ZSAhPT0gbGFuZSkgJiZcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICkpO1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgICBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc3RhdGUgIT09IG5ld0FwaU5hbWUgfHxcbiAgICAgICAgb2xkU3RhdGUgIT09IG5ld1N0YXRlIHx8XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgIChudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMpKVxuICAgICAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyAmJlxuICAgICAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAgICAgKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPVxuICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCRqc2NvbXAkMC5kZXBlbmRlbmNpZXMpKSlcbiAgICAgICAgICAgICAgPyAob2xkQ29udGV4dCB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5ld1N0YXRlLCBsYW5lKSxcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpKVxuICAgICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZSkpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gbmV3U3RhdGUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5jb250ZXh0ID0gbGFuZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gZm91bmRXaWxsVXBkYXRlTmFtZSkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSAhMSkpO1xuICAgICAgfVxuICAgICAgbGFuZSA9IF9pbnN0YW5jZTtcbiAgICAgIG1hcmtSZWYoY3VycmVudCRqc2NvbXAkMCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3RhdGUgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICAgICAgaWYgKGxhbmUgfHwgc3RhdGUpIHtcbiAgICAgICAgbGFuZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID1cbiAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcyA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGlmIChzdGF0ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKVxuICAgICAgICAgIChDb21wb25lbnQgPSBudWxsKSwgKHByb2ZpbGVyU3RhcnRUaW1lID0gLTEpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgQ29tcG9uZW50ID0gY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2FsbFJlbmRlckluREVWKGxhbmUpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAgJiYgc3RhdGVcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGN1cnJlbnQkanNjb21wJDAuY2hpbGQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSkpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBsYW5lLnN0YXRlO1xuICAgICAgICBjdXJyZW50JGpzY29tcCQwID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY3VycmVudCRqc2NvbXAkMCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgY3VycmVudCRqc2NvbXAkMCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBfaW5zdGFuY2UgJiZcbiAgICAgICAgcmVuZGVyTGFuZXMucHJvcHMgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkl0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJhIGNvbXBvbmVudFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMCkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQkanNjb21wJDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI1NjtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAgICAgIENvbXBvbmVudCAmJlxuICAgICAgICBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbiAgJXMuY2hpbGRDb250ZXh0VHlwZXMgPSAuLi5cIixcbiAgICAgICAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICApO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W3dvcmtJblByb2dyZXNzXSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbd29ya0luUHJvZ3Jlc3NdID1cbiAgICAgICAgICAgICEwKSkpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSAmJlxuICAgICAgICBudWxsICE9PSBDb21wb25lbnQuY29udGV4dFR5cGUgJiZcbiAgICAgICAgKChDb21wb25lbnQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtDb21wb25lbnRdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLlwiLFxuICAgICAgICAgICAgQ29tcG9uZW50XG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W0NvbXBvbmVudF0gPSAhMCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gICAgICByZXR1cm4geyBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLCBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKCkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICBjdXJyZW50LFxuICAgICAgcHJpbWFyeVRyZWVEaWREZWZlcixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuY2hpbGRMYW5lcyAmIH5yZW5kZXJMYW5lcyA6IDA7XG4gICAgICBwcmltYXJ5VHJlZURpZERlZmVyICYmIChjdXJyZW50IHw9IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBzaG91bGRTdXNwZW5kSW1wbCh3b3JrSW5Qcm9ncmVzcykgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gICAgICB2YXIgc2hvd0ZhbGxiYWNrID0gITEsXG4gICAgICAgIGRpZFN1c3BlbmQgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpLFxuICAgICAgICBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICAoSlNDb21waWxlcl90ZW1wID0gZGlkU3VzcGVuZCkgfHxcbiAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gITFcbiAgICAgICAgICAgIDogMCAhPT0gKHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpO1xuICAgICAgSlNDb21waWxlcl90ZW1wICYmICgoc2hvd0ZhbGxiYWNrID0gITApLCAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTEyOSkpO1xuICAgICAgSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMzIpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTMzO1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICA/IHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgIDogcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDA7XG4gICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gIW5leHRJbnN0YW5jZSkgfHxcbiAgICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgPyAod2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVoeWRyYXRlZDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICB0cmVlQ29udGV4dDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB0cmVlQ29udGV4dFByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgaWQ6IHRyZWVDb250ZXh0SWQsIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlMYW5lOiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmQgPSBjcmVhdGVGaWJlcigxOCwgbnVsbCwgbnVsbCwgTm9Nb2RlKSksXG4gICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZC5zdGF0ZU5vZGUgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApLFxuICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gZGlkU3VzcGVuZCksXG4gICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICEwKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhMSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSk7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgKHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICgobmV4dEluc3RhbmNlID0gbmV4dEluc3RhbmNlLmRlaHlkcmF0ZWQpLCBudWxsICE9PSBuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sobmV4dEluc3RhbmNlKVxuICAgICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMTYpXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluc3RhbmNlID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgICBuZXh0UHJvcHMgPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICAgIGlmIChzaG93RmFsbGJhY2spXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgICAgICB7IG1vZGU6IFwiaGlkZGVuXCIsIGNoaWxkcmVuOiBuZXh0SW5zdGFuY2UgfSxcbiAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2UucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlLnNpYmxpbmcgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwICYmXG4gICAgICAgICgobmV4dEluc3RhbmNlID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLmRlaHlkcmF0ZWQpLFxuICAgICAgICBudWxsICE9PSBuZXh0SW5zdGFuY2UpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGRpZFN1c3BlbmQpXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTZcbiAgICAgICAgICAgID8gKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDogbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IChyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICAgICAgICA6IChyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0UHJvcHMuZmFsbGJhY2spLFxuICAgICAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgICAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbiB9LFxuICAgICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjay5mbGFncyB8PSAyKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBzaG93RmFsbGJhY2spKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sobmV4dEluc3RhbmNlKSlcbiAgICAgICAgKVxuICAgICAgICAgIChuZXh0SW5zdGFuY2UgPVxuICAgICAgICAgICAgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzKG5leHRJbnN0YW5jZSkpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IG5leHRJbnN0YW5jZS5kaWdlc3QpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRJbnN0YW5jZS5tZXNzYWdlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBuZXh0SW5zdGFuY2Uuc3RhY2spLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZS5jb21wb25lbnRTdGFjayksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gc2hvd0ZhbGxiYWNrXG4gICAgICAgICAgICAgID8gRXJyb3Ioc2hvd0ZhbGxiYWNrKVxuICAgICAgICAgICAgICA6IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgc2VydmVyIGNvdWxkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeSwgbGlrZWx5IGR1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5zdGFjayA9IG5leHRQcm9wcyB8fCBcIlwiKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSB2b2lkIDAgPT09IG5leHRJbnN0YW5jZSA/IG51bGwgOiBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgICBzdGFjazogSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgQ2FwdHVyZWRTdGFja3Muc2V0KHNob3dGYWxsYmFjaywgbmV4dFByb3BzKSxcbiAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IobmV4dFByb3BzKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IDAgIT09IChyZW5kZXJMYW5lcyAmIGN1cnJlbnQuY2hpbGRMYW5lcykpLFxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgfHwgSlNDb21waWxlcl90ZW1wKVxuICAgICAgICApIHtcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCkge1xuICAgICAgICAgICAgbmV4dFByb3BzID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIDQyKSkgbmV4dFByb3BzID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3dpdGNoIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgICAgIGNhc2UgMjU2OlxuICAgICAgICAgICAgICAgIGNhc2UgNTEyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTAyNDpcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgICAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICAgICAgICAgIGNhc2UgODE5MjpcbiAgICAgICAgICAgICAgICBjYXNlIDE2Mzg0OlxuICAgICAgICAgICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgICAgICAgICAgY2FzZSA2NTUzNjpcbiAgICAgICAgICAgICAgICBjYXNlIDEzMTA3MjpcbiAgICAgICAgICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgICAgICAgICBjYXNlIDUyNDI4ODpcbiAgICAgICAgICAgICAgICBjYXNlIDEwNDg1NzY6XG4gICAgICAgICAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgICAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gNjQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDEzNDIxNzcyODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0UHJvcHMgPVxuICAgICAgICAgICAgICAwICE9PSAobmV4dFByb3BzICYgKEpTQ29tcGlsZXJfdGVtcC5zdXNwZW5kZWRMYW5lcyB8IHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IG5leHRQcm9wcztcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgMCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgIG5leHRQcm9wcyAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnJldHJ5TGFuZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucmV0cnlMYW5lID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoY3VycmVudCwgbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoSlNDb21waWxlcl90ZW1wLCBjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhuZXh0SW5zdGFuY2UpIHx8XG4gICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5KG5leHRJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKSlcbiAgICAgICAgICAgIDogKChjdXJyZW50ID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnRyZWVDb250ZXh0KSxcbiAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSkpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAod2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkKSxcbiAgICAgICAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlciksXG4gICAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGN1cnJlbnQuaWQpLFxuICAgICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBjdXJyZW50Lm92ZXJmbG93KSxcbiAgICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDA5NikpO1xuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9XG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAoZGlkU3VzcGVuZCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zaWJsaW5nKSxcbiAgICAgICAgICAobmV4dFByb3BzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLCB7XG4gICAgICAgICAgICBtb2RlOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlblxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICAobmV4dFByb3BzLnN1YnRyZWVGbGFncyA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRcbiAgICAgICAgICAgID8gKHNob3dGYWxsYmFjayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGRpZFN1c3BlbmQsIHNob3dGYWxsYmFjaykpXG4gICAgICAgICAgICA6ICgoc2hvd0ZhbGxiYWNrID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmZsYWdzIHw9IDIpKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRQcm9wcyksXG4gICAgICAgICAgKG5leHRQcm9wcyA9IHNob3dGYWxsYmFjayksXG4gICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAobmV4dEluc3RhbmNlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICBudWxsID09PSBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgID8gKG5leHRJbnN0YW5jZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpXG4gICAgICAgICAgICA6ICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gbmV4dEluc3RhbmNlLmNhY2hlUG9vbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgID8gKChkaWRTdXNwZW5kID0gaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnBhcmVudCAhPT0gZGlkU3VzcGVuZFxuICAgICAgICAgICAgICAgICAgICAgID8geyBwYXJlbnQ6IGRpZFN1c3BlbmQsIHBvb2w6IGRpZFN1c3BlbmQgfVxuICAgICAgICAgICAgICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSlcbiAgICAgICAgICAgICAgICA6IChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBnZXRTdXNwZW5kZWRDYWNoZSgpKSxcbiAgICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICBiYXNlTGFuZXM6IG5leHRJbnN0YW5jZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgKHNob3dGYWxsYmFjay5tZW1vaXplZFN0YXRlID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICk7XG4gICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVuZGVyTGFuZXMgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzLnNpYmxpbmc7XG4gICAgICByZW5kZXJMYW5lcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCB7XG4gICAgICAgIG1vZGU6IFwidmlzaWJsZVwiLFxuICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICB9KTtcbiAgICAgIHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICgoSlNDb21waWxlcl90ZW1wID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zKSxcbiAgICAgICAgbnVsbCA9PT0gSlNDb21waWxlcl90ZW1wXG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgIDogSlNDb21waWxlcl90ZW1wLnB1c2goY3VycmVudCkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJlbmRlckxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pIHtcbiAgICAgIHByaW1hcnlDaGlsZHJlbiA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlbiB9LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlXG4gICAgICApO1xuICAgICAgcHJpbWFyeUNoaWxkcmVuLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcywgbW9kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICBjdXJyZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICAgIGN1cnJlbnQuZmxhZ3MgfD0gMjtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgZmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgZmliZXIucmV0dXJuLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAgICAgIHZhciBpc0FuQXJyYXkgPSBpc0FycmF5SW1wbChjaGlsZFNsb3QpO1xuICAgICAgY2hpbGRTbG90ID0gIWlzQW5BcnJheSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCk7XG4gICAgICByZXR1cm4gaXNBbkFycmF5IHx8IGNoaWxkU2xvdFxuICAgICAgICA/ICgoaXNBbkFycmF5ID0gaXNBbkFycmF5ID8gXCJhcnJheVwiIDogXCJpdGVyYWJsZVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiBhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uIDwvU3VzcGVuc2VMaXN0PlwiLFxuICAgICAgICAgICAgaXNBbkFycmF5LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBpc0FuQXJyYXlcbiAgICAgICAgICApLFxuICAgICAgICAgICExKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGlzQmFja3dhcmRzLFxuICAgICAgdGFpbCxcbiAgICAgIGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbE1vZGVcbiAgICApIHtcbiAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBudWxsID09PSByZW5kZXJTdGF0ZVxuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgICAgICAgcmVuZGVyaW5nOiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICAgICAgICB0YWlsOiB0YWlsLFxuICAgICAgICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAoKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzID0gaXNCYWNrd2FyZHMpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMCksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLmxhc3QgPSBsYXN0Q29udGVudFJvdyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcixcbiAgICAgICAgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChcbiAgICAgICAgdm9pZCAwICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcImZvcndhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwidG9nZXRoZXJcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXVxuICAgICAgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSAhMCksXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJldmVhbE9yZGVyKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9nZXRoZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgICAgY2FzZSBcImJhY2t3YXJkc1wiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFVzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZFwiOlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIFJlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICB2b2lkIDAgPT09IHRhaWxNb2RlIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSB8fFxuICAgICAgICAoXCJjb2xsYXBzZWRcIiAhPT0gdGFpbE1vZGUgJiYgXCJoaWRkZW5cIiAhPT0gdGFpbE1vZGVcbiAgICAgICAgICA/ICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICA6IFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgIFwiYmFja3dhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgICAgICAoKGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuIERpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLFxuICAgICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgYTogaWYgKFxuICAgICAgICAoXCJmb3J3YXJkc1wiID09PSByZXZlYWxPcmRlciB8fCBcImJhY2t3YXJkc1wiID09PSByZXZlYWxPcmRlcikgJiZcbiAgICAgICAgdm9pZCAwICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICExICE9PSBuZXh0UHJvcHNcbiAgICAgIClcbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5leHRQcm9wcykpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0UHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChuZXh0UHJvcHNbaV0sIGkpKSBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChpID0gZ2V0SXRlcmF0b3JGbihuZXh0UHJvcHMpKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSkpIHtcbiAgICAgICAgICBpZiAoKGkgPSBpLmNhbGwobmV4dFByb3BzKSkpXG4gICAgICAgICAgICBmb3IgKHZhciBzdGVwID0gaS5uZXh0KCksIF9pID0gMDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGkubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuIERpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycsXG4gICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICk7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICBuZXh0UHJvcHMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBpZiAoMCAhPT0gKG5leHRQcm9wcyAmIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpXG4gICAgICAgIChuZXh0UHJvcHMgPVxuICAgICAgICAgIChuZXh0UHJvcHMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICBhOiBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICBpZiAoMTMgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIGlmICgxOSA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihjdXJyZW50LCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLnJldHVybiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICAgIGZvciAoOyBudWxsID09PSBjdXJyZW50LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudC5yZXR1cm4gfHwgY3VycmVudC5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQuc2libGluZy5yZXR1cm4gPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICBuZXh0UHJvcHMgJj0gU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG4gICAgICB9XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgICBjYXNlIFwiZm9yd2FyZHNcIjpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIGZvciAocmV2ZWFsT3JkZXIgPSBudWxsOyBudWxsICE9PSByZW5kZXJMYW5lczsgKVxuICAgICAgICAgICAgKGN1cnJlbnQgPSByZW5kZXJMYW5lcy5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpICYmXG4gICAgICAgICAgICAgICAgKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICA/ICgocmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpKVxuICAgICAgICAgICAgOiAoKHJldmVhbE9yZGVyID0gcmVuZGVyTGFuZXMuc2libGluZyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbCkpO1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITEsXG4gICAgICAgICAgICByZXZlYWxPcmRlcixcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgdGFpbE1vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSBudWxsO1xuICAgICAgICAgIHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7IG51bGwgIT09IHJldmVhbE9yZGVyOyApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5hbHRlcm5hdGU7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuc2libGluZztcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLnNpYmxpbmcgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgICByZXZlYWxPcmRlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgITAsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgITEsIG51bGwsIG51bGwsIHZvaWQgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcztcbiAgICAgIGlmICgwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpXG4gICAgICAgIHRocm93IEVycm9yKFwiUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLlwiKTtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICBmb3IgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzOyBudWxsICE9PSBjdXJyZW50LnNpYmxpbmc7IClcbiAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nID1cbiAgICAgICAgICAgICAgY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKDAgIT09IChjdXJyZW50LmxhbmVzICYgcmVuZGVyTGFuZXMpKSByZXR1cm4gITA7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCAmJiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgPyAhMCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENhY2hlQ29udGV4dCxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4O1xuICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IC0wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlTm9kZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkLmNoaWxkTGFuZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuc2libGluZyA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG4gICAgICAgICAgc3RhdGVOb2RlIHx8XG4gICAgICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoc3RhdGVOb2RlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpKTtcbiAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpZFN1c3BlbmRCZWZvcmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IGRpZFN1c3BlbmRCZWZvcmUgJiZcbiAgICAgICAgICAgICgoZGlkU3VzcGVuZEJlZm9yZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLnRhaWwgPSBudWxsKSxcbiAgICAgICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLmxhc3RFZmZlY3QgPSBudWxsKSk7XG4gICAgICAgICAgcHVzaChcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN0YXRlTm9kZSkgYnJlYWs7XG4gICAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMCksXG4gICAgICAgICAgICB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDYWNoZUNvbnRleHQsXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCAmJiBudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Mua2V5LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpIHRocm93IEVycm9yKFwiQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuXCIpO1xuICAgICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIHJlbmRlckxhbmVzLmluZGV4ID0gd29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgICAgICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIHJlbmRlckxhbmVzLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgICAgcmVuZGVyTGFuZXMuX2RlYnVnSW5mbyA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpXG4gICAgICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLlwiKTtcbiAgICAgICAgICBmb3IgKDsgcHJldlNpYmxpbmcuc2libGluZyAhPT0gd29ya0luUHJvZ3Jlc3M7IClcbiAgICAgICAgICAgIGlmICgoKHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZyksIG51bGwgPT09IHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLlwiKTtcbiAgICAgICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XSksIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICByZW5kZXJMYW5lcy5mbGFncyB8PSAyO1xuICAgICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzIHx8XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOClcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAgICAgYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgPyAhMCA6ICExO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICExO1xuICAgICAgICBpZiAoKHJldHVybkZpYmVyID0gaXNIeWRyYXRpbmcpKVxuICAgICAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTA0ODU3NikpO1xuICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICgocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5pbmRleCksXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdHJlZUZvcmtDb3VudCwgcmV0dXJuRmliZXIpKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgYTogaWYgKFxuICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IGNhbGxMYXp5SW5pdEluREVWKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudClcbiAgICAgICAgICApXG4gICAgICAgICAgICBzaG91bGRDb25zdHJ1Y3QoY3VycmVudClcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50KSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MudGFnID0gMCksXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IGN1cnJlbnQuJCR0eXBlb2YpLFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxMTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U2libGluZyA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gXCJcIjtcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgXCIgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT9cIik7XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN1cnJlbnQpIHx8IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiICtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICtcbiAgICAgICAgICAgICAgICBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgK1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICBwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHByZXZTaWJsaW5nLmVsZW1lbnQ7XG4gICAgICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIG5leHRQcm9wcyA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgbmV4dFByb3BzICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNIeWRyYXRpb24gJiYgcHJldlNpYmxpbmcuaXNEZWh5ZHJhdGVkKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGlzRGVoeWRyYXRlZDogITEsXG4gICAgICAgICAgICAgICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyAhPT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyByb290IHJlY2VpdmVkIGFuIGVhcmx5IHVwZGF0ZSwgYmVmb3JlIGFueXRoaW5nIHdhcyBhYmxlIGh5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICgobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIChpc0h5ZHJhdGluZyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwKSksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAoY3VycmVudC5mbGFncyA9IChjdXJyZW50LmZsYWdzICYgLTMpIHwgNDA5NiksXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChuZXh0UHJvcHMgPT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gKGN1cnJlbnQgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICA6IGlzSHlkcmF0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVIb2lzdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZ2V0UmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gcmVxdWlyZWRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyKSksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHByZXZTaWJsaW5nKSkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50IHx8IGlzSHlkcmF0aW5nXG4gICAgICAgICAgICAgICAgPyByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAoKG5leHRQcm9wcyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIXByZXZTaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAgICgobmV4dFN0YXRlID0gY2FuSHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKChuZXh0UHJvcHMgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUod29ya0luUHJvZ3Jlc3MsIDApLnNlcnZlclByb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRTdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9ICEwKSlcbiAgICAgICAgICAgICAgICAgIDogKG5leHRQcm9wcyA9ICExKSxcbiAgICAgICAgICAgICAgICAobmV4dFN0YXRlID0gIW5leHRQcm9wcykpLFxuICAgICAgICAgICAgICBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSkpLFxuICAgICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGwpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbmV4dFByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KHByZXZTaWJsaW5nLCBuZXh0UHJvcHMpXG4gICAgICAgICAgICAgID8gKHJldHVybkZpYmVyID0gbnVsbClcbiAgICAgICAgICAgICAgOiBudWxsICE9PSBuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChwcmV2U2libGluZywgbmV4dFN0YXRlKSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAzMiksXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICA/IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXZTaWJsaW5nKVxuICAgICAgICAgICAgICAgIDogKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmVuZGVyTGFuZXMpIHx8XG4gICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhMCkpXG4gICAgICAgICAgICAgICAgICA6IChyZXR1cm5GaWJlciA9ICExKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSAhcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAoY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIuZWZmZWN0RHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gcHJldlNpYmxpbmcudmFsdWUpLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiIGluIHByZXZTaWJsaW5nIHx8XG4gICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIHx8XG4gICAgICAgICAgICAgICgoaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/XCJcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHJldHVybkZpYmVyLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBwcmV2U2libGluZy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkEgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCB0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIHRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZWFkQ29udGV4dChwcmV2U2libGluZykpLFxuICAgICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gY2FsbENvbXBvbmVudEluREVWKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKChwcmV2U2libGluZyA9IHBlZWtDYWNoZUZyb21Qb29sKCkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3NSb290KSxcbiAgICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVDYWNoZSgpKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZSA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgICByZXRhaW5DYWNoZShuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZy5wb29sZWRDYWNoZUxhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IG5leHRQcm9wcykpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHByZXZTaWJsaW5nKSlcbiAgICAgICAgICAgICAgOiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykgJiZcbiAgICAgICAgICAgICAgICAgIChjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpKSxcbiAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZy5wYXJlbnQgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/ICgocHJldlNpYmxpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IG5leHRQcm9wcy5jYWNoZSksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBwcmV2U2libGluZy5jYWNoZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBbQ2FjaGVDb250ZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICAgICApKSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgdGhyb3cgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICtcbiAgICAgICAgICBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyAocHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlKSxcbiAgICAgICAgICBwdXNoKHJlbmRlcmVyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gY29udGV4dC5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbCkpXG4gICAgICAgIDogKHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dFZhbHVlKSxcbiAgICAgICAgICBwdXNoKHJlbmRlcmVyMkN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgdm9pZCAwICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICBudWxsICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICYmXG4gICAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0LCBwcm92aWRlckZpYmVyKSB7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgID8gKChjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWUpLFxuICAgICAgICAgIChjdXJyZW50VmFsdWUgPSByZW5kZXJlckN1cnNvckRFVi5jdXJyZW50KSxcbiAgICAgICAgICBwb3AocmVuZGVyZXJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBjdXJyZW50VmFsdWUpKVxuICAgICAgICA6ICgoY29udGV4dC5fY3VycmVudFZhbHVlMiA9IGN1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgKGN1cnJlbnRWYWx1ZSA9IHJlbmRlcmVyMkN1cnNvckRFVi5jdXJyZW50KSxcbiAgICAgICAgICBwb3AocmVuZGVyZXIyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgIHBhcmVudCxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgcHJvcGFnYXRpb25Sb290XG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyAmIHJlbmRlckxhbmVzKSAhPT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICA/ICgocGFyZW50LmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcykpXG4gICAgICAgICAgOiBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyAmIHJlbmRlckxhbmVzKSAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHByb3BhZ2F0aW9uUm9vdCkgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBwYXJlbnQgIT09IHByb3BhZ2F0aW9uUm9vdCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJvcGFnYXRpb24gcm9vdCB3aGVuIHNjaGVkdWxpbmcgY29udGV4dCB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjb250ZXh0cyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gZmliZXI7ICkge1xuICAgICAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcbiAgICAgICAgaWYgKG51bGwgIT09IGxpc3QpIHtcbiAgICAgICAgICB2YXIgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgbGlzdCA9IGxpc3QuZmlyc3RDb250ZXh0O1xuICAgICAgICAgIGE6IGZvciAoOyBudWxsICE9PSBsaXN0OyApIHtcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdDtcbiAgICAgICAgICAgIGxpc3QgPSBmaWJlcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gbGlzdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gZGVwZW5kZW5jeSAmJiAoZGVwZW5kZW5jeS5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgICAgICAgICAgIGxpc3QucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIHx8IChuZXh0RmliZXIgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ID0gZGVwZW5kZW5jeS5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgxOCA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXh0RmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJXZSBqdXN0IGNhbWUgZnJvbSBhIHBhcmVudCBzbyB3ZSBtdXN0IGhhdmUgaGFkIGEgcGFyZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG5leHRGaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgICAgICBsaXN0ID0gbmV4dEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSBsaXN0ICYmIChsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICAgICAgbmV4dEZpYmVyLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV4dEZpYmVyKSBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKG5leHRGaWJlciA9IGZpYmVyOyBudWxsICE9PSBuZXh0RmliZXI7ICkge1xuICAgICAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWJlciA9IG5leHRGaWJlci5zaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgICAgICAgICAgIGZpYmVyLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICkge1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgcGFyZW50ID0gd29ya0luUHJvZ3Jlc3MsIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITE7XG4gICAgICAgIG51bGwgIT09IHBhcmVudDtcblxuICAgICAgKSB7XG4gICAgICAgIGlmICghaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQpXG4gICAgICAgICAgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiA1MjQyODgpKSBpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCA9ICEwO1xuICAgICAgICAgIGVsc2UgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiAyNjIxNDQpKSBicmVhaztcbiAgICAgICAgaWYgKDEwID09PSBwYXJlbnQudGFnKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50LnR5cGU7XG4gICAgICAgICAgICBvYmplY3RJcyhwYXJlbnQucGVuZGluZ1Byb3BzLnZhbHVlLCBjdXJyZW50UGFyZW50LnZhbHVlKSB8fFxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gY3VycmVudC5wdXNoKGNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiAoY3VycmVudCA9IFtjb250ZXh0XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgPT09IGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCkge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRTdGF0ZS5tZW1vaXplZFN0YXRlICE9PVxuICAgICAgICAgICAgcGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyBjdXJyZW50LnB1c2goSG9zdFRyYW5zaXRpb25Db250ZXh0KVxuICAgICAgICAgICAgICA6IChjdXJyZW50ID0gW0hvc3RUcmFuc2l0aW9uQ29udGV4dF0pKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjYyMTQ0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudERlcGVuZGVuY2llcykge1xuICAgICAgZm9yIChcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuICAgICAgICBudWxsICE9PSBjdXJyZW50RGVwZW5kZW5jaWVzO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjdXJyZW50RGVwZW5kZW5jaWVzLmNvbnRleHQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMoXG4gICAgICAgICAgICBpc1ByaW1hcnlSZW5kZXJlciA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzLm1lbW9pemVkVmFsdWVcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MgJiYgKHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dCA9IG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gICAgICBudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAmJiBwcmVwYXJlVG9SZWFkQ29udGV4dChjb25zdW1lcik7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgID8gY29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgIDogY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgIGNvbnRleHQgPSB7IGNvbnRleHQ6IGNvbnRleHQsIG1lbW9pemVkVmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsIH07XG4gICAgICBpZiAobnVsbCA9PT0gbGFzdENvbnRleHREZXBlbmRlbmN5KSB7XG4gICAgICAgIGlmIChudWxsID09PSBjb25zdW1lcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgICApO1xuICAgICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0O1xuICAgICAgICBjb25zdW1lci5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3VtZXIuZmxhZ3MgfD0gNTI0Mjg4O1xuICAgICAgfSBlbHNlIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyTG9jYWwoKSxcbiAgICAgICAgZGF0YTogbmV3IE1hcCgpLFxuICAgICAgICByZWZDb3VudDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0YWluQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmV0YWluZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgY2FjaGUucmVmQ291bnQrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZUNhY2hlKGNhY2hlKSB7XG4gICAgICBjYWNoZS5yZWZDb3VudC0tO1xuICAgICAgMCA+IGNhY2hlLnJlZkNvdW50ICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkEgY2FjaGUgaW5zdGFuY2Ugd2FzIHJlbGVhc2VkIGFmdGVyIGl0IHdhcyBhbHJlYWR5IGZyZWVkLiBUaGlzIGxpa2VseSBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIDAgPT09IGNhY2hlLnJlZkNvdW50ICYmXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhY2hlLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWtDYWNoZUZyb21Qb29sKCkge1xuICAgICAgdmFyIGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciA9IHJlc3VtZWRDYWNoZS5jdXJyZW50O1xuICAgICAgcmV0dXJuIG51bGwgIT09IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA/IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdC5wb29sZWRDYWNoZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wpIHtcbiAgICAgIG51bGwgPT09IHByZXZDYWNoZVBvb2xcbiAgICAgICAgPyBwdXNoKHJlc3VtZWRDYWNoZSwgcmVzdW1lZENhY2hlLmN1cnJlbnQsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKVxuICAgICAgICA6IHB1c2gocmVzdW1lZENhY2hlLCBwcmV2Q2FjaGVQb29sLnBvb2wsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gICAgICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY2FjaGVGcm9tUG9vbFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB7XG4gICAgICAgICAgICBwYXJlbnQ6IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gICAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkKSByZXR1cm4gITE7XG4gICAgICBpZiAoMCAhPT0gKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiAxNikpIHJldHVybiAhMDtcbiAgICAgIGZvciAoY3VycmVudCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzg3OCkgfHxcbiAgICAgICAgICAwICE9PSAoY3VycmVudC5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4oXG4gICAgICBwYXJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbilcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGU7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgNSA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgNiA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZ1xuICAgICAgICAgIClcbiAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgNCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZyB8fFxuICAgICAgICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnKVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGQucmV0dXJuID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUucmV0dXJuIHx8XG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zaWJsaW5nLnJldHVybiA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm47XG4gICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpXG4gICAgICAgIGZvciAodmFyIF9ub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IF9ub2RlOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gX25vZGUudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBfbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIF9ub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg2ID09PSBfbm9kZS50YWcpXG4gICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBfbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICBlbHNlIGlmICg0ICE9PSBfbm9kZS50YWcpXG4gICAgICAgICAgICBpZiAoMjIgPT09IF9ub2RlLnRhZyAmJiBudWxsICE9PSBfbm9kZS5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBfbm9kZS5jaGlsZCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiYgKGluc3RhbmNlLnJldHVybiA9IF9ub2RlKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIF9ub2RlLCAhMCwgITApO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gX25vZGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgX25vZGUuY2hpbGQucmV0dXJuID0gX25vZGU7XG4gICAgICAgICAgICAgIF9ub2RlID0gX25vZGUuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChfbm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBfbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBfbm9kZS5yZXR1cm4gfHwgX25vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgX25vZGUgPSBfbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ub2RlLnNpYmxpbmcucmV0dXJuID0gX25vZGUucmV0dXJuO1xuICAgICAgICAgIF9ub2RlID0gX25vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKFxuICAgICAgY29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSxcbiAgICAgIGlzSGlkZGVuXG4gICAgKSB7XG4gICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSlcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgICBpZiAoNSA9PT0gbm9kZS50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG5vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gbm9kZS50YWcpXG4gICAgICAgICAgICAoaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIG5vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIGluc3RhbmNlKTtcbiAgICAgICAgICBlbHNlIGlmICg0ICE9PSBub2RlLnRhZylcbiAgICAgICAgICAgIGlmICgyMiA9PT0gbm9kZS50YWcgJiYgbnVsbCAhPT0gbm9kZS5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBub2RlLmNoaWxkKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJiAoaW5zdGFuY2UucmV0dXJuID0gbm9kZSksXG4gICAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5vZGUubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBcIm1hbnVhbFwiID09PSBub2RlLm1lbW9pemVkUHJvcHMubW9kZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG51bGwgIT09IG5vZGUuY2hpbGQpIHtcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHJldHVybjtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UgJiYgZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGN1cnJlbnQuY29udGFpbmVySW5mbyxcbiAgICAgICAgICBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7XG4gICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLCAhMSwgITEpO1xuICAgICAgICBjdXJyZW50LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0O1xuICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpIHtcbiAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKVxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGUsXG4gICAgICAgICAgX29sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGN1cnJlbnQgPSBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSkgfHxcbiAgICAgICAgICBfb2xkUHJvcHMgIT09IG5ld1Byb3BzXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIF9vbGRQcm9wcyA9IGNsb25lSW5zdGFuY2UoXG4gICAgICAgICAgICBjdXJyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgX29sZFByb3BzLFxuICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAhY3VycmVudCxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICAgIF9vbGRQcm9wcyA9PT0gY3VycmVudEluc3RhbmNlXG4gICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2UpXG4gICAgICAgICAgICA6IChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihcbiAgICAgICAgICAgICAgICBfb2xkUHJvcHMsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHRcbiAgICAgICAgICAgICAgKSAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9vbGRQcm9wcyksXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGFwcGVuZEFsbENoaWxkcmVuKF9vbGRQcm9wcywgd29ya0luUHJvZ3Jlc3MsICExLCAhMSlcbiAgICAgICAgICAgICAgICA6IG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKG1heVN1c3BlbmRDb21taXQodHlwZSwgcHJvcHMpKSB7XG4gICAgICAgIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcykpKVxuICAgICAgICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgcmVzb3VyY2UpIHtcbiAgICAgIGlmIChtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQocmVzb3VyY2UpKSB7XG4gICAgICAgIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkpKVxuICAgICAgICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJldHJ5UXVldWUpIHtcbiAgICAgIG51bGwgIT09IHJldHJ5UXVldWUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgICAoKHJldHJ5UXVldWUgPVxuICAgICAgICAgIDIyICE9PSB3b3JrSW5Qcm9ncmVzcy50YWcgPyBjbGFpbU5leHRSZXRyeUxhbmUoKSA6IDUzNjg3MDkxMiksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyB8PSByZXRyeVF1ZXVlKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyB8PSByZXRyeVF1ZXVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gICAgICBpZiAoIWlzSHlkcmF0aW5nKVxuICAgICAgICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICAgICAgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7IG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjazsgKVxuICAgICAgICAgICAgICBudWxsICE9PSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2suYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IGxhc3RUYWlsTm9kZVxuICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgOiAobGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb2xsYXBzZWRcIjpcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gbGFzdFRhaWxOb2RlOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGxhc3RUYWlsTm9kZS5hbHRlcm5hdGUgJiYgKF9sYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUpLFxuICAgICAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUuc2libGluZyk7XG4gICAgICAgICAgICBudWxsID09PSBfbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIHx8IG51bGwgPT09IHJlbmRlclN0YXRlLnRhaWxcbiAgICAgICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgICAgICA6IChyZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsKVxuICAgICAgICAgICAgICA6IChfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWJibGVQcm9wZXJ0aWVzKGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIHZhciBkaWRCYWlsb3V0ID1cbiAgICAgICAgICBudWxsICE9PSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkLFxuICAgICAgICBuZXdDaGlsZExhbmVzID0gMCxcbiAgICAgICAgc3VidHJlZUZsYWdzID0gMDtcbiAgICAgIGlmIChkaWRCYWlsb3V0KVxuICAgICAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgdmFyIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uLFxuICAgICAgICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICAgIG51bGwgIT09IF9jaGlsZDI7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PSBfY2hpbGQyLmxhbmVzIHwgX2NoaWxkMi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgKF9jaGlsZDIgPSBfY2hpbGQyLnNpYmxpbmcpO1xuICAgICAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgICAgbnVsbCAhPT0gX3RyZWVCYXNlRHVyYXRpb247XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PVxuICAgICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbi5sYW5lcyB8IF90cmVlQmFzZUR1cmF0aW9uLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5mbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uLnJldHVybiA9IGNvbXBsZXRlZFdvcmspLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbi5zaWJsaW5nKTtcbiAgICAgIGVsc2UgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgX2NoaWxkMiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgICAgZm9yICh2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkOyBudWxsICE9PSBjaGlsZDsgKVxuICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9IGNoaWxkLmxhbmVzIHwgY2hpbGQuY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksXG4gICAgICAgICAgICAoX2NoaWxkMiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAgIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF9jaGlsZDI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgbnVsbCAhPT0gX3RyZWVCYXNlRHVyYXRpb247XG5cbiAgICAgICAgKVxuICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9XG4gICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbi5sYW5lcyB8IF90cmVlQmFzZUR1cmF0aW9uLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5zdWJ0cmVlRmxhZ3MpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5mbGFncyksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24ucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbi5zaWJsaW5nKTtcbiAgICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgICAgIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG4gICAgICByZXR1cm4gZGlkQmFpbG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChuZXdQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KTtcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCAmJlxuICAgICAgICAgICAgKChyZW5kZXJMYW5lcy5jb250ZXh0ID0gcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ID0gbnVsbCkpO1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IG51bGwgPT09IGN1cnJlbnQuY2hpbGQpXG4gICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgPyAoZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpLCBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgICAgICAgOiBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NikpIHx8XG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBoeWRyYXRpb25FcnJvcnMgJiZcbiAgICAgICAgICAgICAgICAgIChxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyksXG4gICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpKTtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICAgIHZhciBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgID8gKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgICA6IG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgID8gbmV4dFJlc291cmNlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgICAgID8gKG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTY3NzcyMTcpKVxuICAgICAgICAgICAgICAgIDogKHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgOiB1cGRhdGVIb3N0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgOiB1cGRhdGVIb3N0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgID8gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudClcbiAgICAgICAgICAgICAgICA6ICgoY3VycmVudCA9IHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCBuZXdQcm9wcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgICAgIDogKChuZXh0UmVzb3VyY2UgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IGNyZWF0ZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5leHRSZXNvdXJjZSwgd29ya0luUHJvZ3Jlc3MsICExLCAhMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5leHRSZXNvdXJjZSksXG4gICAgICAgICAgICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgICkgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uXG4gICAgICAgICAgICAgICAgPyByZW5kZXJMYW5lcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICA6IHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyAhPT0gbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gICAgICAgICAgICAgIG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKS5zZXJ2ZXJQcm9wcyA9IG5leHRSZXNvdXJjZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICkgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBuZXdQcm9wcyAmJiBudWxsICE9PSBuZXdQcm9wcy5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgPyBuZXh0UmVzb3VyY2UuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dFJlc291cmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgKChuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksXG4gICAgICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCksXG4gICAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9ICExO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgICAgIChxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSxcbiAgICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gITApO1xuICAgICAgICAgICAgaWYgKCFuZXh0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLCB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGwgIT09IG5ld1Byb3BzO1xuICAgICAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKChuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBuZXh0UmVzb3VyY2UgJiYgKG5ld1Byb3BzLmZsYWdzIHw9IDIwNDgpKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZC5mbGFncyB8PSA4MTkyKTtcbiAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICBuZXdQcm9wcyA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgcmV0dXJuRmliZXIgPSBuZXh0UmVzb3VyY2UucmVuZGVyaW5nO1xuICAgICAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgIGlmIChuZXdQcm9wcykgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcmV0dXJuRmliZXIudXBkYXRlUXVldWU7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzO1xuXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzKHJlbmRlckxhbmVzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgKHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmXG4gICAgICAgICAgICAgICAgICAgICAgICBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UudGFpbCAmJlxuICAgICAgICAgICAgICAgIG5vdyQxKCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyZXR1cm5GaWJlcikpLCBudWxsICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudCksXG4gICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICEwKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRSZXNvdXJjZS50YWlsICYmXG4gICAgICAgICAgICAgICAgICAgIFwiaGlkZGVuXCIgPT09IG5leHRSZXNvdXJjZS50YWlsTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmV0dXJuRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0h5ZHJhdGluZylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIDIgKiBub3ckMSgpIC0gbmV4dFJlc291cmNlLnJlbmRlcmluZ1N0YXJ0VGltZSA+XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAgICAgICA1MzY4NzA5MTIgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UuaXNCYWNrd2FyZHNcbiAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICA6ICgoY3VycmVudCA9IG5leHRSZXNvdXJjZS5sYXN0KSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICA/IChjdXJyZW50LnNpYmxpbmcgPSByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UubGFzdCA9IHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudWxsICE9PSBuZXh0UmVzb3VyY2UudGFpbClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gbmV4dFJlc291cmNlLnRhaWwpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnJlbmRlcmluZyA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnRhaWwgPSBjdXJyZW50LnNpYmxpbmcpLFxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdyQxKCkpLFxuICAgICAgICAgICAgICAoY3VycmVudC5zaWJsaW5nID0gbnVsbCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgPyAocmVuZGVyTGFuZXMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaykgfFxuICAgICAgICAgICAgICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrXG4gICAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSxcbiAgICAgICAgICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcG9wSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MilcbiAgICAgICAgICAgICAgOiBuZXdQcm9wcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICA/IDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgJiZcbiAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyAmIDYgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSlcbiAgICAgICAgICAgICAgOiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICBuZXdQcm9wcyAhPT0gcmVuZGVyTGFuZXMgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgK1xuICAgICAgICAgIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAgICAgMCAhPT0gKGN1cnJlbnQgJiA2NTUzNikgJiYgMCA9PT0gKGN1cnJlbnQgJiAxMjgpXG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5kZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaykge1xuICAgICAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrLnR5cGUsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wSGlkZGVuQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFByb2ZpbGUoY3VycmVudCkge1xuICAgICAgcmV0dXJuIChjdXJyZW50Lm1vZGUgJiAyKSAhPT0gTm9Nb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaG9va0ZsYWdzXG4gICAgKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoZmxhZ3MsIGZpbmlzaGVkV29yaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGxhc3RFZmZlY3QgPSBudWxsICE9PSB1cGRhdGVRdWV1ZSA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKHVwZGF0ZVF1ZXVlLnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChsYXN0RWZmZWN0ID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMCksXG4gICAgICAgICAgICAgIChsYXN0RWZmZWN0ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNhbGxDcmVhdGVJbkRFVixcbiAgICAgICAgICAgICAgICB1cGRhdGVRdWV1ZVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMSksXG4gICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKClcbiAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCksXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gbGFzdEVmZmVjdCAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBsYXN0RWZmZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBob29rTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaG9va05hbWUgPVxuICAgICAgICAgICAgICAgIDAgIT09ICh1cGRhdGVRdWV1ZS50YWcgJiBMYXlvdXQpXG4gICAgICAgICAgICAgICAgICA/IFwidXNlTGF5b3V0RWZmZWN0XCJcbiAgICAgICAgICAgICAgICAgIDogMCAhPT0gKHVwZGF0ZVF1ZXVlLnRhZyAmIEluc2VydGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBcInVzZUluc2VydGlvbkVmZmVjdFwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbGFzdEVmZmVjdFxuICAgICAgICAgICAgICAgICAgPyBcIiBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiB1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuXCJcbiAgICAgICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbGFzdEVmZmVjdC50aGVuXG4gICAgICAgICAgICAgICAgICAgID8gXCJcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgaG9va05hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiBJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0IGFuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBob29rTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIoKCkgPT4ge1xcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbiAgICAvLyBZb3UgY2FuIGF3YWl0IGhlcmVcXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuICAgIC8vIC4uLlxcbiAgfVxcbiAgZmV0Y2hEYXRhKCk7XFxufSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZ1wiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgWW91IHJldHVybmVkOiBcIiArIGxhc3RFZmZlY3Q7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAobiwgYSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCIlcyBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCB3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lc1wiLFxuICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaG9va05hbWUsXG4gICAgICAgICAgICAgICAgYWRkZW5kdW1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlICh1cGRhdGVRdWV1ZSAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgZmxhZ3MsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBsYXN0RWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKCh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgICAgICAgIHZhciBpbnN0ID0gdXBkYXRlUXVldWUuaW5zdCxcbiAgICAgICAgICAgICAgICBkZXN0cm95ID0gaW5zdC5kZXN0cm95O1xuICAgICAgICAgICAgICB2b2lkIDAgIT09IGRlc3Ryb3kgJiZcbiAgICAgICAgICAgICAgICAoKGluc3QuZGVzdHJveSA9IHZvaWQgMCksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICEwKSxcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNhbGxEZXN0cm95SW5ERVYsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgZGVzdHJveVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpXG4gICAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGhvb2tGbGFnc1xuICAgICkge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSB1cGRhdGVRdWV1ZSkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzLFxuICAgICAgICAgICAgdXBkYXRlUXVldWUsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyhpbnN0YW5jZSwgcHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENsYXNzU25hcHNob3QoZmluaXNoZWRXb3JrLCBjdXJyZW50KSB7XG4gICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgKGN1cnJlbnQucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgKSxcbiAgICAgICAgY3VycmVudC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICApKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXNvbHZlZFByZXZQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBzbmFwc2hvdCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjYWxsR2V0U25hcHNob3RCZWZvcmVVcGRhdGVzLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcmVzb2x2ZWRQcmV2UHJvcHMsXG4gICAgICAgICAgcHJldlN0YXRlXG4gICAgICAgICk7XG4gICAgICAgIHByZXZQcm9wcyA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICB2b2lkIDAgIT09IHNuYXBzaG90IHx8XG4gICAgICAgICAgcHJldlByb3BzLmhhcyhmaW5pc2hlZFdvcmsudHlwZSkgfHxcbiAgICAgICAgICAocHJldlByb3BzLmFkZChmaW5pc2hlZFdvcmsudHlwZSksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgY3VycmVudC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgIGN1cnJlbnQudHlwZSxcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICApO1xuICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBzaG91bGRQcm9maWxlKGN1cnJlbnQpXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFVixcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgICBpZiAobnVsbCAhPT0gcmVmKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIChmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZSkpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZWZcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcIlN0cmluZyByZWZzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkLlwiKVxuICAgICAgICAgICAgOiByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiBVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZWYuY3VycmVudCA9IGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5QXR0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIGNvbW1pdEF0dGFjaFJlZiwgY3VycmVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gICAgICB2YXIgcmVmID0gY3VycmVudC5yZWYsXG4gICAgICAgIHJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gICAgICBpZiAobnVsbCAhPT0gcmVmKVxuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmQ2xlYW51cClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWZDbGVhbnVwKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWZDbGVhbnVwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCksXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiYgKGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSlcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZiwgbnVsbCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmLCBudWxsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvciQzKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQzKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQcm9maWxlcihcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICBlZmZlY3REdXJhdGlvblxuICAgICkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcbiAgICAgICAgb25Db21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25Db21taXQ7XG4gICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25SZW5kZXI7XG4gICAgICBjdXJyZW50ID0gbnVsbCA9PT0gY3VycmVudCA/IFwibW91bnRcIiA6IFwidXBkYXRlXCI7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgJiYgKGN1cnJlbnQgPSBcIm5lc3RlZC11cGRhdGVcIik7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfZmluaXNoZWRXb3JrJG1lbW9pemUgJiZcbiAgICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplKFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgY29tbWl0U3RhcnRUaW1lXG4gICAgICAgICk7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvbkNvbW1pdCAmJlxuICAgICAgICBvbkNvbW1pdChcbiAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQcm9maWxlclBvc3RDb21taXRJbXBsKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvblxuICAgICkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgIGZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIuaWQ7XG4gICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblBvc3RDb21taXQ7XG4gICAgICBjdXJyZW50ID0gbnVsbCA9PT0gY3VycmVudCA/IFwibW91bnRcIiA6IFwidXBkYXRlXCI7XG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgJiYgKGN1cnJlbnQgPSBcIm5lc3RlZC11cGRhdGVcIik7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfZmluaXNoZWRXb3JrJG1lbW9pemUyICYmXG4gICAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0TW91bnQsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0VXBkYXRlKGZpbmlzaGVkV29yaywgbmV3UHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0VXBkYXRlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA1ID09PSBmaWJlci50YWcgfHxcbiAgICAgICAgMyA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIChzdXBwb3J0c1Jlc291cmNlcyA/IDI2ID09PSBmaWJlci50YWcgOiAhMSkgfHxcbiAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyA/IDI3ID09PSBmaWJlci50YWcgOiAhMSkgfHxcbiAgICAgICAgNCA9PT0gZmliZXIudGFnXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgICAgYTogZm9yICg7Oykge1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gZmliZXIuc2libGluZzsgKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLnJldHVybiB8fCBpc0hvc3RQYXJlbnQoZmliZXIucmV0dXJuKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmliZXIuc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgZmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgICAgICAgIDUgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIDYgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnMgPyAyNyAhPT0gZmliZXIudGFnIDogMSkgJiZcbiAgICAgICAgICAxOCAhPT0gZmliZXIudGFnO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChmaWJlci5mbGFncyAmIDIpIGNvbnRpbnVlIGE7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyLmNoaWxkIHx8IDQgPT09IGZpYmVyLnRhZykgY29udGludWUgYTtcbiAgICAgICAgICBlbHNlIChmaWJlci5jaGlsZC5yZXR1cm4gPSBmaWJlciksIChmaWJlciA9IGZpYmVyLmNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmaWJlci5mbGFncyAmIDIpKSByZXR1cm4gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAgICAgKG5vZGUgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgYmVmb3JlXG4gICAgICAgICAgICA/IGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZSwgYmVmb3JlKVxuICAgICAgICAgICAgOiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZSk7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgISg0ID09PSB0YWcgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gdGFnKSkgJiZcbiAgICAgICAgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpXG4gICAgICApXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgICAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICBiZWZvcmVcbiAgICAgICAgICAgID8gaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZSwgYmVmb3JlKVxuICAgICAgICAgICAgOiBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUpO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICEoNCA9PT0gdGFnIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgJiYgMjcgPT09IHRhZykpICYmXG4gICAgICAgICgobm9kZSA9IG5vZGUuY2hpbGQpLCBudWxsICE9PSBub2RlKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICAgIG51bGwgIT09IG5vZGU7XG5cbiAgICAgICAgKVxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAoIXN1cHBvcnRzU2luZ2xldG9ucyB8fCAyNyAhPT0gZmluaXNoZWRXb3JrLnRhZylcbiAgICAgICkge1xuICAgICAgICBhOiB7XG4gICAgICAgICAgZm9yICh2YXIgcGFyZW50ID0gZmluaXNoZWRXb3JrLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBwYXJlbnRGaWJlciwgcGFyZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgcGFyZW50RmliZXIuZmxhZ3MgJiAzMiAmJlxuICAgICAgICAgICAgICAocmVzZXRUZXh0Q29udGVudChwYXJlbnQpLCAocGFyZW50RmliZXIuZmxhZ3MgJj0gLTMzKSk7XG4gICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBwYXJlbnRGaWJlciwgcGFyZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICAgIHBhcmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgIHBvcnRhbCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIHBlbmRpbmdDaGlsZHJlblxuICAgICkge1xuICAgICAgcG9ydGFsID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICBwZW5kaW5nQ2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmlyc3RDaGlsZCkge1xuICAgICAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgZm9yIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChyb290ID0gbmV4dEVmZmVjdCksXG4gICAgICAgICAgKGZpcnN0Q2hpbGQgPSByb290LmNoaWxkKSxcbiAgICAgICAgICAwICE9PSAocm9vdC5zdWJ0cmVlRmxhZ3MgJiAxMDI4KSAmJiBudWxsICE9PSBmaXJzdENoaWxkKVxuICAgICAgICApXG4gICAgICAgICAgKGZpcnN0Q2hpbGQucmV0dXJuID0gcm9vdCksIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICBmaXJzdENoaWxkID0gcm9vdCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGZpcnN0Q2hpbGQuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmbGFncyA9IGZpcnN0Q2hpbGQuZmxhZ3M7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpcnN0Q2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIDAgIT09IChmbGFncyAmIDEwMjQpICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICBjb21taXRDbGFzc1NuYXBzaG90KGZpcnN0Q2hpbGQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgMCAhPT0gKGZsYWdzICYgMTAyNCkgJiZcbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKGZpcnN0Q2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICgwICE9PSAoZmxhZ3MgJiAxMDI0KSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RDaGlsZCA9IHJvb3Quc2libGluZztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIGZpcnN0Q2hpbGQucmV0dXJuID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSByb290LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICByb290ID0gc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xuICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gITE7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCB8IEhhc0VmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNClcbiAgICAgICAgICAgIGlmICgoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLCBudWxsID09PSBjdXJyZW50KSlcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkTW91bnQuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkUm9vdC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZFVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJiBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY3VycmVudCA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksIG51bGwgIT09IGZsYWdzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJldlByb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFdvcmsuY2hpbGQpXG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgcHJldlByb3BzID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvbiArPSBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMoY3VycmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmIGZsYWdzICYgNCAmJiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb24gKz0gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2UHJvcHMgPVxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgfHwgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgICAgICBjdXJyZW50ID1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4sXG4gICAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZQcm9wcztcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gY3VycmVudCkgJiZcbiAgICAgICAgICAgICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlblxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAoXCJtYW51YWxcIiA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZVxuICAgICAgICAgICAgICA/IHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pXG4gICAgICAgICAgICAgIDogc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiZcbiAgICAgICAgKChmaWJlci5hbHRlcm5hdGUgPSBudWxsKSwgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKSk7XG4gICAgICBmaWJlci5jaGlsZCA9IG51bGw7XG4gICAgICBmaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICA1ID09PSBmaWJlci50YWcgJiZcbiAgICAgICAgKChhbHRlcm5hdGUgPSBmaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGFsdGVybmF0ZSkpO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIHBhcmVudFxuICAgICkge1xuICAgICAgZm9yIChwYXJlbnQgPSBwYXJlbnQuY2hpbGQ7IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnQgPSBwYXJlbnQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZGVsZXRlZEZpYmVyXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnRcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgc3dpdGNoIChkZWxldGVkRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IHJlbGVhc2VSZXNvdXJjZShkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSlcbiAgICAgICAgICAgICAgOiBkZWxldGVkRmliZXIuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBudWxsKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaG9zdFBhcmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcilcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgIG51bGwgIT09IGhvc3RQYXJlbnQgJiZcbiAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXJcbiAgICAgICAgICAgICAgPyBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgID8gKChwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAocHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lciksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyKSlcbiAgICAgICAgICAgIDogKHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgICAgICBjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24sXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgTGF5b3V0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIChzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSxcbiAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJldkhvc3RQYXJlbnQuY29tcG9uZW50V2lsbFVubW91bnQgJiZcbiAgICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIHByZXZIb3N0UGFyZW50XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9XG4gICAgICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB8fFxuICAgICAgICAgICAgbnVsbCAhPT0gZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpKVxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSk7XG4gICAgICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlKSxcbiAgICAgICAgICAgIG51bGwgPT09IHJldHJ5Q2FjaGUgJiZcbiAgICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpLFxuICAgICAgICAgICAgcmV0cnlDYWNoZVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnRhZyArXG4gICAgICAgICAgICAgIFwiKS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCB3YWtlYWJsZXMpIHtcbiAgICAgIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICAgICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG4gICAgICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudClcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBpblByb2dyZXNzTGFuZXMgJiYgbnVsbCAhPT0gaW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMoaW5Qcm9ncmVzc1Jvb3QsIGluUHJvZ3Jlc3NMYW5lcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QkanNjb21wJDAsIHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsID09PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgfSBlbHNlIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgcm9vdCA9IGRlbGV0ZWRGaWJlcjtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IHJvb3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmIChyZXR1cm5GaWJlci5yZXR1cm4gPSBudWxsKTtcbiAgICAgICAgICByb290LnJldHVybiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIocGFyZW50RmliZXIsIHJvb3QkanNjb21wJDApLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgICBJbnNlcnRpb24gfCBIYXNFZmZlY3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVyblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIExheW91dCB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGZpbmlzaGVkV29yay5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPVxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCA/IGZsYWdzIDogY3VycmVudC5jb25jYXQoZmxhZ3MpKSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBob2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAgICgoZmxhZ3MgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbCksXG4gICAgICAgICAgICAgIChyb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyBudWxsID09PSByb290XG4gICAgICAgICAgICAgICAgICA/IG51bGwgPT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgPyAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGh5ZHJhdGVIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIDogbW91bnRIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGFjcXVpcmVSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICA6IGZsYWdzICE9PSByb290XG4gICAgICAgICAgICAgICAgICA/IChudWxsID09PSBmbGFnc1xuICAgICAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gY3VycmVudC5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubW91bnRIb2lzdGFibGUoY3VycmVudC5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgOiByZWxlYXNlUmVzb3VyY2UoZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByb290XG4gICAgICAgICAgICAgICAgICAgICAgPyBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IGFjcXVpcmVSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IG51bGwgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3VwcG9ydHNTaW5nbGV0b25zICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjbGVhclNpbmdsZXRvbihob2lzdGFibGVSb290KSxcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIDMyKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgcmVzZXRUZXh0Q29udGVudCwgcm9vdCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICgocm9vdCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcm9vdFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGZsYWdzICYgMTAyNCAmJlxuICAgICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITApLFxuICAgICAgICAgICAgICBcImZvcm1cIiAhPT0gZmluaXNoZWRXb3JrLnR5cGUgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGhvc3QgY29tcG9uZW50IHR5cGUuIEV4cGVjdGVkIGEgZm9ybS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0ICYmIHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IGZsYWdzO1xuICAgICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZmxhZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMoKSxcbiAgICAgICAgICAgICAgKHByb3BzID0gY3VycmVudEhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KHJvb3QuY29udGFpbmVySW5mbykpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByb3BzKSlcbiAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgcm9vdC5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICAgIGZsYWdzID0gcm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gcm9vdC5wZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZWVkc0Zvcm1SZXNldCAmJlxuICAgICAgICAgICAgKChuZWVkc0Zvcm1SZXNldCA9ICExKSwgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKGhvaXN0YWJsZVJvb3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKChjdXJyZW50ID0gY3VycmVudEhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gY3VycmVudCkpXG4gICAgICAgICAgICA6IChyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIHN1cHBvcnRzUGVyc2lzdGVuY2UgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBlbmRpbmdDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmNoaWxkLmZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSAhPT1cbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSAmJlxuICAgICAgICAgICAgKGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3ckMSgpKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgIGhvaXN0YWJsZVJvb3QgPSBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuLFxuICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9XG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCB3YXNIaWRkZW47XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuX2N1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgcm9vdC5fdmlzaWJpbGl0eSAmPSAtMztcbiAgICAgICAgICByb290Ll92aXNpYmlsaXR5IHw9IHJvb3QuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMjtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGFncyAmIDgxOTIgJiZcbiAgICAgICAgICAgICgocm9vdC5fdmlzaWJpbGl0eSA9IGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgPyByb290Ll92aXNpYmlsaXR5ICYgLTJcbiAgICAgICAgICAgICAgOiByb290Ll92aXNpYmlsaXR5IHwgMSksXG4gICAgICAgICAgICBob2lzdGFibGVSb290ICYmXG4gICAgICAgICAgICAgICgocm9vdCA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIHdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICAgIHJvb3QgfHxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspKSxcbiAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgICAgKG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJtYW51YWxcIiAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMubW9kZSkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYTogaWYgKCgoY3VycmVudCA9IG51bGwpLCBzdXBwb3J0c011dGF0aW9uKSlcbiAgICAgICAgICAgICAgZm9yIChyb290ID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIDUgPT09IHJvb3QudGFnIHx8XG4gICAgICAgICAgICAgICAgICAoc3VwcG9ydHNSZXNvdXJjZXMgJiYgMjYgPT09IHJvb3QudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gcm9vdC50YWcpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4gPSBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAocHJvcHMgPSB3YXNIaWRkZW4uc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVih3YXNIaWRkZW4sIGhpZGVJbnN0YW5jZSwgcHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICg2ID09PSByb290LnRhZykge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3YXNIaWRkZW4uc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICgoMjIgIT09IHJvb3QudGFnICYmIDIzICE9PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcm9vdC5tZW1vaXplZFN0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPT09IGZpbmlzaGVkV29yaykgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2hpbGRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJvb3QuY2hpbGQucmV0dXJuID0gcm9vdDtcbiAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmNoaWxkO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290ID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgZm9yICg7IG51bGwgPT09IHJvb3Quc2libGluZzsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gcm9vdC5yZXR1cm4gfHwgcm9vdC5yZXR1cm4gPT09IGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgICAgICAgIHJvb3Quc2libGluZy5yZXR1cm4gPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IGZsYWdzLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgKChmbGFncy5yZXRyeVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGN1cnJlbnQpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIGZsYWdzKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCBjb21taXRQbGFjZW1lbnQsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IC0zO1xuICAgICAgfVxuICAgICAgZmxhZ3MgJiA0MDk2ICYmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gLTQwOTcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVJlc2V0Rm9ybXMocGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI0KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgZmliZXIgPSBwYXJlbnRGaWJlcjtcbiAgICAgICAgICByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmliZXIpO1xuICAgICAgICAgIDUgPT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgICAgZmliZXIuZmxhZ3MgJiAxMDI0ICYmXG4gICAgICAgICAgICByZXNldEZvcm1JbnN0YW5jZShmaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhyb290LCBwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIHBhcmVudEZpYmVyLmFsdGVybmF0ZSwgcGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdEhpZGRlbkNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMuZWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKGZsYWdzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlcixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cy5lZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIHBhcmVudEZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChwcmV2aW91c0NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgIChjdXJyZW50ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgY3VycmVudCAhPT0gcHJldmlvdXNDYWNoZSAmJlxuICAgICAgICAobnVsbCAhPSBjdXJyZW50ICYmIHJldGFpbkNhY2hlKGN1cnJlbnQpLFxuICAgICAgICBudWxsICE9IHByZXZpb3VzQ2FjaGUgJiYgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICBmaW5pc2hlZFdvcmsgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHJldGFpbkNhY2hlKGZpbmlzaGVkV29yayksIG51bGwgIT0gY3VycmVudCAmJiByZWxlYXNlQ2FjaGUoY3VycmVudCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICApIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlIHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICgoY29tbWl0dGVkTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgKGNvbW1pdHRlZExhbmVzID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsgIT09IGNvbW1pdHRlZExhbmVzICYmXG4gICAgICAgICAgICAgIChyZXRhaW5DYWNoZShmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBudWxsICE9IGNvbW1pdHRlZExhbmVzICYmIHJlbGVhc2VDYWNoZShjb21taXR0ZWRMYW5lcykpKTtcbiAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAyMDQ4KSB7XG4gICAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogcHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSB8PSA0KSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpO1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyBfaW5zdGFuY2UyLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogKChfaW5zdGFuY2UyLl92aXNpYmlsaXR5IHw9IDQpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICBwYXJlbnRGaWJlclxuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IHN1c3BlbmRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogc3VzcGVuZEluc3RhbmNlKGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnICYmXG4gICAgICAgICAgICBzdXNwZW5kSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KFxuICAgICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICB9IGVsc2UgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBzdXNwZW5zZXlDb21taXRGbGFnKSxcbiAgICAgICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDE2Nzc3MjE2KSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpLFxuICAgICAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldmlvdXNIb2lzdGFibGVSb290KSlcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzRmliZXIgJiZcbiAgICAgICAgKChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIuY2hpbGQpLCBudWxsICE9PSBwYXJlbnRGaWJlcilcbiAgICAgICkge1xuICAgICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICAgICAgZG9cbiAgICAgICAgICAocHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHByZXZpb3VzRmliZXIpO1xuICAgICAgICB3aGlsZSAobnVsbCAhPT0gcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICAgICAgY2hpbGRUb0RlbGV0ZSxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5mbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgUGFzc2l2ZSB8IEhhc0VmZmVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICYgNCAmJlxuICAgICAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsucmV0dXJuIHx8IDEzICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZylcbiAgICAgICAgICAgID8gKChwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJj0gLTUpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QocGFyZW50RmliZXIpLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICBQYXNzaXZlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIDQgJiZcbiAgICAgICAgICAgICgoaW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gLTUpLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICBkZWxldGVkU3VidHJlZVJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3QsXG4gICAgICAgICAgY3VycmVudCA9IGZpYmVyO1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIFBhc3NpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiYgcmV0YWluQ2FjaGUoY3VycmVudCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIHJlbGVhc2VDYWNoZShjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIChjdXJyZW50LnJldHVybiA9IGZpYmVyKSwgKG5leHRFZmZlY3QgPSBjdXJyZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGE6IGZvciAoZmliZXIgPSBkZWxldGVkU3VidHJlZVJvb3Q7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHRFZmZlY3Q7XG4gICAgICAgICAgICB2YXIgc2libGluZyA9IGN1cnJlbnQuc2libGluZyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGZpYmVyKSB7XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgc2libGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgICAgIHZhciBtYXliZUZpYmVyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShob3N0Um9vdCk7XG4gICAgICBpZiAobnVsbCAhPSBtYXliZUZpYmVyKSB7XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgbWF5YmVGaWJlci5tZW1vaXplZFByb3BzW1wiZGF0YS10ZXN0bmFtZVwiXSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1heWJlRmliZXI7XG4gICAgICB9XG4gICAgICBob3N0Um9vdCA9IGZpbmRGaWJlclJvb3QoaG9zdFJvb3QpO1xuICAgICAgaWYgKG51bGwgPT09IGhvc3RSb290KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkNvdWxkIG5vdCBmaW5kIFJlYWN0IGNvbnRhaW5lciB3aXRoaW4gc3BlY2lmaWVkIGhvc3Qgc3VidHJlZS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGhvc3RSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXRjaFNlbGVjdG9yKGZpYmVyJGpzY29tcCQwLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHRhZyA9IGZpYmVyJGpzY29tcCQwLnRhZztcbiAgICAgIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgICAgICBpZiAoZmliZXIkanNjb21wJDAudHlwZSA9PT0gc2VsZWN0b3IudmFsdWUpIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci52YWx1ZTtcbiAgICAgICAgICAgIGZpYmVyJGpzY29tcCQwID0gW2ZpYmVyJGpzY29tcCQwLCAwXTtcbiAgICAgICAgICAgIGZvciAodGFnID0gMDsgdGFnIDwgZmliZXIkanNjb21wJDAubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgdmFyIGZpYmVyID0gZmliZXIkanNjb21wJDBbdGFnKytdLFxuICAgICAgICAgICAgICAgIHRhZyRqc2NvbXAkMCA9IGZpYmVyLnRhZyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvckluZGV4ID0gZmliZXIkanNjb21wJDBbdGFnKytdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yJGpzY29tcCQwID0gc2VsZWN0b3Jbc2VsZWN0b3JJbmRleF07XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoNSAhPT0gdGFnJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAyNiAhPT0gdGFnJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICAyNyAhPT0gdGFnJGpzY29tcCQwKSB8fFxuICAgICAgICAgICAgICAgICFpc0hpZGRlblN1YnRyZWUoZmliZXIpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICBudWxsICE9IHNlbGVjdG9yJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgICBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvciRqc2NvbXAkMCk7XG5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBzZWxlY3RvckluZGV4KyssXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3RvciRqc2NvbXAkMCA9IHNlbGVjdG9yW3NlbGVjdG9ySW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgICAgICAgICAgZmliZXIkanNjb21wJDAucHVzaChmaWJlciwgc2VsZWN0b3JJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdG9yID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpICYmXG4gICAgICAgICAgICBtYXRjaEFjY2Vzc2liaWxpdHlSb2xlKGZpYmVyJGpzY29tcCQwLnN0YXRlTm9kZSwgc2VsZWN0b3IudmFsdWUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoZmliZXIkanNjb21wJDAgPSBnZXRUZXh0Q29udGVudChmaWJlciRqc2NvbXAkMCkpLFxuICAgICAgICAgICAgICBudWxsICE9PSBmaWJlciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgIDAgPD0gZmliZXIkanNjb21wJDAuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChmaWJlciRqc2NvbXAkMCA9IGZpYmVyJGpzY29tcCQwLm1lbW9pemVkUHJvcHNbXCJkYXRhLXRlc3RuYW1lXCJdKSxcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGZpYmVyJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgZmliZXIkanNjb21wJDAudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IudmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcbiAgICAgIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHNlbGVjdG9yLnZhbHVlKSB8fCBcIlVua25vd25cIikgKyBcIj5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgXCJcIikgKyBcIilcIjtcbiAgICAgICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdbcm9sZT1cIicgKyBzZWxlY3Rvci52YWx1ZSArICdcIl0nO1xuICAgICAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1wiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiJztcbiAgICAgICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1tkYXRhLXRlc3RuYW1lPVwiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiXSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgdmFyIG1hdGNoaW5nRmliZXJzID0gW107XG4gICAgICByb290ID0gW3Jvb3QsIDBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHJvb3QubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gcm9vdFtpbmRleCsrXSxcbiAgICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgICAgc2VsZWN0b3JJbmRleCA9IHJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoNSAhPT0gdGFnICYmIDI2ICE9PSB0YWcgJiYgMjcgIT09IHRhZykgfHxcbiAgICAgICAgICAhaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKDsgbnVsbCAhPSBzZWxlY3RvciAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3Rvcik7IClcbiAgICAgICAgICAgIHNlbGVjdG9ySW5kZXgrKywgKHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdKTtcbiAgICAgICAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkgbWF0Y2hpbmdGaWJlcnMucHVzaChmaWJlcik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBudWxsICE9PSBmaWJlcjsgKVxuICAgICAgICAgICAgICByb290LnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoaW5nRmliZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgICAgIGhvc3RSb290ID0gZmluZFBhdGhzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgc2VsZWN0b3JzID0gW107XG4gICAgICBob3N0Um9vdCA9IEFycmF5LmZyb20oaG9zdFJvb3QpO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGhvc3RSb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBub2RlID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgdGFnID0gbm9kZS50YWc7XG4gICAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKVxuICAgICAgICAgIGlzSGlkZGVuU3VidHJlZShub2RlKSB8fCBzZWxlY3RvcnMucHVzaChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApXG4gICAgICAgICAgICBob3N0Um9vdC5wdXNoKG5vZGUpLCAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0b3JzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbW1pdFJvb3QoKSB7XG4gICAgICBzdXBwb3J0c1Rlc3RTZWxlY3RvcnMgJiZcbiAgICAgICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgICAgIHJldHVybiBjb21taXRIb29rKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAgICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gICAgICAgICAgPyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlRcbiAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCB8fFxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0IGFjdCguLi4pXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJlxuICAgICAgICAwICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgKVxuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiAtd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gdHJhbnNpdGlvblxuICAgICAgICA/ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzIHx8ICh0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpKSxcbiAgICAgICAgICB0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmFkZChmaWJlciksXG4gICAgICAgICAgKGZpYmVyID0gY3VycmVudEVudGFuZ2xlZExhbmUpLFxuICAgICAgICAgIDAgIT09IGZpYmVyID8gZmliZXIgOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSlcbiAgICAgICAgOiByZXNvbHZlVXBkYXRlUHJpb3JpdHkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdERlZmVycmVkTGFuZSgpIHtcbiAgICAgIDAgPT09IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICAgICAgPyBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpXG4gICAgICAgICAgICA6IDUzNjg3MDkxMik7XG4gICAgICB2YXIgc3VzcGVuc2VIYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlciAmJiAoc3VzcGVuc2VIYW5kbGVyLmZsYWdzIHw9IDMyKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcInVzZUluc2VydGlvbkVmZmVjdCBtdXN0IG5vdCBzY2hlZHVsZSB1cGRhdGVzLlwiKTtcbiAgICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyAmJiAoZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICEwKTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEpIHx8XG4gICAgICAgIG51bGwgIT09IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdFxuICAgICAgKVxuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKSxcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgbGFuZSk7XG4gICAgICBpZiAoXG4gICAgICAgIDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgJiZcbiAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290XG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzUmVuZGVyaW5nKVxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgcm9vdCA9XG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpKSB8fFxuICAgICAgICAgICAgICAgIFwiVW5rbm93blwiO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuaGFzKHJvb3QpIHx8XG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQocm9vdCksXG4gICAgICAgICAgICAgICAgKGZpYmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhIGRpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsIGZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyXCIsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICByb290XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciB8fFxuICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSAhMCkpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmUpLFxuICAgICAgICAgIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlciksXG4gICAgICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgICAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgJiZcbiAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCBmb3JjZVN5bmMpIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIpO1xuICAgICAgdmFyIHNob3VsZFRpbWVTbGljZSA9XG4gICAgICAgICAgKCFmb3JjZVN5bmMgJiZcbiAgICAgICAgICAgIDAgPT09IChsYW5lcyAmIDYwKSAmJlxuICAgICAgICAgICAgMCA9PT0gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpKSB8fFxuICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpLFxuICAgICAgICBleGl0U3RhdHVzID0gc2hvdWxkVGltZVNsaWNlXG4gICAgICAgICAgPyByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcylcbiAgICAgICAgICA6IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCAhMCksXG4gICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBzaG91bGRUaW1lU2xpY2U7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAhc2hvdWxkVGltZVNsaWNlICYmXG4gICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgMCwgITEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSlcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yY2VTeW5jID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ICYmXG4gICAgICAgICAgICAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZvcmNlU3luYylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgITEpO1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IGxhbmVzO1xuICAgICAgICAgICAgaWYgKHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJiByZW5kZXJXYXNDb25jdXJyZW50KVxuICAgICAgICAgICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTUzNjg3MDkxMyksXG4gICAgICAgICAgICAgICAgKGVycm9yUmV0cnlMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAwICE9PSBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJvclJldHJ5TGFuZXNcbiAgICAgICAgICAgICAgICAgICAgOiBlcnJvclJldHJ5TGFuZXMgJiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgICAgICA/IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgICAgIDogMCk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gZXJyb3JSZXRyeUxhbmVzKSB7XG4gICAgICAgICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuICAgICAgICAgICAgICAgIHZhciB3YXNSb290RGVoeWRyYXRlZCA9XG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkO1xuICAgICAgICAgICAgICAgIHdhc1Jvb3REZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAgICAgICAocHJlcGFyZUZyZXNoU3RhY2soXG4gICAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgKS5mbGFncyB8PSAyNTYpO1xuICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCA9IHJlbmRlclJvb3RTeW5jKFxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwICE9PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdhc1Jvb3REZWh5ZHJhdGVkXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyB8PVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGV4aXRTdGF0dXMgJiYgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhleGl0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgICAgICAgIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKTtcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlID0gcm9vdDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgICAgICAgICAgICBjYXNlIFJvb3RJblByb2dyZXNzOlxuICAgICAgICAgICAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICAgICAgICAgICAgaWYgKChsYW5lcyAmIDQxOTQxNzYpID09PSBsYW5lcykge1xuICAgICAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UuZmluaXNoZWRXb3JrID0gZm9yY2VTeW5jO1xuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSlcbiAgICAgICAgICAgICAgY29tbWl0Um9vdChcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICBJTU1FRElBVEVfQ09NTUlULFxuICAgICAgICAgICAgICAgIC0wLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGxhbmVzICYgNjI5MTQ1NjApID09PSBsYW5lcyAmJlxuICAgICAgICAgICAgICAgICgoZXhpdFN0YXR1cyA9XG4gICAgICAgICAgICAgICAgICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICtcbiAgICAgICAgICAgICAgICAgIEZBTExCQUNLX1RIUk9UVExFX01TIC1cbiAgICAgICAgICAgICAgICAgIG5vdyQxKCkpLFxuICAgICAgICAgICAgICAgIDEwIDwgZXhpdFN0YXR1cylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IGdldE5leHRMYW5lcyhzaG91bGRUaW1lU2xpY2UsIDApKSBicmVhayBhO1xuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZS50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeS5iaW5kKFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgICAgICBUSFJPVFRMRURfQ09NTUlULFxuICAgICAgICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAgIElNTUVESUFURV9DT01NSVQsXG4gICAgICAgICAgICAgICAgLTAsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnNcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnMpXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgbGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcbiAgICAgIGlmIChzdWJ0cmVlRmxhZ3MgJiA4MTkyIHx8IDE2Nzg1NDA4ID09PSAoc3VidHJlZUZsYWdzICYgMTY3ODU0MDgpKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpLFxuICAgICAgICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpbmlzaGVkV29yayksXG4gICAgICAgICAgKGZpbmlzaGVkV29yayA9IHdhaXRGb3JDb21taXRUb0JlUmVhZHkoKSksXG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrKVxuICAgICAgICApIHtcbiAgICAgICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBmaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICBjb21taXRSb290LmJpbmQoXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICBTVVNQRU5ERURfQ09NTUlULFxuICAgICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICAhZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNvbW1pdFJvb3QoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICAgICAgZm9yICh2YXIgbm9kZSA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKDAgPT09IHRhZyB8fCAxMSA9PT0gdGFnIHx8IDE1ID09PSB0YWcpICYmXG4gICAgICAgICAgbm9kZS5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICAgKCh0YWcgPSBub2RlLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICBudWxsICE9PSB0YWcgJiYgKCh0YWcgPSB0YWcuc3RvcmVzKSwgbnVsbCAhPT0gdGFnKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSB0YWdbaV0sXG4gICAgICAgICAgICAgIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICBjaGVjayA9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhnZXRTbmFwc2hvdCgpLCBjaGVjaykpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHRhZyA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIDE2Mzg0ICYmIG51bGwgIT09IHRhZylcbiAgICAgICAgICAodGFnLnJldHVybiA9IG5vZGUpLCAobm9kZSA9IHRhZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHJldHVybiAhMDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICByb290LFxuICAgICAgc3VzcGVuZGVkTGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXM7XG4gICAgICBzdXNwZW5kZWRMYW5lcyAmPSB+d29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXM7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7XG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZSAmJiAocm9vdC53YXJtTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXMpO1xuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgICAgIGZvciAodmFyIGxhbmVzID0gc3VzcGVuZGVkTGFuZXM7IDAgPCBsYW5lczsgKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVtpbmRleF0gPSAtMTtcbiAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICAwICE9PSBzcGF3bmVkTGFuZSAmJlxuICAgICAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgc3VzcGVuZGVkTGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN5bmNXb3JrKCkge1xuICAgICAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dFxuICAgICAgICA/IChmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSksICExKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKSB7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBOb3RTdXNwZW5kZWQpXG4gICAgICAgICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSxcbiAgICAgICAgICAgIHJlc2V0SG9va3NPblVud2luZChpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAgICAgKHRoZW5hYmxlU3RhdGUkMSA9IG51bGwpLFxuICAgICAgICAgICAgKHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwKSxcbiAgICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBpbnRlcnJ1cHRlZFdvcms7IClcbiAgICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZSwgaW50ZXJydXB0ZWRXb3JrKSxcbiAgICAgICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgdGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0ICYmXG4gICAgICAgICgocm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0KSwgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKSk7XG4gICAgICB0aW1lb3V0SGFuZGxlID0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0O1xuICAgICAgbnVsbCAhPT0gdGltZW91dEhhbmRsZSAmJlxuICAgICAgICAoKHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGwpLCB0aW1lb3V0SGFuZGxlKCkpO1xuICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB0aW1lb3V0SGFuZGxlID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gbGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9IGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPVxuICAgICAgICAgIDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPVxuICAgICAgICBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExO1xuICAgICAgMCAhPT0gKGxhbmVzICYgOCkgJiYgKGxhbmVzIHw9IGxhbmVzICYgMzIpO1xuICAgICAgdmFyIGFsbEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcztcbiAgICAgIGlmICgwICE9PSBhbGxFbnRhbmdsZWRMYW5lcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICByb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzLCBhbGxFbnRhbmdsZWRMYW5lcyAmPSBsYW5lcztcbiAgICAgICAgICAwIDwgYWxsRW50YW5nbGVkTGFuZXM7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihhbGxFbnRhbmdsZWRMYW5lcyksXG4gICAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgICBsYW5lcyB8PSByb290W2luZGV4XTtcbiAgICAgICAgICBhbGxFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgfVxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBsYW5lcztcbiAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MoKTtcbiAgICAgIHJldHVybiB0aW1lb3V0SGFuZGxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICAgIGlzUmVuZGVyaW5nID0gITE7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkltbWVkaWF0ZSkpXG4gICAgICAgIDogdGhyb3duVmFsdWUgPT09IFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvblxuICAgICAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbnN0YW5jZSkpXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgPyBTdXNwZW5kZWRPbkh5ZHJhdGlvblxuICAgICAgICAgICAgICAgIDogbnVsbCAhPT0gdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHRocm93blZhbHVlLnRoZW5cbiAgICAgICAgICAgICAgICAgID8gU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgICA6IFN1c3BlbmRlZE9uRXJyb3IpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICAgICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBpZiAobnVsbCA9PT0gZXJyb3JlZFdvcmspXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZCksXG4gICAgICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKGVycm9yZWRXb3JrLm1vZGUgJiAyICYmXG4gICAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKGVycm9yZWRXb3JrKSxcbiAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKFxuICAgICAgICAgICAgICAgIGVycm9yZWRXb3JrLFxuICAgICAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoXG4gICAgICAgICAgICAgICAgZXJyb3JlZFdvcmssXG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgcmV0dXJuIG51bGwgPT09IGhhbmRsZXJcbiAgICAgICAgPyAhMFxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpID09PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICA/IG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgID8gITBcbiAgICAgICAgICAgIDogITFcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSA9PT1cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyB8fFxuICAgICAgICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpXG4gICAgICAgICAgICA/IGhhbmRsZXIgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gcHJldkRpc3BhdGNoZXIgPyBDb250ZXh0T25seURpc3BhdGNoZXIgOiBwcmV2RGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgcmV0dXJuIHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyB8fFxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgIT09XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSB8fFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSAhMCk7XG4gICAgICAoMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyAmIDEzNDIxNzcyNykgJiZcbiAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzICYgMTM0MjE3NzI3KSkgfHxcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290IHx8XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgICBsYW5lcyA9ICExO1xuICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICBhOiBkb1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCAmJiAobGFuZXMgPSAhMCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdEluUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAocmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkNCkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDQpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICBsYW5lcyAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIrKztcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCksXG4gICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRVcGRhdGVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzOyApIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgICAgICBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpO1xuICAgICAgaWYgKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICAgICAgMCA8IG1lbW9pemVkVXBkYXRlcnMuc2l6ZSAmJlxuICAgICAgICAgICAgKHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpKTtcbiAgICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApXG4gICAgICAgICAgICBiOiBzd2l0Y2ggKFxuICAgICAgICAgICAgICAoKGxhbmVzID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAobWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRXJyb3I6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUpO1xuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy50aGVuKGxhbmVzLCBsYW5lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICBpc1RoZW5hYmxlUmVzb2x2ZWQobWVtb2l6ZWRVcGRhdGVycylcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsobGFuZXMpKVxuICAgICAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBob3N0RmliZXIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGhvc3RGaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBob3N0RmliZXIuc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaG9zdEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVVuaXRPZldvcmsocmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdHlwZSBvZiBmaWJlciB0cmlnZ2VyZWQgYSBzdXNwZW5zZXkgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuZGVkUmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICAgICAgPyB3b3JrTG9vcFN5bmMoKVxuICAgICAgICAgICAgOiB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUkNSkge1xuICAgICAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDUpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoMSk7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQoKSxcbiAgICAgICAgICBSb290SW5Qcm9ncmVzc1xuICAgICAgICApO1xuICAgICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDA7XG4gICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICB9XG4gICAgZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICFzaG91bGRZaWVsZCgpOyApXG4gICAgICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZTtcbiAgICAgICh1bml0T2ZXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlXG4gICAgICAgID8gKHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKSxcbiAgICAgICAgICAoY3VycmVudCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGJlZ2luV29yayxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKHVuaXRPZldvcmspKVxuICAgICAgICA6IChjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgYmVnaW5Xb3JrLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICAgICkpO1xuICAgICAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzID0gY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVih1bml0T2ZXb3JrLCByZXBsYXlCZWdpbldvcmssIHVuaXRPZldvcmspO1xuICAgICAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG4gICAgICBudWxsID09PSBuZXh0ID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIDogKHdvcmtJblByb2dyZXNzID0gbmV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxheUJlZ2luV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlLFxuICAgICAgICBpc1Byb2ZpbGluZ01vZGUgPSAodW5pdE9mV29yay5tb2RlICYgMikgIT09IE5vTW9kZTtcbiAgICAgIGlzUHJvZmlsaW5nTW9kZSAmJiBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICBzd2l0Y2ggKHVuaXRPZldvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjdXJyZW50ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHVuaXRPZldvcmsucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgdW5pdE9mV29yay50eXBlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGN1cnJlbnQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdW5pdE9mV29yay5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnR5cGUucmVuZGVyLFxuICAgICAgICAgICAgdW5pdE9mV29yay5yZWYsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspLFxuICAgICAgICAgICAgKHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyA9XG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3ModW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKSk7XG4gICAgICB9XG4gICAgICBpc1Byb2ZpbGluZ01vZGUgJiZcbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgcm9vdCxcbiAgICAgIHVuaXRPZldvcmssXG4gICAgICB0aHJvd25WYWx1ZSxcbiAgICAgIHN1c3BlbmRlZFJlYXNvblxuICAgICkge1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7XG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHRocm93ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksIGVycm9yKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgMzI3NjgpIHtcbiAgICAgICAgaWYgKGlzSHlkcmF0aW5nIHx8IHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25FcnJvcikgcm9vdCA9ICEwO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyB8fFxuICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgKVxuICAgICAgICAgIHJvb3QgPSAhMTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSByb290ID0gITApLFxuICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uSW1tZWRpYXRlIHx8XG4gICAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSlcbiAgICAgICAgKVxuICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24gPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgIG51bGwgIT09IHN1c3BlbmRlZFJlYXNvbiAmJlxuICAgICAgICAgICAgICAxMyA9PT0gc3VzcGVuZGVkUmVhc29uLnRhZyAmJlxuICAgICAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uLmZsYWdzIHw9IDE2Mzg0KTtcbiAgICAgICAgdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCByb290KTtcbiAgICAgIH0gZWxzZSBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDMyNzY4KSkge1xuICAgICAgICAgIHVud2luZFVuaXRPZldvcmsoXG4gICAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgdW5pdE9mV29yayA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIoY29tcGxldGVkV29yayk7XG4gICAgICAgIGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgIGNvbXBsZXRlV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBsZXRlZFdvcmsgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG4gICAgICAgIGlmIChudWxsICE9PSBjb21wbGV0ZWRXb3JrKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gY29tcGxldGVkV29yayk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmssIHNraXBTaWJsaW5ncykge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgbmV4dCA9IHVud2luZFdvcmsodW5pdE9mV29yay5hbHRlcm5hdGUsIHVuaXRPZldvcmspO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV4dCkge1xuICAgICAgICAgIG5leHQuZmxhZ3MgJj0gMzI3Njc7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHVuaXRPZldvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbih1bml0T2ZXb3JrKTtcbiAgICAgICAgICBuZXh0ID0gdW5pdE9mV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBmb3IgKHZhciBjaGlsZCA9IHVuaXRPZldvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApXG4gICAgICAgICAgICAobmV4dCArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiksIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHVuaXRPZldvcmsuYWN0dWFsRHVyYXRpb24gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIG5leHQgPSB1bml0T2ZXb3JrLnJldHVybjtcbiAgICAgICAgbnVsbCAhPT0gbmV4dCAmJlxuICAgICAgICAgICgobmV4dC5mbGFncyB8PSAzMjc2OCksXG4gICAgICAgICAgKG5leHQuc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKG5leHQuZGVsZXRpb25zID0gbnVsbCkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXNraXBTaWJsaW5ncyAmJlxuICAgICAgICAgICgodW5pdE9mV29yayA9IHVuaXRPZldvcmsuc2libGluZyksIG51bGwgIT09IHVuaXRPZldvcmspXG4gICAgICAgICkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdW5pdE9mV29yaztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrID0gbmV4dDtcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IHVuaXRPZldvcmspO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdChcbiAgICAgIHJvb3QsXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIGNvbW1pdFJvb3RJbXBsKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSxcbiAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Um9vdEltcGwoXG4gICAgICByb290LFxuICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICB0cmFuc2l0aW9ucyxcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXNcbiAgICApIHtcbiAgICAgIGRvIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHdoaWxlIChudWxsICE9PSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIik7XG4gICAgICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgPSByb290LmZpbmlzaGVkTGFuZXM7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgaWYgKG51bGwgPT09IGZpbmlzaGVkV29yaykgcmV0dXJuIG1hcmtDb21taXRTdG9wcGVkKCksIG51bGw7XG4gICAgICAwID09PSBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcInJvb3QuZmluaXNoZWRMYW5lcyBzaG91bGQgbm90IGJlIGVtcHR5IGR1cmluZyBhIGNvbW1pdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICAgICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgICAgIHZhciByZW1haW5pbmdMYW5lcyA9IGZpbmlzaGVkV29yay5sYW5lcyB8IGZpbmlzaGVkV29yay5jaGlsZExhbmVzO1xuICAgICAgcmVtYWluaW5nTGFuZXMgfD0gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xuICAgICAgbWFya1Jvb3RGaW5pc2hlZChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICByZW1haW5pbmdMYW5lcyxcbiAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICAgKTtcbiAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDApKTtcbiAgICAgICgwID09PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KSAmJlxuICAgICAgICAwID09PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTAyNTYpKSB8fFxuICAgICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyB8fFxuICAgICAgICAoKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITApLFxuICAgICAgICAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lcyksXG4gICAgICAgIChwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnMpLFxuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCEwKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpO1xuICAgICAgY29tbWl0U3RhcnRUaW1lID0gbm93KCk7XG4gICAgICB0cmFuc2l0aW9ucyA9IDAgIT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxNTk5MCk7XG4gICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDE1OTkwKSB8fCB0cmFuc2l0aW9uc1xuICAgICAgICA/ICgodHJhbnNpdGlvbnMgPSBSZWFjdFNoYXJlZEludGVybmFscy5UKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIChzcGF3bmVkTGFuZSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpKSxcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKHVwZGF0ZWRMYW5lcyA9IGV4ZWN1dGlvbkNvbnRleHQpLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQpLFxuICAgICAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGVcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQoXG4gICAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSxcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKSxcbiAgICAgICAgICByZXF1ZXN0UGFpbnQoKSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCA9IHVwZGF0ZWRMYW5lcyksXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHNwYXduZWRMYW5lKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHRyYW5zaXRpb25zKSlcbiAgICAgICAgOiAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKTtcbiAgICAgICh0cmFuc2l0aW9ucyA9IHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKVxuICAgICAgICA/ICgocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMSksXG4gICAgICAgICAgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdCksXG4gICAgICAgICAgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSlcbiAgICAgICAgOiAocmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcyksXG4gICAgICAgICAgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCkpO1xuICAgICAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIDAgPT09IHJlbWFpbmluZ0xhbmVzICYmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwpO1xuICAgICAgdHJhbnNpdGlvbnMgfHwgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpO1xuICAgICAgb25Db21taXRSb290JDEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCk7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByb290Lm1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICAgIG9uQ29tbWl0Um9vdCgpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgaWYgKG51bGwgIT09IHJlY292ZXJhYmxlRXJyb3JzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvciwgZmluaXNoZWRXb3JrID0gMDtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsgPCByZWNvdmVyYWJsZUVycm9ycy5sZW5ndGg7XG4gICAgICAgICAgZmluaXNoZWRXb3JrKytcbiAgICAgICAgKVxuICAgICAgICAgIChyZW1haW5pbmdMYW5lcyA9IHJlY292ZXJhYmxlRXJyb3JzW2ZpbmlzaGVkV29ya10pLFxuICAgICAgICAgICAgKHRyYW5zaXRpb25zID0gbWFrZUVycm9ySW5mbyhyZW1haW5pbmdMYW5lcy5zdGFjaykpLFxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgIHJlbWFpbmluZ0xhbmVzLnNvdXJjZSxcbiAgICAgICAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGFuZXMudmFsdWUsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgMCAhPT0gKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzICYgMykgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIDAgIT09IChkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgJiA0MTk0MjE4KSAmJlxuICAgICAgMCAhPT0gKHJlbWFpbmluZ0xhbmVzICYgNDIpXG4gICAgICAgID8gKChuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgcm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzXG4gICAgICAgICAgICA/IG5lc3RlZFVwZGF0ZUNvdW50KytcbiAgICAgICAgICAgIDogKChuZXN0ZWRVcGRhdGVDb3VudCA9IDApLCAocm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdCkpKVxuICAgICAgICA6IChuZXN0ZWRVcGRhdGVDb3VudCA9IDApO1xuICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlRXJyb3JJbmZvKGNvbXBvbmVudFN0YWNrKSB7XG4gICAgICBjb21wb25lbnRTdGFjayA9IHsgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29tcG9uZW50U3RhY2ssIFwiZGlnZXN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdZb3UgYXJlIGFjY2Vzc2luZyBcImRpZ2VzdFwiIGZyb20gdGhlIGVycm9ySW5mbyBvYmplY3QgcGFzc2VkIHRvIG9uUmVjb3ZlcmFibGVFcnJvci4gVGhpcyBwcm9wZXJ0eSBpcyBubyBsb25nZXIgcHJvdmlkZWQgYXMgcGFydCBvZiBlcnJvckluZm8gYnV0IGNhbiBiZSBhY2Nlc3NlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSBFcnJvciBpbnN0YW5jZSBpdHNlbGYuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gICAgICAwID09PSAocm9vdC5wb29sZWRDYWNoZUxhbmVzICY9IHJlbWFpbmluZ0xhbmVzKSAmJlxuICAgICAgICAoKHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wb29sZWRDYWNoZSksXG4gICAgICAgIG51bGwgIT0gcmVtYWluaW5nTGFuZXMgJiZcbiAgICAgICAgICAoKHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsKSwgcmVsZWFzZUNhY2hlKHJlbWFpbmluZ0xhbmVzKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAgICAgaWYgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICAgIHZhciByb290ID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMsXG4gICAgICAgICAgcmVtYWluaW5nTGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcztcbiAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwO1xuICAgICAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyksXG4gICAgICAgICAgcHJpb3JpdHkgPSAzMiA+IHJlbmRlclByaW9yaXR5ID8gMzIgOiByZW5kZXJQcmlvcml0eTtcbiAgICAgICAgcmVuZGVyUHJpb3JpdHkgPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKVxuICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuICAgICAgICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcm9vdCRqc2NvbXAkMCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLFxuICAgICAgICAgICAgICBsYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzO1xuICAgICAgICAgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xuICAgICAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PVxuICAgICAgICAgICAgICBOb0NvbnRleHRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMDtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMTtcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICAgICAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIocm9vdCRqc2NvbXAkMC5jdXJyZW50KTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgICAgICAgIHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICAgIHJvb3QkanNjb21wJDAuY3VycmVudCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICAgICAgICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290JGpzY29tcCQwKTtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKTtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHNcbiAgICAgICAgICAgICAgPyByb290JGpzY29tcCQwID09PSByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzXG4gICAgICAgICAgICAgICAgPyBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgICAgIDogKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdCRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgIDogKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApO1xuICAgICAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9XG4gICAgICAgICAgICAgICExO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCRqc2NvbXAkMCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSByb290JGpzY29tcCQwLmN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSByZW5kZXJQcmlvcml0eSksXG4gICAgICAgICAgICByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLnN0YXRlTm9kZSwgc291cmNlRmliZXIsIDIpO1xuICAgICAgcm9vdEZpYmVyID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHNvdXJjZUZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3RGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEocm9vdEZpYmVyLCAyKSwgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3RGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGVycm9yXG4gICAgKSB7XG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMTtcbiAgICAgIGlmICgzID09PSBzb3VyY2VGaWJlci50YWcpXG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yOyApIHtcbiAgICAgICAgICBpZiAoMyA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50YWcpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgICAgIGVycm9yID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSgyKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSBlbnF1ZXVlVXBkYXRlKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yLCAyKTtcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICAoaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbnN0YW5jZSwgMiksXG4gICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIFBvdGVudGlhbCBjYXVzZXMgaW5jbHVkZSBkZWxldGluZyB0aGUgc2FtZSBmaWJlciBtb3JlIHRoYW4gb25jZSwgY29tbWl0dGluZyBhbiBhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG5FcnJvciBtZXNzYWdlOlxcblxcbiVzXCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAgICAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICAgICAgaWYgKG51bGwgPT09IHBpbmdDYWNoZSkge1xuICAgICAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAodGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSkpLFxuICAgICAgICAgIHZvaWQgMCA9PT0gdGhyZWFkSURzICYmXG4gICAgICAgICAgICAoKHRocmVhZElEcyA9IG5ldyBTZXQoKSksIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcykpO1xuICAgICAgdGhyZWFkSURzLmhhcyhsYW5lcykgfHxcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMCksXG4gICAgICAgIHRocmVhZElEcy5hZGQobGFuZXMpLFxuICAgICAgICAocGluZ0NhY2hlID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB3YWtlYWJsZSwgbGFuZXMpKSxcbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyksXG4gICAgICAgIHdha2VhYmxlLnRoZW4ocGluZ0NhY2hlLCBwaW5nQ2FjaGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG4gICAgICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gICAgICBudWxsICE9PSBwaW5nQ2FjaGUgJiYgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gICAgICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbiAgICAgIHJvb3Qud2FybUxhbmVzICY9IH5waW5nZWRMYW5lcztcbiAgICAgIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiZcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgc3VzcGVuZGVkIHJlc291cmNlIGZpbmlzaGVkIGxvYWRpbmcgaW5zaWRlIGEgdGVzdCwgYnV0IHRoZSBldmVudCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG5hY3QoKCkgPT4ge1xcbiAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG59KTtcXG4vKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcblRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgaW4gdGhlIGJyb3dzZXIuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0XCJcbiAgICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiBwaW5nZWRMYW5lcykgPT09IHBpbmdlZExhbmVzICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICBub3ckMSgpIC0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA8IEZBTExCQUNLX1RIUk9UVExFX01TKVxuICAgICAgICAgID8gKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIHw9IHBpbmdlZExhbmVzKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwKSk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIDAgPT09IHJldHJ5TGFuZSAmJiAocmV0cnlMYW5lID0gY2xhaW1OZXh0UmV0cnlMYW5lKCkpO1xuICAgICAgYm91bmRhcnlGaWJlciA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgbnVsbCAhPT0gYm91bmRhcnlGaWJlciAmJlxuICAgICAgICAobWFya1Jvb3RVcGRhdGVkJDEoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSxcbiAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGJvdW5kYXJ5RmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShib3VuZGFyeUZpYmVyKSB7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgcmV0cnlMYW5lID0gMDtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICAgICAgdmFyIHJldHJ5TGFuZSA9IDA7XG4gICAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSBzdXNwZW5zZVN0YXRlICYmIChyZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZS5fcmV0cnlDYWNoZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBudWxsICE9PSByZXRyeUNhY2hlICYmIHJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgICAgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgaXNJblN0cmljdE1vZGVcbiAgICApIHtcbiAgICAgIGlmICgwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMzM1NjI2MjQpKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICBmaWJlciA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBmaWJlci50eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyID0gaXNJblN0cmljdE1vZGUgfHwgaXNTdHJpY3RNb2RlRmliZXI7XG4gICAgICAgICAgMjIgIT09IGZpYmVyLnRhZ1xuICAgICAgICAgICAgPyBmaWJlci5mbGFncyAmIDMzNTU0NDMyXG4gICAgICAgICAgICAgID8gaXNTdHJpY3RNb2RlRmliZXIgJiZcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAoZmliZXIubW9kZSAmIDY0KSA9PT0gTm9Nb2RlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogbnVsbCA9PT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAoaXNTdHJpY3RNb2RlRmliZXIgJiYgZmliZXIuZmxhZ3MgJiA4MTkyXG4gICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICBmaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogZmliZXIuc3VidHJlZUZsYWdzICYgMzM1NTQ0MzIgJiZcbiAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIocm9vdCwgZmliZXIpIHtcbiAgICAgIHZhciBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyA9XG4gICAgICAgIDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogITA7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpYmVyKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaWJlciksXG4gICAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKHJvb3QsIGZpYmVyLmFsdGVybmF0ZSwgZmliZXIsICExKSxcbiAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyAmJlxuICAgICAgICAgICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMocm9vdCwgZmliZXIsIDAsIG51bGwsICExKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpIHtcbiAgICAgIHZhciBkb3VibGVJbnZva2VFZmZlY3RzID0gITA7XG4gICAgICByb290LmN1cnJlbnQubW9kZSAmIDI0IHx8IChkb3VibGVJbnZva2VFZmZlY3RzID0gITEpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdC5jdXJyZW50LFxuICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAzID09PSB0YWcgfHxcbiAgICAgICAgICAxID09PSB0YWcgfHxcbiAgICAgICAgICAwID09PSB0YWcgfHxcbiAgICAgICAgICAxMSA9PT0gdGFnIHx8XG4gICAgICAgICAgMTQgPT09IHRhZyB8fFxuICAgICAgICAgIDE1ID09PSB0YWdcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGFnID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJSZWFjdENvbXBvbmVudFwiO1xuICAgICAgICAgIGlmIChudWxsICE9PSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXModGFnKSkgcmV0dXJuO1xuICAgICAgICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQodGFnKTtcbiAgICAgICAgICB9IGVsc2UgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW3RhZ10pO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgbW91bnRlZCB5ZXQuIFRoaXMgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgYSBzaWRlLWVmZmVjdCBpbiB5b3VyIHJlbmRlciBmdW5jdGlvbiB0aGF0IGFzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byB1c2VFZmZlY3QgaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSB7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJlxuICAgICAgICByb290Lm1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIHNjaGVkdWxpbmdGaWJlciwgbGFuZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFjdFF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWU7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gYWN0UXVldWVcbiAgICAgICAgPyAoYWN0UXVldWUucHVzaChjYWxsYmFjayksIGZha2VBY3RDYWxsYmFja05vZGUpXG4gICAgICAgIDogc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gICAgICBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpICYmXG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQW4gdXBkYXRlIHRvICVzIGluc2lkZSBhIHRlc3Qgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbldoZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSB3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuYWN0KCgpID0+IHtcXG4gIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxufSk7XFxuLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG5UaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIGluIHRoZSBicm93c2VyLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdFwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5ID8gdHlwZSA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSkgcmV0dXJuIHR5cGU7XG4gICAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGZhbWlseVxuICAgICAgICA/IG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IHR5cGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlLnJlbmRlciAmJlxuICAgICAgICAgICgoZmFtaWx5ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKSksXG4gICAgICAgICAgdHlwZS5yZW5kZXIgIT09IGZhbWlseSlcbiAgICAgICAgICA/ICgoZmFtaWx5ID0geyAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSwgcmVuZGVyOiBmYW1pbHkgfSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgKGZhbWlseS5kaXNwbGF5TmFtZSA9IHR5cGUuZGlzcGxheU5hbWUpLFxuICAgICAgICAgICAgZmFtaWx5KVxuICAgICAgICAgIDogdHlwZVxuICAgICAgICA6IGZhbWlseS5jdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsIGVsZW1lbnQpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gITE7XG4gICAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnR5cGU7XG4gICAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMSxcbiAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnQgJiYgbnVsbCAhPT0gZWxlbWVudFxuICAgICAgICAgICAgPyBlbGVtZW50LiQkdHlwZW9mXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZWxlbWVudCAmJiAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50XG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZWVkc0NvbXBhcmVGYW1pbGllcyAmJlxuICAgICAgICAoKGZpYmVyID0gcmVzb2x2ZUZhbWlseShwcmV2VHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGZpYmVyICYmIGZpYmVyID09PSByZXNvbHZlRmFtaWx5KGVsZW1lbnQpKVxuICAgICAgICA/ICEwXG4gICAgICAgIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gICAgICBudWxsICE9PSByZXNvbHZlRmFtaWx5ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgJiZcbiAgICAgICAgKG51bGwgPT09IGZhaWxlZEJvdW5kYXJpZXMgJiYgKGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgV2Vha1NldCgpKSxcbiAgICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgIGZpYmVyLFxuICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgc3RhbGVGYW1pbGllc1xuICAgICkge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGUsXG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpXG4gICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuXCIpO1xuICAgICAgdmFyIG5lZWRzUmVuZGVyID0gITE7XG4gICAgICB0eXBlID0gITE7XG4gICAgICBudWxsICE9PSBjYW5kaWRhdGVUeXBlICYmXG4gICAgICAgICgoY2FuZGlkYXRlVHlwZSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSkpLFxuICAgICAgICB2b2lkIDAgIT09IGNhbmRpZGF0ZVR5cGUgJiZcbiAgICAgICAgICAoc3RhbGVGYW1pbGllcy5oYXMoY2FuZGlkYXRlVHlwZSlcbiAgICAgICAgICAgID8gKHR5cGUgPSAhMClcbiAgICAgICAgICAgIDogdXBkYXRlZEZhbWlsaWVzLmhhcyhjYW5kaWRhdGVUeXBlKSAmJlxuICAgICAgICAgICAgICAoMSA9PT0gdGFnID8gKHR5cGUgPSAhMCkgOiAobmVlZHNSZW5kZXIgPSAhMCkpKSk7XG4gICAgICBudWxsICE9PSBmYWlsZWRCb3VuZGFyaWVzICYmXG4gICAgICAgIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHxcbiAgICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpKSAmJlxuICAgICAgICAodHlwZSA9ICEwKTtcbiAgICAgIHR5cGUgJiYgKGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICEwKTtcbiAgICAgIGlmICh0eXBlIHx8IG5lZWRzUmVuZGVyKVxuICAgICAgICAoYWx0ZXJuYXRlID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhbHRlcm5hdGUsIGZpYmVyLCAyKTtcbiAgICAgIG51bGwgPT09IGNoaWxkIHx8XG4gICAgICAgIHR5cGUgfHxcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgICAgbnVsbCAhPT0gc2libGluZyAmJlxuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIHNpYmxpbmcsXG4gICAgICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnNpYmxpbmcgPVxuICAgICAgICB0aGlzLmNoaWxkID1cbiAgICAgICAgdGhpcy5yZXR1cm4gPVxuICAgICAgICB0aGlzLnN0YXRlTm9kZSA9XG4gICAgICAgIHRoaXMudHlwZSA9XG4gICAgICAgIHRoaXMuZWxlbWVudFR5cGUgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIHRoaXMucmVmQ2xlYW51cCA9IHRoaXMucmVmID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICB0aGlzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXVlID1cbiAgICAgICAgdGhpcy5tZW1vaXplZFByb3BzID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc3VidHJlZUZsYWdzID0gdGhpcy5mbGFncyA9IDA7XG4gICAgICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkTGFuZXMgPSB0aGlzLmxhbmVzID0gMDtcbiAgICAgIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTEuMTtcbiAgICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5fZGVidWdPd25lciA9IHRoaXMuX2RlYnVnSW5mbyA9IG51bGw7XG4gICAgICB0aGlzLl9kZWJ1Z05lZWRzUmVtb3VudCA9ICExO1xuICAgICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuICAgICAgaGFzQmFkTWFwUG9seWZpbGwgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIHx8XG4gICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhKCFDb21wb25lbnQgfHwgIUNvbXBvbmVudC5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICAgICAgY3VycmVudC50YWcsXG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICBjdXJyZW50LmtleSxcbiAgICAgICAgICAgIGN1cnJlbnQubW9kZVxuICAgICAgICAgICkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXIpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQpLFxuICAgICAgICAgIChjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMS4xKSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHBlbmRpbmdQcm9wcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCA9PT0gcGVuZGluZ1Byb3BzXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIGxhbmVzOiBwZW5kaW5nUHJvcHMubGFuZXMsXG4gICAgICAgICAgICAgIGZpcnN0Q29udGV4dDogcGVuZGluZ1Byb3BzLmZpcnN0Q29udGV4dCxcbiAgICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogcGVuZGluZ1Byb3BzLl9kZWJ1Z1RoZW5hYmxlU3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvID0gY3VycmVudC5fZGVidWdJbmZvO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gMzE0NTcyODI7XG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwKSlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgbGFuZXM6IHJlbmRlckxhbmVzLmxhbmVzLFxuICAgICAgICAgICAgICAgICAgZmlyc3RDb250ZXh0OiByZW5kZXJMYW5lcy5maXJzdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiByZW5kZXJMYW5lcy5fZGVidWdUaGVuYWJsZVN0YXRlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICBvd25lcixcbiAgICAgIG1vZGUsXG4gICAgICBsYW5lc1xuICAgICkge1xuICAgICAgdmFyIGZpYmVyVGFnID0gMCxcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gdHlwZTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgKGZpYmVyVGFnID0gMSksXG4gICAgICAgICAgKHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpKTtcbiAgICAgIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzdXBwb3J0c1Jlc291cmNlcyAmJiBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgICA/ICgoZmliZXJUYWcgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgIChmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUodHlwZSwgcGVuZGluZ1Byb3BzLCBmaWJlclRhZylcbiAgICAgICAgICAgICAgPyAyNlxuICAgICAgICAgICAgICA6IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSlcbiAgICAgICAgICAgICAgICA/IDI3XG4gICAgICAgICAgICAgICAgOiA1KSlcbiAgICAgICAgICA6IHN1cHBvcnRzUmVzb3VyY2VzXG4gICAgICAgICAgICA/ICgoZmliZXJUYWcgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgKGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGZpYmVyVGFnKVxuICAgICAgICAgICAgICAgID8gMjZcbiAgICAgICAgICAgICAgICA6IDUpKVxuICAgICAgICAgICAgOiAoZmliZXJUYWcgPSBzdXBwb3J0c1NpbmdsZXRvbnNcbiAgICAgICAgICAgICAgICA/IGlzSG9zdFNpbmdsZXRvblR5cGUodHlwZSlcbiAgICAgICAgICAgICAgICAgID8gMjdcbiAgICAgICAgICAgICAgICAgIDogNVxuICAgICAgICAgICAgICAgIDogNSk7XG4gICAgICBlbHNlXG4gICAgICAgIGE6IHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICAgIGZpYmVyVGFnID0gODtcbiAgICAgICAgICAgIG1vZGUgfD0gMjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodHlwZSA9IHBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgIChvd25lciA9IG1vZGUpLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgdHlwZS5pZCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdHlwZS5pZFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMiwgdHlwZSwga2V5LCBvd25lciB8IDIpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICAoa2V5LnN0YXRlTm9kZSA9IHsgZWZmZWN0RHVyYXRpb246IDAsIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMCB9KSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxMywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTksIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUpLFxuICAgICAgICAgICAgICAoa2V5LmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmIG51bGwgIT09IHR5cGUpXG4gICAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDE2O1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZSB8fFxuICAgICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gT2JqZWN0LmtleXModHlwZSkubGVuZ3RoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgICAgID8gKHBlbmRpbmdQcm9wcyA9IFwibnVsbFwiKVxuICAgICAgICAgICAgICA6IGlzQXJyYXlJbXBsKHR5cGUpXG4gICAgICAgICAgICAgICAgPyAocGVuZGluZ1Byb3BzID0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICAgICAgPyAoKHBlbmRpbmdQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIlVua25vd25cIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgICAgICAocmVzb2x2ZWRUeXBlID1cbiAgICAgICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgICAgIDogKHBlbmRpbmdQcm9wcyA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gb3duZXJcbiAgICAgICAgICAgICAgPyBcIm51bWJlclwiID09PSB0eXBlb2Ygb3duZXIudGFnXG4gICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKVxuICAgICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG93bmVyLm5hbWVcbiAgICAgICAgICAgICAgICAgID8gb3duZXIubmFtZVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGZpYmVyVGFnICYmXG4gICAgICAgICAgICAgIChyZXNvbHZlZFR5cGUgKz1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIGZpYmVyVGFnICsgXCJgLlwiKTtcbiAgICAgICAgICAgIGZpYmVyVGFnID0gMjk7XG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMgPSBFcnJvcihcbiAgICAgICAgICAgICAgXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAocGVuZGluZ1Byb3BzICsgXCIuXCIgKyByZXNvbHZlZFR5cGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAga2V5ID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgICAgIGtleS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICBrZXkudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgICAgIGtleS5sYW5lcyA9IGxhbmVzO1xuICAgICAga2V5Ll9kZWJ1Z093bmVyID0gb3duZXI7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBtb2RlID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICBlbGVtZW50LnR5cGUsXG4gICAgICAgIGVsZW1lbnQua2V5LFxuICAgICAgICBlbGVtZW50LnByb3BzLFxuICAgICAgICBlbGVtZW50Ll9vd25lcixcbiAgICAgICAgbW9kZSxcbiAgICAgICAgbGFuZXNcbiAgICAgICk7XG4gICAgICBtb2RlLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgICAgIGVsZW1lbnRzID0gY3JlYXRlRmliZXIoNywgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gICAgICBlbGVtZW50cy5sYW5lcyA9IGxhbmVzO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gICAgICBwZW5kaW5nUHJvcHMgPSBjcmVhdGVGaWJlcigyMiwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgICAgcGVuZGluZ1Byb3BzLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gICAgICBwZW5kaW5nUHJvcHMubGFuZXMgPSBsYW5lcztcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcbiAgICAgICAgX3Zpc2liaWxpdHk6IDEsXG4gICAgICAgIF9wZW5kaW5nVmlzaWJpbGl0eTogMSxcbiAgICAgICAgX3BlbmRpbmdNYXJrZXJzOiBudWxsLFxuICAgICAgICBfcmV0cnlDYWNoZTogbnVsbCxcbiAgICAgICAgX3RyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICBfY3VycmVudDogbnVsbCxcbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UsXG4gICAgICAgICAgICBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkNhbGxpbmcgT2Zmc2NyZWVuLmRldGFjaCBiZWZvcmUgaW5zdGFuY2UgaGFuZGxlIGhhcyBiZWVuIHNldC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMCA9PT0gKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5IHw9IDIpLFxuICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlLFxuICAgICAgICAgICAgZmliZXIgPSBpbnN0YW5jZS5fY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJDYWxsaW5nIE9mZnNjcmVlbi5kZXRhY2ggYmVmb3JlIGluc3RhbmNlIGhhbmRsZSBoYXMgYmVlbiBzZXQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDAgIT09IChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyKSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAoKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmPSAtMyksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBlbmRpbmdQcm9wcy5zdGF0ZU5vZGUgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZTtcbiAgICAgIHJldHVybiBwZW5kaW5nUHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIGNvbnRlbnQgPSBjcmVhdGVGaWJlcig2LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgICAgIGNvbnRlbnQubGFuZXMgPSBsYW5lcztcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICAgICAgbW9kZSA9IGNyZWF0ZUZpYmVyKFxuICAgICAgICA0LFxuICAgICAgICBudWxsICE9PSBwb3J0YWwuY2hpbGRyZW4gPyBwb3J0YWwuY2hpbGRyZW4gOiBbXSxcbiAgICAgICAgcG9ydGFsLmtleSxcbiAgICAgICAgbW9kZVxuICAgICAgKTtcbiAgICAgIG1vZGUubGFuZXMgPSBsYW5lcztcbiAgICAgIG1vZGUuc3RhdGVOb2RlID0ge1xuICAgICAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICAgICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICB0aGlzLnRhZyA9IDE7XG4gICAgICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICAgICAgdGhpcy5maW5pc2hlZFdvcmsgPVxuICAgICAgICB0aGlzLnBpbmdDYWNoZSA9XG4gICAgICAgIHRoaXMuY3VycmVudCA9XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkcmVuID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgdGhpcy5jYWxsYmFja05vZGUgPVxuICAgICAgICB0aGlzLm5leHQgPVxuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0ID1cbiAgICAgICAgdGhpcy5jb250ZXh0ID1cbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nQ29tbWl0ID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcCgtMSk7XG4gICAgICB0aGlzLmVudGFuZ2xlZExhbmVzID1cbiAgICAgICAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID1cbiAgICAgICAgdGhpcy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZmluaXNoZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuZXhwaXJlZExhbmVzID1cbiAgICAgICAgdGhpcy53YXJtTGFuZXMgPVxuICAgICAgICB0aGlzLnBpbmdlZExhbmVzID1cbiAgICAgICAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9XG4gICAgICAgIHRoaXMucGVuZGluZ0xhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcCgwKTtcbiAgICAgIHRoaXMuaGlkZGVuVXBkYXRlcyA9IGNyZWF0ZUxhbmVNYXAobnVsbCk7XG4gICAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICAgICAgdGhpcy5vblVuY2F1Z2h0RXJyb3IgPSBvblVuY2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uQ2F1Z2h0RXJyb3IgPSBvbkNhdWdodEVycm9yO1xuICAgICAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG4gICAgICB0aGlzLnBvb2xlZENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGVMYW5lcyA9IDA7XG4gICAgICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgICAgIHRoaXMuaW5jb21wbGV0ZVRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSB0aGlzLmVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgICBjb250YWluZXJJbmZvID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG4gICAgICBmb3IgKHRhZyA9IDA7IDMxID4gdGFnOyB0YWcrKykgY29udGFpbmVySW5mby5wdXNoKG5ldyBTZXQoKSk7XG4gICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gaHlkcmF0ZSA/IFwiaHlkcmF0ZVJvb3QoKVwiIDogXCJjcmVhdGVSb290KClcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGUsXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIGNvbnRhaW5lckluZm8gPSBuZXcgRmliZXJSb290Tm9kZShcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICBoeWRyYXRlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgZm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgdGFnID0gMTtcbiAgICAgICEwID09PSBpc1N0cmljdE1vZGUgJiYgKHRhZyB8PSAyNCk7XG4gICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiAodGFnIHw9IDIpO1xuICAgICAgaXNTdHJpY3RNb2RlID0gY3JlYXRlRmliZXIoMywgbnVsbCwgbnVsbCwgdGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8uY3VycmVudCA9IGlzU3RyaWN0TW9kZTtcbiAgICAgIGlzU3RyaWN0TW9kZS5zdGF0ZU5vZGUgPSBjb250YWluZXJJbmZvO1xuICAgICAgdGFnID0gY3JlYXRlQ2FjaGUoKTtcbiAgICAgIHJldGFpbkNhY2hlKHRhZyk7XG4gICAgICBjb250YWluZXJJbmZvLnBvb2xlZENhY2hlID0gdGFnO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGlzU3RyaWN0TW9kZS5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgICAgY2FjaGU6IHRhZ1xuICAgICAgfTtcbiAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZShpc1N0cmljdE1vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckluZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBpZiAoIXBhcmVudENvbXBvbmVudCkgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgIHBhcmVudENvbXBvbmVudCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lclN5bmMoXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIDAgPT09IGNvbnRhaW5lci50YWcgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgICAgY29udGFpbmVyLmN1cnJlbnQsXG4gICAgICAgIDIsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgcm9vdEZpYmVyLFxuICAgICAgbGFuZSxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3RcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCBjb250YWluZXIsIGVsZW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbnVsbCA9PT0gY29udGFpbmVyLmNvbnRleHRcbiAgICAgICAgPyAoY29udGFpbmVyLmNvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpXG4gICAgICAgIDogKGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpc1JlbmRlcmluZyAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzICYmXG4gICAgICAgICgoZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy5cIixcbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICkpO1xuICAgICAgY29udGFpbmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgY29udGFpbmVyLnBheWxvYWQgPSB7IGVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwID09PSBjYWxsYmFjayA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjayAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICksXG4gICAgICAgIChjb250YWluZXIuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgZWxlbWVudCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBjb250YWluZXIsIGxhbmUpO1xuICAgICAgbnVsbCAhPT0gZWxlbWVudCAmJlxuICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSksXG4gICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiBudWxsICE9PSBmaWJlci5kZWh5ZHJhdGVkKSB7XG4gICAgICAgIHZhciBhID0gZmliZXIucmV0cnlMYW5lO1xuICAgICAgICBmaWJlci5yZXRyeUxhbmUgPSAwICE9PSBhICYmIGEgPCByZXRyeUxhbmUgPyBhIDogcmV0cnlMYW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIChmaWJlciA9IGZpYmVyLmFsdGVybmF0ZSkgJiYgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExhbmVMYWJlbE1hcCgpIHtcbiAgICAgIGZvciAodmFyIG1hcCA9IG5ldyBNYXAoKSwgbGFuZSA9IDEsIGluZGV4ID0gMDsgMzEgPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICAgIG1hcC5zZXQobGFuZSwgbGFiZWwpO1xuICAgICAgICBsYW5lICo9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIChcInVzZSBzdHJpY3RcIik7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgU2NoZWR1bGVyID0gcmVxdWlyZShcInNjaGVkdWxlclwiKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnNjb3BlXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO1xuICAgIHZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnRyYWNpbmdfbWFya2VyXCIpO1xuICAgIHZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgY3VycmVudCA9IG51bGwsXG4gICAgICBpc1JlbmRlcmluZyA9ICExLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgcmVuZGVyZXJWZXJzaW9uID0gJCQkY29uZmlnLnJlbmRlcmVyVmVyc2lvbixcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWUgPSAkJCRjb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICAgIGV4dHJhRGV2VG9vbHNDb25maWcgPSAkJCRjb25maWcuZXh0cmFEZXZUb29sc0NvbmZpZyxcbiAgICAgIGdldFB1YmxpY0luc3RhbmNlID0gJCQkY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dCxcbiAgICAgIGdldENoaWxkSG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSAkJCRjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRjb25maWcucmVzZXRBZnRlckNvbW1pdCxcbiAgICAgIGNyZWF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZUluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gJCQkY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgc2NoZWR1bGVUaW1lb3V0ID0gJCQkY29uZmlnLnNjaGVkdWxlVGltZW91dCxcbiAgICAgIGNhbmNlbFRpbWVvdXQgPSAkJCRjb25maWcuY2FuY2VsVGltZW91dCxcbiAgICAgIG5vVGltZW91dCA9ICQkJGNvbmZpZy5ub1RpbWVvdXQsXG4gICAgICBpc1ByaW1hcnlSZW5kZXJlciA9ICQkJGNvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbiAgICAkJCRjb25maWcud2FybnNJZk5vdEFjdGluZztcbiAgICB2YXIgc3VwcG9ydHNNdXRhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c011dGF0aW9uLFxuICAgICAgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGNvbmZpZy5zdXBwb3J0c1BlcnNpc3RlbmNlLFxuICAgICAgc3VwcG9ydHNIeWRyYXRpb24gPSAkJCRjb25maWcuc3VwcG9ydHNIeWRyYXRpb24sXG4gICAgICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gJCQkY29uZmlnLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgJCQkY29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgICAkJCRjb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gICAgdmFyIHByZXBhcmVQb3J0YWxNb3VudCA9ICQkJGNvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG4gICAgJCQkY29uZmlnLnByZXBhcmVTY29wZVVwZGF0ZTtcbiAgICAkJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tU2NvcGU7XG4gICAgdmFyIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5zZXRDdXJyZW50VXBkYXRlUHJpb3JpdHksXG4gICAgICBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcuZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5LFxuICAgICAgcmVzb2x2ZVVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnJlc29sdmVVcGRhdGVQcmlvcml0eTtcbiAgICAkJCRjb25maWcucmVzb2x2ZUV2ZW50VHlwZTtcbiAgICAkJCRjb25maWcucmVzb2x2ZUV2ZW50VGltZVN0YW1wO1xuICAgIHZhciBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uID0gJCQkY29uZmlnLnNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24sXG4gICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRjb25maWcuZGV0YWNoRGVsZXRlZEluc3RhbmNlO1xuICAgICQkJGNvbmZpZy5yZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2s7XG4gICAgdmFyIG1heVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5U3VzcGVuZENvbW1pdCxcbiAgICAgIHByZWxvYWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5wcmVsb2FkSW5zdGFuY2UsXG4gICAgICBzdGFydFN1c3BlbmRpbmdDb21taXQgPSAkJCRjb25maWcuc3RhcnRTdXNwZW5kaW5nQ29tbWl0LFxuICAgICAgc3VzcGVuZEluc3RhbmNlID0gJCQkY29uZmlnLnN1c3BlbmRJbnN0YW5jZSxcbiAgICAgIHdhaXRGb3JDb21taXRUb0JlUmVhZHkgPSAkJCRjb25maWcud2FpdEZvckNvbW1pdFRvQmVSZWFkeSxcbiAgICAgIE5vdFBlbmRpbmdUcmFuc2l0aW9uID0gJCQkY29uZmlnLk5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0ID0gJCQkY29uZmlnLkhvc3RUcmFuc2l0aW9uQ29udGV4dCxcbiAgICAgIHJlc2V0Rm9ybUluc3RhbmNlID0gJCQkY29uZmlnLnJlc2V0Rm9ybUluc3RhbmNlLFxuICAgICAgYmluZFRvQ29uc29sZSA9ICQkJGNvbmZpZy5iaW5kVG9Db25zb2xlLFxuICAgICAgc3VwcG9ydHNNaWNyb3Rhc2tzID0gJCQkY29uZmlnLnN1cHBvcnRzTWljcm90YXNrcyxcbiAgICAgIHNjaGVkdWxlTWljcm90YXNrID0gJCQkY29uZmlnLnNjaGVkdWxlTWljcm90YXNrLFxuICAgICAgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkY29uZmlnLnN1cHBvcnRzVGVzdFNlbGVjdG9ycyxcbiAgICAgIGZpbmRGaWJlclJvb3QgPSAkJCRjb25maWcuZmluZEZpYmVyUm9vdCxcbiAgICAgIGdldEJvdW5kaW5nUmVjdCA9ICQkJGNvbmZpZy5nZXRCb3VuZGluZ1JlY3QsXG4gICAgICBnZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5nZXRUZXh0Q29udGVudCxcbiAgICAgIGlzSGlkZGVuU3VidHJlZSA9ICQkJGNvbmZpZy5pc0hpZGRlblN1YnRyZWUsXG4gICAgICBtYXRjaEFjY2Vzc2liaWxpdHlSb2xlID0gJCQkY29uZmlnLm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUsXG4gICAgICBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkY29uZmlnLnNldEZvY3VzSWZGb2N1c2FibGUsXG4gICAgICBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyID0gJCQkY29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsXG4gICAgICBhcHBlbmRDaGlsZCA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZCxcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGNvbW1pdFRleHRVcGRhdGUgPSAkJCRjb25maWcuY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGNvbW1pdE1vdW50ID0gJCQkY29uZmlnLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gJCQkY29uZmlnLmNvbW1pdFVwZGF0ZSxcbiAgICAgIGluc2VydEJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcbiAgICAgIHJlbW92ZUNoaWxkID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcixcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcucmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5oaWRlSW5zdGFuY2UsXG4gICAgICBoaWRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICB1bmhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVJbnN0YW5jZSxcbiAgICAgIHVuaGlkZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICBjbGVhckNvbnRhaW5lciA9ICQkJGNvbmZpZy5jbGVhckNvbnRhaW5lcixcbiAgICAgIGNsb25lSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVDb250YWluZXJDaGlsZHJlbixcbiAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5yZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICBjbG9uZUhpZGRlbkluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2UsXG4gICAgICBjbG9uZUhpZGRlblRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUhpZGRlblRleHRJbnN0YW5jZSxcbiAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyxcbiAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrID0gJCQkY29uZmlnLmlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrLFxuICAgICAgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzID1cbiAgICAgICAgJCQkY29uZmlnLmdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyxcbiAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5ID0gJCQkY29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5LFxuICAgICAgY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlciA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyLFxuICAgICAgaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyA9ICQkJGNvbmZpZy5pc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nID0gJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIgPVxuICAgICAgICAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPVxuICAgICAgICAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSA9XG4gICAgICAgICQkJGNvbmZpZy5nZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXIsXG4gICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlLFxuICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5ID0gJCQkY29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeSxcbiAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIgPVxuICAgICAgICAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcixcbiAgICAgIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzID1cbiAgICAgICAgJCQkY29uZmlnLnNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzLFxuICAgICAgZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyA9XG4gICAgICAgICQkJGNvbmZpZy5kaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzLFxuICAgICAgZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyxcbiAgICAgIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MgPVxuICAgICAgICAkJCRjb25maWcuZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyxcbiAgICAgIHZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSxcbiAgICAgIHN1cHBvcnRzUmVzb3VyY2VzID0gJCQkY29uZmlnLnN1cHBvcnRzUmVzb3VyY2VzLFxuICAgICAgaXNIb3N0SG9pc3RhYmxlVHlwZSA9ICQkJGNvbmZpZy5pc0hvc3RIb2lzdGFibGVUeXBlLFxuICAgICAgZ2V0SG9pc3RhYmxlUm9vdCA9ICQkJGNvbmZpZy5nZXRIb2lzdGFibGVSb290LFxuICAgICAgZ2V0UmVzb3VyY2UgPSAkJCRjb25maWcuZ2V0UmVzb3VyY2UsXG4gICAgICBhY3F1aXJlUmVzb3VyY2UgPSAkJCRjb25maWcuYWNxdWlyZVJlc291cmNlLFxuICAgICAgcmVsZWFzZVJlc291cmNlID0gJCQkY29uZmlnLnJlbGVhc2VSZXNvdXJjZSxcbiAgICAgIGh5ZHJhdGVIb2lzdGFibGUgPSAkJCRjb25maWcuaHlkcmF0ZUhvaXN0YWJsZSxcbiAgICAgIG1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLm1vdW50SG9pc3RhYmxlLFxuICAgICAgdW5tb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy51bm1vdW50SG9pc3RhYmxlLFxuICAgICAgY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UsXG4gICAgICBwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzID0gJCQkY29uZmlnLnByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMsXG4gICAgICBtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0LFxuICAgICAgcHJlbG9hZFJlc291cmNlID0gJCQkY29uZmlnLnByZWxvYWRSZXNvdXJjZSxcbiAgICAgIHN1c3BlbmRSZXNvdXJjZSA9ICQkJGNvbmZpZy5zdXNwZW5kUmVzb3VyY2UsXG4gICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgPSAkJCRjb25maWcuc3VwcG9ydHNTaW5nbGV0b25zLFxuICAgICAgcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIGNsZWFyU2luZ2xldG9uID0gJCQkY29uZmlnLmNsZWFyU2luZ2xldG9uLFxuICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLmFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICBpc0hvc3RTaW5nbGV0b25UeXBlID0gJCQkY29uZmlnLmlzSG9zdFNpbmdsZXRvblR5cGUsXG4gICAgICB2YWx1ZVN0YWNrID0gW107XG4gICAgdmFyIGZpYmVyU3RhY2sgPSBbXTtcbiAgICB2YXIgaW5kZXgkanNjb21wJDAgPSAtMSxcbiAgICAgIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuICAgIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbiAgICB2YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2ssXG4gICAgICBsb2ckMSA9IE1hdGgubG9nLFxuICAgICAgTE4yID0gTWF0aC5MTjIsXG4gICAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgsXG4gICAgICBuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCxcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMyA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgICAgY2FuY2VsQ2FsbGJhY2skMSA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxcbiAgICAgIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgICAgcmVxdWVzdFBhaW50ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3JlcXVlc3RQYWludCxcbiAgICAgIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIEltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICAgICAgVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgICBOb3JtYWxQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxcbiAgICAgIGxvZyA9IFNjaGVkdWxlci5sb2csXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSxcbiAgICAgIHJlbmRlcmVySUQgPSBudWxsLFxuICAgICAgaW5qZWN0ZWRIb29rID0gbnVsbCxcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBudWxsLFxuICAgICAgaGFzTG9nZ2VkRXJyb3IgPSAhMSxcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBmb3JrU3RhY2sgPSBbXSxcbiAgICAgIGZvcmtTdGFja0luZGV4ID0gMCxcbiAgICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsLFxuICAgICAgdHJlZUZvcmtDb3VudCA9IDAsXG4gICAgICBpZFN0YWNrID0gW10sXG4gICAgICBpZFN0YWNrSW5kZXggPSAwLFxuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IG51bGwsXG4gICAgICB0cmVlQ29udGV4dElkID0gMSxcbiAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBcIlwiLFxuICAgICAgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBuZWVkc0VzY2FwaW5nID0gL1tcIicmPD5cXG5cXHRdfF5cXHN8XFxzJC8sXG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwsXG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCxcbiAgICAgIGlzSHlkcmF0aW5nID0gITEsXG4gICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExLFxuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsLFxuICAgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSxcbiAgICAgIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiSHlkcmF0aW9uIE1pc21hdGNoIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gdXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApLFxuICAgICAgTm9Nb2RlID0gMCxcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXMgPSBbXSxcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDAsXG4gICAgICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSAwLFxuICAgICAgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSA9IC0wLFxuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMS4xLFxuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IC0wLFxuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gITEsXG4gICAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gITEsXG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSAhMSxcbiAgICAgIGlzRmx1c2hpbmdXb3JrID0gITEsXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IDAsXG4gICAgICBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgPSB7fSxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsLFxuICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDAsXG4gICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsLFxuICAgICAgVXBkYXRlU3RhdGUgPSAwLFxuICAgICAgUmVwbGFjZVN0YXRlID0gMSxcbiAgICAgIEZvcmNlVXBkYXRlID0gMixcbiAgICAgIENhcHR1cmVVcGRhdGUgPSAzLFxuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9ICExO1xuICAgIHZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICAgIHZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITEsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgICAgICAgcmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGRpc2NhcmRQZW5kaW5nV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9LFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSxcbiAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSB8fFxuICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgITAgIT09XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIDggJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChcbiAgICAgICAgICBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10pKTtcbiAgICAgIGlmICgwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUpIHtcbiAgICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgICAgMCA8IGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiBUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICkpO1xuICAgIH07XG4gICAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKSxcbiAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoXG4gICAgICBmaWJlcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICB2YXIgc3RyaWN0Um9vdCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBub2RlID0gZmliZXI7IG51bGwgIT09IG5vZGU7IClcbiAgICAgICAgbm9kZS5tb2RlICYgOCAmJiAoc3RyaWN0Um9vdCA9IG5vZGUpLCAobm9kZSA9IG5vZGUucmV0dXJuKTtcbiAgICAgIG51bGwgPT09IHN0cmljdFJvb3RcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKVxuICAgICAgICA6ICFkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSAmJlxuICAgICAgICAgICgobm9kZSA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCkpLFxuICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jb250ZXh0VHlwZXMgfHxcbiAgICAgICAgICAgIG51bGwgIT0gZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyB8fFxuICAgICAgICAgICAgKG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCkpICYmXG4gICAgICAgICAgKHZvaWQgMCA9PT0gbm9kZSAmJlxuICAgICAgICAgICAgKChub2RlID0gW10pLCBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIG5vZGUpKSxcbiAgICAgICAgICBub2RlLnB1c2goZmliZXIpKTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSkge1xuICAgICAgICBpZiAoMCAhPT0gZmliZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF0sXG4gICAgICAgICAgICB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIik7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmlyc3RGaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZS5cXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyB1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dFwiLFxuICAgICAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIHZhciBTdXNwZW5zZUV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgcmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSBgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG5UbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciBjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWBcIlxuICAgICAgKSxcbiAgICAgIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gdXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApLFxuICAgICAgbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQSBsaXN0ZW5lciB3YXMgdW5leHBlY3RlZGx5IGF0dGFjaGVkIHRvIGEgXCJub29wXCIgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsLFxuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMSxcbiAgICAgIGNhbGxDb21wb25lbnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgICAgICAgICB2YXIgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgICAgICAgaXNSZW5kZXJpbmcgPSAhMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudEluREVWID1cbiAgICAgICAgY2FsbENvbXBvbmVudFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxDb21wb25lbnQpLFxuICAgICAgY2FsbFJlbmRlciA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHdhc1JlbmRlcmluZyA9IGlzUmVuZGVyaW5nO1xuICAgICAgICAgIGlzUmVuZGVyaW5nID0gITA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaXNSZW5kZXJpbmcgPSB3YXNSZW5kZXJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbFJlbmRlckluREVWID0gY2FsbFJlbmRlcltcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxSZW5kZXIpLFxuICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrLCBpbnN0YW5jZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFViA9IGNhbGxDb21wb25lbnREaWRNb3VudFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRNb3VudCksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICBwcmV2U3RhdGUsXG4gICAgICAgICAgc25hcHNob3RcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgc25hcHNob3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYgPSBjYWxsQ29tcG9uZW50RGlkVXBkYXRlW1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZFVwZGF0ZSksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2ggPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZXJyb3JJbmZvKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2s6IG51bGwgIT09IHN0YWNrID8gc3RhY2sgOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFViA9IGNhbGxDb21wb25lbnREaWRDYXRjaFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRDYXRjaCksXG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViA9IGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnRXaWxsVW5tb3VudCksXG4gICAgICBjYWxsQ3JlYXRlID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG4gICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lmluc3Q7XG4gICAgICAgICAgY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIChlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ3JlYXRlSW5ERVYgPSBjYWxsQ3JlYXRlW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENyZWF0ZSksXG4gICAgICBjYWxsRGVzdHJveSA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBkZXN0cm95XG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsRGVzdHJveUluREVWID1cbiAgICAgICAgY2FsbERlc3Ryb3lbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsRGVzdHJveSksXG4gICAgICBjYWxsTGF6eUluaXQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChsYXp5KSB7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Ll9pbml0O1xuICAgICAgICAgIHJldHVybiBpbml0KGxhenkuX3BheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbExhenlJbml0SW5ERVYgPVxuICAgICAgICBjYWxsTGF6eUluaXRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsTGF6eUluaXQpLFxuICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbCxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwLFxuICAgICAgY3VycmVudERlYnVnSW5mbyA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXRNYXBzO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gKGRpZFdhcm5BYm91dE1hcHMgPSAhMSk7XG4gICAgdmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICAgIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcbiAgICB2YXIgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyA9IHt9O1xuICAgIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gY2hpbGQgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNoaWxkICYmXG4gICAgICAgIGNoaWxkLl9zdG9yZSAmJlxuICAgICAgICAoKCFjaGlsZC5fc3RvcmUudmFsaWRhdGVkICYmIG51bGwgPT0gY2hpbGQua2V5KSB8fFxuICAgICAgICAgIDIgPT09IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBjaGlsZC5fc3RvcmUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSAxO1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpLFxuICAgICAgICAgIGNvbXBvbmVudEtleSA9IGNvbXBvbmVudE5hbWUgfHwgXCJudWxsXCI7XG4gICAgICAgIGlmICghb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0pIHtcbiAgICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSA9ICEwO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX293bmVyO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBcIlwiO1xuICAgICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgcmV0dXJuRmliZXIudGFnICYmXG4gICAgICAgICAgICAoY29tcG9uZW50S2V5ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikpICYmXG4gICAgICAgICAgICAoY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9XG4gICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgY29tcG9uZW50S2V5ICsgXCJgLlwiKTtcbiAgICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIHx8XG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAoY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9XG4gICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICAgICAgXCI+LlwiKSk7XG4gICAgICAgICAgdmFyIGNoaWxkT3duZXJBcHBlbmRpeCA9IFwiXCI7XG4gICAgICAgICAgbnVsbCAhPSBjaGlsZCAmJlxuICAgICAgICAgICAgcmV0dXJuRmliZXIgIT09IGNoaWxkICYmXG4gICAgICAgICAgICAoKGNvbXBvbmVudE5hbWUgPSBudWxsKSxcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjaGlsZC50YWdcbiAgICAgICAgICAgICAgPyAoY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY2hpbGQpKVxuICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBjaGlsZC5uYW1lICYmIChjb21wb25lbnROYW1lID0gY2hpbGQubmFtZSksXG4gICAgICAgICAgICBjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgIChjaGlsZE93bmVyQXBwZW5kaXggPVxuICAgICAgICAgICAgICAgIFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY29tcG9uZW50TmFtZSArIFwiLlwiKSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyxcbiAgICAgICAgICAgICAgY2hpbGRPd25lckFwcGVuZGl4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoITApLFxuICAgICAgbW91bnRDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMSksXG4gICAgICBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBzaGVsbEJvdW5kYXJ5ID0gbnVsbCxcbiAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMSxcbiAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDIsXG4gICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApLFxuICAgICAgTm9GbGFncyA9IDAsXG4gICAgICBIYXNFZmZlY3QgPSAxLFxuICAgICAgSW5zZXJ0aW9uID0gMixcbiAgICAgIExheW91dCA9IDQsXG4gICAgICBQYXNzaXZlID0gOCxcbiAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O1xuICAgIHZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciByZW5kZXJMYW5lcyA9IDAsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbCxcbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGwsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMSxcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITEsXG4gICAgICBsb2NhbElkQ291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDAsXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbCxcbiAgICAgIGdsb2JhbENsaWVudElkQ291bnRlciA9IDAsXG4gICAgICBSRV9SRU5ERVJfTElNSVQgPSAyNSxcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbCxcbiAgICAgIGhvb2tUeXBlc0RldiA9IG51bGwsXG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xLFxuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSAhMTtcbiAgICB2YXIgY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGxhc3RFZmZlY3Q6IG51bGwsIGV2ZW50czogbnVsbCwgc3RvcmVzOiBudWxsLCBtZW1vQ2FjaGU6IG51bGwgfTtcbiAgICB9O1xuICAgIHZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gICAgICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSWQ6IHRocm93SW52YWxpZEhvb2tFcnJvclxuICAgIH07XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlTWVtb0NhY2hlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VBY3Rpb25TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICB2YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2hcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgdmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgdmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIG93bmVyID0gY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gb3duZXIgJiYgaXNSZW5kZXJpbmcgJiYgMSA9PT0gb3duZXIudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBvd25lci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gcmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCBuZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyByZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCBjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKSB8fCBcIkEgY29tcG9uZW50XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKGNvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHMpXG4gICAgICAgICAgICA/IGdldE5lYXJlc3RNb3VudGVkRmliZXIoY29tcG9uZW50KSA9PT0gY29tcG9uZW50XG4gICAgICAgICAgICA6ICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGluc3QpLFxuICAgICAgICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICAgICAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgICAgICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoaW5zdCwgbGFuZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgY2FsbGJhY2sgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoY2FsbGJhY2ssIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhjYWxsYmFjaywgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgY29tcG9uZW50TmFtZSA9IG51bGwsXG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGwsXG4gICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIFJlYWN0J3Mgc2VsZWN0aXZlIGh5ZHJhdGlvbiBmZWF0dXJlLiBJZiB0aGlzIGxlYWtzIGludG8gdXNlcnNwYWNlLCBpdCdzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKSxcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlcyA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbiAgICB2YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgICAgICAgZGVoeWRyYXRlZDogbnVsbCxcbiAgICAgICAgdHJlZUNvbnRleHQ6IG51bGwsXG4gICAgICAgIHJldHJ5TGFuZTogMFxuICAgICAgfSxcbiAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gITEsXG4gICAgICB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gICAgdmFyIHJlbmRlcmVyMkN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGwsXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsLFxuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExLFxuICAgICAgQWJvcnRDb250cm9sbGVyTG9jYWwgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgQWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgPyBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICAgICAgICAgIHNpZ25hbCA9ICh0aGlzLnNpZ25hbCA9IHtcbiAgICAgICAgICAgICAgICAgIGFib3J0ZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaWduYWwuYWJvcnRlZCA9ICEwO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgc2NoZWR1bGVDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgICBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgIENhY2hlQ29udGV4dCA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBudWxsLFxuICAgICAgICBfY3VycmVudFZhbHVlMjogbnVsbCxcbiAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyOiBudWxsLFxuICAgICAgICBfY3VycmVudFJlbmRlcmVyMjogbnVsbFxuICAgICAgfSxcbiAgICAgIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgICAgZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICBudWxsICE9PSBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICB9O1xuICAgIHZhciByZXN1bWVkQ2FjaGUgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG4gICAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9ICExLFxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9ICExLFxuICAgICAgbmVlZHNGb3JtUmVzZXQgPSAhMSxcbiAgICAgIFBvc3NpYmx5V2Vha1NldCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtTZXQgPyBXZWFrU2V0IDogU2V0LFxuICAgICAgbmV4dEVmZmVjdCA9IG51bGwsXG4gICAgICBpblByb2dyZXNzTGFuZXMgPSBudWxsLFxuICAgICAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gITEsXG4gICAgICBob3N0UGFyZW50ID0gbnVsbCxcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExLFxuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBudWxsLFxuICAgICAgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDgxOTIsXG4gICAgICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICAgICAgICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uIChyZXNvdXJjZVR5cGUpIHtcbiAgICAgICAgICB2YXIgY2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpLFxuICAgICAgICAgICAgY2FjaGVGb3JUeXBlID0gY2FjaGUuZGF0YS5nZXQocmVzb3VyY2VUeXBlKTtcbiAgICAgICAgICB2b2lkIDAgPT09IGNhY2hlRm9yVHlwZSAmJlxuICAgICAgICAgICAgKChjYWNoZUZvclR5cGUgPSByZXNvdXJjZVR5cGUoKSksXG4gICAgICAgICAgICBjYWNoZS5kYXRhLnNldChyZXNvdXJjZVR5cGUsIGNhY2hlRm9yVHlwZSkpO1xuICAgICAgICAgIHJldHVybiBjYWNoZUZvclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93bmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDT01QT05FTlRfVFlQRSA9IDAsXG4gICAgICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSAxLFxuICAgICAgUk9MRV9UWVBFID0gMixcbiAgICAgIFRFU1RfTkFNRV9UWVBFID0gMyxcbiAgICAgIFRFWFRfVFlQRSA9IDQ7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuZm9yKSB7XG4gICAgICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgICAgIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IuY29tcG9uZW50XCIpO1xuICAgICAgSEFTX1BTRVVET19DTEFTU19UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzc1wiKTtcbiAgICAgIFJPTEVfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnJvbGVcIik7XG4gICAgICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnRlc3RfaWRcIik7XG4gICAgICBURVhUX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci50ZXh0XCIpO1xuICAgIH1cbiAgICB2YXIgY29tbWl0SG9va3MgPSBbXSxcbiAgICAgIFBvc3NpYmx5V2Vha01hcCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwLFxuICAgICAgTm9Db250ZXh0ID0gMCxcbiAgICAgIFJlbmRlckNvbnRleHQgPSAyLFxuICAgICAgQ29tbWl0Q29udGV4dCA9IDQsXG4gICAgICBSb290SW5Qcm9ncmVzcyA9IDAsXG4gICAgICBSb290RmF0YWxFcnJvcmVkID0gMSxcbiAgICAgIFJvb3RFcnJvcmVkID0gMixcbiAgICAgIFJvb3RTdXNwZW5kZWQgPSAzLFxuICAgICAgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQsXG4gICAgICBSb290Q29tcGxldGVkID0gNSxcbiAgICAgIFJvb3REaWROb3RDb21wbGV0ZSA9IDYsXG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0LFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCxcbiAgICAgIE5vdFN1c3BlbmRlZCA9IDAsXG4gICAgICBTdXNwZW5kZWRPbkVycm9yID0gMSxcbiAgICAgIFN1c3BlbmRlZE9uRGF0YSA9IDIsXG4gICAgICBTdXNwZW5kZWRPbkltbWVkaWF0ZSA9IDMsXG4gICAgICBTdXNwZW5kZWRPbkluc3RhbmNlID0gNCxcbiAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUgPSA1LFxuICAgICAgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlID0gNixcbiAgICAgIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSA9IDcsXG4gICAgICBTdXNwZW5kZWRPbkh5ZHJhdGlvbiA9IDgsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCxcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITEsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICExLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITEsXG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3MsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9ICExLFxuICAgICAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDAsXG4gICAgICBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDMwMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eSxcbiAgICAgIFJFTkRFUl9USU1FT1VUX01TID0gNTAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGwsXG4gICAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwsXG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExLFxuICAgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSAwLFxuICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGwsXG4gICAgICBORVNURURfVVBEQVRFX0xJTUlUID0gNTAsXG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDAsXG4gICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbCxcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExLFxuICAgICAgSU1NRURJQVRFX0NPTU1JVCA9IDAsXG4gICAgICBTVVNQRU5ERURfQ09NTUlUID0gMSxcbiAgICAgIFRIUk9UVExFRF9DT01NSVQgPSAyLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGwsXG4gICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGZha2VBY3RDYWxsYmFja05vZGUgPSB7fSxcbiAgICAgIHJlc29sdmVGYW1pbHkgPSBudWxsLFxuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgdmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAgIG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gITA7XG4gICAgfVxuICAgIHZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG4gICAgdmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wcyA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGwsXG4gICAgICBzY2hlZHVsZVVwZGF0ZSA9IG51bGwsXG4gICAgICBzZXRFcnJvckhhbmRsZXIgPSBudWxsLFxuICAgICAgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKHBhdGggPSBjb3B5V2l0aFNldEltcGwoaWQubWVtb2l6ZWRTdGF0ZSwgcGF0aCwgMCwgdmFsdWUpKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAocGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChwYXRoID0gY29weVdpdGhEZWxldGVJbXBsKGlkLm1lbW9pemVkU3RhdGUsIHBhdGgsIDApKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAocGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChvbGRQYXRoID0gY29weVdpdGhSZW5hbWUoaWQubWVtb2l6ZWRTdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IG9sZFBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gb2xkUGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChvbGRQYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IG9sZFBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKG9sZFBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXRJbXBsKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIDAsIHZhbHVlKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZUltcGwoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgMCk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgcGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoXG4gICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIG9sZFBhdGgsXG4gICAgICAgIG5ld1BhdGhcbiAgICAgICk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgb2xkUGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBvbGRQYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihvbGRQYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgc2V0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZEVycm9ySW1wbCkge1xuICAgICAgc2hvdWxkRXJyb3JJbXBsID0gbmV3U2hvdWxkRXJyb3JJbXBsO1xuICAgIH07XG4gICAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG4gICAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICAgIH07XG4gICAgZXhwb3J0cy5hdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDY3MTA4ODY0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSxcbiAgICAgICAgICByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZpYmVyID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaWJlci5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhmaWJlci5wZW5kaW5nTGFuZXMpO1xuICAgICAgICAgICAgaWYgKDAgIT09IGxhbmVzKSB7XG4gICAgICAgICAgICAgIGZpYmVyLnBlbmRpbmdMYW5lcyB8PSAyO1xuICAgICAgICAgICAgICBmb3IgKGZpYmVyLmVudGFuZ2xlZExhbmVzIHw9IDI7IGxhbmVzOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IDEgPDwgKDMxIC0gY2x6MzIobGFuZXMpKTtcbiAgICAgICAgICAgICAgICBmaWJlci5lbnRhbmdsZW1lbnRzWzFdIHw9IGxhbmU7XG4gICAgICAgICAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGZpYmVyKTtcbiAgICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT1cbiAgICAgICAgICAgICAgICBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPVxuICAgICAgICAgICAgICAgICAgbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TKSxcbiAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAobGFuZXMgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgICAgIG51bGwgIT09IGxhbmVzICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihsYW5lcywgZmliZXIsIDIpLFxuICAgICAgICAgICAgZmx1c2hTeW5jV29yaygpLFxuICAgICAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb21wb25lbnRTZWxlY3RvciA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBDT01QT05FTlRfVFlQRSwgdmFsdWU6IGNvbXBvbmVudCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrc1xuICAgICkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICAhMSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IEhBU19QU0VVRE9fQ0xBU1NfVFlQRSwgdmFsdWU6IHNlbGVjdG9ycyB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBjYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4gPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgITAsXG4gICAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBpc1N0cmljdE1vZGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICAgICAgY29udGFpbmVySW5mbyA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICAgICAgdGFnID0gcmVxdWVzdFVwZGF0ZUxhbmUoY29udGFpbmVySW5mbyk7XG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MgPSBjcmVhdGVVcGRhdGUodGFnKTtcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcy5jYWxsYmFjayA9XG4gICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IG51bGw7XG4gICAgICBlbnF1ZXVlVXBkYXRlKGNvbnRhaW5lckluZm8sIGh5ZHJhdGlvbkNhbGxiYWNrcywgdGFnKTtcbiAgICAgIGluaXRpYWxDaGlsZHJlbi5jdXJyZW50LmxhbmVzID0gdGFnO1xuICAgICAgbWFya1Jvb3RVcGRhdGVkJDEoaW5pdGlhbENoaWxkcmVuLCB0YWcpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluaXRpYWxDaGlsZHJlbik7XG4gICAgICByZXR1cm4gaW5pdGlhbENoaWxkcmVuO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICB2YXIga2V5ID1cbiAgICAgICAgMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUkNikge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICBrZXlbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICAgIGtleS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgICBcIk9iamVjdFwiXG4gICAgICAgICksXG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICAgICAga2V5OiBudWxsID09IGtleSA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBST0xFX1RZUEUsIHZhbHVlOiByb2xlIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBURVNUX05BTUVfVFlQRSwgdmFsdWU6IGlkIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRleHRTZWxlY3RvciA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogVEVYVF9UWVBFLCB2YWx1ZTogdGV4dCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25DYXVnaHRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lXG4gICAgICAgICAgPyBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgICA6IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuXCIsXG4gICAgICAgIHJlY3JlYXRlTWVzc2FnZSA9XG4gICAgICAgICAgXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCB1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCBcIiArXG4gICAgICAgICAgKChlcnJvckJvdW5kYXJ5TmFtZSB8fCBcIkFub255bW91c1wiKSArIFwiLlwiKSxcbiAgICAgICAgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgIT0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogXCJcIjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IuZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgPyBiaW5kVG9Db25zb2xlKFxuICAgICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIiVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJlY3JlYXRlTWVzc2FnZVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICAgICkoKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlb1xcblxcbiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVNZXNzYWdlLFxuICAgICAgICAgICAgICByZWNyZWF0ZU1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmF1bHRPblVuY2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgZXJyb3IgPSBjb21wb25lbnROYW1lXG4gICAgICAgID8gXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCJcbiAgICAgICAgOiBcIkFuIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHMuXCI7XG4gICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgIT0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogXCJcIjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0YWNrO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBcIkNvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcblZpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmVycmVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMzIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbigpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICBmbihhLCBiLCBjLCBkKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5maW5kQWxsTm9kZXMgPSBmaW5kQWxsTm9kZXM7XG4gICAgZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgc2VsZWN0b3JzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgaG9zdFJvb3QgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKVxuICAgICAgICBob3N0Um9vdC5wdXNoKGdldEJvdW5kaW5nUmVjdChzZWxlY3RvcnNbaV0pKTtcbiAgICAgIGZvciAoc2VsZWN0b3JzID0gaG9zdFJvb3QubGVuZ3RoIC0gMTsgMCA8IHNlbGVjdG9yczsgc2VsZWN0b3JzLS0pIHtcbiAgICAgICAgaSA9IGhvc3RSb290W3NlbGVjdG9yc107XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHRhcmdldExlZnQgPSBpLngsXG4gICAgICAgICAgICB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyBpLndpZHRoLFxuICAgICAgICAgICAgdGFyZ2V0VG9wID0gaS55LFxuICAgICAgICAgICAgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0VG9wICsgaS5oZWlnaHQsXG4gICAgICAgICAgICBqID0gc2VsZWN0b3JzIC0gMTtcbiAgICAgICAgICAwIDw9IGo7XG4gICAgICAgICAgai0tXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoc2VsZWN0b3JzICE9PSBqKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJSZWN0ID0gaG9zdFJvb3Rbal0sXG4gICAgICAgICAgICAgIG90aGVyTGVmdCA9IG90aGVyUmVjdC54LFxuICAgICAgICAgICAgICBvdGhlclJpZ2h0ID0gb3RoZXJMZWZ0ICsgb3RoZXJSZWN0LndpZHRoLFxuICAgICAgICAgICAgICBvdGhlclRvcCA9IG90aGVyUmVjdC55LFxuICAgICAgICAgICAgICBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA+PSBvdGhlckxlZnQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0VG9wID49IG90aGVyVG9wICYmXG4gICAgICAgICAgICAgIHRhcmdldFJpZ2h0IDw9IG90aGVyUmlnaHQgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0Qm90dG9tIDw9IG90aGVyQm90dG9tXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ICE9PSBvdGhlckxlZnQgfHxcbiAgICAgICAgICAgICAgICBpLndpZHRoICE9PSBvdGhlclJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgICAgICBvdGhlckJvdHRvbSA8IHRhcmdldFRvcCB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9wID4gdGFyZ2V0Qm90dG9tXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvdGhlclRvcCA+IHRhcmdldFRvcCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LmhlaWdodCArPSBvdGhlclRvcCAtIHRhcmdldFRvcCksXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC55ID0gdGFyZ2V0VG9wKSk7XG4gICAgICAgICAgICAgIG90aGVyQm90dG9tIDwgdGFyZ2V0Qm90dG9tICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcCk7XG4gICAgICAgICAgICAgIGhvc3RSb290LnNwbGljZShzZWxlY3RvcnMsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgdGFyZ2V0VG9wICE9PSBvdGhlclRvcCB8fFxuICAgICAgICAgICAgICAgIGkuaGVpZ2h0ICE9PSBvdGhlclJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldExlZnQgfHxcbiAgICAgICAgICAgICAgICBvdGhlckxlZnQgPiB0YXJnZXRSaWdodFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3RoZXJMZWZ0ID4gdGFyZ2V0TGVmdCAmJlxuICAgICAgICAgICAgICAgICgob3RoZXJSZWN0LndpZHRoICs9IG90aGVyTGVmdCAtIHRhcmdldExlZnQpLFxuICAgICAgICAgICAgICAgIChvdGhlclJlY3QueCA9IHRhcmdldExlZnQpKTtcbiAgICAgICAgICAgICAgb3RoZXJSaWdodCA8IHRhcmdldFJpZ2h0ICYmXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0KTtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0Um9vdDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciBmaWJlciA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICBpZiAodm9pZCAwID09PSBmaWJlcikge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50LnJlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIGNvbXBvbmVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbihcIixcIik7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBjb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjb21wb25lbnQgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoY29tcG9uZW50LnN0YXRlTm9kZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBmaWJlciA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcbiAgICAgIGZpYmVyID1cbiAgICAgICAgbnVsbCAhPT0gZmliZXIgPyBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGZpYmVyKSA6IG51bGw7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZmliZXIgPyBudWxsIDogZ2V0UHVibGljSW5zdGFuY2UoZmliZXIuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZpYmVyID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscztcbiAgICAgIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnQucmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgY29tcG9uZW50ID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50ID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKG51bGwgPT09IGNvbXBvbmVudCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoY29tcG9uZW50Lm1vZGUgJiA4KSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNvbXBvbmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmliZXIubW9kZSAmIDhcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuIEluc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGVcIixcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCIlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiBJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlXCIsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb21wb25lbnQuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHM7XG4gICAgZXhwb3J0cy5mbHVzaFN5bmNGcm9tUmVjb25jaWxlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gMTtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICgoc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLCAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLCBmbikpXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmZsdXNoU3luY1dvcmsgPSBmbHVzaFN5bmNXb3JrO1xuICAgIGV4cG9ydHMuZm9jdXNXaXRoaW4gPSBmdW5jdGlvbiAoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgICAgIHNlbGVjdG9ycyA9IGZpbmRQYXRocyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIHNlbGVjdG9ycyA9IEFycmF5LmZyb20oc2VsZWN0b3JzKTtcbiAgICAgIGZvciAoaG9zdFJvb3QgPSAwOyBob3N0Um9vdCA8IHNlbGVjdG9ycy5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBzZWxlY3RvcnNbaG9zdFJvb3QrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnO1xuICAgICAgICBpZiAoIWlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZykgJiZcbiAgICAgICAgICAgIHNldEZvY3VzSWZGb2N1c2FibGUoZmliZXIuc3RhdGVOb2RlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChmaWJlciksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfTtcbiAgICBleHBvcnRzLmdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgdmFyIG1heFNlbGVjdG9ySW5kZXggPSAwLFxuICAgICAgICBtYXRjaGVkTmFtZXMgPSBbXTtcbiAgICAgIGhvc3RSb290ID0gW2ZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCksIDBdO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGhvc3RSb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IGhvc3RSb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgICBzZWxlY3RvckluZGV4ID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG4gICAgICAgIGlmICgoNSAhPT0gdGFnICYmIDI2ICE9PSB0YWcgJiYgMjcgIT09IHRhZykgfHwgIWlzSGlkZGVuU3VidHJlZShmaWJlcikpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSAmJlxuICAgICAgICAgICAgICAobWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikpLFxuICAgICAgICAgICAgICBzZWxlY3RvckluZGV4KyssXG4gICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4ICYmXG4gICAgICAgICAgICAgICAgKG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4KSksXG4gICAgICAgICAgICBzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aClcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgIGhvc3RSb290LnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGhvc3RSb290ID0gW107XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGg7XG4gICAgICAgICAgbWF4U2VsZWN0b3JJbmRleCsrXG4gICAgICAgIClcbiAgICAgICAgICBob3N0Um9vdC5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3JzW21heFNlbGVjdG9ySW5kZXhdKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgXCJmaW5kQWxsTm9kZXMgd2FzIGFibGUgdG8gbWF0Y2ggcGFydCBvZiB0aGUgc2VsZWN0b3I6XFxuICBcIiArXG4gICAgICAgICAgKG1hdGNoZWROYW1lcy5qb2luKFwiID4gXCIpICtcbiAgICAgICAgICAgIFwiXFxuXFxuTm8gbWF0Y2hpbmcgY29tcG9uZW50IHdhcyBmb3VuZCBmb3I6XFxuICBcIikgK1xuICAgICAgICAgIGhvc3RSb290LmpvaW4oXCIgPiBcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyLmNoaWxkKSByZXR1cm4gbnVsbDtcbiAgICAgIHN3aXRjaCAoY29udGFpbmVyLmNoaWxkLnRhZykge1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5pbmplY3RJbnRvRGV2VG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50ZXJuYWxzID0ge1xuICAgICAgICBidW5kbGVUeXBlOiAxLFxuICAgICAgICB2ZXJzaW9uOiByZW5kZXJlclZlcnNpb24sXG4gICAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IHJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdFNoYXJlZEludGVybmFscyxcbiAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICAgIHJlY29uY2lsZXJWZXJzaW9uOiBcIjE5LjAuMFwiXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gZXh0cmFEZXZUb29sc0NvbmZpZyAmJlxuICAgICAgICAoaW50ZXJuYWxzLnJlbmRlcmVyQ29uZmlnID0gZXh0cmFEZXZUb29sc0NvbmZpZyk7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGUgPSBvdmVycmlkZUhvb2tTdGF0ZTtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHMgPSBvdmVycmlkZVByb3BzO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDtcbiAgICAgIGludGVybmFscy5zY2hlZHVsZVVwZGF0ZSA9IHNjaGVkdWxlVXBkYXRlO1xuICAgICAgaW50ZXJuYWxzLnNldEVycm9ySGFuZGxlciA9IHNldEVycm9ySGFuZGxlcjtcbiAgICAgIGludGVybmFscy5zZXRTdXNwZW5zZUhhbmRsZXIgPSBzZXRTdXNwZW5zZUhhbmRsZXI7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVSZWZyZXNoID0gc2NoZWR1bGVSZWZyZXNoO1xuICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlUm9vdCA9IHNjaGVkdWxlUm9vdDtcbiAgICAgIGludGVybmFscy5zZXRSZWZyZXNoSGFuZGxlciA9IHNldFJlZnJlc2hIYW5kbGVyO1xuICAgICAgaW50ZXJuYWxzLmdldEN1cnJlbnRGaWJlciA9IGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzO1xuICAgICAgaW50ZXJuYWxzLmdldExhbmVMYWJlbE1hcCA9IGdldExhbmVMYWJlbE1hcDtcbiAgICAgIGludGVybmFscy5pbmplY3RQcm9maWxpbmdIb29rcyA9IGluamVjdFByb2ZpbGluZ0hvb2tzO1xuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc0FscmVhZHlSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0O1xuICAgIH07XG4gICAgZXhwb3J0cy5vYnNlcnZlVmlzaWJsZVJlY3RzID0gZnVuY3Rpb24gKFxuICAgICAgaG9zdFJvb3QsXG4gICAgICBzZWxlY3RvcnMsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2soKSB7XG4gICAgICAgIHZhciBuZXh0SW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgICAgaW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAwID4gbmV4dEluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpICYmIHVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV4dEluc3RhbmNlUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgMCA+IGluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpICYmIG9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBjYWxsYmFjayA9IHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW5zdGFuY2VSb290cywgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgdmFyIGRpc2Nvbm5lY3QgPSBjYWxsYmFjay5kaXNjb25uZWN0LFxuICAgICAgICBvYnNlcnZlID0gY2FsbGJhY2sub2JzZXJ2ZSxcbiAgICAgICAgdW5vYnNlcnZlID0gY2FsbGJhY2sudW5vYnNlcnZlO1xuICAgICAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjb21taXRIb29rcy5pbmRleE9mKGNvbW1pdEhvb2spO1xuICAgICAgICAgIDAgPD0gaW5kZXggJiYgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBkaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLnNob3VsZEVycm9yID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gc2hvdWxkRXJyb3JJbXBsKGZpYmVyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc2hvdWxkU3VzcGVuZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIHNob3VsZFN1c3BlbmRJbXBsKGZpYmVyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3RhcnRIb3N0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChcbiAgICAgIGZvcm1GaWJlcixcbiAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIGZvcm1EYXRhXG4gICAgKSB7XG4gICAgICBpZiAoNSAhPT0gZm9ybUZpYmVyLnRhZylcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0aGUgZm9ybSBpbnN0YW5jZSB0byBiZSBhIEhvc3RDb21wb25lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBxdWV1ZSA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikucXVldWU7XG4gICAgICBzdGFydFRyYW5zaXRpb24oXG4gICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgcXVldWUsXG4gICAgICAgIHBlbmRpbmdTdGF0ZSxcbiAgICAgICAgTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIG51bGwgPT09IGFjdGlvblxuICAgICAgICAgID8gbm9vcFxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5UICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwicmVxdWVzdEZvcm1SZXNldCB3YXMgY2FsbGVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gZml4LCBtb3ZlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciByZXNldFN0YXRlUXVldWUgPVxuICAgICAgICAgICAgICAgIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikubmV4dC5xdWV1ZTtcbiAgICAgICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgICAgIGZvcm1GaWJlcixcbiAgICAgICAgICAgICAgICByZXNldFN0YXRlUXVldWUsXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZm9ybUZpYmVyKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKGZvcm1EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVwZGF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudCxcbiAgICAgICAgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICAgICAgdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgbGFuZSxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfTtcbiAgICBleHBvcnRzLnVwZGF0ZUNvbnRhaW5lclN5bmMgPSB1cGRhdGVDb250YWluZXJTeW5jO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9KSxcbiAgKG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cyksXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pKTtcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2R1bGUiLCJleHBvcnRzIiwiJCQkY29uZmlnIiwiZmluZEhvb2siLCJmaWJlciIsImlkIiwibWVtb2l6ZWRTdGF0ZSIsIm5leHQiLCJjb3B5V2l0aFNldEltcGwiLCJvYmoiLCJwYXRoIiwiaW5kZXgiLCJ2YWx1ZSIsImxlbmd0aCIsImtleSIsInVwZGF0ZWQiLCJpc0FycmF5SW1wbCIsInNsaWNlIiwiYXNzaWduIiwiY29weVdpdGhSZW5hbWUiLCJvbGRQYXRoIiwibmV3UGF0aCIsImNvbnNvbGUiLCJ3YXJuIiwiaSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZEtleSIsInNwbGljZSIsImNvcHlXaXRoRGVsZXRlSW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwic2hvdWxkRXJyb3JJbXBsIiwiY3JlYXRlRmliZXIiLCJ0YWciLCJwZW5kaW5nUHJvcHMiLCJtb2RlIiwiRmliZXJOb2RlIiwic2NoZWR1bGVSb290Iiwicm9vdCIsImVsZW1lbnQiLCJjb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwidXBkYXRlQ29udGFpbmVyU3luYyIsImZsdXNoU3luY1dvcmsiLCJzY2hlZHVsZVJlZnJlc2giLCJ1cGRhdGUiLCJyZXNvbHZlRmFtaWx5Iiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsImZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5IiwiY3VycmVudCIsInNldFJlZnJlc2hIYW5kbGVyIiwiaGFuZGxlciIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsImVycm9yIiwid2FybkludmFsaWRDb250ZXh0QWNjZXNzIiwibm9vcCIsIndhcm5Gb3JNaXNzaW5nS2V5Iiwic2V0VG9Tb3J0ZWRTdHJpbmciLCJzZXQiLCJhcnJheSIsImZvckVhY2giLCJwdXNoIiwic29ydCIsImpvaW4iLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9DT05TVU1FUl9UWVBFIiwiX2NvbnRleHQiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiaW5uZXJUeXBlIiwicmVuZGVyIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiX3BheWxvYWQiLCJfaW5pdCIsIngiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiX2RlYnVnSW5mbyIsInJldHVybiIsImRpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsImxvZyIsInByZXZJbmZvIiwiaW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwiZ3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJncm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJwcmVmaXgiLCJFcnJvciIsIm1hdGNoIiwic3RhY2siLCJ0cmltIiwic3VmZml4IiwiaW5kZXhPZiIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsInJlZW50cnkiLCJmcmFtZSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJnZXQiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiSCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiRmFrZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiUmVmbGVjdCIsImNvbnRyb2wiLCJjYWxsIiwieCQwIiwieCQxIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJpbmNsdWRlcyIsIl9mcmFtZSIsInJlcGxhY2UiLCJkZXNjcmliZUZpYmVyIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJkZWJ1Z0luZm8iLCJlbnRyeSIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCIsIm1lc3NhZ2UiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicnVuV2l0aEZpYmVySW5ERVYiLCJjYWxsYmFjayIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwicHJldmlvdXNGaWJlciIsImdldEN1cnJlbnRTdGFjayIsImlzUmVuZGVyaW5nIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5vZGUiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsImZsYWdzIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwiY2hpbGQiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwic3RhdGVOb2RlIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJwYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlckltcGwiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsIiwiY3JlYXRlQ3Vyc29yIiwiZGVmYXVsdFZhbHVlIiwicG9wIiwiY3Vyc29yIiwiaW5kZXgkanNjb21wJDAiLCJmaWJlclN0YWNrIiwidmFsdWVTdGFjayIsImNsejMyRmFsbGJhY2siLCJsb2ckMSIsIkxOMiIsImdldExhYmVsRm9yTGFuZSIsImxhbmUiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyIsImxhbmVzIiwicGVuZGluZ1N5bmNMYW5lcyIsImdldE5leHRMYW5lcyIsIndpcExhbmVzIiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIndhcm1MYW5lcyIsImZpbmlzaGVkTGFuZXMiLCJub25JZGxlUGVuZGluZ0xhbmVzIiwiY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyIsInJlbmRlckxhbmVzIiwiY29tcHV0ZUV4cGlyYXRpb25UaW1lIiwiY3VycmVudFRpbWUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsIm5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsIm5leHRSZXRyeUxhbmUiLCJjcmVhdGVMYW5lTWFwIiwiaW5pdGlhbCIsImxhbmVNYXAiLCJtYXJrUm9vdFVwZGF0ZWQkMSIsInVwZGF0ZUxhbmUiLCJtYXJrUm9vdEZpbmlzaGVkIiwicmVtYWluaW5nTGFuZXMiLCJzcGF3bmVkTGFuZSIsInVwZGF0ZWRMYW5lcyIsInN1c3BlbmRlZFJldHJ5TGFuZXMiLCJwcmV2aW91c2x5UGVuZGluZ0xhbmVzIiwiZXhwaXJlZExhbmVzIiwiZW50YW5nbGVkTGFuZXMiLCJlcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyIsInNoZWxsU3VzcGVuZENvdW50ZXIiLCJlbnRhbmdsZW1lbnRzIiwiZXhwaXJhdGlvblRpbWVzIiwiaGlkZGVuVXBkYXRlcyIsImNsejMyIiwiaGlkZGVuVXBkYXRlc0ZvckxhbmUiLCJtYXJrU3Bhd25lZERlZmVycmVkTGFuZSIsInNwYXduZWRMYW5lSW5kZXgiLCJtYXJrUm9vdEVudGFuZ2xlZCIsInJvb3RFbnRhbmdsZWRMYW5lcyIsImFkZEZpYmVyVG9MYW5lc01hcCIsImlzRGV2VG9vbHNQcmVzZW50IiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsImFkZCIsIm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZCIsIm1lbW9pemVkVXBkYXRlcnMiLCJzaXplIiwiaGFzIiwiY2xlYXIiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImhvb2siLCJpc0Rpc2FibGVkIiwic3VwcG9ydHNGaWJlciIsInJlbmRlcmVySUQiLCJpbmplY3QiLCJpbmplY3RlZEhvb2siLCJlcnIiLCJjaGVja0RDRSIsIm9uQ29tbWl0Um9vdCQxIiwiZXZlbnRQcmlvcml0eSIsIm9uQ29tbWl0RmliZXJSb290IiwiZGlkRXJyb3IiLCJzY2hlZHVsZXJQcmlvcml0eSIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSQxIiwiSWRsZVByaW9yaXR5IiwiaGFzTG9nZ2VkRXJyb3IiLCJzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyIsIm5ld0lzU3RyaWN0TW9kZSIsInVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlIiwic2V0U3RyaWN0TW9kZSIsImluamVjdFByb2ZpbGluZ0hvb2tzIiwicHJvZmlsaW5nSG9va3MiLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya1JlbmRlclN0YXJ0ZWQiLCJtYXJrUmVuZGVyU3RvcHBlZCIsIm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCIsImlzIiwieSIsImNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyIiwic291cmNlIiwiZXhpc3RpbmciLCJDYXB0dXJlZFN0YWNrcyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrQ291bnQiLCJ0cmVlRm9ya1Byb3ZpZGVyIiwicHVzaFRyZWVJZCIsImlkU3RhY2siLCJpZFN0YWNrSW5kZXgiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VMZW5ndGgiLCJudW1iZXJPZk92ZXJmbG93Qml0cyIsInRvU3RyaW5nIiwicHVzaE1hdGVyaWFsaXplZFRyZWVJZCIsInBvcFRyZWVDb250ZXh0IiwiaXNIeWRyYXRpbmciLCJyZXF1aXJlZENvbnRleHQiLCJjIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsImNvbnRleHRTdGFja0N1cnNvciIsImdldFJvb3RIb3N0Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJnZXRIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGV4dCIsImhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IiLCJuZXh0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGV4dCIsImlzUHJpbWFyeVJlbmRlcmVyIiwiSG9zdFRyYW5zaXRpb25Db250ZXh0IiwiX2N1cnJlbnRWYWx1ZSIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwiX2N1cnJlbnRWYWx1ZTIiLCJmaW5kTm90YWJsZU5vZGUiLCJpbmRlbnQiLCJzZXJ2ZXJQcm9wcyIsInNlcnZlclRhaWwiLCJjaGlsZHJlbiIsImRpc3RhbmNlRnJvbUxlYWYiLCJpbmRlbnRhdGlvbiIsInJlcGVhdCIsImFkZGVkIiwicmVtb3ZlZCIsImRlc2NyaWJlRmliZXJUeXBlIiwiZGVzY3JpYmVUZXh0Tm9kZSIsImNvbnRlbnQiLCJtYXhMZW5ndGgiLCJuZWVkc0VzY2FwaW5nIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZXNjcmliZVRleHREaWZmIiwiY2xpZW50VGV4dCIsImZpcnN0RGlmZiIsImNoYXJDb2RlQXQiLCJvYmplY3ROYW1lIiwib2JqZWN0IiwibSIsInAwIiwiZGVzY3JpYmVWYWx1ZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsInByb3BOYW1lIiwiaGFzT3duUHJvcGVydHkiLCJqc29uUHJvcE5hbWUiLCJTdHJpbmciLCJkZXNjcmliZVByb3BWYWx1ZSIsImRlc2NyaWJlRXhwYW5kZWRFbGVtZW50Iiwicm93UHJlZml4IiwicmVtYWluaW5nUm93TGVuZ3RoIiwicHJvcGVydGllcyIsInByb3BWYWx1ZSIsImRlc2NyaWJlUHJvcGVydGllc0RpZmYiLCJjbGllbnRPYmplY3QiLCJzZXJ2ZXJPYmplY3QiLCJyZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzIiwiY2xpZW50UHJvcFZhbHVlIiwiX3Byb3BOYW1lIiwiZGVzY3JpYmVFbGVtZW50RGlmZiIsImNsaWVudFByb3BzIiwic2VydmVyUHJvcE5hbWVzIiwiTWFwIiwicHJvcE5hbWUkanNjb21wJDAiLCJ0b0xvd2VyQ2FzZSIsIl9wcm9wTmFtZTIiLCJtYXhMZW5ndGgkanNjb21wJDAiLCJzZXJ2ZXJQcm9wTmFtZSIsImRlbGV0ZSIsImtleXMiLCJkZXNjcmliZVNpYmxpbmdGaWJlciIsImRlc2NyaWJlTm9kZSIsInNraXBUb05vZGUiLCJzZXJ2ZXJDb21wb25lbnROYW1lIiwiZGVzY3JpYmVEaWZmIiwicm9vdE5vZGUiLCJidWlsZEh5ZHJhdGlvbkRpZmZOb2RlIiwiaHlkcmF0aW9uRGlmZlJvb3RERVYiLCJzaWJsaW5ncyIsIndhcm5Ob25IeWRyYXRlZEluc3RhbmNlIiwicmVqZWN0ZWRDYW5kaWRhdGUiLCJkaWRTdXNwZW5kT3JFcnJvckRFViIsImRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MiLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJkaWZmIiwiZGlmZlJvb3QiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24iLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsImh5ZHJhdGVJbnN0YW5jZSIsIm1lbW9pemVkUHJvcHMiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJyb290T3JTaW5nbGV0b25Db250ZXh0IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJzaG91bGRDbGVhciIsInN1cHBvcnRzU2luZ2xldG9ucyIsInNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzIiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZGlmZk5vZGUiLCJkZXNjcmlwdGlvbiIsImdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJkZWh5ZHJhdGVkIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsImh5ZHJhdGlvbkVycm9ycyIsImVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MiLCJmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzIiwiZW5kSW5kZXgiLCJjb25jdXJyZW50UXVldWVzSW5kZXgiLCJjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMiLCJjb25jdXJyZW50UXVldWVzIiwicXVldWUiLCJwZW5kaW5nIiwibWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUiLCJnZXRSb290Rm9yVXBkYXRlZEZpYmVyIiwiZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lIiwic291cmNlRmliZXIiLCJpc0hpZGRlbiIsImNoaWxkTGFuZXMiLCJfdmlzaWJpbGl0eSIsIm5lc3RlZFVwZGF0ZUNvdW50IiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCIsInJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMiLCJyb290V2l0aE5lc3RlZFVwZGF0ZXMiLCJORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQiLCJ3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWIiwicHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucyIsInByZXZFZmZlY3REdXJhdGlvbiIsInByb2ZpbGVyRWZmZWN0RHVyYXRpb24iLCJwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMiLCJlbGFwc2VkVGltZSIsImJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyIsInN0YXJ0UHJvZmlsZXJUaW1lciIsInByb2ZpbGVyU3RhcnRUaW1lIiwibm93IiwiYWN0dWFsU3RhcnRUaW1lIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbiIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uIiwicmVjb3JkRWZmZWN0RHVyYXRpb24iLCJzdGFydEVmZmVjdFRpbWVyIiwidHJhbnNmZXJBY3R1YWxEdXJhdGlvbiIsImVuc3VyZVJvb3RJc1NjaGVkdWxlZCIsImxhc3RTY2hlZHVsZWRSb290IiwiZmlyc3RTY2hlZHVsZWRSb290IiwibWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrIiwiYWN0UXVldWUiLCJkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QiLCJzY2hlZHVsZUltbWVkaWF0ZVRhc2siLCJwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2siLCJkaWRTY2hlZHVsZU1pY3JvdGFzayIsImZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsIiwic3luY1RyYW5zaXRpb25MYW5lcyIsIm9ubHlMZWdhY3kiLCJpc0ZsdXNoaW5nV29yayIsImRpZFBlcmZvcm1Tb21lV29yayIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290IiwiY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUiLCJzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uIiwibm93JDEiLCJwcmV2Iiwic2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayIsImV4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tOb2RlIiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24iLCJTdXNwZW5kZWRPbkRhdGEiLCJjYW5jZWxQZW5kaW5nQ29tbWl0IiwiY2FuY2VsQ2FsbGJhY2siLCJjYWxsYmFja1ByaW9yaXR5IiwiZmFrZUFjdENhbGxiYWNrTm9kZSQxIiwicGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrIiwiYmluZCIsInNjaGVkdWxlQ2FsbGJhY2skMyIsImRpZFRpbWVvdXQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJvcmlnaW5hbENhbGxiYWNrTm9kZSIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwIiwicGVyZm9ybVdvcmtPblJvb3QiLCJjYW5jZWxDYWxsYmFjayQxIiwiY2IiLCJzdXBwb3J0c01pY3JvdGFza3MiLCJzY2hlZHVsZU1pY3JvdGFzayIsImV4ZWN1dGlvbkNvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIk5vQ29udGV4dCIsInJlcXVlc3RUcmFuc2l0aW9uTGFuZSIsImVudGFuZ2xlQXN5bmNBY3Rpb24iLCJ0cmFuc2l0aW9uIiwidGhlbmFibGUiLCJjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzIiwiZW50YW5nbGVkTGlzdGVuZXJzIiwiY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCIsImN1cnJlbnRFbnRhbmdsZWRMYW5lIiwiY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwic3RhdHVzIiwidGhlbiIsInJlc29sdmUiLCJwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlIiwibGlzdGVuZXJzIiwiY2hhaW5UaGVuYWJsZVZhbHVlIiwicmVzdWx0IiwidGhlbmFibGVXaXRoT3ZlcnJpZGUiLCJyZWFzb24iLCJpbml0aWFsaXplVXBkYXRlUXVldWUiLCJ1cGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwic2hhcmVkIiwiaGlkZGVuQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwiY2xvbmVVcGRhdGVRdWV1ZSIsImNyZWF0ZVVwZGF0ZSIsIlVwZGF0ZVN0YXRlIiwicGF5bG9hZCIsImVucXVldWVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY29tcG9uZW50TmFtZSIsImVudGFuZ2xlVHJhbnNpdGlvbnMiLCJxdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJjbG9uZSIsInN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwiZW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJpbnN0YW5jZSRqc2NvbXAkMCIsImhhc0ZvcmNlVXBkYXRlIiwicGVuZGluZ1F1ZXVlIiwibGFzdFBlbmRpbmdVcGRhdGUiLCJmaXJzdFBlbmRpbmdVcGRhdGUiLCJuZXdTdGF0ZSIsImlzSGlkZGVuVXBkYXRlIiwicGFydGlhbFN0YXRlIiwibmV4dFByb3BzIiwiaW5zdGFuY2UiLCJSZXBsYWNlU3RhdGUiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwibmV4dFN0YXRlIiwiQ2FwdHVyZVVwZGF0ZSIsIkZvcmNlVXBkYXRlIiwid29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIiwiY2FsbENhbGxiYWNrIiwiY29tbWl0SGlkZGVuQ2FsbGJhY2tzIiwiY29tbWl0Q2FsbGJhY2tzIiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJvYmplY3RJcyIsImtleXNBIiwia2V5c0IiLCJjdXJyZW50S2V5IiwiY3JlYXRlVGhlbmFibGVTdGF0ZSIsImRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSIsInRoZW5hYmxlcyIsImlzVGhlbmFibGVSZXNvbHZlZCIsIm5vb3AkMSIsInRyYWNrVXNlZFRoZW5hYmxlIiwidGhlbmFibGVTdGF0ZSIsImRpZFVzZVByb21pc2UiLCJ0cmFja2VkVGhlbmFibGVzIiwiY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2giLCJmdWxmaWxsZWRWYWx1ZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwibmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwicmVqZWN0ZWRSZWFzb24iLCJwdXNoRGVidWdJbmZvIiwicHJldmlvdXNEZWJ1Z0luZm8iLCJjdXJyZW50RGVidWdJbmZvIiwiY29uY2F0IiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwicmV0dXJuRmliZXIiLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwiZXJyb3JlZEtleSIsInVud3JhcFRoZW5hYmxlIiwidGhlbmFibGVJbmRleENvdW50ZXIkMSIsInRoZW5hYmxlU3RhdGUkMSIsImNvZXJjZVJlZiIsInJlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsImludmFsaWRDaGlsZCIsInBhcmVudE5hbWUiLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuT25TeW1ib2xUeXBlIiwib3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyIsImNyZWF0ZUNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJkZWxldGlvbnMiLCJkZWxldGVSZW1haW5pbmdDaGlsZHJlbiIsImN1cnJlbnRGaXJzdENoaWxkIiwibWFwUmVtYWluaW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkcmVuIiwidXNlRmliZXIiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4IiwicGxhY2VTaW5nbGVDaGlsZCIsInVwZGF0ZVRleHROb2RlIiwidGV4dENvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiX2RlYnVnT3duZXIiLCJ1cGRhdGVFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJ1cGRhdGVGcmFnbWVudCIsImlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyIsImNhbGxMYXp5SW5pdEluREVWIiwiX293bmVyIiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiY29udGFpbmVySW5mbyIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwiZnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX3ByZXZEZWJ1Z0luZm8iLCJyZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uIiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIl9wcmV2RGVidWdJbmZvNyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJTZXQiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJzdGVwIiwiZG9uZSIsInJlY29uY2lsZUNoaWxkRmliZXJzSW1wbCIsInByZXZEZWJ1Z0luZm8iLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZW50cmllcyIsImRpZFdhcm5BYm91dE1hcHMiLCJmaXJzdENoaWxkRmliZXIiLCJwdXNoSGlkZGVuQ29udGV4dCIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImVudGFuZ2xlZFJlbmRlckxhbmVzIiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yIiwiY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciIsImJhc2VMYW5lcyIsInJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2siLCJwb3BIaWRkZW5Db250ZXh0IiwicHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyIiwic3VzcGVuc2VTdGFja0N1cnNvciIsIlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIiwic3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IiLCJzaGVsbEJvdW5kYXJ5IiwicHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlciIsInJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayIsInBvcFN1c3BlbnNlSGFuZGxlciIsImZpbmRGaXJzdFN1c3BlbmRlZCIsInJvdyIsInN0YXRlIiwiaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyIsImlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrIiwicmV2ZWFsT3JkZXIiLCJtb3VudEhvb2tUeXBlc0RldiIsImhvb2tOYW1lIiwiY3VycmVudEhvb2tOYW1lSW5EZXYiLCJob29rVHlwZXNEZXYiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJob29rVHlwZXNVcGRhdGVJbmRleERldiIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJ0YWJsZSIsIm9sZEhvb2tOYW1lIiwibmV3SG9va05hbWUiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJ3YXJuT25Vc2VGb3JtU3RhdGVJbkRldiIsImRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSIsInRocm93SW52YWxpZEhvb2tFcnJvciIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsInJlbmRlcldpdGhIb29rcyIsIkNvbXBvbmVudCIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsIl9kZWJ1Z0hvb2tUeXBlcyIsImRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50IiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViIsIk5vTW9kZSIsImNhbGxDb21wb25lbnRJbkRFViIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyIsInJlbmRlcldpdGhIb29rc0FnYWluIiwiZmluaXNoUmVuZGVyaW5nSG9va3MiLCJkZXBlbmRlbmNpZXMiLCJmaXJzdENvbnRleHQiLCJfZGVidWdUaGVuYWJsZVN0YXRlIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJ0aGVuYWJsZUluZGV4Q291bnRlciIsImRpZFJlY2VpdmVVcGRhdGUiLCJjaGVja0lmQ29udGV4dENoYW5nZWQiLCJkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCIsIm51bWJlck9mUmVSZW5kZXJzIiwiUkVfUkVOREVSX0xJTUlUIiwibGFzdEVmZmVjdCIsImV2ZW50cyIsInN0b3JlcyIsIm1lbW9DYWNoZSIsIkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsIlRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQiLCJkaXNwYXRjaGVyIiwibWF5YmVUaGVuYWJsZSIsInVzZVN0YXRlIiwidXNlVGhlbmFibGUiLCJjaGVja0RpZFJlbmRlcklkSG9vayIsImRpZFJlbmRlcklkSG9vayIsImxvY2FsSWRDb3VudGVyIiwiYmFpbG91dEhvb2tzIiwicmVzZXRIb29rc09uVW53aW5kIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlUXVldWUiLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0Q3VycmVudEhvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwidXNlIiwidXNhYmxlIiwicmVhZENvbnRleHQiLCJ1c2VNZW1vQ2FjaGUiLCJkYXRhIiwibWFwIiwiY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSIsIkFycmF5IiwiUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCIsImJhc2ljU3RhdGVSZWR1Y2VyIiwiYWN0aW9uIiwibW91bnRSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJpbml0IiwiaW5pdGlhbFN0YXRlIiwiZGlzcGF0Y2giLCJsYXN0UmVuZGVyZWRSZWR1Y2VyIiwibGFzdFJlbmRlcmVkU3RhdGUiLCJkaXNwYXRjaFJlZHVjZXJBY3Rpb24iLCJ1cGRhdGVSZWR1Y2VyIiwidXBkYXRlUmVkdWNlckltcGwiLCJiYXNlRmlyc3QiLCJuZXdCYXNlUXVldWVGaXJzdCIsIm5ld0Jhc2VRdWV1ZUxhc3QiLCJyZXZlcnRMYW5lIiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJtb3VudFN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsIm5leHRTbmFwc2hvdCIsImRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IiwicHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayIsIm1vdW50RWZmZWN0Iiwic3Vic2NyaWJlVG9TdG9yZSIsInB1c2hFZmZlY3QiLCJIYXNFZmZlY3QiLCJQYXNzaXZlIiwidXBkYXRlU3RvcmVJbnN0YW5jZSIsImRlc3Ryb3kiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsImlzSHlkcmF0aW5nJGpzY29tcCQwIiwiY2FjaGVkU25hcHNob3QiLCJjcmVhdGUiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicmVuZGVyZWRTbmFwc2hvdCIsImluc3QiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiZm9yY2VTdG9yZVJlcmVuZGVyIiwibGF0ZXN0R2V0U25hcHNob3QiLCJuZXh0VmFsdWUiLCJzY2hlZHVsZVVwZGF0ZU9uRmliZXIiLCJtb3VudFN0YXRlSW1wbCIsImluaXRpYWxTdGF0ZUluaXRpYWxpemVyIiwibW91bnRTdGF0ZSIsImRpc3BhdGNoU2V0U3RhdGUiLCJtb3VudE9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlIiwidXBkYXRlT3B0aW1pc3RpYyIsInVwZGF0ZU9wdGltaXN0aWNJbXBsIiwicmVyZW5kZXJPcHRpbWlzdGljIiwiZGlzcGF0Y2hBY3Rpb25TdGF0ZSIsImFjdGlvblF1ZXVlIiwic2V0UGVuZGluZ1N0YXRlIiwic2V0U3RhdGUiLCJpc1JlbmRlclBoYXNlVXBkYXRlIiwiYWN0aW9uTm9kZSIsImlzVHJhbnNpdGlvbiIsImxpc3RlbmVyIiwiVCIsInJ1bkFjdGlvblN0YXRlQWN0aW9uIiwicHJldlN0YXRlIiwicHJldlRyYW5zaXRpb24iLCJjdXJyZW50VHJhbnNpdGlvbiIsIl91cGRhdGVkRmliZXJzIiwicmV0dXJuVmFsdWUiLCJvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsIlMiLCJoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZSIsIm9uQWN0aW9uRXJyb3IiLCJlcnJvciQyIiwib25BY3Rpb25TdWNjZXNzIiwibm90aWZ5QWN0aW9uTGlzdGVuZXJzIiwibGFzdCIsImFjdGlvblN0YXRlUmVkdWNlciIsIm9sZFN0YXRlIiwibW91bnRBY3Rpb25TdGF0ZSIsImluaXRpYWxTdGF0ZVByb3AiLCJzc3JGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJpc01hdGNoaW5nIiwibWFya2VySW5zdGFuY2UiLCJjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyIiwiaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyIsInVwZGF0ZUFjdGlvblN0YXRlIiwic3RhdGVIb29rIiwidXBkYXRlQWN0aW9uU3RhdGVJbXBsIiwiY3VycmVudFN0YXRlSG9vayIsImFjdGlvblF1ZXVlSG9vayIsImFjdGlvblN0YXRlQWN0aW9uRWZmZWN0IiwicmVyZW5kZXJBY3Rpb25TdGF0ZSIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwibW91bnRFZmZlY3RJbXBsIiwiZmliZXJGbGFncyIsImhvb2tGbGFncyIsIm1vdW50TGF5b3V0RWZmZWN0IiwiTGF5b3V0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNsZWFudXAiLCJtb3VudEltcGVyYXRpdmVIYW5kbGUiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJtb3VudERlZmVycmVkVmFsdWVJbXBsIiwidXBkYXRlRGVmZXJyZWRWYWx1ZSIsInVwZGF0ZURlZmVycmVkVmFsdWVJbXBsIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwicmVxdWVzdERlZmVycmVkTGFuZSIsInByZXZWYWx1ZSIsInN0YXJ0VHJhbnNpdGlvbiIsInBlbmRpbmdTdGF0ZSIsImZpbmlzaGVkU3RhdGUiLCJwcmV2aW91c1ByaW9yaXR5IiwiZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5Iiwic2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwidGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsIiwicmVxdWVzdFVwZGF0ZUxhbmUiLCJlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bCIsImZvcm1GaWJlciIsImV4aXN0aW5nU3RhdGVIb29rIiwiaW5pdGlhbFJlc2V0U3RhdGUiLCJtb3VudFRyYW5zaXRpb24iLCJ1cGRhdGVUcmFuc2l0aW9uIiwiYm9vbGVhbk9yVGhlbmFibGUiLCJzdGFydCIsInJlcmVuZGVyVHJhbnNpdGlvbiIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJpZFdpdGhMZWFkaW5nQml0IiwiZ2xvYmFsQ2xpZW50SWRDb3VudGVyIiwibW91bnRSZWZyZXNoIiwicmVmcmVzaENhY2hlIiwic2VlZEtleSIsInByb3ZpZGVyIiwiY3JlYXRlQ2FjaGUiLCJjYWNoZSIsIkpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCIsImVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZSIsImVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZSIsIkpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJjdXJyZW50U3RhdGUiLCJ0aHJvd0lmRHVyaW5nUmVuZGVyIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjdG9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJyZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyIsImJhc2VQcm9wcyIsImRlZmF1bHRQcm9wcyIsImxvZ1VuY2F1Z2h0RXJyb3IiLCJlcnJvckluZm8iLCJlcnJvckJvdW5kYXJ5TmFtZSIsInRocm93bkVycm9ycyIsIm9uVW5jYXVnaHRFcnJvciIsImNvbXBvbmVudFN0YWNrIiwiZSIsInNldFRpbWVvdXQiLCJsb2dDYXVnaHRFcnJvciIsImJvdW5kYXJ5Iiwib25DYXVnaHRFcnJvciIsImVycm9yQm91bmRhcnkiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwiaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyIsImNvbXBvbmVudERpZENhdGNoIiwibGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQiLCJjYWxsQ29tcG9uZW50RGlkQ2F0Y2hJbkRFViIsInRocm93RXhjZXB0aW9uIiwicm9vdFJlbmRlckxhbmVzIiwicmVzdG9yZVBlbmRpbmdVcGRhdGVycyIsInByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsIndvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMiLCJSb290SW5Qcm9ncmVzcyIsIlJvb3RTdXNwZW5kZWQiLCJub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUiLCJhdHRhY2hQaW5nTGlzdGVuZXIiLCJ0cmFuc2l0aW9ucyIsIm1hcmtlckluc3RhbmNlcyIsInJldHJ5UXVldWUiLCJjYXVzZSIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290RXJyb3JlZCIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsIm1vdW50Q2hpbGRGaWJlcnMiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsInVwZGF0ZUZvcndhcmRSZWYiLCJwcm9wc1dpdGhvdXRSZWYiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50Iiwic2hvdWxkQ29uc3RydWN0IiwiY29tcGFyZSIsInJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMiLCJjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsInByZXZQcm9wcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50IiwibmV4dElzRGV0YWNoZWQiLCJfcGVuZGluZ1Zpc2liaWxpdHkiLCJtYXJrUmVmIiwiZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQiLCJjYWNoZVBvb2wiLCJwdXNoVHJhbnNpdGlvbiIsIm5leHRCYXNlTGFuZXMiLCJwZWVrQ2FjaGVGcm9tUG9vbCIsIkNhY2hlQ29udGV4dCIsInBvb2wiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJjb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMiLCJyZXBsYXlGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZUNsYXNzQ29tcG9uZW50IiwiY3VycmVudCRqc2NvbXAkMCIsIl9pbnN0YW5jZSIsInVwZGF0ZXIiLCJlbnF1ZXVlU2V0U3RhdGUiLCJjb250ZXh0VHlwZSIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsIl9yZWFjdEludGVybmFscyIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwibmV3QXBpTmFtZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJyZWZzIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJyZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsImNvbXBvbmVudERpZE1vdW50IiwidW5yZXNvbHZlZE9sZFByb3BzIiwib2xkQ29udGV4dCIsImNhbGxSZW5kZXJJbkRFViIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJnZXRTdXNwZW5kZWRDYWNoZSIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwicHJpbWFyeVRyZWVEaWREZWZlciIsIndvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG93RmFsbGJhY2siLCJkaWRTdXNwZW5kIiwiSlNDb21waWxlcl90ZW1wIiwiRm9yY2VTdXNwZW5zZUZhbGxiYWNrIiwibmV4dEluc3RhbmNlIiwiSlNDb21waWxlcl90ZW1wJGpzY29tcCQwIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJ0cmVlQ29udGV4dCIsIm92ZXJmbG93IiwicmV0cnlMYW5lIiwiZmFsbGJhY2siLCJtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJTVVNQRU5ERURfTUFSS0VSIiwibW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsInJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nIiwiZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzIiwiZGlnZXN0IiwiU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uIiwicmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeSIsInJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5IiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlIiwic3VidHJlZUZsYWdzIiwicHJpbWFyeUNoaWxkcmVuIiwib2Zmc2NyZWVuUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIiLCJwcm9wYWdhdGlvblJvb3QiLCJzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoIiwidmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZCIsImNoaWxkU2xvdCIsImlzQW5BcnJheSIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsImlzQmFja3dhcmRzIiwidGFpbCIsImxhc3RDb250ZW50Um93IiwidGFpbE1vZGUiLCJyZW5kZXJTdGF0ZSIsInJlbmRlcmluZyIsInJlbmRlcmluZ1N0YXJ0VGltZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJfaSIsImF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlIiwicHVzaFByb3ZpZGVyIiwiZWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJkaWRTdXNwZW5kQmVmb3JlIiwiYmVnaW5Xb3JrIiwiX2RlYnVnTmVlZHNSZW1vdW50IiwicHJldlNpYmxpbmciLCJyZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzIiwiaXNEZWh5ZHJhdGVkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJzdXBwb3J0c1Jlc291cmNlcyIsImdldFJlc291cmNlIiwiY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UiLCJyZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UiLCJkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJ2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsInZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciIsInBvb2xlZENhY2hlIiwicmV0YWluQ2FjaGUiLCJwb29sZWRDYWNoZUxhbmVzIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwibGFzdENvbnRleHREZXBlbmRlbmN5IiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJwcm92aWRlckZpYmVyIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlckN1cnNvckRFViIsIl9jdXJyZW50UmVuZGVyZXIiLCJyZW5kZXJlclNpZ2lsIiwicmVuZGVyZXIyQ3Vyc29yREVWIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsImNvbnRleHRzIiwiZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlIiwibGlzdCIsIm5leHRGaWJlciIsImRlcGVuZGVuY3kiLCJpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCIsImN1cnJlbnRQYXJlbnQiLCJjdXJyZW50RGVwZW5kZW5jaWVzIiwibWVtb2l6ZWRWYWx1ZSIsInJlYWRDb250ZXh0Rm9yQ29uc3VtZXIiLCJjb25zdW1lciIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXJMb2NhbCIsInJlZkNvdW50Iiwic2lnbmFsIiwiYWJvcnRlZCIsInJlbGVhc2VDYWNoZSIsInNjaGVkdWxlQ2FsbGJhY2skMSIsIk5vcm1hbFByaW9yaXR5IiwiYWJvcnQiLCJjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIiLCJyZXN1bWVkQ2FjaGUiLCJvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyIsInByZXZDYWNoZVBvb2wiLCJjYWNoZUZyb21Qb29sIiwibWFya1VwZGF0ZSIsImRvZXNSZXF1aXJlQ2xvbmUiLCJjb21wbGV0ZWRXb3JrIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJuZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJzdXBwb3J0c011dGF0aW9uIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsIl9ub2RlIiwiY2xvbmVIaWRkZW5JbnN0YW5jZSIsImNsb25lSGlkZGVuVGV4dEluc3RhbmNlIiwiYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciIsImNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwidXBkYXRlSG9zdENvbnRhaW5lciIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJwZW5kaW5nQ2hpbGRyZW4iLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwidXBkYXRlSG9zdENvbXBvbmVudCIsImN1cnJlbnRJbnN0YW5jZSIsIl9vbGRQcm9wcyIsImN1cnJlbnRIb3N0Q29udGV4dCIsImNsb25lSW5zdGFuY2UiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCIsIm1heVN1c3BlbmRDb21taXQiLCJwcmVsb2FkSW5zdGFuY2UiLCJzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuIiwiU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uIiwicHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkIiwicmVzb3VyY2UiLCJtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQiLCJwcmVsb2FkUmVzb3VyY2UiLCJzY2hlZHVsZVJldHJ5RWZmZWN0Iiwid29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwiaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrIiwibGFzdFRhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImJ1YmJsZVByb3BlcnRpZXMiLCJkaWRCYWlsb3V0IiwibmV3Q2hpbGRMYW5lcyIsIl90cmVlQmFzZUR1cmF0aW9uIiwiX2NoaWxkMiIsInRyZWVCYXNlRHVyYXRpb24iLCJjb21wbGV0ZVdvcmsiLCJwZW5kaW5nQ29udGV4dCIsInF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMiLCJuZXh0UmVzb3VyY2UiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsInByZXBhcmVQb3J0YWxNb3VudCIsInJlc2V0V29ya0luUHJvZ3Jlc3MiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwidW53aW5kV29yayIsInVud2luZEludGVycnVwdGVkV29yayIsImludGVycnVwdGVkV29yayIsInNob3VsZFByb2ZpbGUiLCJjb21taXRIb29rTGF5b3V0RWZmZWN0cyIsImZpbmlzaGVkV29yayIsImNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQiLCJjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMiLCJuZWFyZXN0TW91bnRlZEFuY2VzdG9yIiwiY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50IiwiZmlyc3RFZmZlY3QiLCJOb0ZsYWdzIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkIiwiSW5zZXJ0aW9uIiwiaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiY2FsbENyZWF0ZUluREVWIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkIiwiYWRkZW5kdW0iLCJuIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkIiwiY2FsbERlc3Ryb3lJbkRFViIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRDbGFzc0NhbGxiYWNrcyIsImNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMiLCJjb21taXRDbGFzc1NuYXBzaG90IiwicmVzb2x2ZWRQcmV2UHJvcHMiLCJzbmFwc2hvdCIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFViIsImNvbW1pdEF0dGFjaFJlZiIsImdldFB1YmxpY0luc3RhbmNlIiwic2FmZWx5QXR0YWNoUmVmIiwic2FmZWx5RGV0YWNoUmVmIiwiZXJyb3IkMyIsImNvbW1pdFByb2ZpbGVyIiwiY29tbWl0U3RhcnRUaW1lIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplIiwib25Db21taXQiLCJvblJlbmRlciIsImNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUyIiwib25Qb3N0Q29tbWl0IiwiY29tbWl0SG9zdE1vdW50IiwiY29tbWl0TW91bnQiLCJjb21taXRIb3N0VXBkYXRlIiwiY29tbWl0VXBkYXRlIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyIiwiYmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJjb21taXRQbGFjZW1lbnQiLCJwYXJlbnRGaWJlciIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMiLCJmaXJzdENoaWxkIiwicHJlcGFyZUZvckNvbW1pdCIsIm5leHRFZmZlY3QiLCJjbGVhckNvbnRhaW5lciIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdExheW91dEVmZmVjdE9uRmliZXIiLCJmaW5pc2hlZFJvb3QiLCJyZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyIsImNhbGxDb21wb25lbnREaWRNb3VudEluREVWIiwiY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWIiwiY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MiLCJvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyIsImNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIiLCJkZWxldGVkRmliZXIiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInJlbGVhc2VSZXNvdXJjZSIsInVubW91bnRIb2lzdGFibGUiLCJwcmV2SG9zdFBhcmVudCIsImhvc3RQYXJlbnQiLCJwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyIiwiaG9zdFBhcmVudElzQ29udGFpbmVyIiwicmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwicmVtb3ZlQ2hpbGQiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJnZXRSZXRyeUNhY2hlIiwicmV0cnlDYWNoZSIsIlBvc3NpYmx5V2Vha1NldCIsIl9yZXRyeUNhY2hlIiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsIndha2VhYmxlcyIsIndha2VhYmxlIiwicmV0cnkiLCJyZXNvbHZlUmV0cnlXYWtlYWJsZSIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwiY29tbWl0TXV0YXRpb25FZmZlY3RzIiwiY29tbWl0dGVkTGFuZXMiLCJjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyIsInJvb3QkanNjb21wJDAiLCJjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMiLCJob2lzdGFibGVSb290IiwiY3VycmVudEhvaXN0YWJsZVJvb3QiLCJoeWRyYXRlSG9pc3RhYmxlIiwibW91bnRIb2lzdGFibGUiLCJhY3F1aXJlUmVzb3VyY2UiLCJjbGVhclNpbmdsZXRvbiIsImFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSIsIm5lZWRzRm9ybVJlc2V0IiwiY29tbWl0VGV4dFVwZGF0ZSIsInByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMiLCJnZXRIb2lzdGFibGVSb290IiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJyZWN1cnNpdmVseVJlc2V0Rm9ybXMiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwid2FzSGlkZGVuIiwiX2N1cnJlbnQiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsImhpZGVJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsInJlc2V0Rm9ybUluc3RhbmNlIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsImRpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZWFwcGVhckxheW91dEVmZmVjdHMiLCJpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzIiwiY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyIsInByZXZpb3VzQ2FjaGUiLCJjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0dGVkVHJhbnNpdGlvbnMiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwicmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJfaW5zdGFuY2UyIiwiZmluaXNoZWRSb290JGpzY29tcCQwIiwicmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0Iiwic3VzcGVuc2V5Q29tbWl0RmxhZyIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyIiwic3VzcGVuZFJlc291cmNlIiwic3VzcGVuZEluc3RhbmNlIiwicHJldmlvdXNIb2lzdGFibGVSb290IiwiZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbiIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdCIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsImZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdCIsImhvc3RSb290IiwibWF5YmVGaWJlciIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJmaW5kRmliZXJSb290IiwibWF0Y2hTZWxlY3RvciIsImZpYmVyJGpzY29tcCQwIiwic2VsZWN0b3IiLCJDT01QT05FTlRfVFlQRSIsIkhBU19QU0VVRE9fQ0xBU1NfVFlQRSIsInRhZyRqc2NvbXAkMCIsInNlbGVjdG9ySW5kZXgiLCJzZWxlY3RvciRqc2NvbXAkMCIsImlzSGlkZGVuU3VidHJlZSIsIlJPTEVfVFlQRSIsIm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUiLCJURVhUX1RZUEUiLCJnZXRUZXh0Q29udGVudCIsIlRFU1RfTkFNRV9UWVBFIiwic2VsZWN0b3JUb1N0cmluZyIsImZpbmRQYXRocyIsInNlbGVjdG9ycyIsIm1hdGNoaW5nRmliZXJzIiwiZmluZEFsbE5vZGVzIiwic3VwcG9ydHNUZXN0U2VsZWN0b3JzIiwiZnJvbSIsIm9uQ29tbWl0Um9vdCIsImNvbW1pdEhvb2tzIiwiY29tbWl0SG9vayIsImlzQ29uY3VycmVudEFjdEVudmlyb25tZW50IiwiaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwicmVzb2x2ZVVwZGF0ZVByaW9yaXR5Iiwic3VzcGVuc2VIYW5kbGVyIiwiaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzIiwiZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyIsInByZXBhcmVGcmVzaFN0YWNrIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsIndhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFViIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwiZm9yY2VTeW5jIiwic2hvdWxkVGltZVNsaWNlIiwiZXhpdFN0YXR1cyIsInJlbmRlclJvb3RDb25jdXJyZW50IiwicmVuZGVyUm9vdFN5bmMiLCJyZW5kZXJXYXNDb25jdXJyZW50Iiwid29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmciLCJSb290RGlkTm90Q29tcGxldGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MiLCJpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMiLCJlcnJvclJldHJ5TGFuZXMiLCJlcnJvclJldHJ5TGFuZXMkanNjb21wJDAiLCJ3YXNSb290RGVoeWRyYXRlZCIsIndvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciIsIndvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RDb21wbGV0ZWQiLCJjb21taXRSb290Iiwid29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyIsIndvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUiLCJJTU1FRElBVEVfQ09NTUlUIiwiRkFMTEJBQ0tfVEhST1RUTEVfTVMiLCJ0aW1lb3V0SGFuZGxlIiwic2NoZWR1bGVUaW1lb3V0IiwiY29tbWl0Um9vdFdoZW5SZWFkeSIsIlRIUk9UVExFRF9DT01NSVQiLCJlcnJvcnMiLCJhcHBseSIsInJlY292ZXJhYmxlRXJyb3JzIiwiZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIiwiZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIiwic3VzcGVuZGVkQ29tbWl0UmVhc29uIiwiY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lIiwiY29tcGxldGVkUmVuZGVyRW5kVGltZSIsInN0YXJ0U3VzcGVuZGluZ0NvbW1pdCIsIndhaXRGb3JDb21taXRUb0JlUmVhZHkiLCJTVVNQRU5ERURfQ09NTUlUIiwiY2hlY2siLCJkaWRBdHRlbXB0RW50aXJlVHJlZSIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwicmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrIiwiTm90U3VzcGVuZGVkIiwibm9UaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsIndvcmtJblByb2dyZXNzVGhyb3duVmFsdWUiLCJhbGxFbnRhbmdsZWRMYW5lcyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJoYW5kbGVUaHJvdyIsInRocm93blZhbHVlIiwiU3VzcGVuZGVkT25JbW1lZGlhdGUiLCJTdXNwZW5kZWRPbkluc3RhbmNlIiwiU3VzcGVuZGVkT25IeWRyYXRpb24iLCJTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UiLCJTdXNwZW5kZWRPbkVycm9yIiwiZXJyb3JlZFdvcmsiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsIlN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSIsIm1hcmtDb21wb25lbnRTdXNwZW5kZWQiLCJwdXNoRGlzcGF0Y2hlciIsInB1c2hBc3luY0Rpc3BhdGNoZXIiLCJwcmV2QXN5bmNEaXNwYXRjaGVyIiwiQSIsIkRlZmF1bHRBc3luY0Rpc3BhdGNoZXIiLCJzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZyIsInByZXZFeGVjdXRpb25Db250ZXh0IiwidW5pdE9mV29yayIsInRocm93QW5kVW53aW5kV29ya0xvb3AiLCJ3b3JrTG9vcFN5bmMiLCJ0aHJvd25WYWx1ZSQ0IiwicGVyZm9ybVVuaXRPZldvcmsiLCJSRU5ERVJfVElNRU9VVF9NUyIsInJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsiLCJTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlIiwiaG9zdEZpYmVyIiwiY29tcGxldGVVbml0T2ZXb3JrIiwid29ya0xvb3BDb25jdXJyZW50IiwidGhyb3duVmFsdWUkNSIsIm1hcmtSZW5kZXJZaWVsZGVkIiwic2hvdWxkWWllbGQiLCJyZXBsYXlCZWdpbldvcmsiLCJpc1Byb2ZpbGluZ01vZGUiLCJzdXNwZW5kZWRSZWFzb24iLCJ1bndpbmRVbml0T2ZXb3JrIiwic2tpcFNpYmxpbmdzIiwicHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkiLCJjb21taXRSb290SW1wbCIsInJlbmRlclByaW9yaXR5TGV2ZWwiLCJyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyIsImZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsIm1hcmtDb21taXRTdGFydGVkIiwicm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyIsInBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMiLCJzY2hlZHVsZUNhbGxiYWNrIiwicmVzZXRBZnRlckNvbW1pdCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCIsInJlcXVlc3RQYWludCIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzIiwicmVsZWFzZVJvb3RQb29sZWRDYWNoZSIsImNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsIm9uUmVjb3ZlcmFibGVFcnJvciIsIm1ha2VFcnJvckluZm8iLCJyZW5kZXJQcmlvcml0eSIsInByaW9yaXR5IiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdCIsInJvb3RGaWJlciIsInBpbmdDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsInRocmVhZElEcyIsInBpbmdTdXNwZW5kZWRSb290IiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwiYm91bmRhcnlGaWJlciIsInN1c3BlbnNlU3RhdGUiLCJyZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwiaXNJblN0cmljdE1vZGUiLCJpc1N0cmljdE1vZGVGaWJlciIsImRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyIiwic2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMiLCJhcmd1bWVudHMiLCJkb3VibGVJbnZva2VFZmZlY3RzIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCIsInNjaGVkdWxpbmdGaWJlciIsInByaW9yaXR5TGV2ZWwiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlIiwiZmFtaWx5IiwicHJldlR5cGUiLCJuZWVkc0NvbXBhcmVGYW1pbGllcyIsIiQkdHlwZW9mTmV4dFR5cGUiLCJXZWFrU2V0IiwiZmFpbGVkQm91bmRhcmllcyIsImNhbmRpZGF0ZVR5cGUiLCJuZWVkc1JlbmRlciIsImhhc0JhZE1hcFBvbHlmaWxsIiwicHJldmVudEV4dGVuc2lvbnMiLCJpc1JlYWN0Q29tcG9uZW50Iiwib3duZXIiLCJmaWJlclRhZyIsInJlc29sdmVkVHlwZSIsImlzSG9zdEhvaXN0YWJsZVR5cGUiLCJpc0hvc3RTaW5nbGV0b25UeXBlIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiZWxlbWVudHMiLCJwcmltYXJ5Q2hpbGRJbnN0YW5jZSIsIl9wZW5kaW5nTWFya2VycyIsIl90cmFuc2l0aW9ucyIsImRldGFjaCIsImF0dGFjaCIsIkZpYmVyUm9vdE5vZGUiLCJoeWRyYXRlIiwiaW5jb21wbGV0ZVRyYW5zaXRpb25zIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJoeWRyYXRpb25DYWxsYmFja3MiLCJpc1N0cmljdE1vZGUiLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJ1cGRhdGVDb250YWluZXJJbXBsIiwib25TY2hlZHVsZUZpYmVyUm9vdCIsIm1hcmtSZW5kZXJTY2hlZHVsZWQiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwibWFya1JldHJ5TGFuZUltcGwiLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsImdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzIiwiZ2V0TGFuZUxhYmVsTWFwIiwibGFiZWwiLCJSZWFjdCIsInJlcXVpcmUiLCJTY2hlZHVsZXIiLCJTeW1ib2wiLCJmb3IiLCJpdGVyYXRvciIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIl9fcmVhY3REaXNhYmxlZExvZyIsIldlYWtNYXAiLCJpc0FycmF5IiwicmVuZGVyZXJWZXJzaW9uIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsImV4dHJhRGV2VG9vbHNDb25maWciLCJ3YXJuc0lmTm90QWN0aW5nIiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJwcmVwYXJlU2NvcGVVcGRhdGUiLCJnZXRJbnN0YW5jZUZyb21TY29wZSIsInJlc29sdmVFdmVudFR5cGUiLCJyZXNvbHZlRXZlbnRUaW1lU3RhbXAiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJiaW5kVG9Db25zb2xlIiwiZ2V0Qm91bmRpbmdSZWN0Iiwic2V0Rm9jdXNJZkZvY3VzYWJsZSIsInNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJmcmVlemUiLCJNYXRoIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX2NhbmNlbENhbGxiYWNrIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9ub3ciLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsImNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsImNhbGxDb21wb25lbnQiLCJ3YXNSZW5kZXJpbmciLCJjYWxsUmVuZGVyIiwiY2FsbENvbXBvbmVudERpZE1vdW50IiwiY2FsbENvbXBvbmVudERpZFVwZGF0ZSIsImNhbGxDb21wb25lbnREaWRDYXRjaCIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsImNhbGxDcmVhdGUiLCJlZmZlY3QiLCJjYWxsRGVzdHJveSIsImNhbGxMYXp5SW5pdCIsImxhenkiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb21wb25lbnRLZXkiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lckFwcGVuZGl4IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlRGVidWdWYWx1ZSIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VUcmFuc2l0aW9uIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VJZCIsInVzZUNhY2hlUmVmcmVzaCIsInVzZUZvcm1TdGF0ZSIsInVzZUFjdGlvblN0YXRlIiwidXNlT3B0aW1pc3RpYyIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiaXNNb3VudGVkIiwiY29tcG9uZW50IiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwicmVwb3J0R2xvYmFsRXJyb3IiLCJyZXBvcnRFcnJvciIsIndpbmRvdyIsIkVycm9yRXZlbnQiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsImVtaXQiLCJBYm9ydENvbnRyb2xsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiQ29uc3VtZXIiLCJQcm92aWRlciIsIl90aHJlYWRDb3VudCIsInByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsImdldENhY2hlRm9yVHlwZSIsInJlc291cmNlVHlwZSIsImNhY2hlRm9yVHlwZSIsImdldE93bmVyIiwic3ltYm9sRm9yIiwiSW5maW5pdHkiLCJub25FeHRlbnNpYmxlT2JqZWN0IiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJvdmVycmlkZUhvb2tTdGF0ZSIsIm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCIsIm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCIsIm92ZXJyaWRlUHJvcHMiLCJvdmVycmlkZVByb3BzRGVsZXRlUGF0aCIsIm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoIiwic2NoZWR1bGVVcGRhdGUiLCJzZXRFcnJvckhhbmRsZXIiLCJzZXRTdXNwZW5zZUhhbmRsZXIiLCJuZXdTaG91bGRFcnJvckltcGwiLCJuZXdTaG91bGRTdXNwZW5kSW1wbCIsImF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5IiwiYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uIiwiYmF0Y2hlZFVwZGF0ZXMiLCJjcmVhdGVDb21wb25lbnRTZWxlY3RvciIsImNyZWF0ZUNvbnRhaW5lciIsImNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUiLCJjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3JlYXRlUG9ydGFsIiwiZSQ2IiwidG9TdHJpbmdUYWciLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImNyZWF0ZVRleHRTZWxlY3RvciIsInRleHQiLCJkZWZhdWx0T25DYXVnaHRFcnJvciIsImNvbXBvbmVudE5hbWVNZXNzYWdlIiwicmVjcmVhdGVNZXNzYWdlIiwicHJldkdldEN1cnJlbnRTdGFjayIsImVudmlyb25tZW50TmFtZSIsImRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IiLCJkZWZhdWx0T25VbmNhdWdodEVycm9yIiwiZGVmZXJyZWRVcGRhdGVzIiwiZGlzY3JldGVVcGRhdGVzIiwiZCIsImZpbmRCb3VuZGluZ1JlY3RzIiwidGFyZ2V0TGVmdCIsInRhcmdldFJpZ2h0Iiwid2lkdGgiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRCb3R0b20iLCJoZWlnaHQiLCJqIiwib3RoZXJSZWN0Iiwib3RoZXJMZWZ0Iiwib3RoZXJSaWdodCIsIm90aGVyVG9wIiwib3RoZXJCb3R0b20iLCJmaW5kSG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIiLCJmb2N1c1dpdGhpbiIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwidmVyc2lvbiIsImN1cnJlbnREaXNwYXRjaGVyUmVmIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJyZWNvbmNpbGVyVmVyc2lvbiIsInJlbmRlcmVyQ29uZmlnIiwiZ2V0Q3VycmVudEZpYmVyIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwib2JzZXJ2ZVZpc2libGVSZWN0cyIsIm9wdGlvbnMiLCJuZXh0SW5zdGFuY2VSb290cyIsImluc3RhbmNlUm9vdHMiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInNob3VsZEVycm9yIiwic2hvdWxkU3VzcGVuZCIsInN0YXJ0SG9zdFRyYW5zaXRpb24iLCJmb3JtRGF0YSIsInJlc2V0U3RhdGVRdWV1ZSIsInVwZGF0ZUNvbnRhaW5lciIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ })

};
;